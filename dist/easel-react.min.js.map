{"version":3,"file":"easel-react.min.js","mappings":";CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,UACR,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,SAAUJ,GACQ,iBAAZC,QACdA,QAAoB,WAAID,EAAQG,QAAQ,UAExCJ,EAAiB,WAAIC,EAAQD,EAAY,MAC1C,CATD,CASGO,KAAOC,G,iCCTVL,EAAOD,QAAUM,C,4BCSjBL,EAAOD,QANP,SAAwCO,GACtC,IAAIC,EAAmD,KACnDA,GACFD,EAAaE,aAAa,QAASD,EAEvC,C,sBCNA,IAAIE,EAAc,GAClB,SAASC,EAAqBC,GAE5B,IADA,IAAIC,GAAU,EACLC,EAAI,EAAGA,EAAIJ,EAAYK,OAAQD,IACtC,GAAIJ,EAAYI,GAAGF,aAAeA,EAAY,CAC5CC,EAASC,EACT,KACF,CAEF,OAAOD,CACT,CACA,SAASG,EAAaC,EAAMC,GAG1B,IAFA,IAAIC,EAAa,CAAC,EACdC,EAAc,GACTN,EAAI,EAAGA,EAAIG,EAAKF,OAAQD,IAAK,CACpC,IAAIO,EAAOJ,EAAKH,GACZQ,EAAKJ,EAAQK,KAAOF,EAAK,GAAKH,EAAQK,KAAOF,EAAK,GAClDG,EAAQL,EAAWG,IAAO,EAC1BV,EAAa,GAAGa,OAAOH,EAAI,KAAKG,OAAOD,GAC3CL,EAAWG,GAAME,EAAQ,EACzB,IAAIE,EAAoBf,EAAqBC,GACzCe,EAAM,CACRC,IAAKP,EAAK,GACVQ,MAAOR,EAAK,GACZS,UAAWT,EAAK,GAChBU,SAAUV,EAAK,GACfW,MAAOX,EAAK,IAEd,IAA2B,IAAvBK,EACFhB,EAAYgB,GAAmBO,aAC/BvB,EAAYgB,GAAmBQ,QAAQP,OAClC,CACL,IAAIO,EAAUC,EAAgBR,EAAKT,GACnCA,EAAQkB,QAAUtB,EAClBJ,EAAY2B,OAAOvB,EAAG,EAAG,CACvBF,WAAYA,EACZsB,QAASA,EACTD,WAAY,GAEhB,CACAb,EAAYkB,KAAK1B,EACnB,CACA,OAAOQ,CACT,CACA,SAASe,EAAgBR,EAAKT,GAC5B,IAAIqB,EAAMrB,EAAQsB,OAAOtB,GACzBqB,EAAIE,OAAOd,GAWX,OAVc,SAAiBe,GAC7B,GAAIA,EAAQ,CACV,GAAIA,EAAOd,MAAQD,EAAIC,KAAOc,EAAOb,QAAUF,EAAIE,OAASa,EAAOZ,YAAcH,EAAIG,WAAaY,EAAOX,WAAaJ,EAAII,UAAYW,EAAOV,QAAUL,EAAIK,MACzJ,OAEFO,EAAIE,OAAOd,EAAMe,EACnB,MACEH,EAAII,QAER,CAEF,CACA1C,EAAOD,QAAU,SAAUiB,EAAMC,GAG/B,IAAI0B,EAAkB5B,EADtBC,EAAOA,GAAQ,GADfC,EAAUA,GAAW,CAAC,GAGtB,OAAO,SAAgB2B,GACrBA,EAAUA,GAAW,GACrB,IAAK,IAAI/B,EAAI,EAAGA,EAAI8B,EAAgB7B,OAAQD,IAAK,CAC/C,IACIgC,EAAQnC,EADKiC,EAAgB9B,IAEjCJ,EAAYoC,GAAOb,YACrB,CAEA,IADA,IAAIc,EAAqB/B,EAAa6B,EAAS3B,GACtC8B,EAAK,EAAGA,EAAKJ,EAAgB7B,OAAQiC,IAAM,CAClD,IACIC,EAAStC,EADKiC,EAAgBI,IAEK,IAAnCtC,EAAYuC,GAAQhB,aACtBvB,EAAYuC,GAAQf,UACpBxB,EAAY2B,OAAOY,EAAQ,GAE/B,CACAL,EAAkBG,CACpB,CACF,C,uBCtEA9C,EAAOD,QAVP,SAA2B4B,EAAKrB,GAC9B,GAAIA,EAAa2C,WACf3C,EAAa2C,WAAWC,QAAUvB,MAC7B,CACL,KAAOrB,EAAa6C,YAClB7C,EAAa8C,YAAY9C,EAAa6C,YAExC7C,EAAa+C,YAAYC,SAASC,eAAe5B,GACnD,CACF,C,uBCNA3B,EAAOD,QAAU,SAAUyD,GACzB,IAAIxC,EAAO,GA4EX,OAzEAA,EAAKyC,SAAW,WACd,OAAOrD,KAAKsD,IAAI,SAAUtC,GACxB,IAAIuC,EAAU,GACVC,OAA+B,IAAZxC,EAAK,GAoB5B,OAnBIA,EAAK,KACPuC,GAAW,cAAcnC,OAAOJ,EAAK,GAAI,QAEvCA,EAAK,KACPuC,GAAW,UAAUnC,OAAOJ,EAAK,GAAI,OAEnCwC,IACFD,GAAW,SAASnC,OAAOJ,EAAK,GAAGN,OAAS,EAAI,IAAIU,OAAOJ,EAAK,IAAM,GAAI,OAE5EuC,GAAWH,EAAuBpC,GAC9BwC,IACFD,GAAW,KAETvC,EAAK,KACPuC,GAAW,KAETvC,EAAK,KACPuC,GAAW,KAENA,CACT,GAAGE,KAAK,GACV,EAGA7C,EAAKH,EAAI,SAAWiD,EAASlC,EAAOmC,EAAQjC,EAAUC,GAC7B,iBAAZ+B,IACTA,EAAU,CAAC,CAAC,KAAMA,OAASE,KAE7B,IAAIC,EAAyB,CAAC,EAC9B,GAAIF,EACF,IAAK,IAAIG,EAAI,EAAGA,EAAI9D,KAAKU,OAAQoD,IAAK,CACpC,IAAI7C,EAAKjB,KAAK8D,GAAG,GACP,MAAN7C,IACF4C,EAAuB5C,IAAM,EAEjC,CAEF,IAAK,IAAI8C,EAAK,EAAGA,EAAKL,EAAQhD,OAAQqD,IAAM,CAC1C,IAAI/C,EAAO,GAAGI,OAAOsC,EAAQK,IACzBJ,GAAUE,EAAuB7C,EAAK,WAGrB,IAAVW,SACc,IAAZX,EAAK,KAGdA,EAAK,GAAK,SAASI,OAAOJ,EAAK,GAAGN,OAAS,EAAI,IAAIU,OAAOJ,EAAK,IAAM,GAAI,MAAMI,OAAOJ,EAAK,GAAI,MAF/FA,EAAK,GAAKW,GAMVH,IACGR,EAAK,IAGRA,EAAK,GAAK,UAAUI,OAAOJ,EAAK,GAAI,MAAMI,OAAOJ,EAAK,GAAI,KAC1DA,EAAK,GAAKQ,GAHVR,EAAK,GAAKQ,GAMVE,IACGV,EAAK,IAGRA,EAAK,GAAK,cAAcI,OAAOJ,EAAK,GAAI,OAAOI,OAAOJ,EAAK,GAAI,KAC/DA,EAAK,GAAKU,GAHVV,EAAK,GAAK,GAAGI,OAAOM,IAMxBd,EAAKqB,KAAKjB,GACZ,CACF,EACOJ,CACT,C,uBClFAhB,EAAOD,QAAU,SAAUqB,GACzB,IAAIuC,EAAUvC,EAAK,GACfgD,EAAahD,EAAK,GACtB,IAAKgD,EACH,OAAOT,EAET,GAAoB,mBAATU,KAAqB,CAC9B,IAAIC,EAASD,KAAKE,SAASC,mBAAmBC,KAAKC,UAAUN,MACzDO,EAAO,+DAA+DnD,OAAO8C,GAC7EM,EAAgB,OAAOpD,OAAOmD,EAAM,OACxC,MAAO,CAAChB,GAASnC,OAAO,CAACoD,IAAgBf,KAAK,KAChD,CACA,MAAO,CAACF,GAASE,KAAK,KACxB,C,6ECZIgB,E,MAA0B,GAA4B,KAE1DA,EAAwBxC,KAAK,CAACrC,EAAOqB,GAAI,mooDAAoooD,GAAG,CAAC,QAAU,EAAE,QAAU,CAAC,kCAAkC,MAAQ,GAAG,SAAW,wkmBAAwkmB,eAAiB,CAAC,oooDAA8ooD,WAAa,MAEr/2H,S;yDCPAyD,EAAQ,KAARA,CAAyFA,EAAQ,M,iBCAjGC,EAAOhF,QAAU,onF,qBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,sBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,sBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,kBCAjGC,EAAOhF,QAAU,qjQ,kBCAjBgF,EAAOhF,QAAU,q2P,sBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,sBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,kBCAjGC,EAAOhF,QAAU,qkc,kBCAjBgF,EAAOhF,QAAU,mxG,kBCAjBgF,EAAOhF,QAAU,80d,kBCAjBgF,EAAOhF,QAAU,qhX,kBCAjBgF,EAAOhF,QAAU,qqE,sBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,kBCAjGC,EAAOhF,QAAU,y/E,sBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,K,sBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,K,kBCAjGC,EAAOhF,QAAU,+qK,sBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,20R,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,m2gB,mBCAjBgF,EAAOhF,QAAU,ysf,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,4nI,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,+nF,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,K,mBCAjGC,EAAOhF,QAAU,qzV,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,K,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,K,mBCAjGC,EAAOhF,QAAU,g8M,mBCAjBgF,EAAOhF,QAAU,wtE,mBCAjBgF,EAAOhF,QAAU,y+N,mBCAjBgF,EAAOhF,QAAU,6rP,mBCAjBgF,EAAOhF,QAAU,usD,mBCAjBgF,EAAOhF,QAAU,o6Y,mBCAjBgF,EAAOhF,QAAU,6pW,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,K,mBCAjGC,EAAOhF,QAAU,uqC,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,ivF,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,yxN,mBCAjBgF,EAAOhF,QAAU,+pY,mBCAjBgF,EAAOhF,QAAU,grE,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,q5X,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,w6F,mBCAjBgF,EAAOhF,QAAU,04e,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,iuM,mBCAjBgF,EAAOhF,QAAU,2rC,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,0vF,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,4iH,mBCAjBgF,EAAOhF,QAAU,2m/B,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,uiQ,mBCAjBgF,EAAOhF,QAAU,62D,mBCAjBgF,EAAOhF,QAAU,m/O,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,i4F,mBCAjBgF,EAAOhF,QAAU,sqH,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,mlL,mBCIjBgF,EAAOhF,QAAU,SAASgF,GACzB,SAASC,EAAID,GACQ,oBAAZE,UACJA,QAAQC,OAASD,QAAQE,KAAK,kBAAmBJ,EACtD,CAOA,IAC2B,oBAAfK,YAJmB,oBAAhBC,aAA2D,oBAArBC,iBAKnDF,WAAWL,GACe,oBAATQ,KACjBA,KAAKC,KAAK,KAAMT,GAEhBC,EAAI,wCAEN,CAAE,MAAOD,GACRC,EAAID,EACL,CACD,C,mBC1BAA,EAAOhF,QAAU,6xD,mBCAjBgF,EAAOhF,QAAU,6sF,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,21B,mBCAjBgF,EAAOhF,QAAU,iiL,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,ogE,mBCAjBgF,EAAOhF,QAAU,87S,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,wiK,mBCAjBgF,EAAOhF,QAAU,w6V,mBCAjBgF,EAAOhF,QAAU,4/Y,mBCAjBgF,EAAOhF,QAAU,u8G,mBCAjBgF,EAAOhF,QAAU,+kG,mBCAjBgF,EAAOhF,QAAU,gmb,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,K,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,q1B,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,s1E,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,i+Q,mBCAjBgF,EAAOhF,QAAU,8uF,mBCAjBgF,EAAOhF,QAAU,otB,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,o6K,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,K,mBCAjGC,EAAOhF,QAAU,whM,mBCAjBgF,EAAOhF,QAAU,q+G,mBCAjBgF,EAAOhF,QAAU,0pN,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,6wJ,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,I,mBCAjGC,EAAOhF,QAAU,gvC,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,uyhD,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,m5P,mBCAjBgF,EAAOhF,QAAU,oyI,mBCAjBgF,EAAOhF,QAAU,qnuB,mBCAjBgF,EAAOhF,QAAU,u+yB,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,K,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,irB,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,wzN,mBCAjBgF,EAAOhF,QAAU,+qJ,mBCAjBgF,EAAOhF,QAAU,y9J,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,i2B,mBCAjBgF,EAAOhF,QAAU,isZ,mBCAjBgF,EAAOhF,QAAU,iwS,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,i8D,mBCAjBgF,EAAOhF,QAAU,imK,mBCAjBgF,EAAOhF,QAAU,ggxB,mBCAjBgF,EAAOhF,QAAU,+uB,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,o9xxB,mBCAjBgF,EAAOhF,QAAU,4zK,mBCAjBgF,EAAOhF,QAAU,wkyB,mBCAjBgF,EAAOhF,QAAU,81F,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,8wH,mBCAjBgF,EAAOhF,QAAU,w0H,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,y3H,mBCAjBgF,EAAOhF,QAAU,qkN,mBCAjBgF,EAAOhF,QAAU,61D,mBCAjBgF,EAAOhF,QAAU,krC,mBCAjBgF,EAAOhF,QAAU,s5D,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,uBCAjGA,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,g7D,mBCAjBgF,EAAOhF,QAAU,ioY,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,m7R,uBCAjB+E,EAAQ,KAARA,CAAyFA,EAAQ,M,mBCAjGC,EAAOhF,QAAU,0uX,mBCAjBgF,EAAOhF,QAAU,ksQ,mBCAjBgF,EAAOhF,QAAU,ozB,GCCbiF,EAA2B,CAAC,EAGhC,SAASF,EAAoBW,GAE5B,IAAI5E,EAAemE,EAAyBS,GAC5C,YAAI5E,EACH,OAAOA,EAAad,QAGrB,IAAI2F,EAASV,EAAyBS,GAAY,CAGjD1F,QAAS,CAAC,GAOX,OAHAgF,EAAoBU,GAAUC,EAAQA,EAAO3F,QAAS+E,GAG/CY,EAAO3F,OACf,CCrBA+E,EAAoBC,EAAK,SAAAA,GACxB,IAAIC,EAASD,GAAUA,EAAOY,WAC7B,kBAAOZ,EAAiBa,OAAA,EACxB,kBAAMb,CAAA,EAEP,OADAD,EAAoBe,EAAEb,EAAQ,CAAEc,EAAGd,IAC5BA,CAAA,ECLRF,EAAoBe,EAAI,SAACd,EAASC,GACjC,IAAI,IAAIS,KAAOT,EACXF,EAAoBW,EAAET,EAAYS,KAASX,EAAoBW,EAAEV,EAASU,IAC5EM,OAAOC,eAAejB,EAASU,EAAK,CAAEQ,YAAA,EAAkBC,IAAKlB,EAAWS,IAAA,ECJ3EX,EAAoBW,EAAI,SAACV,EAAKC,GAAA,OAAUe,OAAOI,UAAUC,eAAeZ,KAAKT,EAAKC,EAAA,E,uzBCSlFhF,EAAOD,QANP,SAA4BkB,GAC1B,IAAIoF,EAAU/C,SAASgD,cAAc,SAGrC,OAFArF,EAAQsF,cAAcF,EAASpF,EAAQuF,YACvCvF,EAAQwF,OAAOJ,EAASpF,EAAQA,SACzBoF,CACT,C,uBCNA,IAAIK,EAAO,CAAC,EA+BZ1G,EAAOD,QAPP,SAA0B0G,EAAQE,GAChC,IAAIC,EAtBN,SAAmBA,GACjB,QAA4B,IAAjBF,EAAKE,GAAyB,CACvC,IAAIC,EAAcvD,SAASwD,cAAcF,GAGzC,GAAIG,OAAOC,mBAAqBH,aAAuBE,OAAOC,kBAC5D,IAGEH,EAAcA,EAAYI,gBAAgBC,IAC5C,CAAE,MAAOlC,GAEP6B,EAAc,IAChB,CAEFH,EAAKE,GAAUC,CACjB,CACA,OAAOH,EAAKE,EACd,CAIeO,CAAUV,GACvB,IAAKG,EACH,MAAM,IAAIQ,MAAM,2GAElBR,EAAOvD,YAAYsD,EACrB,C,+BCrBIU,EAAqBC,OAAOC,IAAI,8BAEpC,SAASC,EAAQC,EAAMC,EAAQC,GAC7B,IAAIC,EAAM,KAGV,QAFA,IAAWD,IAAaC,EAAM,GAAKD,QACnC,IAAWD,EAAOE,MAAQA,EAAM,GAAKF,EAAOE,KACxC,QAASF,EAEX,IAAK,IAAIG,KADTF,EAAW,CAAC,EACSD,EACnB,QAAUG,IAAaF,EAASE,GAAYH,EAAOG,SAChDF,EAAWD,EAElB,OADAA,EAASC,EAASG,IACX,CACLC,SAAUV,EACVI,KAAMA,EACNG,IAAKA,EACLE,SAAK,IAAWJ,EAASA,EAAS,KAClCM,MAAOL,EAEX,CAlBwBL,OAAOC,IAAI,kBAoBnCxH,EAAQkI,IAAMT,C,uBC4BdxH,EAAOD,QAjBP,SAAgBkB,GACd,GAAwB,oBAAbqC,SACT,MAAO,CACLd,OAAQ,WAAmB,EAC3BE,OAAQ,WAAmB,GAG/B,IAAIpC,EAAeW,EAAQiH,mBAAmBjH,GAC9C,MAAO,CACLuB,OAAQ,SAAgBd,IAjD5B,SAAepB,EAAcW,EAASS,GACpC,IAAIC,EAAM,GACND,EAAII,WACNH,GAAO,cAAcH,OAAOE,EAAII,SAAU,QAExCJ,EAAIE,QACND,GAAO,UAAUH,OAAOE,EAAIE,MAAO,OAErC,IAAIgC,OAAiC,IAAdlC,EAAIK,MACvB6B,IACFjC,GAAO,SAASH,OAAOE,EAAIK,MAAMjB,OAAS,EAAI,IAAIU,OAAOE,EAAIK,OAAS,GAAI,OAE5EJ,GAAOD,EAAIC,IACPiC,IACFjC,GAAO,KAELD,EAAIE,QACND,GAAO,KAELD,EAAII,WACNH,GAAO,KAET,IAAIE,EAAYH,EAAIG,UAChBA,GAA6B,oBAATwC,OACtB1C,GAAO,uDAAuDH,OAAO6C,KAAKE,SAASC,mBAAmBC,KAAKC,UAAU7C,MAAe,QAKtIZ,EAAQkH,kBAAkBxG,EAAKrB,EAAcW,EAAQA,QACvD,CAoBMmH,CAAM9H,EAAcW,EAASS,EAC/B,EACAgB,OAAQ,YArBZ,SAA4BpC,GAE1B,GAAgC,OAA5BA,EAAa+H,WACf,OAAO,EAET/H,EAAa+H,WAAWjF,YAAY9C,EACtC,CAgBMgI,CAAmBhI,EACrB,EAEJ,C,6BCxDEN,EAAOD,QAAU,EAAjB,I,GCFEwI,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBzE,IAAjB0E,EACH,OAAOA,EAAa3I,QAGrB,IAAIC,EAASuI,EAAyBE,GAAY,CACjDpH,GAAIoH,EAEJ1I,QAAS,CAAC,GAOX,OAHA4I,EAAoBF,GAAUzI,EAAQA,EAAOD,QAASyI,GAG/CxI,EAAOD,OACf,CCrBAyI,EAAoBzD,EAAK/E,IACxB,IAAI4I,EAAS5I,GAAUA,EAAO2F,WAC7B,IAAO3F,EAAiB,QACxB,IAAM,EAEP,OADAwI,EAAoB3C,EAAE+C,EAAQ,CAAE9C,EAAG8C,IAC5BA,GCLRJ,EAAoB3C,EAAI,CAAC9F,EAAS8I,KACjC,IAAI,IAAIjB,KAAOiB,EACXL,EAAoB/C,EAAEoD,EAAYjB,KAASY,EAAoB/C,EAAE1F,EAAS6H,IAC5E7B,OAAOC,eAAejG,EAAS6H,EAAK,CAAE3B,YAAY,EAAMC,IAAK2C,EAAWjB,MCJ3EY,EAAoB/C,EAAI,CAAC/D,EAAKoH,IAAU/C,OAAOI,UAAUC,eAAeZ,KAAK9D,EAAKoH,GCAlFN,EAAoBO,QAAK/E,E,iMCWrB/C,EAAU,CAAC,EAEfA,EAAQkH,kBAAoB,IAC5BlH,EAAQsF,cAAgB,IACxBtF,EAAQwF,OAAS,SAAc,KAAM,QACrCxF,EAAQsB,OAAS,IACjBtB,EAAQiH,mBAAqB,IAEhB,IAAI,IAASjH,GAKJ,KAAW,IAAQ+H,QAAS,IAAQA,O,6/CCU1D,IAAMC,GAAcC,EAAAA,EAAAA,YAAW,SAAClB,EAAOF,GACrC,IAAAqB,EAiCInB,EA/BFoB,MAAAA,OAAK,IAAAD,EAAG,IAAGA,EAAAE,EA+BTrB,EA9BFsB,OAAAA,OAAM,IAAAD,EAAG,IAAGA,EAAAE,EA8BVvB,EA3BFwB,SAAAA,OAAQ,IAAAD,EAAG,CAAC,EAACA,EAAAE,EA2BXzB,EA1BF0B,QAAAA,OAAO,IAAAD,EAAG,GAAEA,EAAAE,EA0BV3B,EAzBF4B,oBAAAA,OAAmB,IAAAD,EAAG,KAAIA,EAAAE,EAyBxB7B,EAtBF8B,gBAAAA,OAAe,IAAAD,EAAG,UAASA,EAAAE,EAsBzB/B,EArBFgC,sBAAAA,OAAqB,IAAAD,GAAQA,EAAAE,EAqB3BjC,EAlBFkC,YAAAA,OAAW,IAAAD,EAAG,GAAEA,EAAAE,EAkBdnC,EAjBFoC,iBAAAA,OAAgB,IAAAD,EAAG,GAAEA,EAAAE,EAiBnBrC,EAdFsC,eAAAA,OAAc,IAAAD,GAAQA,EAAAE,EAcpBvC,EAbFwC,WAAAA,OAAU,IAAAD,GAAOA,EAAAE,EAafzC,EAVF0C,SAAAA,OAAQ,IAAAD,EAAG,KAAIA,EAAAE,EAUb3C,EATF4C,OAAAA,OAAM,IAAAD,EAAG,KAAIA,EAAAE,EASX7C,EARF8C,cAAAA,OAAa,IAAAD,EAAG,KAAIA,EAAAE,EAQlB/C,EAPFgD,iBAAAA,OAAgB,IAAAD,EAAG,KAAIA,EAAAE,EAOrBjD,EANFkD,gBAAAA,OAAe,IAAAD,EAAG,KAAIA,EAAAE,EAMpBnD,EALFoD,mBAAAA,OAAkB,IAAAD,EAAG,KAAIA,EAAAE,EAKvBrD,EAJFsD,mBAAAA,OAAkB,IAAAD,EAAG,KAAIA,EAGtBE,E,6WAAaC,CACdxD,EAAKyD,GAEHC,GAAeC,EAAAA,EAAAA,QAAO,MACtBC,GAAmBD,EAAAA,EAAAA,QAAO,MA+JhC,OA5JAE,EAAAA,EAAAA,WAAU,WACR,GAAKH,EAAaI,SAAY/E,OAAOgF,MAArC,CAMA,IAAMC,EAAWC,EAAAA,EAAA,GACZV,GAAa,IAChBW,YAAa9C,EACb+C,aAAc7C,EACdE,SAAAA,EACAE,QAAAA,EACAE,oBAAAA,EACAE,gBAAAA,EACAE,sBAAAA,EACAE,YAAAA,EACAE,iBAAAA,EACAE,eAAAA,EACAE,WAAAA,IAIF,IACE,IAAM4B,EAAgB,IAAIrF,OAAOgF,MAAML,EAAaI,QAASE,GAC7DJ,EAAiBE,QAAUM,EAGvB1B,GACF0B,EAAcC,GAAG,iBAAkB3B,GAEjCE,GACFwB,EAAcC,GAAG,cAAezB,GAE9BE,GACFsB,EAAcC,GAAG,eAAgBvB,GAE/BE,GACFoB,EAAcC,GAAG,kBAAmBrB,GAElCE,GACFkB,EAAcC,GAAG,iBAAkBnB,GAEjCE,GACFgB,EAAcC,GAAG,oBAAqBjB,GAEpCE,GACFc,EAAcC,GAAG,oBAAqBf,EAG1C,CAAE,MAAOpG,GACPD,QAAQC,MAAM,8BAA+BA,EAC/C,CAGA,OAAO,WACL,GAAI0G,EAAiBE,QAAS,CAC5B,IACEF,EAAiBE,QAAQQ,SAC3B,CAAE,MAAOpH,GACPD,QAAQC,MAAM,mCAAoCA,EACpD,CACA0G,EAAiBE,QAAU,IAC7B,CACF,CA5DA,CAFE7G,QAAQC,MAAM,kDA+DlB,EAAG,KAGH2G,EAAAA,EAAAA,WAAU,WACR,GAAID,EAAiBE,SAAWF,EAAiBE,QAAQxJ,IACvD,IACEsJ,EAAiBE,QAAQxJ,IAAIiK,QAAQnD,EAAOE,EAC9C,CAAE,MAAOpE,GACPD,QAAQC,MAAM,6BAA8BA,EAC9C,CAEJ,EAAG,CAACkE,EAAOE,KAGXkD,EAAAA,EAAAA,qBAAoB1E,EAAK,iBAAO,CAE9B2E,YAAa,WAAF,OAAQb,EAAiBE,OAAO,EAG3CY,gBAAiB,WAAmC,IAAlCC,EAAMC,UAAA9L,OAAA,QAAAkD,IAAA4I,UAAA,GAAAA,UAAA,GAAG,MAAOC,EAAOD,UAAA9L,OAAA,QAAAkD,IAAA4I,UAAA,GAAAA,UAAA,GAAG,EAC1C,OAAKhB,EAAiBE,SAAYF,EAAiBE,QAAQxJ,IAGpDsJ,EAAiBE,QAAQxJ,IAAIoK,gBAAgBC,EAAQE,GAFnD,IAGX,EAEAC,aAAc,SAACC,GAA4C,IAAlCJ,EAAMC,UAAA9L,OAAA,QAAAkD,IAAA4I,UAAA,GAAAA,UAAA,GAAG,MAAOC,EAAOD,UAAA9L,OAAA,QAAAkD,IAAA4I,UAAA,GAAAA,UAAA,GAAG,EAC5ChB,EAAiBE,SAAYF,EAAiBE,QAAQxJ,KAG3DsJ,EAAiBE,QAAQxJ,IAAIwK,aAAaC,EAAUJ,EAAQE,EAC9D,EAEAG,UAAW,SAACC,GACLrB,EAAiBE,SAAYF,EAAiBE,QAAQxJ,KAG3DsJ,EAAiBE,QAAQxJ,IAAI0K,UAAUC,EACzC,EAEAC,MAAO,WACAtB,EAAiBE,SAAYF,EAAiBE,QAAQxJ,KAG3DsJ,EAAiBE,QAAQxJ,IAAI6K,aAC/B,EAEAC,mBAAoB,SAACC,GACdzB,EAAiBE,SAAYF,EAAiBE,QAAQxJ,KAG3DsJ,EAAiBE,QAAQxJ,IAAI8K,mBAAmBC,EAClD,EAEAd,QAAS,SAACe,EAAGC,GACN3B,EAAiBE,SAAYF,EAAiBE,QAAQxJ,KAG3DsJ,EAAiBE,QAAQxJ,IAAIiK,QAAQe,EAAGC,EAC1C,EAEAC,KAAM,WACC5B,EAAiBE,SAGtBF,EAAiBE,QAAQ0B,MAC3B,EAEAC,KAAM,WACC7B,EAAiBE,SAGtBF,EAAiBE,QAAQ2B,MAC3B,EAEAC,eAAgB,SAACC,GACV/B,EAAiBE,SAGtBF,EAAiBE,QAAQ8B,QAAQ,wBAAyBD,EAC5D,EAGAE,gBAAiB,WACf,OAAKjC,EAAiBE,SAAYF,EAAiBE,QAAQgC,QAGpDlC,EAAiBE,QAAQgC,QAFvB,IAGX,EACD,IAGCC,EAAAA,EAAAA,KAAA,OACEjG,IAAK4D,EACLsC,UAAU,sBACVrH,MAAO,CACLyC,MAAO,OACPE,OAAQ,OACR2E,SAAU,aAIlB,GAEAhF,EAAYiF,YAAc,cAE1B,MCzOA,EDyOA,C","sources":["webpack://EaselReact/webpack/universalModuleDefinition","webpack://EaselReact/external umd {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}","webpack://EaselReact/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://EaselReact/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://EaselReact/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://EaselReact/./node_modules/css-loader/dist/runtime/api.js","webpack://EaselReact/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://EaselReact/./dist/easel.min.css","webpack://EaselReact/easel/src/toolbars/instances/CropImageToolbar.js?4d11","webpack://EaselReact/easel/src/plugins/brush-eraser/EraserPath.js","webpack://EaselReact/easel/src/plugins/feature-shape-contextmenu/ShapeContextMenu.js?26d6","webpack://EaselReact/easel/src/plugins/shape-rectangle/Rectangle.js?7c84","webpack://EaselReact/easel/src/plugins/BaseOptionTool.js?d3b7","webpack://EaselReact/easel/src/plugins/feature-canvas-properties/CanvasProperties.js","webpack://EaselReact/easel/src/Easel.Events.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableRect.js?b67c","webpack://EaselReact/easel/src/toolbars/ui-plugins/ToolbarComboBox.js?9b54","webpack://EaselReact/easel/src/plugins/feature-fullscreen/FullscreenModeButton.js","webpack://EaselReact/easel/src/plugins/brush-pencil/Pencil.js","webpack://EaselReact/easel/src/toolbars/ToolbarPlaceholder.js","webpack://EaselReact/easel/src/plugins/feature-image-crop/ImageCrop.js","webpack://EaselReact/easel/src/Localization_en.js","webpack://EaselReact/easel/src/plugins/option-color/Color.js?4568","webpack://EaselReact/easel/src/plugins/option-text-styles/TextColor.js","webpack://EaselReact/easel/src/plugins/brush-pencil/Pencil.js?5405","webpack://EaselReact/easel/src/toolbars/ToolbarPlaceholder.js?bff2","webpack://EaselReact/easel/src/plugins/BaseBrush.js","webpack://EaselReact/easel/src/toolbars/instances/SettingsToolbar.js?9cae","webpack://EaselReact/easel/src/plugins/BaseTool.js","webpack://EaselReact/easel/src/plugins/feature-shape-contextmenu/ContextMenu.Api.js?2179","webpack://EaselReact/easel/src/toolbars/ui-plugins/ToolbarComboBox.js","webpack://EaselReact/easel/src/plugins/options-shape-border/ShapeBorder.js","webpack://EaselReact/easel/src/plugins/shape-text/Text.js?814c","webpack://EaselReact/easel/src/fabricjs_extensions/Clipping.js?9dc4","webpack://EaselReact/easel/src/toolbars/instances/DrawingToolsToolbar.js","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontFamily.js?b2fe","webpack://EaselReact/easel/src/fabricjs_extensions/ErasablePath.js?ca61","webpack://EaselReact/easel/src/plugins/shape-diamond/Diamond.js","webpack://EaselReact/easel/src/Localization_en.js?8c3f","webpack://EaselReact/easel/src/plugins/feature-toggle-visiblity-button/ToggleVisibilityButton.js","webpack://EaselReact/easel/src/plugins/BaseShape.js?3d72","webpack://EaselReact/easel/src/toolbars/instances/OverCanvasToolbar.js?0799","webpack://EaselReact/easel/src/plugins/feature-fullscreen/FullscreenModeButton.js?3585","webpack://EaselReact/easel/src/plugins/options-shape-border/ShapeBorder.js?70d9","webpack://EaselReact/easel/src/Easel.Events.js?cd29","webpack://EaselReact/easel/src/plugins/option-stroke-width/StrokeWidth.js","webpack://EaselReact/easel/src/plugins/api-set-inactive-drawer-image/ApiSetInactiveEaselImage.js","webpack://EaselReact/easel/src/fabricjs_extensions/PText.js","webpack://EaselReact/easel/src/plugins/shape-image/ImageShape.js","webpack://EaselReact/easel/src/plugins/brush-eraser/EraserBrush.js","webpack://EaselReact/easel/src/plugins/brush-eraser/Eraser.js","webpack://EaselReact/easel/src/Easel.Storage.js","webpack://EaselReact/easel/lib/fabric.1.7.1.js?51ab","webpack://EaselReact/easel/src/plugins/option-text-styles/TextColor.js?d79b","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableObject.js","webpack://EaselReact/easel/src/plugins/feature-zoom/ZoomViewport.js?77f2","webpack://EaselReact/easel/src/plugins/option-color/ColorpickerControl.js?3031","webpack://EaselReact/easel/src/plugins/feature-selection/SelectionTool.js?dae1","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontWeight.js","webpack://EaselReact/easel/src/plugins/option-text-styles/TextLineHeight.js?8998","webpack://EaselReact/easel/src/toolbars/EaselToolbar.js?9952","webpack://EaselReact/easel/src/plugins/shape-polygon/Polygon.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasablePencilBrush.js","webpack://EaselReact/easel/src/plugins/feature-overcanvas-popup/OpenPopupButton.js","webpack://EaselReact/easel/src/fabricjs_extensions/SegmentablePolygon.js?f786","webpack://EaselReact/easel/src/plugins/option-opacity/Opacity.js?af08","webpack://EaselReact/easel/src/plugins/BaseOptionTool.js","webpack://EaselReact/easel/src/plugins/options-shape-fill/ShapeFill.js?4366","webpack://EaselReact/easel/src/plugins/option-color/OpacityControl.js?7b0d","webpack://EaselReact/easel/src/fabricjs_extensions/PCircle.js?2806","webpack://EaselReact/easel/src/plugins/feature-zoom/Zoom.js?2042","webpack://EaselReact/easel/src/plugins/option-text-styles/TextDecoration.js","webpack://EaselReact/easel/src/plugins/BaseTextOptionTool.js","webpack://EaselReact/easel/src/plugins/brush-eraser/Eraser.js?7089","webpack://EaselReact/easel/src/toolbars/instances/ToolOptionsToolbar.js?3712","webpack://EaselReact/easel/src/fabricjs_extensions/PTriangle.js?60e5","webpack://EaselReact/easel/src/plugins/option-color/Color.js","webpack://EaselReact/easel/src/plugins/feature-shape-contextmenu/ContextMenu.Api.js","webpack://EaselReact/easel/src/fabricjs_extensions/PText.js?df68","webpack://EaselReact/easel/src/Easel.Storage.js?aee5","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontStyle.js","webpack://EaselReact/easel/src/toolbars/instances/MinimizedToolbar.js?b9bf","webpack://EaselReact/easel/src/plugins/option-colorpicker-html5/ColorpickerHtml5.js?dc4c","webpack://EaselReact/easel/src/toolbars/instances/ToolOptionsToolbar.js","webpack://EaselReact/easel/src/plugins/feature-zoom/Zoom.js","webpack://EaselReact/easel/src/toolbars/ui-plugins/ToolbarTooltip.js?c65e","webpack://EaselReact/easel/src/fabricjs_extensions/ErasablePencilBrush.js?6f88","webpack://EaselReact/easel/src/Globals.js?d6bd","webpack://EaselReact/easel/src/plugins/brush-eraser-simplewhite/SimpleWhiteEraser.js?a033","webpack://EaselReact/easel/src/plugins/option-line-width/LineWidth.js","webpack://EaselReact/easel/src/plugins/option-colorpicker-html5/ColorpickerHtml5.js","webpack://EaselReact/easel/src/Easel.SimpleFactory.js","webpack://EaselReact/easel/src/plugins/shape-image/ImageShape.js?cb6a","webpack://EaselReact/easel/src/plugins/shape-arrow/ArrowTwoSideShape.js?22fc","webpack://EaselReact/easel/src/plugins/option-text-styles/TextBackgoundColor.js?a2af","webpack://EaselReact/easel/src/plugins/option-text-styles/TextBackgoundColor.js","webpack://EaselReact/easel/src/plugins/shape-rectangle/Rectangle.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableMixin.js?bdba","webpack://EaselReact/easel/src/plugins/shape-arrow/ArrowTwoSideShape.js","webpack://EaselReact/easel/node_modules/script-loader/addScript.js","webpack://EaselReact/easel/src/fabricjs_extensions/PDiamond.js","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontSize.js","webpack://EaselReact/easel/src/Easel.SimpleFactory.js?2e2c","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableRect.js","webpack://EaselReact/easel/src/plugins/shape-arrow/ArrowShape.js","webpack://EaselReact/easel/src/plugins/feature-overcanvas-popup/OpenPopupButton.js?13b5","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableLine.js","webpack://EaselReact/easel/src/plugins/BaseShape.js","webpack://EaselReact/easel/src/fabricjs_extensions/FloatingControl.js?bd1b","webpack://EaselReact/easel/src/plugins/feature-toggle-visiblity-button/ToggleVisibilityButton.js?48f7","webpack://EaselReact/easel/src/plugins/feature-export-svg/ExportSVG.js","webpack://EaselReact/easel/src/plugins/feature-overcanvas-popup/OvercanvasPopup.js","webpack://EaselReact/easel/src/fabricjs_extensions/FloatingControl.js","webpack://EaselReact/easel/src/plugins/option-text-styles/TextAlign.js","webpack://EaselReact/easel/src/Easel.DefaultOptions.js","webpack://EaselReact/easel/src/toolbars/EaselToolbarManager.js","webpack://EaselReact/easel/src/plugins/feature-image-crop/ImageCrop.js?7ccf","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontWeight.js?19c4","webpack://EaselReact/easel/src/plugins/shape-image/ImageToolApi.js","webpack://EaselReact/easel/src/plugins/feature-export-svg/ExportSVG.js?d446","webpack://EaselReact/easel/src/plugins/feature-movable-floating-mode/MovableFloatingMode.js?a5d9","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableImage.js?64db","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableImage.js","webpack://EaselReact/easel/src/Util.js?7882","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontSize.js?bb2c","webpack://EaselReact/easel/src/plugins/feature-movable-floating-mode/MovableFloatingMode.js","webpack://EaselReact/easel/src/plugins/shape-circle/Circle.js","webpack://EaselReact/easel/src/toolbars/instances/OverCanvasToolbar.js","webpack://EaselReact/easel/src/plugins/BaseTool.js?76b2","webpack://EaselReact/easel/src/Canvas.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableObject.js?9db7","webpack://EaselReact/easel/src/plugins/feature-canvas-properties/CanvasProperties.js?e01b","webpack://EaselReact/easel/src/fabricjs_extensions/Line.js","webpack://EaselReact/easel/src/plugins/option-text-styles/TextLineHeight.js","webpack://EaselReact/easel/src/fabricjs_extensions/Arrow.js","webpack://EaselReact/easel/src/plugins/BaseTextOptionTool.js?6c8b","webpack://EaselReact/easel/src/plugins/option-color/OpacityControl.js","webpack://EaselReact/easel/src/Easel.DefaultOptions.js?335c","webpack://EaselReact/easel/src/plugins/api-set-inactive-drawer-image/ApiSetInactiveEaselImage.js?71b6","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontStyle.js?4ceb","webpack://EaselReact/easel/src/Easel.js?fe33","webpack://EaselReact/easel/src/fabricjs_extensions/Arrow.js?9eb3","webpack://EaselReact/easel/src/plugins/brush-eraser/EraserPath.js?e93c","webpack://EaselReact/easel/src/fabricjs_extensions/ErasablePath.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableText.js?d6c6","webpack://EaselReact/easel/src/Easel.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableLine.js?f120","webpack://EaselReact/easel/src/fabricjs_extensions/PDiamond.js?9125","webpack://EaselReact/easel/src/Easel.ObjectApi.js?d4c3","webpack://EaselReact/easel/src/fabricjs_extensions/SegmentablePolygon.js","webpack://EaselReact/easel/src/Easel.ObjectApi.js","webpack://EaselReact/easel/src/toolbars/EaselToolbar.js","webpack://EaselReact/easel/src/plugins/option-color/ColorpickerControl.js","webpack://EaselReact/easel/src/plugins/feature-overcanvas-popup/OvercanvasPopup.js?c13e","webpack://EaselReact/easel/src/fabricjs_extensions/PRect.js?f3cb","webpack://EaselReact/easel/src/plugins/BaseBrush.js?daee","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableArrow.js?6148","webpack://EaselReact/easel/src/fabricjs_extensions/Line.js?2056","webpack://EaselReact/easel/src/plugins/feature-fullscreen/Fullscreen.js?300c","webpack://EaselReact/easel/src/toolbars/instances/MinimizedToolbar.js","webpack://EaselReact/easel/src/plugins/option-text-styles/TextAlign.js?7bcc","webpack://EaselReact/easel/src/plugins/shape-circle/Circle.js?6fc8","webpack://EaselReact/easel/src/toolbars/EaselToolbarManager.js?13ff","webpack://EaselReact/easel/src/plugins/brush-eraser/EraserBrush.js?0664","webpack://EaselReact/easel/src/plugins/shape-diamond/Diamond.js?4f4b","webpack://EaselReact/easel/src/plugins/shape-line/Line.js?6847","webpack://EaselReact/easel/src/plugins/option-text-styles/TextFontFamily.js","webpack://EaselReact/easel/src/plugins/option-opacity/Opacity.js","webpack://EaselReact/easel/src/plugins/feature-zoom/ZoomViewport.js","webpack://EaselReact/easel/src/Canvas.js?8ae8","webpack://EaselReact/easel/src/plugins/shape-arrow/ArrowShape.js?55f9","webpack://EaselReact/easel/src/plugins/shape-polygon/Polygon.js?e817","webpack://EaselReact/easel/src/plugins/feature-image-crop/ImageCropPlugin.js?5fff","webpack://EaselReact/easel/src/toolbars/instances/SettingsToolbar.js","webpack://EaselReact/easel/src/toolbars/ui-plugins/ToolbarTooltip.js","webpack://EaselReact/easel/src/plugins/shape-text/Text.js","webpack://EaselReact/easel/src/plugins/option-stroke-width/StrokeWidth.js?7a21","webpack://EaselReact/easel/src/plugins/feature-selection/SelectionTool.js","webpack://EaselReact/easel/src/Easel.Api.js","webpack://EaselReact/easel/src/Util.js","webpack://EaselReact/easel/src/Globals.js","webpack://EaselReact/easel/src/Easel.Api.js?cf91","webpack://EaselReact/easel/lib/fabric.1.7.1.js","webpack://EaselReact/easel/src/plugins/shape-line/Line.js","webpack://EaselReact/easel/src/plugins/feature-image-crop/ImageCropPlugin.js","webpack://EaselReact/easel/src/plugins/options-shape-fill/ShapeFill.js","webpack://EaselReact/easel/src/toolbars/ui-plugins/ToolbarTooltipManager.js?6f07","webpack://EaselReact/easel/src/fabricjs_extensions/PCircle.js","webpack://EaselReact/easel/src/plugins/option-brushSize/BrushSize.js","webpack://EaselReact/easel/src/plugins/option-text-styles/TextDecoration.js?b1a4","webpack://EaselReact/easel/src/plugins/brush-eraser-simplewhite/SimpleWhiteEraser.js","webpack://EaselReact/easel/src/toolbars/ui-plugins/ToolbarTooltipManager.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableArrow.js","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableText.js","webpack://EaselReact/easel/src/fabricjs_extensions/PTriangle.js","webpack://EaselReact/easel/src/plugins/option-brushSize/BrushSize.js?7f3b","webpack://EaselReact/easel/src/plugins/shape-image/ImageToolApi.js?654b","webpack://EaselReact/easel/src/fabricjs_extensions/PRect.js","webpack://EaselReact/easel/src/plugins/feature-shape-contextmenu/ShapeContextMenu.js","webpack://EaselReact/easel/src/plugins/option-line-width/LineWidth.js?abcd","webpack://EaselReact/easel/src/plugins/feature-fullscreen/Fullscreen.js","webpack://EaselReact/easel/src/toolbars/instances/DrawingToolsToolbar.js?d0ec","webpack://EaselReact/easel/src/fabricjs_extensions/ErasableMixin.js","webpack://EaselReact/easel/src/fabricjs_extensions/Clipping.js","webpack://EaselReact/easel/src/toolbars/instances/CropImageToolbar.js","webpack://EaselReact/easel/webpack/bootstrap","webpack://EaselReact/easel/webpack/runtime/compat get default export","webpack://EaselReact/easel/webpack/runtime/define property getters","webpack://EaselReact/easel/webpack/runtime/hasOwnProperty shorthand","webpack://EaselReact/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://EaselReact/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://EaselReact/./node_modules/react/cjs/react-jsx-runtime.production.js","webpack://EaselReact/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://EaselReact/./node_modules/react/jsx-runtime.js","webpack://EaselReact/webpack/bootstrap","webpack://EaselReact/webpack/runtime/compat get default export","webpack://EaselReact/webpack/runtime/define property getters","webpack://EaselReact/webpack/runtime/hasOwnProperty shorthand","webpack://EaselReact/webpack/runtime/nonce","webpack://EaselReact/./dist/easel.min.css?63ef","webpack://EaselReact/./react/EaselCanvas.jsx","webpack://EaselReact/./react/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"EaselReact\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"EaselReact\"] = factory(root[\"React\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__12__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.easel-toolbar,.easel-toolbar ul{background:var(--easel-color-surface,#fff);box-sizing:border-box;margin:0;padding:0;position:relative;user-select:none;z-index:1060!important}.easel-toolbar{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#f0f0f0);border-radius:24px;box-shadow:0 8px 32px rgba(122,77,217,.18),0 2px 8px rgba(0,0,0,.08);color:var(--easel-color-text,#2d1b4e)}.easel-toolbar .toolbar-dropdown-block,.easel-toolbar ul{z-index:202!important}.easel-toolbar .toolbar-content-wrapper{display:flex!important;justify-content:center!important;left:0;position:relative;top:0;transition:left .2s ease-out,top .2s ease-out}.easel-toolbar.easel-toolbar--horizontal{width:100%}.easel-toolbar.easel-toolbar--vertical{height:100%;z-index:500!important}.popup-content-wrapper .popup-content .easel-toolbar{overflow:visible}.easel-toolbar.easel-toolbar--multiline.easel-toolbar--horizontal .toolbar-content-wrapper,.easel-toolbar.easel-toolbar--multiline.easel-toolbar--vertical .toolbar-content-wrapper{height:auto;white-space:normal;width:100%}.easel-toolbar.toolbar-scrollable.easel-toolbar--horizontal .toolbar-content-wrapper{height:100%;white-space:nowrap;width:auto}.easel-toolbar.toolbar-scrollable.easel-toolbar--vertical .toolbar-content-wrapper{height:auto;white-space:normal;width:100%}.easel-toolbar>li,.easel-toolbar>ul>li,li.toolbar-item{background:var(--easel-color-surface,#fff);display:inline-block;list-style:none;text-align:start;vertical-align:top;white-space:nowrap}.toolbar-button{background:transparent;border-radius:12px;display:inline-block;height:40px;list-style-type:none;margin:0 2px;min-width:40px;text-align:center;transition:all .2s cubic-bezier(.4,0,.2,1);vertical-align:top;width:40px}.toolbar-button.btn-popup-canvas{min-width:40px;padding:0;width:40px}.toolbar-button.btn-popup-canvas a{align-items:center;display:flex;justify-content:center;padding:0}.toolbar-button a{border-radius:12px;color:var(--easel-color-text,#2d1b4e);display:inline-block;height:100%;line-height:40px;text-align:center;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.toolbar-button a:focus{outline:none}.toolbar-button a i{pointer-events:none}.drawer-instance-container:not(.touch) .toolbar-button:not(.dragging):not(.disabled) a:hover{background:var(--easel-color-primary,#a277ff);box-shadow:0 6px 20px rgba(122,77,217,.35);color:var(--easel-color-surface,#fff);transform:translateY(-2px) scale(1.05)}.toolbar-button.disabled:not(.dragging) a{background-color:var(--easel-color-border,#dcdcdc);color:var(--easel-color-text-muted,#6d5c88)}.toolbar-button a.active{background-color:var(--easel-color-primary,#a277ff);box-shadow:0 4px 16px rgba(122,77,217,.3),inset 0 1px 3px rgba(0,0,0,.1);color:var(--easel-color-surface,#fff);outline:none;transform:scale(.95)}.toolbar-button.btn-export-svg a{background:var(--easel-color-primary,#a277ff);box-shadow:0 6px 20px rgba(122,77,217,.35);color:var(--easel-color-surface,#fff);font-weight:600}.toolbar-button.btn-export-svg a:hover{transform:translateY(-2px) scale(1.05)}.submenu-wrapper{background:hsla(0,0%,100%,.95);border:1px solid var(--easel-color-border,#f0f0f0);border-radius:12px;box-shadow:0 8px 32px rgba(122,77,217,.18),0 2px 8px rgba(0,0,0,.08);padding:4px;pointer-events:auto;position:absolute;width:35px;z-index:1100}.submenu-wrapper .toolbar-button{margin:2px 0;width:35px}.toolbar-content-wrapper .submenu-wrapper{display:none}.group-items-container{padding:0;white-space:normal}.easel-toolbar .btn-delete-canvas a{color:var(--easel-color-danger,#d45a78)}.easel-toolbar.toolbar-scrollable{overflow:visible}.easel-toolbar.easel-toolbar--horizontal{display:block;margin:0 auto;max-width:90%;padding:8px 16px;width:fit-content}.easel-toolbar.easel-toolbar--horizontal .toolbar-content-wrapper,.easel-toolbar.easel-toolbar--vertical .toolbar-content-wrapper{display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-justify-content:flex-start;-ms-flex-pack:start;-webkit-align-content:flex-start;justify-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start}.easel-toolbar.easel-toolbar--multiline .toolbar-content-wrapper,.popup-content-wrapper .popup-content .easel-toolbar .toolbar-content-wrapper{-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.easel-toolbar.toolbar-scrollable .toolbar-content-wrapper{-webkit-flex-wrap:nowrap;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.easel-toolbar.easel-toolbar--horizontal .toolbar-content-wrapper{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.easel-toolbar.easel-toolbar--vertical .toolbar-content-wrapper{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.easel-toolbar.easel-toolbar--horizontal.empty-toolbar{height:0}.easel-toolbar.easel-toolbar--vertical{display:inline-block;position:relative;vertical-align:top;width:fit-content}.easel-toolbar.easel-toolbar--vertical.empty-toolbar{width:0}.toolbar-placeholder-right .easel-toolbar.easel-toolbar--vertical{background:hsla(0,0%,100%,.98);min-width:48px;padding:4px;width:auto}.toolbar-placeholder-right .toolbar-dropdown-toggle{background:var(--easel-color-surface,#fff);border:none;border-radius:12px;cursor:pointer;display:block;height:40px;outline:none;position:relative;transition:all .2s cubic-bezier(.4,0,.2,1);width:40px;z-index:1}.toolbar-placeholder-right .toolbar-dropdown-toggle:hover{background:var(--easel-color-primary,#a277ff);box-shadow:0 6px 20px rgba(122,77,217,.35);transform:scale(1.05)}.toolbar-placeholder-right .toolbar-dropdown-toggle:hover i{color:var(--easel-color-surface,#fff)}.toolbar-placeholder-right .toolbar-dropdown-toggle i{color:var(--easel-color-text,#2d1b4e);font-size:18px;line-height:40px;transition:color .2s ease}.toolbar-placeholder-right .toolbar-dropdown-toggle i:before{display:block}.toolbar-placeholder-right .toolbar-content-wrapper{animation:slideDown .2s ease-out;background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#f0f0f0);border-radius:16px;box-shadow:0 12px 40px rgba(122,77,217,.25),0 4px 12px rgba(0,0,0,.1);display:none;max-height:400px;min-width:48px;overflow-y:visible;padding:8px;position:absolute;right:0;top:52px;z-index:1100}@keyframes slideDown{0%{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}.toolbar-placeholder-right .easel-toolbar.easel-toolbar--vertical.dropdown-open .toolbar-content-wrapper{display:flex}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar{width:6px}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar-track{background:transparent}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar-thumb{background:var(--easel-color-border-strong,#cbb6ff);border-radius:3px}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar-thumb:hover{background:var(--easel-color-primary,#a277ff)}.easel-toolbar.easel-toolbar--horizontal>li{height:100%}.toolbars-wrapper{bottom:0;left:0;pointer-events:none;position:absolute;right:0;top:0;z-index:1050}.toolbar-placeholder{box-sizing:border-box;margin:0;padding-left:0;pointer-events:auto;position:absolute;z-index:1000}.toolbar-placeholder:not(.toolbar-placeholder-inside){z-index:5000}.toolbar-placeholder-top{top:10px}.toolbar-placeholder-bottom,.toolbar-placeholder-top{height:auto;left:0;right:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none}.toolbar-placeholder-bottom{align-items:center;bottom:15px;display:flex;justify-content:center;pointer-events:none}@media (max-width:767px){.toolbar-placeholder-top{display:none!important}}.toolbar-placeholder-bottom .easel-toolbar{pointer-events:auto}.toolbar-placeholder-left{bottom:0;left:10px;top:0}.toolbar-placeholder-left,.toolbar-placeholder-right{-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;width:auto}.toolbar-placeholder-right{bottom:auto;right:15px;top:15px}.toolbar-placeholder-top.toolbar-placeholder-inside{margin-top:0;top:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none}.toolbar-placeholder-bottom.toolbar-placeholder-inside{bottom:0;margin-bottom:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;z-index:1002}.toolbar-placeholder-left.toolbar-placeholder-inside{left:0;margin-left:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;z-index:1001}.toolbar-placeholder-right.toolbar-placeholder-inside{margin-right:0;right:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;z-index:1001}.toolbar-placeholder.toolbar-placeholder-inside{height:100%;overflow:hidden;pointer-events:none;width:100%}.toolbar-placeholder.toolbar-placeholder-inside .easel-toolbar{overflow:visible;pointer-events:auto;position:absolute}.toolbar-placeholder-top.toolbar-placeholder-inside .easel-toolbar{left:0;right:0;top:0}.toolbar-placeholder-bottom.toolbar-placeholder-inside .easel-toolbar{bottom:0;left:0;right:0}.toolbar-placeholder-left.toolbar-placeholder-inside .easel-toolbar{bottom:0;left:0;top:0}.element-properties-toolbar{border-radius:20px;box-shadow:0 10px 30px rgba(122,77,217,.18);display:inline-flex;flex-direction:column;max-width:min(320px,calc(100% - 24px));min-width:0;padding:16px 12px;width:auto}.element-properties-toolbar.easel-toolbar--vertical .toolbar-content-wrapper{align-items:stretch;display:flex;flex-direction:column;gap:12px;width:auto}.toolbar-placeholder-left.toolbar-placeholder-inside .element-properties-toolbar{bottom:auto;left:16px;top:50%;transform:translateY(-50%)}.toolbar-placeholder-right.toolbar-placeholder-inside .easel-toolbar{bottom:0;right:0;top:0}.toolbar-placeholder-overcanvas{left:0;top:0;z-index:1100}.toolbar-placeholder-overcanvas .easel-toolbar{border:none;box-shadow:none;overflow:initial}.toolbar-placeholder-overcanvas .easel-toolbar .toolbar-content-wrapper{position:static}.toolbar-placeholder-overcanvas .easel-toolbar .toolbar-content-wrapper li{border:1px solid var(--easel-color-border,#e5e5e5);position:absolute;width:35px}.toolbar-placeholder .toolbar-placeholder-overlay{background-color:var(--easel-color-surface,#fff);bottom:0;display:none;left:0;list-style-type:none;opacity:.85;position:absolute;right:0;top:0;z-index:1200}.toolbar-placeholder.placeholder-overlayed .toolbar-placeholder-overlay{display:block}.toolbar-placeholder.placeholder-disabled,.toolbar-placeholder.placeholder-disabled :not(.popup-overlay):not(.toolbar-placeholder-overlay){cursor:default!important;pointer-events:none!important}.toolbar-label{height:100%;line-height:35px;margin-right:10px;width:auto}.toolbar-item-wrapper,.toolbar-label{display:inline-block;vertical-align:top}.toolbar-item-wrapper{list-style:none;position:relative;text-align:left}.toolbar-item-label{display:inline-block;height:100%;line-height:35px;margin-right:10px;vertical-align:top;width:auto}.toolbar-item-icon{background-color:transparent;background-position:50%;border-radius:12px;bottom:0;cursor:pointer;display:none;left:0;line-height:40px;position:absolute;right:0;text-align:center;top:0;transition:all .2s cubic-bezier(.4,0,.2,1)}.toolbar-item-icon:before{transition:color .4s linear}.toolbar-item-wrapper .toolbar-dropdown-block{display:inline-block;position:relative}.toolbar-item-wrapper.toolbar-button-item{border:1px solid transparent;border-radius:12px;height:40px;margin:0 3px;padding:0;transition:all .2s cubic-bezier(.4,0,.2,1);width:40px}.toolbar-item-wrapper.toolbar-button-item:before{border:1px solid transparent;color:var(--easel-color-text,#2d1b4e);height:40px;margin:0 3px;padding:0;width:40px}.toolbar-item-wrapper.toolbar-button-item.prevent-highlight .toolbar-item-icon{background-color:var(--easel-color-surface,#fff)!important}.toolbar-item-wrapper.toolbar-button-item.prevent-highlight .toolbar-item-icon:before{color:var(--easel-color-text,#2d1b4e)!important}.toolbar-item-wrapper.toolbar-button-item:not(.option-value-inherited):not(.option-value-invalid):not(.option-value-multiple) .toolbar-item-icon:before{color:var(--easel-color-surface,#fff)}.toolbar-item-wrapper.toolbar-button-item.option-value-inherited:not(.option-value-multiple) .toolbar-item-icon{background-color:var(--easel-color-surface,#fff)}.toolbar-item-wrapper.toolbar-button-item.option-value-multiple .toolbar-item-icon{background-color:var(--easel-color-border,#dcdcdc)}.toolbar-item-wrapper.toolbar-button-item .toolbar-dropdown-block{left:-1px;position:absolute;top:100%}.element-properties-toolbar .toolbar-item-wrapper.toolbar-button-item .toolbar-dropdown-block{bottom:auto;left:calc(100% + 12px);top:50%;transform:translateY(-50%)}.toolbar-placeholder-bottom .toolbar-item-wrapper.toolbar-button-item .toolbar-dropdown-block{bottom:100%;left:-1px;position:absolute;top:auto}.toolbar-item-wrapper.toolbar-button-item .toolbar-item-label,.toolbar-item-wrapper.toolbar-button-item.collapsed .toolbar-dropdown-block{display:none}.toolbar-item-wrapper.toolbar-button-item .toolbar-item-icon{display:block}.btn-toggle-canvas.active a,.btn-toggle-canvas.dragging a{background-color:var(--easel-color-primary,#a277ff);color:var(--easel-color-surface,#fff);outline:none}.easel-toolbar.tool-minimized-toolbar{display:none}.toolbar-item-description{display:inline-block;vertical-align:top}.toolbar-item-description input{vertical-align:top}.easel-toolbar input[type=range]{-webkit-appearance:none;appearance:none;background:var(--easel-color-surface-muted,#f7f3ff);border:none;border-radius:12px;height:32px;overflow:hidden;padding:8px 12px;top:0;width:200px}.easel-toolbar input[type=range]::-webkit-slider-runnable-track{background:var(--easel-color-border,#ddd);border:none;border-radius:10px;height:6px;width:100%}.easel-toolbar input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;background:var(--easel-color-primary,#a277ff);border:3px solid var(--easel-color-surface,#fff);border-radius:50%;box-shadow:0 2px 8px rgba(122,77,217,.3);cursor:pointer;height:20px;margin-top:-7px;transition:all .2s ease;width:20px}.easel-toolbar input[type=range]:focus{outline:none}.easel-toolbar input[type=range]:focus::-webkit-slider-runnable-track{background:var(--easel-color-border-strong,#ccc)}.easel-toolbar input[type=range]::-moz-range-track{background:var(--easel-color-border,#ddd);border:none;border-radius:10px;height:6px;width:100%}.easel-toolbar input[type=range]::-moz-range-thumb{background:var(--easel-color-primary,#a277ff);border:3px solid var(--easel-color-surface,#fff);border-radius:50%;box-shadow:0 2px 8px rgba(122,77,217,.3);cursor:pointer;height:20px;width:20px}.easel-toolbar input[type=range]:-moz-focusring{outline:1px solid #fff;outline-offset:-1px}.easel-toolbar input[type=range]::-ms-track{background:transparent;border-color:transparent;border-width:6px 0;color:transparent;height:5px;width:300px}.easel-toolbar input[type=range]::-ms-fill-lower{background:var(--easel-color-border-strong,#777);border-radius:10px}.easel-toolbar input[type=range]::-ms-fill-upper{background:var(--easel-color-border,#ddd);border-radius:10px}.easel-toolbar input[type=range]::-ms-thumb{background:var(--easel-color-primary,#a277ff);border:3px solid var(--easel-color-surface,#fff);border-radius:50%;box-shadow:0 2px 8px rgba(122,77,217,.3);cursor:pointer;height:20px;width:20px}.easel-toolbar input[type=range]:focus::-ms-fill-lower{background:var(--easel-color-border-strong,#888)}.easel-toolbar input[type=range]:focus::-ms-fill-upper{background:var(--easel-color-border-strong,#ccc)}.tooltip-transparent{display:block!important;opacity:0!important;visibility:visible!important}.editable-canvas-tooltip{background:#000;border-radius:4px;color:#fff;display:block;font-size:12px;opacity:0;padding:5px 8px;pointer-events:none;position:absolute;transition:opacity .2s;z-index:100001}.editable-canvas-tooltip.active{opacity:1}.editable-canvas-tooltip:after{border-style:solid;content:\"\";height:0;position:absolute;width:0}.editable-canvas-tooltip[positionX=left][positionY=top]{border-bottom-right-radius:0}.editable-canvas-tooltip[positionX=left][positionY=top]:after{border-color:transparent transparent transparent #000;border-width:10px 0 0 10px;bottom:0;left:100%}.editable-canvas-tooltip[positionX=left][positionY=bottom]{border-top-right-radius:0}.editable-canvas-tooltip[positionX=left][positionY=bottom]:after{border-color:#000 transparent transparent;border-width:10px 10px 0 0;left:100%;top:0}.editable-canvas-tooltip[positionX=right][positionY=bottom]{border-top-left-radius:0}.editable-canvas-tooltip[positionX=right][positionY=bottom]:after{border-color:transparent #000 transparent transparent;border-width:0 10px 10px 0;right:100%;top:0}.editable-canvas-tooltip[positionX=right][positionY=top]{border-bottom-left-radius:0}.editable-canvas-tooltip[positionX=right][positionY=top]:after{border-color:transparent transparent #000;border-width:0 0 10px 10px;bottom:0;right:100%}.editable-canvas-tooltip[positionX=right][positionY=center]:after{border-color:transparent #000 transparent transparent;border-width:5px 10px 5px 0;right:100%}.editable-canvas-tooltip[positionX=left][positionY=center]:after,.editable-canvas-tooltip[positionX=right][positionY=center]:after{top:50%;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%)}.editable-canvas-tooltip[positionX=left][positionY=center]:after{border-color:transparent transparent transparent #000;border-width:5px 0 5px 10px;left:100%}.editable-canvas-tooltip[positionX=center][positionY=top]:after{border-color:#000 transparent transparent;border-width:10px 5px 0;top:100%}.editable-canvas-tooltip[positionX=center][positionY=bottom]:after,.editable-canvas-tooltip[positionX=center][positionY=top]:after{left:50%;-webkit-transform:translateX(-50%);-moz-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translateX(-50%)}.editable-canvas-tooltip[positionX=center][positionY=bottom]:after{border-color:transparent transparent #000;border-width:0 5px 10px;bottom:100%}.toolbar-combobox-wrapper{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-sizing:border-box;color:var(--easel-color-text,#2d1b4e);display:inline-block;margin:2px auto;min-width:140px;outline:none;position:relative;transition:all .2s cubic-bezier(.4,0,.2,1);width:auto}.toolbar-placeholder-bottom .toolbar-combobox-wrapper{bottom:100%;position:absolute;top:auto}.toolbar-combobox-wrapper>.selected{border-radius:12px;cursor:pointer;display:table;float:left;height:36px;line-height:36px;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.toolbar-combobox-wrapper>.selected span{display:table-cell;font-size:14px;padding:0 13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle}.toolbar-combobox-wrapper.option-value-inherited>.selected{background-color:#dcdcdc}.toolbar-combobox-wrapper.option-value-multiple>.selected{background-color:#efb5b5}.toolbar-combobox-wrapper.hightlight-red>.selected .ui-button{background:#fff}.toolbar-combobox-wrapper .dropdown-box{background-color:hsla(0,0%,100%,.98);border-top:none;border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-shadow:0 8px 24px rgba(122,77,217,.15);box-sizing:border-box;padding:8px 0;position:relative;top:38px;z-index:2}.toolbar-combobox-wrapper:not(.button-mode) .toolbar-item-description{display:inline-block}.toolbar-combobox-wrapper .inputbox{clear:both;display:none;margin:5px 5px 0}.toolbar-combobox-wrapper.edit-mode .inputbox{display:block}.toolbar-combobox-wrapper .inputbox input[type=text]{background:var(--easel-color-surface-muted,#f7f3ff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:10px;color:var(--easel-color-text,#2d1b4e);font-size:14px;outline:none;padding:10px 14px;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.toolbar-combobox-wrapper .inputbox input[type=text]:focus{background:var(--easel-color-surface,#fff);border-color:var(--easel-color-primary,#a277ff);box-shadow:0 0 0 3px rgba(162,119,255,.15)}.toolbar-combobox-wrapper .option-list{clear:both;list-style:none;padding:0;-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0;-webkit-padding-start:0;display:inline-block;margin-top:5px;max-height:195px;overflow-x:auto;overflow-y:visible;position:relative;width:100%}.toolbar-combobox-wrapper .option-list .option-item{border-radius:8px;color:var(--easel-color-text,#2d1b4e);cursor:pointer;display:block;font-size:13px;line-height:32px;margin:2px 8px;padding:0 12px;transition:all .2s cubic-bezier(.4,0,.2,1)}.toolbar-combobox-wrapper .option-list .option-item .option-item-text{display:inline-block;white-space:nowrap}.toolbar-combobox-wrapper .option-list .option-item:first-letter{text-transform:uppercase}.toolbar-combobox-wrapper .option-list .option-item:not(.selected):hover{background-color:var(--easel-color-primary-light,#d6c6ff);transform:translateX(4px)}.toolbar-combobox-wrapper .option-list .option-item.selected{background-color:var(--easel-color-primary,#a277ff);color:var(--easel-color-surface,#fff);font-weight:500}.toolbar-combobox-wrapper .ui-button{background-color:transparent;border-left:1px solid var(--easel-color-border,#e3d8ff);border-radius:0 12px 12px 0;color:var(--easel-color-text-muted,#6d5c88);cursor:pointer;display:table-cell;float:right;height:100%;text-align:center;transition:all .2s cubic-bezier(.4,0,.2,1);width:40px}.toolbar-combobox-wrapper .ui-button:hover{background-color:var(--easel-color-primary-light,#d6c6ff);color:var(--easel-color-primary-dark,#7c4ed9)}.toolbar-combobox-wrapper .ui-button i{margin-top:7px}.toolbar-combobox-wrapper:focus{box-shadow:0 0 0 3px rgba(162,119,255,.15)}.toolbar-combobox-wrapper:focus,.toolbar-combobox-wrapper:focus .dropdown-box{border-color:var(--easel-color-primary,#a277ff)}.toolbar-combobox-wrapper:focus .ui-button{border-left-color:var(--easel-color-primary,#a277ff)}.toolbar-combobox-wrapper.focus{box-shadow:0 0 0 3px rgba(162,119,255,.15)}.toolbar-combobox-wrapper.focus,.toolbar-combobox-wrapper.focus .dropdown-box{border-color:var(--easel-color-primary,#a277ff)}.toolbar-combobox-wrapper.focus .ui-button{border-left-color:var(--easel-color-primary,#a277ff)}.toolbar-item-wrapper:not(.toolbar-button-item) .toolbar-combobox-wrapper .dropdown-box.collapsed,.toolbar-item-wrapper:not(.toolbar-button-item) .toolbar-combobox-wrapper.collapsed .dropdown-box{display:none}.toolbar-button-item .toolbar-combobox-wrapper{margin:0 0 -1px}.combobox-cloned.toolbar-combobox-wrapper>.selected,.toolbar-button-item .toolbar-combobox-wrapper>.selected{display:none}.combobox-cloned.toolbar-combobox-wrapper>.dropdown-box,.toolbar-button-item .toolbar-combobox-wrapper>.dropdown-box{display:block;top:0}.toolbar-button-item .collapsed .toolbar-combobox-wrapper:not(.combobox-cloned){display:none}#easel-canvas-box.fullscreen{background:var(--easel-color-surface,#fff)!important;bottom:0!important;height:auto!important;left:0!important;position:fixed!important;right:0!important;top:0!important;transition:none!important;width:auto!important;z-index:100000}#easel-canvas-box.fullscreen .easel-canvas-resizer,#easel-canvas-box.fullscreen .toolbar-button.btn-delete-canvas,#easel-canvas-box.fullscreen .toolbar-button.btn-minimize-canvas,#easel-canvas-box.fullscreen .toolbar-button.btn-move,#easel-canvas-box.fullscreen .toolbar-button.btn-restore-canvas{display:none!important}#easel-canvas-box.fullscreen .fullscreenOverOther{z-index:2000!important}#easel-canvas-box.fullscreen .canvas-container{height:100%!important;width:100%!important}#easel-canvas-box.animation.fullscreen,#easel-canvas-box.fullscreen-in-progress{transition:none!important}#easel-canvas-box.fullscreen-in-progress .toolbars-wrapper{opacity:0!important}.zoom-tooltip{background-color:#ccc;border-radius:5px;left:50%;opacity:.85;padding:5px;pointer-events:none;position:absolute;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);-moz-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);transition:opacity .5s linear;z-index:20000000}.zoom-tooltip.transparent-tooltip{opacity:0}.crop-container{background:var(--easel-color-surface,#fff);bottom:0;left:0;position:absolute;right:0;top:0;z-index:20000}.crop-container .cr-image{left:0;max-height:none;max-width:none;opacity:0;position:absolute;top:0;transform-origin:0 0;z-index:-1;z-index:-2}.crop-container .cr-boundary{height:100%;margin:0 auto;overflow:hidden;position:relative;width:100%;z-index:1}.crop-container .cr-viewport{border:2px solid var(--easel-color-surface,#fff);bottom:0;box-shadow:0 0 2000px 2000px rgba(45,27,78,.5);left:0;margin:auto;pointer-events:none;position:absolute;right:0;top:0;z-index:100}.crop-container .cr-original-image{display:none}.crop-container .cr-vp-circle{border-radius:50%}.crop-container .cr-overlay{border-radius:12px;cursor:move;position:absolute;z-index:1}.crop-container .cr-slider-wrap{bottom:0;left:0;margin:15px auto;position:absolute;right:0;text-align:center;z-index:1}.croppie-result{overflow:hidden;position:relative}.croppie-result img{position:absolute}.crop-container .cr-image,.crop-container .cr-overlay,.crop-container .cr-viewport{-webkit-transform:translateZ(0);-moz-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0)}.cr-viewport-resizer{height:inherit;left:50%;position:absolute;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);-moz-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);width:inherit}.cr-viewport-resizer.resizing{background:rgba(162,119,255,.18);border:2px dotted var(--easel-color-primary-dark,#7c4ed9);box-sizing:content-box;margin:0}.cr-viewport-resizer-handler{background:var(--easel-color-primary,#a277ff);border:2px solid var(--easel-color-border,#ccc);cursor:nwse-resize;height:15px;left:100%;margin:-10px 0 0 -10px;pointer-events:auto;position:absolute;top:100%;width:15px}.cr-controls-wrapper{position:absolute;right:5px;top:50%;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);z-index:200}.cr-controls-wrapper .btn{display:block;margin:5px auto}.cr-slider{-webkit-appearance:none;appearance:none;background-color:transparent;cursor:pointer;max-width:100%;padding-bottom:8px;padding-top:8px;width:300px}.cr-slider::-webkit-slider-runnable-track{background:var(--easel-color-border,rgba(0,0,0,.3));border:0;border-radius:3px;height:3px;width:100%}.cr-slider::-webkit-slider-thumb{-webkit-appearance:none;background:var(--easel-color-primary,#a277ff);border:none;border-radius:50%;height:16px;margin-top:-6px;width:16px}.cr-slider:focus{outline:none}.cr-slider::-moz-range-track{background:var(--easel-color-border,rgba(0,0,0,.3));border:0;border-radius:3px;height:3px;width:100%}.cr-slider::-moz-range-thumb{background:var(--easel-color-primary,#a277ff);border:none;border-radius:50%;height:16px;margin-top:-6px;width:16px}.cr-slider:-moz-focusring{outline:1px solid #fff;outline-offset:-1px}.cr-slider::-ms-track{background:transparent;border-color:transparent;border-width:6px 0;color:transparent;height:5px;width:100%}.cr-slider::-ms-fill-lower{background:var(--easel-color-border-strong,rgba(0,0,0,.4));border-radius:10px}.cr-slider::-ms-fill-upper{background:var(--easel-color-border,rgba(0,0,0,.3));border-radius:10px}.cr-slider::-ms-thumb{background:var(--easel-color-primary,#a277ff);border:none;border-radius:50%;height:16px;margin-top:1px;width:16px}.cr-slider:focus::-ms-fill-lower,.cr-slider:focus::-ms-fill-upper{background:rgba(0,0,0,.5)}.cr-rotate-controls{bottom:5px;left:5px;position:absolute;z-index:1}.cr-rotate-controls button{background:var(--easel-color-surface,transparent);border:0;color:var(--easel-color-text-muted,#6d5c88)}.cr-rotate-controls i:before{display:inline-block;font-size:22px;font-style:normal;font-weight:900}.cr-rotate-l i:before{content:\"\"}.cr-rotate-r i:before{content:\"\"}.image-crop-wrapper{background:var(--easel-color-surface,#fff);bottom:0;left:0;overflow:hidden;position:absolute;right:0;top:0;z-index:201}.cr-image{left:50%;max-height:100%;max-width:100%;position:absolute;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);-moz-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%)}.cr-image-fullsize{opacity:0}.imager-crop-container{z-index:1300}.imager-crop-canvas,.imager-crop-container{height:100%;left:0;position:absolute;top:0;width:100%}.crop-corner{background:#fff;border:1px solid #00b7ff;height:7px;position:absolute;width:7px;z-index:1301}.crop-top-left{cursor:nwse-resize;left:0;top:0}.crop-top-right{cursor:nesw-resize;right:0;top:0}.crop-bottom-right{bottom:0;cursor:nwse-resize;right:0}.crop-bottom-left{bottom:0;cursor:nesw-resize;left:0}.crop-border{position:absolute}.crop-border.crop-border-top{height:1px;top:4px;width:100%}.crop-border.crop-border-right{height:100%;right:2px;width:1px}.crop-border.crop-border-bottom{bottom:2px;height:1px;width:100%}.crop-border.crop-border-left{height:100%;left:4px;width:1px}.minimized{border:none!important;height:auto!important;width:auto!important}.minimized .toolbar-placeholder.toolbar-placeholder-top.toolbar-placeholder-inside,.minimized .toolbars-wrapper{position:static}.drawer-toolbar.tool-minimized-toolbar,.minimized .canvas-container,.minimized .drawer-toolbar:not(.tool-minimized-toolbar),.minimized .toolbar-button.btn-fullscreen-canvas,.minimized span.redactor-drawer-resizer{display:none}.minimized .drawer-toolbar.tool-minimized-toolbar{display:inline-block}.minimized .drawer-toolbar.tool-minimized-toolbar .toolbar-content-wrapper{display:inline-block;white-space:nowrap}.canvas-caption{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:8px;color:var(--easel-color-text,#2d1b4e);display:inline-block;line-height:32px;list-style-type:none;margin:0 5px;padding:0 12px;text-align:center;vertical-align:middle}.editable-canvas-colorpicker{-webkit-appearance:none;appearance:none;background:var(--easel-color-surface,#fff);border:none;height:32px;position:relative;width:32px}.editable-canvas-colorpicker::-webkit-color-swatch-wrapper{padding:0}.editable-canvas-colorpicker::-webkit-color-swatch{border:none}ul.drawer-toolbar li.editable-easel-plugin-color .toolbar-label{position:relative;top:-9px}ul.drawer-toolbar li.editable-easel-plugin-color{padding-left:10px;text-align:left;width:auto}.editable-canvas-stroke-width .toolbar-item-description{display:inline-block}.editable-canvas-stroke-width input.editable-canvas-stroke-width-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.editable-canvas-stroke-width .editable-canvas-stroke-width-label{padding-left:10px}span.toolbar-label.editable-canvas-stroke-width-indicator{display:inline-block;margin-right:5px;width:50px}label.background-transparency{display:inline!important;font-weight:400;padding-left:10px!important;width:auto}.toolbar-button .fa-line{-ms-transform:rotate(24deg);-webkit-transform:rotate(24deg);-moz-transform:rotate(24deg);transform:rotate(24deg);width:14px}.toolbar-button .fa-line:before{content:\"/\";font-size:19px!important;font-weight:700;line-height:10px;position:relative;top:2px}.drawer-tool-mouse-tooltip .fa-line{left:5px;position:relative;top:2px}.popup-wrapper{bottom:0;left:0;position:absolute;right:0;top:0;z-index:1106}.popup-wrapper .popup-content-wrapper{background-color:var(--easel-color-surface,#fff);border:1px solid rgba(45,27,78,.08);border-radius:18px;box-shadow:0 20px 45px rgba(15,23,42,.12);max-width:420px;position:absolute;z-index:1}.popup-wrapper .popup-content-wrapper.popup-transparent{opacity:0}.popup-wrapper .popup-content-wrapper .popup-arrow{height:10px;margin-left:-5px;margin-top:-5px;position:absolute;width:10px;z-index:111}.popup-wrapper .popup-content-wrapper .popup-arrow:after,.popup-wrapper .popup-content-wrapper .popup-arrow:before{border:0 solid;content:\"\";display:block;margin-left:-5px;margin-top:-5px;position:absolute}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow{bottom:auto!important;top:100%!important}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:before{border-width:10px 10px 0;margin-top:5px}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:after{border-color:var(--easel-color-surface,#fff) transparent transparent transparent;margin-top:3px}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:before{border-color:var(--easel-color-border,#ccc) transparent transparent transparent}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow{left:100%!important;right:auto!important}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:before{border-width:10px 0 10px 10px;margin-left:5px}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:after{border-color:transparent transparent transparent var(--easel-color-surface,#fff);margin-left:3px}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:before{border-color:transparent transparent transparent var(--easel-color-border,#ccc)}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow{left:auto!important;right:100%!important}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:before{border-width:10px 10px 10px 0;margin-left:0}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:after{border-color:transparent var(--easel-color-surface,#fff) transparent transparent;margin-left:2px}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:before{border-color:transparent var(--easel-color-border,#ccc) transparent transparent}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow{bottom:100%!important;margin-top:0;top:auto!important}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:before{border-width:0 10px 10px}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:after{border-color:transparent transparent var(--easel-color-surface,#fff) transparent;margin-top:2px}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:before{border-color:transparent transparent var(--easel-color-border,#ccc) transparent;margin-top:0}.popup-wrapper .popup-content{--popup-grid-min-column:260px;align-content:flex-start;align-items:stretch;box-sizing:border-box;display:grid;gap:20px;grid-template-columns:repeat(auto-fit,minmax(0,max-content));justify-content:flex-start;max-height:70vh;overflow-y:auto;padding:20px;width:100%}.popup-wrapper .popup-content .toolbar-placeholder{background:var(--easel-color-surface,#fff);border:1px solid rgba(45,27,78,.08);border-radius:16px;box-shadow:0 12px 30px rgba(15,23,42,.08);display:grid;gap:14px;grid-auto-rows:minmax(0,max-content);justify-self:flex-start;list-style:none;margin:0;max-width:100%;padding:18px;width:max-content}.popup-wrapper .popup-content .drawer-toolbar{background:transparent;border:none;box-shadow:none;max-width:100%;width:100%}.popup-wrapper .popup-content .drawer-toolbar .toolbar-content-wrapper{gap:12px;width:100%}.popup-wrapper .popup-overlay{background-color:rgba(45,27,78,.12);bottom:0;left:0;opacity:1;position:absolute;right:0;top:0}@media (max-width:640px){.popup-wrapper .popup-content-wrapper{max-width:calc(100% - 24px)}.popup-wrapper .popup-content{gap:16px;grid-template-columns:1fr;max-height:80vh}}.popup-wrapper .popup-close-btn{border-radius:50%;color:var(--easel-color-text-muted,#6d5c88);cursor:pointer;height:32px;line-height:32px;position:absolute;right:8px;text-align:center;top:8px;transition:all .2s cubic-bezier(.4,0,.2,1);width:32px;z-index:1007}.popup-wrapper .popup-close-btn:hover{background:var(--easel-color-primary-light,#d6c6ff);color:var(--easel-color-primary-dark,#7c4ed9);transform:scale(1.1)}.popup-wrapper .popup-content .toolbar-placeholder{position:static}.popup-wrapper .popup-content .toolbar-item-wrapper{display:flex;flex-direction:column;gap:6px;width:100%}.popup-wrapper .popup-content .toolbar-item-label{color:var(--easel-color-text-muted,#6d5c88);font-size:.7rem;letter-spacing:.08em;line-height:1;margin:0;text-transform:uppercase}.popup-wrapper .popup-content .toolbar-item-wrapper .toolbar-item-icon{position:relative}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range{align-items:center;background:var(--easel-color-surface-muted,#faf8ff);border-radius:12px;column-gap:12px;display:grid;grid-template-columns:minmax(0,1fr) auto;grid-template-rows:auto auto;min-width:100%;padding:8px 12px 12px;row-gap:6px;width:100%}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range input[type=range]{grid-column:1/-1;margin:0;width:100%}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range .toolbar-item-description{align-items:center;display:grid;gap:8px;grid-column:1/-1;grid-template-columns:minmax(0,1fr) auto;padding:0;position:static}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range .toolbar-label{padding:0;text-align:left}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range .toolbar-label.toolbar-label-indicator{text-align:right}.btn-diamond .fa-diamond,.drawer-tool-mouse-tooltip .fa-diamond{font-size:14px}.drawer-tool-mouse-tooltip{background:#f5f5f5;border:1px solid #efefef;border-radius:4px;box-shadow:0 2px 3px rgba(0,0,0,.03);margin-left:10px;margin-top:10px;opacity:0;padding:5px 10px;pointer-events:none;position:absolute;transition:opacity .2s;white-space:nowrap;z-index:99999}.editable-canvas-border-type{padding-left:8px;position:relative;width:auto!important}.popup-content-wrapper .popup-content .editable-canvas-border-type .toolbar-label{margin-right:6px}.editable-canvas-border-type .border-type-indicator{background-position:50%;background-repeat:no-repeat;height:20px;line-height:20px;margin-top:8px;padding:0 8px;width:60px!important}.border-type-dropdown,.editable-canvas-border-type .border-type-indicator{border:1px solid var(--easel-color-border,#ccc);box-sizing:content-box;display:inline-block;text-align:center}.border-type-dropdown{background:var(--easel-color-surface,#fff);left:auto;padding:5px;position:absolute;right:0;transform:none;width:66px}.border-type-dropdown ul li{background-position-y:50%;background-repeat:no-repeat;cursor:pointer;display:block;height:20px;line-height:20px;width:100%}.border-type-dropdown ul li:hover{background-color:var(--easel-color-primary,#a277ff)}.popup-content-wrapper .popup-content .border-type-dropdown,.toolbar-placeholder-bottom .border-type-dropdown{bottom:100%}.toolbar-placeholder-top .border-type-dropdown{top:100%}.toolbar-placeholder-left .border-type-dropdown{left:100%;top:0}.toolbar-placeholder-right .border-type-dropdown{right:100%;top:0}.border-type-dropdown.toolbar-dropdown-block.border-type-dropdown-cloned{text-align:center;width:66px}.border-type-dropdown-cloned ul{padding:0}.touch li.easel-plugin-brushsize{padding-left:10px!important;padding-top:10px!important}ul.drawer-toolbar li.editable-canvas-brushsize{padding-left:10px!important;padding-right:10px;width:auto}li.editable-canvas-brushsize .editable-canvas-brushsize-indicator{display:inline-block;margin-right:5px;width:50px}.popup-wrapper .popup-content .drawer-toolbar li.editable-canvas-brushsize{box-sizing:border-box;margin:0;min-width:100%;padding:0 10px;text-align:right;width:100%}.popup-wrapper .popup-content .drawer-toolbar li.editable-canvas-brushsize .editable-canvas-brushsize-input{float:right}.popup-wrapper .popup-content li.editable-canvas-brushsize .editable-canvas-brushsize-indicator{float:none;text-align:left}li.editable-canvas-brushsize .editable-canvas-brushsize-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.list-item-range{align-items:stretch;display:flex!important;flex-direction:column}.editable-canvas-opacity-option-indicator{display:inline-block;margin-right:5px;width:50px}li.editable-canvas-opacity-option .editable-canvas-opacity-option-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.editable-canvas-opacity-option-label{padding-left:10px}.popup-content .drawer-toolbar li.editable-canvas-opacity-option{box-sizing:border-box;margin:0;min-width:100%;padding:0 10px;text-align:right;width:100%}.popup-content li.editable-canvas-opacity-option .editable-canvas-opacity-option-input{float:right}.popup-content .drawer-toolbar li.editable-canvas-opacity-option .editable-canvas-opacity-option-indicator{float:none;text-align:left}.toolbar-button .fa.fa-arrows-h,.toolbar-button .fa.fa-long-arrow-right{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);-moz-transform:rotate(-45deg);transform:rotate(-45deg)}.editable-canvas-line-width .toolbar-item-description{display:inline-block}.editable-canvas-line-width input.editable-canvas-line-width-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.editable-canvas-line-width .editable-canvas-line-width-label{padding-left:10px}span.toolbar-label.editable-canvas-line-width-indicator{display:inline-block;margin-right:5px;width:50px}button.stop-polygon{background:#fff;border:1px solid #e2e2e2;box-shadow:0 0 5px rgba(0,0,0,.1);padding:6px 15px;position:absolute;right:0;top:0;z-index:1000}.editable-canvas-shape-context-menu{background:hsla(0,0%,100%,.98);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:16px;box-shadow:0 12px 48px rgba(122,77,217,.2),0 4px 16px rgba(0,0,0,.1);height:auto!important;overflow:hidden;padding:8px;position:absolute;text-align:left;width:200px;z-index:99999}.editable-canvas-shape-context-menu li a{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.editable-canvas-shape-context-menu li{list-style-type:none;width:100%}.editable-canvas-shape-context-menu li a{border-radius:10px;cursor:pointer;display:inline-block;margin:0;padding:10px 16px;text-align:left;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.editable-canvas-shape-context-menu li a:hover{background:var(--easel-color-primary,#a277ff);color:var(--easel-color-surface,#fff);text-decoration:none;transform:translateX(4px)}.editable-canvas-text-option{box-sizing:border-box;display:flex;flex-direction:column;gap:10px;padding-left:10px;padding-right:10px;width:100%}.editable-canvas-text-option select{margin:7px auto;width:100%}.editable-canvas-text-option .toolbar-item-description{align-items:center;display:flex;flex-wrap:wrap;gap:8px;justify-content:space-between;width:100%}.editable-canvas-text-option .toolbar-dropdown-block{display:block;overflow:visible;position:relative;width:100%}.editable-canvas-text-option .toolbar-combobox-wrapper{width:100%}.editable-canvas-text-option .toolbar-combobox-wrapper .dropdown-box{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-shadow:0 16px 32px rgba(15,23,42,.22);left:0;max-height:260px;min-width:100%;overflow-y:auto;padding:10px 0;position:absolute;right:0;top:calc(100% + 8px);z-index:30}.editable-canvas-text-option .toolbar-combobox-wrapper .dropdown-box.collapsed,.editable-canvas-text-option .toolbar-combobox-wrapper.collapsed .dropdown-box{display:none}.editable-canvas-text-option .toolbar-combobox-wrapper .option-list{max-height:220px;overflow-y:auto}ul.drawer-toolbar li.editable-canvas-fontfamily{cursor:pointer;height:auto;position:relative;width:100%}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-shadow:0 16px 32px rgba(15,23,42,.22);box-sizing:border-box;left:0;max-height:260px;max-width:100%;overflow-y:auto;padding:8px;position:absolute;right:auto;top:calc(100% + 8px);width:min(320px,calc(100% + 40px));z-index:40}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown li{background:transparent;display:block;height:auto;text-align:left;width:100%}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown li a{border-radius:8px;color:var(--easel-color-text,#2d1b4e);display:block;padding:6px 10px;text-decoration:none;transition:all .2s cubic-bezier(.4,0,.2,1)}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown li a:hover{background:var(--easel-color-primary-light,#d6c6ff);color:var(--easel-color-primary-dark,#7c4ed9)}ul.drawer-toolbar.toolbar-topRight li.editable-canvas-fontfamily .fonts-dropdown{left:auto;right:0}.editable-canvas-color-button .color-input-wrapper{align-items:center;display:flex;gap:12px;position:relative;width:100%}.editable-canvas-color-button .html5-color-input{background:var(--easel-color-surface,#fff);border:none;border-radius:12px;box-shadow:inset 0 0 0 1px rgba(45,27,78,.12);cursor:pointer;flex:1;height:40px;outline:none;padding:0;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.editable-canvas-color-button .html5-color-input::-webkit-color-swatch-wrapper{border-radius:12px;padding:0}.editable-canvas-color-button .html5-color-input::-moz-color-swatch,.editable-canvas-color-button .html5-color-input::-webkit-color-swatch{border:none;border-radius:10px}.editable-canvas-color-button .html5-color-input:focus,.editable-canvas-color-button .html5-color-input:hover{box-shadow:inset 0 0 0 2px var(--easel-color-primary,#a277ff)}.editable-canvas-color-button .color-indicator{display:none}.colorpicker-control .color-dropdown{padding:5px;position:absolute}li.colorpicker-control{padding-left:10px!important;width:auto!important}.colorpicker-control span.color-indicator{background-color:var(--easel-color-surface,#fff);display:inline-block;height:32px;position:relative;top:0;width:32px}.colorpicker-control .color-swatch{border:1px solid var(--easel-color-surface,#fff);box-sizing:border-box;float:left;height:32px;margin:0;padding:0;width:32px}.colorpicker-control .color-swatch.transparent{background-color:var(--easel-color-surface,#fff);margin:0;text-align:center;width:100%}.control-hidden{visibility:hidden!important}.toolbar-colorpicker-dropdown{display:none}.color-dropdown.palette-with-scroll{display:block}.popup-content-wrapper .popup-content li.colorpicker-control{min-width:50%}.popup-content-wrapper .popup-content li.colorpicker-control.editable-canvas-text-option{height:40px;line-height:40px!important;min-width:177px}.popup-content-wrapper .popup-content li.colorpicker-control span.color-indicator{float:right;right:8px}.popup-content-wrapper .popup-content li.colorpicker-control.editable-canvas-text-option span.color-indicator{float:right;right:1px;top:4px}.popup-content-wrapper .popup-content .color-dropdown{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#ccc);overflow:auto}.popup-content-wrapper .popup-content .color-dropdown:not([data-position]){-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:365px}.popup-content-wrapper .popup-content[data-position=top] .color-dropdown,.toolbar-placeholder-bottom .color-dropdown{bottom:100%;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-wrap:wrap-reverse;-ms-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;left:0;max-width:365px}.popup-content-wrapper .popup-content[data-position=bottom] .color-dropdown,.toolbar-placeholder-top .color-dropdown{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;left:0;max-width:375px;top:100%}.popup-content-wrapper .popup-content[data-position=right] .color-dropdown,.toolbar-placeholder-left .color-dropdown{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;left:100%;max-height:375px;top:0}.popup-content-wrapper .popup-content[data-position=left] .color-dropdown,.toolbar-placeholder-right .color-dropdown{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex-wrap:wrap-reverse;-ms-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;max-height:375px;padding-bottom:14px;right:100%;top:0}li.editable-canvas-color-redactor{padding-left:10px!important;width:auto!important}li.editable-canvas-color-redactor span.color-dropdown{left:0;position:absolute;top:30px;width:290px}li.editable-canvas-color-redactor span.color-indicator{background-color:var(--easel-color-surface,#fff);display:inline-block;height:32px;position:relative;top:0;width:32px}.toolbar-topRight li.editable-canvas-color-redactor span.color-dropdown{left:auto;right:0}ul.drawer-toolbar li.editable-canvas-opacity-label{padding-left:3px;padding-right:3px;width:auto}ul.drawer-toolbar li.editable-canvas-opacity{margin-left:10px;margin-right:10px;width:auto}.opacity-indicator{background:linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc),linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc);background-position:0 0,4px 4px;background-size:8px 8px;border:2px solid var(--easel-color-border,#e3d8ff);border-radius:10px;box-shadow:inset 0 2px 4px rgba(0,0,0,.1);display:inline-block;height:28px;margin:0 8px;vertical-align:middle;width:28px}li.editable-canvas-opacity .editable-canvas-opacity-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.popup-content .drawer-toolbar li.editable-canvas-opacity{box-sizing:border-box;margin:0;min-width:100%;padding:0 10px;text-align:right;width:100%}.popup-content li.editable-canvas-opacity .editable-canvas-opacity-input{float:right}.popup-content .drawer-toolbar li.editable-canvas-opacity .editable-canvas-opacity-indicator{float:none;text-align:left}:root{--easel-color-primary:#a277ff;--easel-color-primary-dark:#7c4ed9;--easel-color-primary-light:#d6c6ff;--easel-color-accent:#c594ff;--easel-color-surface:#fff;--easel-color-surface-muted:#faf8ff;--easel-color-border:#e3d8ff;--easel-color-border-strong:#cbb6ff;--easel-color-text:#2d1b4e;--easel-color-text-muted:#6d5c88;--easel-color-danger:#d45a78;--drawer-shadow-soft:0px 14px 40px rgba(122,77,217,.15)}body{background:var(--easel-color-surface-muted,#f7f3ff);color:var(--easel-color-text,#2d1b4e);font-family:Arial,sans-serif;overflow:scroll!important}.hidden{display:none!important;visibility:hidden!important}#easel-canvas-box .sp-replacer{height:32px;margin:0;padding:0;width:32px}#easel-canvas-box .sp-preview{height:100%;margin:0;padding:0;width:100%}#easel-canvas-box .sp-preview-inner{height:100%;width:100%}#easel-canvas-box .sp-dd{display:none}#redactor-drawer-box{background:var(--easel-color-surface-muted,transparent);box-sizing:content-box;color:inherit;outline:none;top:35px;transition:none;vertical-align:middle}#easel-canvas-box.animated{transition:height .5s ease-out,width .5s ease-out 0s,left .5s ease-out 0s,top .5s ease-out 0s}body.easel-moving #easel-canvas-box.easel-instance-container,body.easel-moving #easel-canvas-box.easel-instance-container .canvas-container,body.easel-resizing #easel-canvas-box.easel-instance-container,body.easel-resizing #easel-canvas-box.easel-instance-container .canvas-container{transition:none}body.drawer-zoom-moving,body.drawer-zoom-moving *{cursor:-webkit-grabbing!important;cursor:grabbing!important}body.drawer-moving,body.drawer-moving *{cursor:move!important}body.drawer-resizing,body.drawer-resizing *{cursor:nwse-resize!important}.drawer-floating-control{pointer-events:auto;z-index:400}.drawer-floating-control.text-edit-corner{cursor:pointer}#easel-canvas-box .canvas-container{box-shadow:var(--drawer-shadow-soft,0 0 50px rgba(0,0,0,.03));margin:0;overflow:hidden;position:relative;transition:none;z-index:200}#easel-canvas-box.animated .canvas-container{transition:height .5s ease-out,width .5s ease-out 0s,left .5s ease-out 0s,top .5s ease-out 0s}#easel-canvas-box .canvas-container canvas{background:transparent}.noselect{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#redactor-drawer-properties .drawer-properties-height,#redactor-drawer-properties .drawer-properties-width{text-align:center;width:45%}#redactor-drawer-properties .size-separator{display:inline-block;text-align:center;width:10%}#easel-canvas-box{font-family:Arial,sans-serif}.redactor-editor .btn-group ul{background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.1);left:-2px;padding:0;position:absolute;top:30px}.editable-canvas-image{opacity:1}.editable-canvas-image.edit-mode{opacity:0}#redactor-modal,#redactor-modal-box,#redactor-modal-overlay{z-index:1100!important}`, \"\",{\"version\":3,\"sources\":[\"webpack://./dist/easel.min.css\"],\"names\":[],\"mappings\":\"AAAA,iCAAiC,0CAA0C,CAAC,qBAAqB,CAAC,QAAQ,CAAC,SAAS,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,eAAe,0CAA0C,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,oEAAoE,CAAC,qCAAqC,CAAC,yDAAyD,qBAAqB,CAAC,wCAAwC,sBAAsB,CAAC,gCAAgC,CAAC,MAAM,CAAC,iBAAiB,CAAC,KAAK,CAAC,6CAA6C,CAAC,yCAAyC,UAAU,CAAC,uCAAuC,WAAW,CAAC,qBAAqB,CAAC,qDAAqD,gBAAgB,CAAC,oLAAoL,WAAW,CAAC,kBAAkB,CAAC,UAAU,CAAC,qFAAqF,WAAW,CAAC,kBAAkB,CAAC,UAAU,CAAC,mFAAmF,WAAW,CAAC,kBAAkB,CAAC,UAAU,CAAC,uDAAuD,0CAA0C,CAAC,oBAAoB,CAAC,eAAe,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,kBAAkB,CAAC,gBAAgB,sBAAsB,CAAC,kBAAkB,CAAC,oBAAoB,CAAC,WAAW,CAAC,oBAAoB,CAAC,YAAY,CAAC,cAAc,CAAC,iBAAiB,CAAC,0CAA0C,CAAC,kBAAkB,CAAC,UAAU,CAAC,iCAAiC,cAAc,CAAC,SAAS,CAAC,UAAU,CAAC,mCAAmC,kBAAkB,CAAC,YAAY,CAAC,sBAAsB,CAAC,SAAS,CAAC,kBAAkB,kBAAkB,CAAC,qCAAqC,CAAC,oBAAoB,CAAC,WAAW,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,0CAA0C,CAAC,UAAU,CAAC,wBAAwB,YAAY,CAAC,oBAAoB,mBAAmB,CAAC,6FAA6F,6CAA6C,CAAC,0CAA0C,CAAC,qCAAqC,CAAC,sCAAsC,CAAC,0CAA0C,kDAAkD,CAAC,2CAA2C,CAAC,yBAAyB,mDAAmD,CAAC,wEAAwE,CAAC,qCAAqC,CAAC,YAAY,CAAC,oBAAoB,CAAC,iCAAiC,6CAA6C,CAAC,0CAA0C,CAAC,qCAAqC,CAAC,eAAe,CAAC,uCAAuC,sCAAsC,CAAC,iBAAiB,8BAA8B,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,oEAAoE,CAAC,WAAW,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,UAAU,CAAC,YAAY,CAAC,iCAAiC,YAAY,CAAC,UAAU,CAAC,0CAA0C,YAAY,CAAC,uBAAuB,SAAS,CAAC,kBAAkB,CAAC,oCAAoC,uCAAuC,CAAC,kCAAkC,gBAAgB,CAAC,yCAAyC,aAAa,CAAC,aAAa,CAAC,aAAa,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,kIAAkI,mBAAmB,CAAC,oBAAoB,CAAC,YAAY,CAAC,kCAAkC,CAAC,mBAAmB,CAAC,gCAAgC,CAAC,0BAA0B,CAAC,wBAAwB,CAAC,wBAAwB,CAAC,8BAA8B,CAAC,oBAAoB,CAAC,sBAAsB,CAAC,+IAA+I,sBAAsB,CAAC,kBAAkB,CAAC,cAAc,CAAC,2DAA2D,wBAAwB,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,kEAAkE,0BAA0B,CAAC,sBAAsB,CAAC,kBAAkB,CAAC,gEAAgE,6BAA6B,CAAC,yBAAyB,CAAC,qBAAqB,CAAC,uDAAuD,QAAQ,CAAC,uCAAuC,oBAAoB,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,qDAAqD,OAAO,CAAC,kEAAkE,8BAA8B,CAAC,cAAc,CAAC,WAAW,CAAC,UAAU,CAAC,oDAAoD,0CAA0C,CAAC,WAAW,CAAC,kBAAkB,CAAC,cAAc,CAAC,aAAa,CAAC,WAAW,CAAC,YAAY,CAAC,iBAAiB,CAAC,0CAA0C,CAAC,UAAU,CAAC,SAAS,CAAC,0DAA0D,6CAA6C,CAAC,0CAA0C,CAAC,qBAAqB,CAAC,4DAA4D,qCAAqC,CAAC,sDAAsD,qCAAqC,CAAC,cAAc,CAAC,gBAAgB,CAAC,yBAAyB,CAAC,6DAA6D,aAAa,CAAC,oDAAoD,gCAAgC,CAAC,0CAA0C,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,qEAAqE,CAAC,YAAY,CAAC,gBAAgB,CAAC,cAAc,CAAC,kBAAkB,CAAC,WAAW,CAAC,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAC,qBAAqB,GAAG,SAAS,CAAC,2BAA2B,CAAC,GAAG,SAAS,CAAC,uBAAuB,CAAC,CAAC,yGAAyG,YAAY,CAAC,uEAAuE,SAAS,CAAC,6EAA6E,sBAAsB,CAAC,6EAA6E,mDAAmD,CAAC,iBAAiB,CAAC,mFAAmF,6CAA6C,CAAC,4CAA4C,WAAW,CAAC,kBAAkB,QAAQ,CAAC,MAAM,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,qBAAqB,qBAAqB,CAAC,QAAQ,CAAC,cAAc,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,YAAY,CAAC,sDAAsD,YAAY,CAAC,yBAAyB,QAAQ,CAAC,qDAAqD,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,cAAc,CAAC,4BAA4B,kBAAkB,CAAC,WAAW,CAAC,YAAY,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,yBAAyB,yBAAyB,sBAAsB,CAAC,CAAC,2CAA2C,mBAAmB,CAAC,0BAA0B,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,qDAAqD,sBAAsB,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,cAAc,CAAC,UAAU,CAAC,2BAA2B,WAAW,CAAC,UAAU,CAAC,QAAQ,CAAC,oDAAoD,YAAY,CAAC,KAAK,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,cAAc,CAAC,uDAAuD,QAAQ,CAAC,eAAe,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,cAAc,CAAC,YAAY,CAAC,qDAAqD,MAAM,CAAC,aAAa,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,cAAc,CAAC,YAAY,CAAC,sDAAsD,cAAc,CAAC,OAAO,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,kBAAkB,CAAC,cAAc,CAAC,YAAY,CAAC,gDAAgD,WAAW,CAAC,eAAe,CAAC,mBAAmB,CAAC,UAAU,CAAC,+DAA+D,gBAAgB,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,mEAAmE,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,sEAAsE,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,oEAAoE,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,4BAA4B,kBAAkB,CAAC,2CAA2C,CAAC,mBAAmB,CAAC,qBAAqB,CAAC,sCAAsC,CAAC,WAAW,CAAC,iBAAiB,CAAC,UAAU,CAAC,6EAA6E,mBAAmB,CAAC,YAAY,CAAC,qBAAqB,CAAC,QAAQ,CAAC,UAAU,CAAC,iFAAiF,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,0BAA0B,CAAC,qEAAqE,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,gCAAgC,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,+CAA+C,WAAW,CAAC,eAAe,CAAC,gBAAgB,CAAC,wEAAwE,eAAe,CAAC,2EAA2E,kDAAkD,CAAC,iBAAiB,CAAC,UAAU,CAAC,kDAAkD,gDAAgD,CAAC,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,oBAAoB,CAAC,WAAW,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,wEAAwE,aAAa,CAAC,2IAA2I,wBAAwB,CAAC,6BAA6B,CAAC,eAAe,WAAW,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,UAAU,CAAC,qCAAqC,oBAAoB,CAAC,kBAAkB,CAAC,sBAAsB,eAAe,CAAC,iBAAiB,CAAC,eAAe,CAAC,oBAAoB,oBAAoB,CAAC,WAAW,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,UAAU,CAAC,mBAAmB,4BAA4B,CAAC,uBAAuB,CAAC,kBAAkB,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAAC,MAAM,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,iBAAiB,CAAC,KAAK,CAAC,0CAA0C,CAAC,0BAA0B,2BAA2B,CAAC,8CAA8C,oBAAoB,CAAC,iBAAiB,CAAC,0CAA0C,4BAA4B,CAAC,kBAAkB,CAAC,WAAW,CAAC,YAAY,CAAC,SAAS,CAAC,0CAA0C,CAAC,UAAU,CAAC,iDAAiD,4BAA4B,CAAC,qCAAqC,CAAC,WAAW,CAAC,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,+EAA+E,0DAA0D,CAAC,sFAAsF,+CAA+C,CAAC,wJAAwJ,qCAAqC,CAAC,gHAAgH,gDAAgD,CAAC,mFAAmF,kDAAkD,CAAC,kEAAkE,SAAS,CAAC,iBAAiB,CAAC,QAAQ,CAAC,8FAA8F,WAAW,CAAC,sBAAsB,CAAC,OAAO,CAAC,0BAA0B,CAAC,8FAA8F,WAAW,CAAC,SAAS,CAAC,iBAAiB,CAAC,QAAQ,CAAC,0IAA0I,YAAY,CAAC,6DAA6D,aAAa,CAAC,0DAA0D,mDAAmD,CAAC,qCAAqC,CAAC,YAAY,CAAC,sCAAsC,YAAY,CAAC,0BAA0B,oBAAoB,CAAC,kBAAkB,CAAC,gCAAgC,kBAAkB,CAAC,iCAAiC,uBAAuB,CAAC,eAAe,CAAC,mDAAmD,CAAC,WAAW,CAAC,kBAAkB,CAAC,WAAW,CAAC,eAAe,CAAC,gBAAgB,CAAC,KAAK,CAAC,WAAW,CAAC,gEAAgE,yCAAyC,CAAC,WAAW,CAAC,kBAAkB,CAAC,UAAU,CAAC,UAAU,CAAC,uDAAuD,uBAAuB,CAAC,6CAA6C,CAAC,gDAAgD,CAAC,iBAAiB,CAAC,wCAAwC,CAAC,cAAc,CAAC,WAAW,CAAC,eAAe,CAAC,uBAAuB,CAAC,UAAU,CAAC,uCAAuC,YAAY,CAAC,sEAAsE,gDAAgD,CAAC,mDAAmD,yCAAyC,CAAC,WAAW,CAAC,kBAAkB,CAAC,UAAU,CAAC,UAAU,CAAC,mDAAmD,6CAA6C,CAAC,gDAAgD,CAAC,iBAAiB,CAAC,wCAAwC,CAAC,cAAc,CAAC,WAAW,CAAC,UAAU,CAAC,gDAAgD,sBAAsB,CAAC,mBAAmB,CAAC,4CAA4C,sBAAsB,CAAC,wBAAwB,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,UAAU,CAAC,WAAW,CAAC,iDAAiD,gDAAgD,CAAC,kBAAkB,CAAC,iDAAiD,yCAAyC,CAAC,kBAAkB,CAAC,4CAA4C,6CAA6C,CAAC,gDAAgD,CAAC,iBAAiB,CAAC,wCAAwC,CAAC,cAAc,CAAC,WAAW,CAAC,UAAU,CAAC,uDAAuD,gDAAgD,CAAC,uDAAuD,gDAAgD,CAAC,qBAAqB,uBAAuB,CAAC,mBAAmB,CAAC,4BAA4B,CAAC,yBAAyB,eAAe,CAAC,iBAAiB,CAAC,UAAU,CAAC,aAAa,CAAC,cAAc,CAAC,SAAS,CAAC,eAAe,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,sBAAsB,CAAC,cAAc,CAAC,gCAAgC,SAAS,CAAC,+BAA+B,kBAAkB,CAAC,UAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,wDAAwD,4BAA4B,CAAC,8DAA8D,qDAAqD,CAAC,0BAA0B,CAAC,QAAQ,CAAC,SAAS,CAAC,2DAA2D,yBAAyB,CAAC,iEAAiE,yCAAyC,CAAC,0BAA0B,CAAC,SAAS,CAAC,KAAK,CAAC,4DAA4D,wBAAwB,CAAC,kEAAkE,qDAAqD,CAAC,0BAA0B,CAAC,UAAU,CAAC,KAAK,CAAC,yDAAyD,2BAA2B,CAAC,+DAA+D,yCAAyC,CAAC,0BAA0B,CAAC,QAAQ,CAAC,UAAU,CAAC,kEAAkE,qDAAqD,CAAC,2BAA2B,CAAC,UAAU,CAAC,mIAAmI,OAAO,CAAC,kCAAkC,CAAC,+BAA+B,CAAC,8BAA8B,CAAC,0BAA0B,CAAC,iEAAiE,qDAAqD,CAAC,2BAA2B,CAAC,SAAS,CAAC,gEAAgE,yCAAyC,CAAC,uBAAuB,CAAC,QAAQ,CAAC,mIAAmI,QAAQ,CAAC,kCAAkC,CAAC,+BAA+B,CAAC,8BAA8B,CAAC,0BAA0B,CAAC,mEAAmE,yCAAyC,CAAC,uBAAuB,CAAC,WAAW,CAAC,0BAA0B,0CAA0C,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,qBAAqB,CAAC,qCAAqC,CAAC,oBAAoB,CAAC,eAAe,CAAC,eAAe,CAAC,YAAY,CAAC,iBAAiB,CAAC,0CAA0C,CAAC,UAAU,CAAC,sDAAsD,WAAW,CAAC,iBAAiB,CAAC,QAAQ,CAAC,oCAAoC,kBAAkB,CAAC,cAAc,CAAC,aAAa,CAAC,UAAU,CAAC,WAAW,CAAC,gBAAgB,CAAC,0CAA0C,CAAC,UAAU,CAAC,yCAAyC,kBAAkB,CAAC,cAAc,CAAC,cAAc,CAAC,wBAAwB,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,qBAAqB,CAAC,2DAA2D,wBAAwB,CAAC,0DAA0D,wBAAwB,CAAC,8DAA8D,eAAe,CAAC,wCAAwC,oCAAoC,CAAC,eAAe,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,0CAA0C,CAAC,qBAAqB,CAAC,aAAa,CAAC,iBAAiB,CAAC,QAAQ,CAAC,SAAS,CAAC,sEAAsE,oBAAoB,CAAC,oCAAoC,UAAU,CAAC,YAAY,CAAC,gBAAgB,CAAC,8CAA8C,aAAa,CAAC,qDAAqD,mDAAmD,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,qCAAqC,CAAC,cAAc,CAAC,YAAY,CAAC,iBAAiB,CAAC,0CAA0C,CAAC,UAAU,CAAC,2DAA2D,0CAA0C,CAAC,+CAA+C,CAAC,0CAA0C,CAAC,uCAAuC,UAAU,CAAC,eAAe,CAAC,SAAS,CAAC,uBAAuB,CAAC,sBAAsB,CAAC,sBAAsB,CAAC,oBAAoB,CAAC,uBAAuB,CAAC,oBAAoB,CAAC,cAAc,CAAC,gBAAgB,CAAC,eAAe,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,UAAU,CAAC,oDAAoD,iBAAiB,CAAC,qCAAqC,CAAC,cAAc,CAAC,aAAa,CAAC,cAAc,CAAC,gBAAgB,CAAC,cAAc,CAAC,cAAc,CAAC,0CAA0C,CAAC,sEAAsE,oBAAoB,CAAC,kBAAkB,CAAC,iEAAiE,wBAAwB,CAAC,yEAAyE,yDAAyD,CAAC,yBAAyB,CAAC,6DAA6D,mDAAmD,CAAC,qCAAqC,CAAC,eAAe,CAAC,qCAAqC,4BAA4B,CAAC,uDAAuD,CAAC,2BAA2B,CAAC,2CAA2C,CAAC,cAAc,CAAC,kBAAkB,CAAC,WAAW,CAAC,WAAW,CAAC,iBAAiB,CAAC,0CAA0C,CAAC,UAAU,CAAC,2CAA2C,yDAAyD,CAAC,6CAA6C,CAAC,uCAAuC,cAAc,CAAC,gCAAgC,0CAA0C,CAAC,8EAA8E,+CAA+C,CAAC,2CAA2C,oDAAoD,CAAC,gCAAgC,0CAA0C,CAAC,8EAA8E,+CAA+C,CAAC,2CAA2C,oDAAoD,CAAC,oMAAoM,YAAY,CAAC,+CAA+C,eAAe,CAAC,6GAA6G,YAAY,CAAC,qHAAqH,aAAa,CAAC,KAAK,CAAC,gFAAgF,YAAY,CAAC,6BAA6B,oDAAoD,CAAC,kBAAkB,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,eAAe,CAAC,yBAAyB,CAAC,oBAAoB,CAAC,cAAc,CAAC,ySAAyS,sBAAsB,CAAC,kDAAkD,sBAAsB,CAAC,+CAA+C,qBAAqB,CAAC,oBAAoB,CAAC,gFAAgF,yBAAyB,CAAC,2DAA2D,mBAAmB,CAAC,cAAc,qBAAqB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,OAAO,CAAC,mDAAmD,CAAC,gDAAgD,CAAC,+CAA+C,CAAC,2CAA2C,CAAC,6BAA6B,CAAC,gBAAgB,CAAC,kCAAkC,SAAS,CAAC,gBAAgB,0CAA0C,CAAC,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,0BAA0B,MAAM,CAAC,eAAe,CAAC,cAAc,CAAC,SAAS,CAAC,iBAAiB,CAAC,KAAK,CAAC,oBAAoB,CAAC,UAAU,CAAC,UAAU,CAAC,6BAA6B,WAAW,CAAC,aAAa,CAAC,eAAe,CAAC,iBAAiB,CAAC,UAAU,CAAC,SAAS,CAAC,6BAA6B,gDAAgD,CAAC,QAAQ,CAAC,8CAA8C,CAAC,MAAM,CAAC,WAAW,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,mCAAmC,YAAY,CAAC,8BAA8B,iBAAiB,CAAC,4BAA4B,kBAAkB,CAAC,WAAW,CAAC,iBAAiB,CAAC,SAAS,CAAC,gCAAgC,QAAQ,CAAC,MAAM,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,iBAAiB,CAAC,SAAS,CAAC,gBAAgB,eAAe,CAAC,iBAAiB,CAAC,oBAAoB,iBAAiB,CAAC,mFAAmF,+BAA+B,CAAC,4BAA4B,CAAC,2BAA2B,CAAC,uBAAuB,CAAC,qBAAqB,cAAc,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,mDAAmD,CAAC,gDAAgD,CAAC,+CAA+C,CAAC,2CAA2C,CAAC,aAAa,CAAC,8BAA8B,gCAAgC,CAAC,yDAAyD,CAAC,sBAAsB,CAAC,QAAQ,CAAC,6BAA6B,6CAA6C,CAAC,+CAA+C,CAAC,kBAAkB,CAAC,WAAW,CAAC,SAAS,CAAC,sBAAsB,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,UAAU,CAAC,qBAAqB,iBAAiB,CAAC,SAAS,CAAC,OAAO,CAAC,kCAAkC,CAAC,+BAA+B,CAAC,8BAA8B,CAAC,0BAA0B,CAAC,WAAW,CAAC,0BAA0B,aAAa,CAAC,eAAe,CAAC,WAAW,uBAAuB,CAAC,eAAe,CAAC,4BAA4B,CAAC,cAAc,CAAC,cAAc,CAAC,kBAAkB,CAAC,eAAe,CAAC,WAAW,CAAC,0CAA0C,mDAAmD,CAAC,QAAQ,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,CAAC,iCAAiC,uBAAuB,CAAC,6CAA6C,CAAC,WAAW,CAAC,iBAAiB,CAAC,WAAW,CAAC,eAAe,CAAC,UAAU,CAAC,iBAAiB,YAAY,CAAC,6BAA6B,mDAAmD,CAAC,QAAQ,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,CAAC,6BAA6B,6CAA6C,CAAC,WAAW,CAAC,iBAAiB,CAAC,WAAW,CAAC,eAAe,CAAC,UAAU,CAAC,0BAA0B,sBAAsB,CAAC,mBAAmB,CAAC,sBAAsB,sBAAsB,CAAC,wBAAwB,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,UAAU,CAAC,UAAU,CAAC,2BAA2B,0DAA0D,CAAC,kBAAkB,CAAC,2BAA2B,mDAAmD,CAAC,kBAAkB,CAAC,sBAAsB,6CAA6C,CAAC,WAAW,CAAC,iBAAiB,CAAC,WAAW,CAAC,cAAc,CAAC,UAAU,CAAC,kEAAkE,yBAAyB,CAAC,oBAAoB,UAAU,CAAC,QAAQ,CAAC,iBAAiB,CAAC,SAAS,CAAC,2BAA2B,iDAAiD,CAAC,QAAQ,CAAC,2CAA2C,CAAC,6BAA6B,oBAAoB,CAAC,cAAc,CAAC,iBAAiB,CAAC,eAAe,CAAC,sBAAsB,WAAW,CAAC,sBAAsB,WAAW,CAAC,oBAAoB,0CAA0C,CAAC,QAAQ,CAAC,MAAM,CAAC,eAAe,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,WAAW,CAAC,UAAU,QAAQ,CAAC,eAAe,CAAC,cAAc,CAAC,iBAAiB,CAAC,OAAO,CAAC,mDAAmD,CAAC,gDAAgD,CAAC,+CAA+C,CAAC,2CAA2C,CAAC,mBAAmB,SAAS,CAAC,uBAAuB,YAAY,CAAC,2CAA2C,WAAW,CAAC,MAAM,CAAC,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,aAAa,eAAe,CAAC,wBAAwB,CAAC,UAAU,CAAC,iBAAiB,CAAC,SAAS,CAAC,YAAY,CAAC,eAAe,kBAAkB,CAAC,MAAM,CAAC,KAAK,CAAC,gBAAgB,kBAAkB,CAAC,OAAO,CAAC,KAAK,CAAC,mBAAmB,QAAQ,CAAC,kBAAkB,CAAC,OAAO,CAAC,kBAAkB,QAAQ,CAAC,kBAAkB,CAAC,MAAM,CAAC,aAAa,iBAAiB,CAAC,6BAA6B,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,+BAA+B,WAAW,CAAC,SAAS,CAAC,SAAS,CAAC,gCAAgC,UAAU,CAAC,UAAU,CAAC,UAAU,CAAC,8BAA8B,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,qBAAqB,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,gHAAgH,eAAe,CAAC,qNAAqN,YAAY,CAAC,kDAAkD,oBAAoB,CAAC,2EAA2E,oBAAoB,CAAC,kBAAkB,CAAC,gBAAgB,0CAA0C,CAAC,kDAAkD,CAAC,iBAAiB,CAAC,qCAAqC,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,YAAY,CAAC,cAAc,CAAC,iBAAiB,CAAC,qBAAqB,CAAC,6BAA6B,uBAAuB,CAAC,eAAe,CAAC,0CAA0C,CAAC,WAAW,CAAC,WAAW,CAAC,iBAAiB,CAAC,UAAU,CAAC,2DAA2D,SAAS,CAAC,mDAAmD,WAAW,CAAC,gEAAgE,iBAAiB,CAAC,QAAQ,CAAC,iDAAiD,iBAAiB,CAAC,eAAe,CAAC,UAAU,CAAC,wDAAwD,oBAAoB,CAAC,uEAAuE,oBAAoB,CAAC,eAAe,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,kBAAkB,CAAC,WAAW,CAAC,kEAAkE,iBAAiB,CAAC,0DAA0D,oBAAoB,CAAC,gBAAgB,CAAC,UAAU,CAAC,8BAA8B,wBAAwB,CAAC,eAAe,CAAC,2BAA2B,CAAC,UAAU,CAAC,yBAAyB,2BAA2B,CAAC,+BAA+B,CAAC,4BAA4B,CAAC,uBAAuB,CAAC,UAAU,CAAC,gCAAgC,WAAW,CAAC,wBAAwB,CAAC,eAAe,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,oCAAoC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,eAAe,QAAQ,CAAC,MAAM,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,sCAAsC,gDAAgD,CAAC,mCAAmC,CAAC,kBAAkB,CAAC,yCAAyC,CAAC,eAAe,CAAC,iBAAiB,CAAC,SAAS,CAAC,wDAAwD,SAAS,CAAC,mDAAmD,WAAW,CAAC,gBAAgB,CAAC,eAAe,CAAC,iBAAiB,CAAC,UAAU,CAAC,WAAW,CAAC,mHAAmH,cAAc,CAAC,UAAU,CAAC,aAAa,CAAC,gBAAgB,CAAC,eAAe,CAAC,iBAAiB,CAAC,sEAAsE,qBAAqB,CAAC,kBAAkB,CAAC,yJAAyJ,wBAAwB,CAAC,cAAc,CAAC,4EAA4E,gFAAgF,CAAC,cAAc,CAAC,6EAA6E,+EAA+E,CAAC,uEAAuE,mBAAmB,CAAC,oBAAoB,CAAC,2JAA2J,6BAA6B,CAAC,eAAe,CAAC,6EAA6E,gFAAgF,CAAC,eAAe,CAAC,8EAA8E,+EAA+E,CAAC,wEAAwE,mBAAmB,CAAC,oBAAoB,CAAC,6JAA6J,6BAA6B,CAAC,aAAa,CAAC,8EAA8E,gFAAgF,CAAC,eAAe,CAAC,+EAA+E,+EAA+E,CAAC,yEAAyE,qBAAqB,CAAC,YAAY,CAAC,kBAAkB,CAAC,+JAA+J,wBAAwB,CAAC,+EAA+E,gFAAgF,CAAC,cAAc,CAAC,gFAAgF,+EAA+E,CAAC,YAAY,CAAC,8BAA8B,6BAA6B,CAAC,wBAAwB,CAAC,mBAAmB,CAAC,qBAAqB,CAAC,YAAY,CAAC,QAAQ,CAAC,4DAA4D,CAAC,0BAA0B,CAAC,eAAe,CAAC,eAAe,CAAC,YAAY,CAAC,UAAU,CAAC,mDAAmD,0CAA0C,CAAC,mCAAmC,CAAC,kBAAkB,CAAC,yCAAyC,CAAC,YAAY,CAAC,QAAQ,CAAC,oCAAoC,CAAC,uBAAuB,CAAC,eAAe,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAAC,iBAAiB,CAAC,8CAA8C,sBAAsB,CAAC,WAAW,CAAC,eAAe,CAAC,cAAc,CAAC,UAAU,CAAC,uEAAuE,QAAQ,CAAC,UAAU,CAAC,8BAA8B,mCAAmC,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,yBAAyB,sCAAsC,2BAA2B,CAAC,8BAA8B,QAAQ,CAAC,yBAAyB,CAAC,eAAe,CAAC,CAAC,gCAAgC,iBAAiB,CAAC,2CAA2C,CAAC,cAAc,CAAC,WAAW,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,SAAS,CAAC,iBAAiB,CAAC,OAAO,CAAC,0CAA0C,CAAC,UAAU,CAAC,YAAY,CAAC,sCAAsC,mDAAmD,CAAC,6CAA6C,CAAC,oBAAoB,CAAC,mDAAmD,eAAe,CAAC,oDAAoD,YAAY,CAAC,qBAAqB,CAAC,OAAO,CAAC,UAAU,CAAC,kDAAkD,2CAA2C,CAAC,eAAe,CAAC,oBAAoB,CAAC,aAAa,CAAC,QAAQ,CAAC,wBAAwB,CAAC,uEAAuE,iBAAiB,CAAC,uEAAuE,kBAAkB,CAAC,mDAAmD,CAAC,kBAAkB,CAAC,eAAe,CAAC,YAAY,CAAC,wCAAwC,CAAC,4BAA4B,CAAC,cAAc,CAAC,qBAAqB,CAAC,WAAW,CAAC,UAAU,CAAC,yFAAyF,gBAAgB,CAAC,QAAQ,CAAC,UAAU,CAAC,iGAAiG,kBAAkB,CAAC,YAAY,CAAC,OAAO,CAAC,gBAAgB,CAAC,wCAAwC,CAAC,SAAS,CAAC,eAAe,CAAC,sFAAsF,SAAS,CAAC,eAAe,CAAC,8GAA8G,gBAAgB,CAAC,gEAAgE,cAAc,CAAC,2BAA2B,kBAAkB,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,oCAAoC,CAAC,gBAAgB,CAAC,eAAe,CAAC,SAAS,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,sBAAsB,CAAC,kBAAkB,CAAC,aAAa,CAAC,6BAA6B,gBAAgB,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,kFAAkF,gBAAgB,CAAC,oDAAoD,uBAAuB,CAAC,2BAA2B,CAAC,WAAW,CAAC,gBAAgB,CAAC,cAAc,CAAC,aAAa,CAAC,oBAAoB,CAAC,0EAA0E,+CAA+C,CAAC,sBAAsB,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,sBAAsB,0CAA0C,CAAC,SAAS,CAAC,WAAW,CAAC,iBAAiB,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,CAAC,4BAA4B,yBAAyB,CAAC,2BAA2B,CAAC,cAAc,CAAC,aAAa,CAAC,WAAW,CAAC,gBAAgB,CAAC,UAAU,CAAC,kCAAkC,mDAAmD,CAAC,8GAA8G,WAAW,CAAC,+CAA+C,QAAQ,CAAC,gDAAgD,SAAS,CAAC,KAAK,CAAC,iDAAiD,UAAU,CAAC,KAAK,CAAC,yEAAyE,iBAAiB,CAAC,UAAU,CAAC,gCAAgC,SAAS,CAAC,iCAAiC,2BAA2B,CAAC,0BAA0B,CAAC,+CAA+C,2BAA2B,CAAC,kBAAkB,CAAC,UAAU,CAAC,kEAAkE,oBAAoB,CAAC,gBAAgB,CAAC,UAAU,CAAC,2EAA2E,qBAAqB,CAAC,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,gBAAgB,CAAC,UAAU,CAAC,4GAA4G,WAAW,CAAC,gGAAgG,UAAU,CAAC,eAAe,CAAC,8DAA8D,oBAAoB,CAAC,eAAe,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,kBAAkB,CAAC,WAAW,CAAC,iBAAiB,mBAAmB,CAAC,sBAAsB,CAAC,qBAAqB,CAAC,0CAA0C,oBAAoB,CAAC,gBAAgB,CAAC,UAAU,CAAC,wEAAwE,oBAAoB,CAAC,eAAe,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,kBAAkB,CAAC,WAAW,CAAC,sCAAsC,iBAAiB,CAAC,iEAAiE,qBAAqB,CAAC,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,gBAAgB,CAAC,UAAU,CAAC,uFAAuF,WAAW,CAAC,2GAA2G,UAAU,CAAC,eAAe,CAAC,wEAAwE,gCAAgC,CAAC,4BAA4B,CAAC,6BAA6B,CAAC,wBAAwB,CAAC,sDAAsD,oBAAoB,CAAC,mEAAmE,oBAAoB,CAAC,eAAe,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,kBAAkB,CAAC,WAAW,CAAC,8DAA8D,iBAAiB,CAAC,wDAAwD,oBAAoB,CAAC,gBAAgB,CAAC,UAAU,CAAC,oBAAoB,eAAe,CAAC,wBAAwB,CAAC,iCAAiC,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,oCAAoC,8BAA8B,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,oEAAoE,CAAC,qBAAqB,CAAC,eAAe,CAAC,WAAW,CAAC,iBAAiB,CAAC,eAAe,CAAC,WAAW,CAAC,aAAa,CAAC,yCAAyC,0BAA0B,CAAC,wBAAwB,CAAC,uBAAuB,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,uCAAuC,oBAAoB,CAAC,UAAU,CAAC,yCAAyC,kBAAkB,CAAC,cAAc,CAAC,oBAAoB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,eAAe,CAAC,0CAA0C,CAAC,UAAU,CAAC,+CAA+C,6CAA6C,CAAC,qCAAqC,CAAC,oBAAoB,CAAC,yBAAyB,CAAC,6BAA6B,qBAAqB,CAAC,YAAY,CAAC,qBAAqB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,UAAU,CAAC,oCAAoC,eAAe,CAAC,UAAU,CAAC,uDAAuD,kBAAkB,CAAC,YAAY,CAAC,cAAc,CAAC,OAAO,CAAC,6BAA6B,CAAC,UAAU,CAAC,qDAAqD,aAAa,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,UAAU,CAAC,uDAAuD,UAAU,CAAC,qEAAqE,0CAA0C,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,yCAAyC,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC,eAAe,CAAC,cAAc,CAAC,iBAAiB,CAAC,OAAO,CAAC,oBAAoB,CAAC,UAAU,CAAC,8JAA8J,YAAY,CAAC,oEAAoE,gBAAgB,CAAC,eAAe,CAAC,gDAAgD,cAAc,CAAC,WAAW,CAAC,iBAAiB,CAAC,UAAU,CAAC,gEAAgE,0CAA0C,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,yCAAyC,CAAC,qBAAqB,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC,eAAe,CAAC,WAAW,CAAC,iBAAiB,CAAC,UAAU,CAAC,oBAAoB,CAAC,kCAAkC,CAAC,UAAU,CAAC,mEAAmE,sBAAsB,CAAC,aAAa,CAAC,WAAW,CAAC,eAAe,CAAC,UAAU,CAAC,qEAAqE,iBAAiB,CAAC,qCAAqC,CAAC,aAAa,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,0CAA0C,CAAC,2EAA2E,mDAAmD,CAAC,6CAA6C,CAAC,iFAAiF,SAAS,CAAC,OAAO,CAAC,mDAAmD,kBAAkB,CAAC,YAAY,CAAC,QAAQ,CAAC,iBAAiB,CAAC,UAAU,CAAC,iDAAiD,0CAA0C,CAAC,WAAW,CAAC,kBAAkB,CAAC,6CAA6C,CAAC,cAAc,CAAC,MAAM,CAAC,WAAW,CAAC,YAAY,CAAC,SAAS,CAAC,0CAA0C,CAAC,UAAU,CAAC,+EAA+E,kBAAkB,CAAC,SAAS,CAAC,2IAA2I,WAAW,CAAC,kBAAkB,CAAC,8GAA8G,6DAA6D,CAAC,+CAA+C,YAAY,CAAC,qCAAqC,WAAW,CAAC,iBAAiB,CAAC,uBAAuB,2BAA2B,CAAC,oBAAoB,CAAC,0CAA0C,gDAAgD,CAAC,oBAAoB,CAAC,WAAW,CAAC,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,mCAAmC,gDAAgD,CAAC,qBAAqB,CAAC,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,+CAA+C,gDAAgD,CAAC,QAAQ,CAAC,iBAAiB,CAAC,UAAU,CAAC,gBAAgB,2BAA2B,CAAC,8BAA8B,YAAY,CAAC,oCAAoC,aAAa,CAAC,6DAA6D,aAAa,CAAC,yFAAyF,WAAW,CAAC,0BAA0B,CAAC,eAAe,CAAC,kFAAkF,WAAW,CAAC,SAAS,CAAC,8GAA8G,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,sDAAsD,0CAA0C,CAAC,+CAA+C,CAAC,aAAa,CAAC,2EAA2E,sBAAsB,CAAC,kBAAkB,CAAC,cAAc,CAAC,WAAW,CAAC,qHAAqH,WAAW,CAAC,0BAA0B,CAAC,sBAAsB,CAAC,kBAAkB,CAAC,8BAA8B,CAAC,0BAA0B,CAAC,sBAAsB,CAAC,MAAM,CAAC,eAAe,CAAC,qHAAqH,0BAA0B,CAAC,sBAAsB,CAAC,kBAAkB,CAAC,sBAAsB,CAAC,kBAAkB,CAAC,cAAc,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,qHAAqH,6BAA6B,CAAC,yBAAyB,CAAC,qBAAqB,CAAC,sBAAsB,CAAC,kBAAkB,CAAC,cAAc,CAAC,SAAS,CAAC,gBAAgB,CAAC,KAAK,CAAC,qHAAqH,6BAA6B,CAAC,yBAAyB,CAAC,qBAAqB,CAAC,8BAA8B,CAAC,0BAA0B,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,UAAU,CAAC,KAAK,CAAC,kCAAkC,2BAA2B,CAAC,oBAAoB,CAAC,sDAAsD,MAAM,CAAC,iBAAiB,CAAC,QAAQ,CAAC,WAAW,CAAC,uDAAuD,gDAAgD,CAAC,oBAAoB,CAAC,WAAW,CAAC,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,wEAAwE,SAAS,CAAC,OAAO,CAAC,mDAAmD,gBAAgB,CAAC,iBAAiB,CAAC,UAAU,CAAC,6CAA6C,gBAAgB,CAAC,iBAAiB,CAAC,UAAU,CAAC,mBAAmB,8JAA8J,CAAC,+BAA+B,CAAC,uBAAuB,CAAC,kDAAkD,CAAC,kBAAkB,CAAC,yCAAyC,CAAC,oBAAoB,CAAC,WAAW,CAAC,YAAY,CAAC,qBAAqB,CAAC,UAAU,CAAC,0DAA0D,oBAAoB,CAAC,eAAe,CAAC,gBAAgB,CAAC,iBAAiB,CAAC,OAAO,CAAC,kBAAkB,CAAC,WAAW,CAAC,0DAA0D,qBAAqB,CAAC,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,gBAAgB,CAAC,UAAU,CAAC,yEAAyE,WAAW,CAAC,6FAA6F,UAAU,CAAC,eAAe,CAAC,MAAM,6BAA6B,CAAC,kCAAkC,CAAC,mCAAmC,CAAC,4BAA4B,CAAC,0BAA0B,CAAC,mCAAmC,CAAC,4BAA4B,CAAC,mCAAmC,CAAC,0BAA0B,CAAC,gCAAgC,CAAC,4BAA4B,CAAC,uDAAuD,CAAC,KAAK,mDAAmD,CAAC,qCAAqC,CAAC,4BAA4B,CAAC,yBAAyB,CAAC,QAAQ,sBAAsB,CAAC,2BAA2B,CAAC,+BAA+B,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,8BAA8B,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,CAAC,oCAAoC,WAAW,CAAC,UAAU,CAAC,yBAAyB,YAAY,CAAC,qBAAqB,uDAAuD,CAAC,sBAAsB,CAAC,aAAa,CAAC,YAAY,CAAC,QAAQ,CAAC,eAAe,CAAC,qBAAqB,CAAC,2BAA2B,6FAA6F,CAAC,4RAA4R,eAAe,CAAC,kDAAkD,iCAAiC,CAAC,yBAAyB,CAAC,wCAAwC,qBAAqB,CAAC,4CAA4C,4BAA4B,CAAC,yBAAyB,mBAAmB,CAAC,WAAW,CAAC,0CAA0C,cAAc,CAAC,oCAAoC,6DAA6D,CAAC,QAAQ,CAAC,eAAe,CAAC,iBAAiB,CAAC,eAAe,CAAC,WAAW,CAAC,6CAA6C,6FAA6F,CAAC,2CAA2C,sBAAsB,CAAC,UAAU,0BAA0B,CAAC,wBAAwB,CAAC,uBAAuB,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,2GAA2G,iBAAiB,CAAC,SAAS,CAAC,4CAA4C,oBAAoB,CAAC,iBAAiB,CAAC,SAAS,CAAC,kBAAkB,4BAA4B,CAAC,+BAA+B,eAAe,CAAC,mCAAmC,CAAC,SAAS,CAAC,SAAS,CAAC,iBAAiB,CAAC,QAAQ,CAAC,uBAAuB,SAAS,CAAC,iCAAiC,SAAS,CAAC,4DAA4D,sBAAsB\",\"sourcesContent\":[\".easel-toolbar,.easel-toolbar ul{background:var(--easel-color-surface,#fff);box-sizing:border-box;margin:0;padding:0;position:relative;user-select:none;z-index:1060!important}.easel-toolbar{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#f0f0f0);border-radius:24px;box-shadow:0 8px 32px rgba(122,77,217,.18),0 2px 8px rgba(0,0,0,.08);color:var(--easel-color-text,#2d1b4e)}.easel-toolbar .toolbar-dropdown-block,.easel-toolbar ul{z-index:202!important}.easel-toolbar .toolbar-content-wrapper{display:flex!important;justify-content:center!important;left:0;position:relative;top:0;transition:left .2s ease-out,top .2s ease-out}.easel-toolbar.easel-toolbar--horizontal{width:100%}.easel-toolbar.easel-toolbar--vertical{height:100%;z-index:500!important}.popup-content-wrapper .popup-content .easel-toolbar{overflow:visible}.easel-toolbar.easel-toolbar--multiline.easel-toolbar--horizontal .toolbar-content-wrapper,.easel-toolbar.easel-toolbar--multiline.easel-toolbar--vertical .toolbar-content-wrapper{height:auto;white-space:normal;width:100%}.easel-toolbar.toolbar-scrollable.easel-toolbar--horizontal .toolbar-content-wrapper{height:100%;white-space:nowrap;width:auto}.easel-toolbar.toolbar-scrollable.easel-toolbar--vertical .toolbar-content-wrapper{height:auto;white-space:normal;width:100%}.easel-toolbar>li,.easel-toolbar>ul>li,li.toolbar-item{background:var(--easel-color-surface,#fff);display:inline-block;list-style:none;text-align:start;vertical-align:top;white-space:nowrap}.toolbar-button{background:transparent;border-radius:12px;display:inline-block;height:40px;list-style-type:none;margin:0 2px;min-width:40px;text-align:center;transition:all .2s cubic-bezier(.4,0,.2,1);vertical-align:top;width:40px}.toolbar-button.btn-popup-canvas{min-width:40px;padding:0;width:40px}.toolbar-button.btn-popup-canvas a{align-items:center;display:flex;justify-content:center;padding:0}.toolbar-button a{border-radius:12px;color:var(--easel-color-text,#2d1b4e);display:inline-block;height:100%;line-height:40px;text-align:center;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.toolbar-button a:focus{outline:none}.toolbar-button a i{pointer-events:none}.drawer-instance-container:not(.touch) .toolbar-button:not(.dragging):not(.disabled) a:hover{background:var(--easel-color-primary,#a277ff);box-shadow:0 6px 20px rgba(122,77,217,.35);color:var(--easel-color-surface,#fff);transform:translateY(-2px) scale(1.05)}.toolbar-button.disabled:not(.dragging) a{background-color:var(--easel-color-border,#dcdcdc);color:var(--easel-color-text-muted,#6d5c88)}.toolbar-button a.active{background-color:var(--easel-color-primary,#a277ff);box-shadow:0 4px 16px rgba(122,77,217,.3),inset 0 1px 3px rgba(0,0,0,.1);color:var(--easel-color-surface,#fff);outline:none;transform:scale(.95)}.toolbar-button.btn-export-svg a{background:var(--easel-color-primary,#a277ff);box-shadow:0 6px 20px rgba(122,77,217,.35);color:var(--easel-color-surface,#fff);font-weight:600}.toolbar-button.btn-export-svg a:hover{transform:translateY(-2px) scale(1.05)}.submenu-wrapper{background:hsla(0,0%,100%,.95);border:1px solid var(--easel-color-border,#f0f0f0);border-radius:12px;box-shadow:0 8px 32px rgba(122,77,217,.18),0 2px 8px rgba(0,0,0,.08);padding:4px;pointer-events:auto;position:absolute;width:35px;z-index:1100}.submenu-wrapper .toolbar-button{margin:2px 0;width:35px}.toolbar-content-wrapper .submenu-wrapper{display:none}.group-items-container{padding:0;white-space:normal}.easel-toolbar .btn-delete-canvas a{color:var(--easel-color-danger,#d45a78)}.easel-toolbar.toolbar-scrollable{overflow:visible}.easel-toolbar.easel-toolbar--horizontal{display:block;margin:0 auto;max-width:90%;padding:8px 16px;width:fit-content}.easel-toolbar.easel-toolbar--horizontal .toolbar-content-wrapper,.easel-toolbar.easel-toolbar--vertical .toolbar-content-wrapper{display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-justify-content:flex-start;-ms-flex-pack:start;-webkit-align-content:flex-start;justify-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start}.easel-toolbar.easel-toolbar--multiline .toolbar-content-wrapper,.popup-content-wrapper .popup-content .easel-toolbar .toolbar-content-wrapper{-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.easel-toolbar.toolbar-scrollable .toolbar-content-wrapper{-webkit-flex-wrap:nowrap;-ms-flex-wrap:nowrap;flex-wrap:nowrap}.easel-toolbar.easel-toolbar--horizontal .toolbar-content-wrapper{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row}.easel-toolbar.easel-toolbar--vertical .toolbar-content-wrapper{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.easel-toolbar.easel-toolbar--horizontal.empty-toolbar{height:0}.easel-toolbar.easel-toolbar--vertical{display:inline-block;position:relative;vertical-align:top;width:fit-content}.easel-toolbar.easel-toolbar--vertical.empty-toolbar{width:0}.toolbar-placeholder-right .easel-toolbar.easel-toolbar--vertical{background:hsla(0,0%,100%,.98);min-width:48px;padding:4px;width:auto}.toolbar-placeholder-right .toolbar-dropdown-toggle{background:var(--easel-color-surface,#fff);border:none;border-radius:12px;cursor:pointer;display:block;height:40px;outline:none;position:relative;transition:all .2s cubic-bezier(.4,0,.2,1);width:40px;z-index:1}.toolbar-placeholder-right .toolbar-dropdown-toggle:hover{background:var(--easel-color-primary,#a277ff);box-shadow:0 6px 20px rgba(122,77,217,.35);transform:scale(1.05)}.toolbar-placeholder-right .toolbar-dropdown-toggle:hover i{color:var(--easel-color-surface,#fff)}.toolbar-placeholder-right .toolbar-dropdown-toggle i{color:var(--easel-color-text,#2d1b4e);font-size:18px;line-height:40px;transition:color .2s ease}.toolbar-placeholder-right .toolbar-dropdown-toggle i:before{display:block}.toolbar-placeholder-right .toolbar-content-wrapper{animation:slideDown .2s ease-out;background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#f0f0f0);border-radius:16px;box-shadow:0 12px 40px rgba(122,77,217,.25),0 4px 12px rgba(0,0,0,.1);display:none;max-height:400px;min-width:48px;overflow-y:visible;padding:8px;position:absolute;right:0;top:52px;z-index:1100}@keyframes slideDown{0%{opacity:0;transform:translateY(-10px)}to{opacity:1;transform:translateY(0)}}.toolbar-placeholder-right .easel-toolbar.easel-toolbar--vertical.dropdown-open .toolbar-content-wrapper{display:flex}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar{width:6px}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar-track{background:transparent}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar-thumb{background:var(--easel-color-border-strong,#cbb6ff);border-radius:3px}.toolbar-placeholder-right .toolbar-content-wrapper::-webkit-scrollbar-thumb:hover{background:var(--easel-color-primary,#a277ff)}.easel-toolbar.easel-toolbar--horizontal>li{height:100%}.toolbars-wrapper{bottom:0;left:0;pointer-events:none;position:absolute;right:0;top:0;z-index:1050}.toolbar-placeholder{box-sizing:border-box;margin:0;padding-left:0;pointer-events:auto;position:absolute;z-index:1000}.toolbar-placeholder:not(.toolbar-placeholder-inside){z-index:5000}.toolbar-placeholder-top{top:10px}.toolbar-placeholder-bottom,.toolbar-placeholder-top{height:auto;left:0;right:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none}.toolbar-placeholder-bottom{align-items:center;bottom:15px;display:flex;justify-content:center;pointer-events:none}@media (max-width:767px){.toolbar-placeholder-top{display:none!important}}.toolbar-placeholder-bottom .easel-toolbar{pointer-events:auto}.toolbar-placeholder-left{bottom:0;left:10px;top:0}.toolbar-placeholder-left,.toolbar-placeholder-right{-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;width:auto}.toolbar-placeholder-right{bottom:auto;right:15px;top:15px}.toolbar-placeholder-top.toolbar-placeholder-inside{margin-top:0;top:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none}.toolbar-placeholder-bottom.toolbar-placeholder-inside{bottom:0;margin-bottom:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;z-index:1002}.toolbar-placeholder-left.toolbar-placeholder-inside{left:0;margin-left:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;z-index:1001}.toolbar-placeholder-right.toolbar-placeholder-inside{margin-right:0;right:0;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;z-index:1001}.toolbar-placeholder.toolbar-placeholder-inside{height:100%;overflow:hidden;pointer-events:none;width:100%}.toolbar-placeholder.toolbar-placeholder-inside .easel-toolbar{overflow:visible;pointer-events:auto;position:absolute}.toolbar-placeholder-top.toolbar-placeholder-inside .easel-toolbar{left:0;right:0;top:0}.toolbar-placeholder-bottom.toolbar-placeholder-inside .easel-toolbar{bottom:0;left:0;right:0}.toolbar-placeholder-left.toolbar-placeholder-inside .easel-toolbar{bottom:0;left:0;top:0}.element-properties-toolbar{border-radius:20px;box-shadow:0 10px 30px rgba(122,77,217,.18);display:inline-flex;flex-direction:column;max-width:min(320px,calc(100% - 24px));min-width:0;padding:16px 12px;width:auto}.element-properties-toolbar.easel-toolbar--vertical .toolbar-content-wrapper{align-items:stretch;display:flex;flex-direction:column;gap:12px;width:auto}.toolbar-placeholder-left.toolbar-placeholder-inside .element-properties-toolbar{bottom:auto;left:16px;top:50%;transform:translateY(-50%)}.toolbar-placeholder-right.toolbar-placeholder-inside .easel-toolbar{bottom:0;right:0;top:0}.toolbar-placeholder-overcanvas{left:0;top:0;z-index:1100}.toolbar-placeholder-overcanvas .easel-toolbar{border:none;box-shadow:none;overflow:initial}.toolbar-placeholder-overcanvas .easel-toolbar .toolbar-content-wrapper{position:static}.toolbar-placeholder-overcanvas .easel-toolbar .toolbar-content-wrapper li{border:1px solid var(--easel-color-border,#e5e5e5);position:absolute;width:35px}.toolbar-placeholder .toolbar-placeholder-overlay{background-color:var(--easel-color-surface,#fff);bottom:0;display:none;left:0;list-style-type:none;opacity:.85;position:absolute;right:0;top:0;z-index:1200}.toolbar-placeholder.placeholder-overlayed .toolbar-placeholder-overlay{display:block}.toolbar-placeholder.placeholder-disabled,.toolbar-placeholder.placeholder-disabled :not(.popup-overlay):not(.toolbar-placeholder-overlay){cursor:default!important;pointer-events:none!important}.toolbar-label{height:100%;line-height:35px;margin-right:10px;width:auto}.toolbar-item-wrapper,.toolbar-label{display:inline-block;vertical-align:top}.toolbar-item-wrapper{list-style:none;position:relative;text-align:left}.toolbar-item-label{display:inline-block;height:100%;line-height:35px;margin-right:10px;vertical-align:top;width:auto}.toolbar-item-icon{background-color:transparent;background-position:50%;border-radius:12px;bottom:0;cursor:pointer;display:none;left:0;line-height:40px;position:absolute;right:0;text-align:center;top:0;transition:all .2s cubic-bezier(.4,0,.2,1)}.toolbar-item-icon:before{transition:color .4s linear}.toolbar-item-wrapper .toolbar-dropdown-block{display:inline-block;position:relative}.toolbar-item-wrapper.toolbar-button-item{border:1px solid transparent;border-radius:12px;height:40px;margin:0 3px;padding:0;transition:all .2s cubic-bezier(.4,0,.2,1);width:40px}.toolbar-item-wrapper.toolbar-button-item:before{border:1px solid transparent;color:var(--easel-color-text,#2d1b4e);height:40px;margin:0 3px;padding:0;width:40px}.toolbar-item-wrapper.toolbar-button-item.prevent-highlight .toolbar-item-icon{background-color:var(--easel-color-surface,#fff)!important}.toolbar-item-wrapper.toolbar-button-item.prevent-highlight .toolbar-item-icon:before{color:var(--easel-color-text,#2d1b4e)!important}.toolbar-item-wrapper.toolbar-button-item:not(.option-value-inherited):not(.option-value-invalid):not(.option-value-multiple) .toolbar-item-icon:before{color:var(--easel-color-surface,#fff)}.toolbar-item-wrapper.toolbar-button-item.option-value-inherited:not(.option-value-multiple) .toolbar-item-icon{background-color:var(--easel-color-surface,#fff)}.toolbar-item-wrapper.toolbar-button-item.option-value-multiple .toolbar-item-icon{background-color:var(--easel-color-border,#dcdcdc)}.toolbar-item-wrapper.toolbar-button-item .toolbar-dropdown-block{left:-1px;position:absolute;top:100%}.element-properties-toolbar .toolbar-item-wrapper.toolbar-button-item .toolbar-dropdown-block{bottom:auto;left:calc(100% + 12px);top:50%;transform:translateY(-50%)}.toolbar-placeholder-bottom .toolbar-item-wrapper.toolbar-button-item .toolbar-dropdown-block{bottom:100%;left:-1px;position:absolute;top:auto}.toolbar-item-wrapper.toolbar-button-item .toolbar-item-label,.toolbar-item-wrapper.toolbar-button-item.collapsed .toolbar-dropdown-block{display:none}.toolbar-item-wrapper.toolbar-button-item .toolbar-item-icon{display:block}.btn-toggle-canvas.active a,.btn-toggle-canvas.dragging a{background-color:var(--easel-color-primary,#a277ff);color:var(--easel-color-surface,#fff);outline:none}.easel-toolbar.tool-minimized-toolbar{display:none}.toolbar-item-description{display:inline-block;vertical-align:top}.toolbar-item-description input{vertical-align:top}.easel-toolbar input[type=range]{-webkit-appearance:none;appearance:none;background:var(--easel-color-surface-muted,#f7f3ff);border:none;border-radius:12px;height:32px;overflow:hidden;padding:8px 12px;top:0;width:200px}.easel-toolbar input[type=range]::-webkit-slider-runnable-track{background:var(--easel-color-border,#ddd);border:none;border-radius:10px;height:6px;width:100%}.easel-toolbar input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;background:var(--easel-color-primary,#a277ff);border:3px solid var(--easel-color-surface,#fff);border-radius:50%;box-shadow:0 2px 8px rgba(122,77,217,.3);cursor:pointer;height:20px;margin-top:-7px;transition:all .2s ease;width:20px}.easel-toolbar input[type=range]:focus{outline:none}.easel-toolbar input[type=range]:focus::-webkit-slider-runnable-track{background:var(--easel-color-border-strong,#ccc)}.easel-toolbar input[type=range]::-moz-range-track{background:var(--easel-color-border,#ddd);border:none;border-radius:10px;height:6px;width:100%}.easel-toolbar input[type=range]::-moz-range-thumb{background:var(--easel-color-primary,#a277ff);border:3px solid var(--easel-color-surface,#fff);border-radius:50%;box-shadow:0 2px 8px rgba(122,77,217,.3);cursor:pointer;height:20px;width:20px}.easel-toolbar input[type=range]:-moz-focusring{outline:1px solid #fff;outline-offset:-1px}.easel-toolbar input[type=range]::-ms-track{background:transparent;border-color:transparent;border-width:6px 0;color:transparent;height:5px;width:300px}.easel-toolbar input[type=range]::-ms-fill-lower{background:var(--easel-color-border-strong,#777);border-radius:10px}.easel-toolbar input[type=range]::-ms-fill-upper{background:var(--easel-color-border,#ddd);border-radius:10px}.easel-toolbar input[type=range]::-ms-thumb{background:var(--easel-color-primary,#a277ff);border:3px solid var(--easel-color-surface,#fff);border-radius:50%;box-shadow:0 2px 8px rgba(122,77,217,.3);cursor:pointer;height:20px;width:20px}.easel-toolbar input[type=range]:focus::-ms-fill-lower{background:var(--easel-color-border-strong,#888)}.easel-toolbar input[type=range]:focus::-ms-fill-upper{background:var(--easel-color-border-strong,#ccc)}.tooltip-transparent{display:block!important;opacity:0!important;visibility:visible!important}.editable-canvas-tooltip{background:#000;border-radius:4px;color:#fff;display:block;font-size:12px;opacity:0;padding:5px 8px;pointer-events:none;position:absolute;transition:opacity .2s;z-index:100001}.editable-canvas-tooltip.active{opacity:1}.editable-canvas-tooltip:after{border-style:solid;content:\\\"\\\";height:0;position:absolute;width:0}.editable-canvas-tooltip[positionX=left][positionY=top]{border-bottom-right-radius:0}.editable-canvas-tooltip[positionX=left][positionY=top]:after{border-color:transparent transparent transparent #000;border-width:10px 0 0 10px;bottom:0;left:100%}.editable-canvas-tooltip[positionX=left][positionY=bottom]{border-top-right-radius:0}.editable-canvas-tooltip[positionX=left][positionY=bottom]:after{border-color:#000 transparent transparent;border-width:10px 10px 0 0;left:100%;top:0}.editable-canvas-tooltip[positionX=right][positionY=bottom]{border-top-left-radius:0}.editable-canvas-tooltip[positionX=right][positionY=bottom]:after{border-color:transparent #000 transparent transparent;border-width:0 10px 10px 0;right:100%;top:0}.editable-canvas-tooltip[positionX=right][positionY=top]{border-bottom-left-radius:0}.editable-canvas-tooltip[positionX=right][positionY=top]:after{border-color:transparent transparent #000;border-width:0 0 10px 10px;bottom:0;right:100%}.editable-canvas-tooltip[positionX=right][positionY=center]:after{border-color:transparent #000 transparent transparent;border-width:5px 10px 5px 0;right:100%}.editable-canvas-tooltip[positionX=left][positionY=center]:after,.editable-canvas-tooltip[positionX=right][positionY=center]:after{top:50%;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%)}.editable-canvas-tooltip[positionX=left][positionY=center]:after{border-color:transparent transparent transparent #000;border-width:5px 0 5px 10px;left:100%}.editable-canvas-tooltip[positionX=center][positionY=top]:after{border-color:#000 transparent transparent;border-width:10px 5px 0;top:100%}.editable-canvas-tooltip[positionX=center][positionY=bottom]:after,.editable-canvas-tooltip[positionX=center][positionY=top]:after{left:50%;-webkit-transform:translateX(-50%);-moz-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translateX(-50%)}.editable-canvas-tooltip[positionX=center][positionY=bottom]:after{border-color:transparent transparent #000;border-width:0 5px 10px;bottom:100%}.toolbar-combobox-wrapper{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-sizing:border-box;color:var(--easel-color-text,#2d1b4e);display:inline-block;margin:2px auto;min-width:140px;outline:none;position:relative;transition:all .2s cubic-bezier(.4,0,.2,1);width:auto}.toolbar-placeholder-bottom .toolbar-combobox-wrapper{bottom:100%;position:absolute;top:auto}.toolbar-combobox-wrapper>.selected{border-radius:12px;cursor:pointer;display:table;float:left;height:36px;line-height:36px;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.toolbar-combobox-wrapper>.selected span{display:table-cell;font-size:14px;padding:0 13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle}.toolbar-combobox-wrapper.option-value-inherited>.selected{background-color:#dcdcdc}.toolbar-combobox-wrapper.option-value-multiple>.selected{background-color:#efb5b5}.toolbar-combobox-wrapper.hightlight-red>.selected .ui-button{background:#fff}.toolbar-combobox-wrapper .dropdown-box{background-color:hsla(0,0%,100%,.98);border-top:none;border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-shadow:0 8px 24px rgba(122,77,217,.15);box-sizing:border-box;padding:8px 0;position:relative;top:38px;z-index:2}.toolbar-combobox-wrapper:not(.button-mode) .toolbar-item-description{display:inline-block}.toolbar-combobox-wrapper .inputbox{clear:both;display:none;margin:5px 5px 0}.toolbar-combobox-wrapper.edit-mode .inputbox{display:block}.toolbar-combobox-wrapper .inputbox input[type=text]{background:var(--easel-color-surface-muted,#f7f3ff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:10px;color:var(--easel-color-text,#2d1b4e);font-size:14px;outline:none;padding:10px 14px;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.toolbar-combobox-wrapper .inputbox input[type=text]:focus{background:var(--easel-color-surface,#fff);border-color:var(--easel-color-primary,#a277ff);box-shadow:0 0 0 3px rgba(162,119,255,.15)}.toolbar-combobox-wrapper .option-list{clear:both;list-style:none;padding:0;-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0;-webkit-padding-start:0;display:inline-block;margin-top:5px;max-height:195px;overflow-x:auto;overflow-y:visible;position:relative;width:100%}.toolbar-combobox-wrapper .option-list .option-item{border-radius:8px;color:var(--easel-color-text,#2d1b4e);cursor:pointer;display:block;font-size:13px;line-height:32px;margin:2px 8px;padding:0 12px;transition:all .2s cubic-bezier(.4,0,.2,1)}.toolbar-combobox-wrapper .option-list .option-item .option-item-text{display:inline-block;white-space:nowrap}.toolbar-combobox-wrapper .option-list .option-item:first-letter{text-transform:uppercase}.toolbar-combobox-wrapper .option-list .option-item:not(.selected):hover{background-color:var(--easel-color-primary-light,#d6c6ff);transform:translateX(4px)}.toolbar-combobox-wrapper .option-list .option-item.selected{background-color:var(--easel-color-primary,#a277ff);color:var(--easel-color-surface,#fff);font-weight:500}.toolbar-combobox-wrapper .ui-button{background-color:transparent;border-left:1px solid var(--easel-color-border,#e3d8ff);border-radius:0 12px 12px 0;color:var(--easel-color-text-muted,#6d5c88);cursor:pointer;display:table-cell;float:right;height:100%;text-align:center;transition:all .2s cubic-bezier(.4,0,.2,1);width:40px}.toolbar-combobox-wrapper .ui-button:hover{background-color:var(--easel-color-primary-light,#d6c6ff);color:var(--easel-color-primary-dark,#7c4ed9)}.toolbar-combobox-wrapper .ui-button i{margin-top:7px}.toolbar-combobox-wrapper:focus{box-shadow:0 0 0 3px rgba(162,119,255,.15)}.toolbar-combobox-wrapper:focus,.toolbar-combobox-wrapper:focus .dropdown-box{border-color:var(--easel-color-primary,#a277ff)}.toolbar-combobox-wrapper:focus .ui-button{border-left-color:var(--easel-color-primary,#a277ff)}.toolbar-combobox-wrapper.focus{box-shadow:0 0 0 3px rgba(162,119,255,.15)}.toolbar-combobox-wrapper.focus,.toolbar-combobox-wrapper.focus .dropdown-box{border-color:var(--easel-color-primary,#a277ff)}.toolbar-combobox-wrapper.focus .ui-button{border-left-color:var(--easel-color-primary,#a277ff)}.toolbar-item-wrapper:not(.toolbar-button-item) .toolbar-combobox-wrapper .dropdown-box.collapsed,.toolbar-item-wrapper:not(.toolbar-button-item) .toolbar-combobox-wrapper.collapsed .dropdown-box{display:none}.toolbar-button-item .toolbar-combobox-wrapper{margin:0 0 -1px}.combobox-cloned.toolbar-combobox-wrapper>.selected,.toolbar-button-item .toolbar-combobox-wrapper>.selected{display:none}.combobox-cloned.toolbar-combobox-wrapper>.dropdown-box,.toolbar-button-item .toolbar-combobox-wrapper>.dropdown-box{display:block;top:0}.toolbar-button-item .collapsed .toolbar-combobox-wrapper:not(.combobox-cloned){display:none}#easel-canvas-box.fullscreen{background:var(--easel-color-surface,#fff)!important;bottom:0!important;height:auto!important;left:0!important;position:fixed!important;right:0!important;top:0!important;transition:none!important;width:auto!important;z-index:100000}#easel-canvas-box.fullscreen .easel-canvas-resizer,#easel-canvas-box.fullscreen .toolbar-button.btn-delete-canvas,#easel-canvas-box.fullscreen .toolbar-button.btn-minimize-canvas,#easel-canvas-box.fullscreen .toolbar-button.btn-move,#easel-canvas-box.fullscreen .toolbar-button.btn-restore-canvas{display:none!important}#easel-canvas-box.fullscreen .fullscreenOverOther{z-index:2000!important}#easel-canvas-box.fullscreen .canvas-container{height:100%!important;width:100%!important}#easel-canvas-box.animation.fullscreen,#easel-canvas-box.fullscreen-in-progress{transition:none!important}#easel-canvas-box.fullscreen-in-progress .toolbars-wrapper{opacity:0!important}.zoom-tooltip{background-color:#ccc;border-radius:5px;left:50%;opacity:.85;padding:5px;pointer-events:none;position:absolute;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);-moz-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);transition:opacity .5s linear;z-index:20000000}.zoom-tooltip.transparent-tooltip{opacity:0}.crop-container{background:var(--easel-color-surface,#fff);bottom:0;left:0;position:absolute;right:0;top:0;z-index:20000}.crop-container .cr-image{left:0;max-height:none;max-width:none;opacity:0;position:absolute;top:0;transform-origin:0 0;z-index:-1;z-index:-2}.crop-container .cr-boundary{height:100%;margin:0 auto;overflow:hidden;position:relative;width:100%;z-index:1}.crop-container .cr-viewport{border:2px solid var(--easel-color-surface,#fff);bottom:0;box-shadow:0 0 2000px 2000px rgba(45,27,78,.5);left:0;margin:auto;pointer-events:none;position:absolute;right:0;top:0;z-index:100}.crop-container .cr-original-image{display:none}.crop-container .cr-vp-circle{border-radius:50%}.crop-container .cr-overlay{border-radius:12px;cursor:move;position:absolute;z-index:1}.crop-container .cr-slider-wrap{bottom:0;left:0;margin:15px auto;position:absolute;right:0;text-align:center;z-index:1}.croppie-result{overflow:hidden;position:relative}.croppie-result img{position:absolute}.crop-container .cr-image,.crop-container .cr-overlay,.crop-container .cr-viewport{-webkit-transform:translateZ(0);-moz-transform:translateZ(0);-ms-transform:translateZ(0);transform:translateZ(0)}.cr-viewport-resizer{height:inherit;left:50%;position:absolute;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);-moz-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);width:inherit}.cr-viewport-resizer.resizing{background:rgba(162,119,255,.18);border:2px dotted var(--easel-color-primary-dark,#7c4ed9);box-sizing:content-box;margin:0}.cr-viewport-resizer-handler{background:var(--easel-color-primary,#a277ff);border:2px solid var(--easel-color-border,#ccc);cursor:nwse-resize;height:15px;left:100%;margin:-10px 0 0 -10px;pointer-events:auto;position:absolute;top:100%;width:15px}.cr-controls-wrapper{position:absolute;right:5px;top:50%;-webkit-transform:translateY(-50%);-moz-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);z-index:200}.cr-controls-wrapper .btn{display:block;margin:5px auto}.cr-slider{-webkit-appearance:none;appearance:none;background-color:transparent;cursor:pointer;max-width:100%;padding-bottom:8px;padding-top:8px;width:300px}.cr-slider::-webkit-slider-runnable-track{background:var(--easel-color-border,rgba(0,0,0,.3));border:0;border-radius:3px;height:3px;width:100%}.cr-slider::-webkit-slider-thumb{-webkit-appearance:none;background:var(--easel-color-primary,#a277ff);border:none;border-radius:50%;height:16px;margin-top:-6px;width:16px}.cr-slider:focus{outline:none}.cr-slider::-moz-range-track{background:var(--easel-color-border,rgba(0,0,0,.3));border:0;border-radius:3px;height:3px;width:100%}.cr-slider::-moz-range-thumb{background:var(--easel-color-primary,#a277ff);border:none;border-radius:50%;height:16px;margin-top:-6px;width:16px}.cr-slider:-moz-focusring{outline:1px solid #fff;outline-offset:-1px}.cr-slider::-ms-track{background:transparent;border-color:transparent;border-width:6px 0;color:transparent;height:5px;width:100%}.cr-slider::-ms-fill-lower{background:var(--easel-color-border-strong,rgba(0,0,0,.4));border-radius:10px}.cr-slider::-ms-fill-upper{background:var(--easel-color-border,rgba(0,0,0,.3));border-radius:10px}.cr-slider::-ms-thumb{background:var(--easel-color-primary,#a277ff);border:none;border-radius:50%;height:16px;margin-top:1px;width:16px}.cr-slider:focus::-ms-fill-lower,.cr-slider:focus::-ms-fill-upper{background:rgba(0,0,0,.5)}.cr-rotate-controls{bottom:5px;left:5px;position:absolute;z-index:1}.cr-rotate-controls button{background:var(--easel-color-surface,transparent);border:0;color:var(--easel-color-text-muted,#6d5c88)}.cr-rotate-controls i:before{display:inline-block;font-size:22px;font-style:normal;font-weight:900}.cr-rotate-l i:before{content:\\\"\\\"}.cr-rotate-r i:before{content:\\\"\\\"}.image-crop-wrapper{background:var(--easel-color-surface,#fff);bottom:0;left:0;overflow:hidden;position:absolute;right:0;top:0;z-index:201}.cr-image{left:50%;max-height:100%;max-width:100%;position:absolute;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);-moz-transform:translateX(-50%) translateY(-50%);-ms-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%)}.cr-image-fullsize{opacity:0}.imager-crop-container{z-index:1300}.imager-crop-canvas,.imager-crop-container{height:100%;left:0;position:absolute;top:0;width:100%}.crop-corner{background:#fff;border:1px solid #00b7ff;height:7px;position:absolute;width:7px;z-index:1301}.crop-top-left{cursor:nwse-resize;left:0;top:0}.crop-top-right{cursor:nesw-resize;right:0;top:0}.crop-bottom-right{bottom:0;cursor:nwse-resize;right:0}.crop-bottom-left{bottom:0;cursor:nesw-resize;left:0}.crop-border{position:absolute}.crop-border.crop-border-top{height:1px;top:4px;width:100%}.crop-border.crop-border-right{height:100%;right:2px;width:1px}.crop-border.crop-border-bottom{bottom:2px;height:1px;width:100%}.crop-border.crop-border-left{height:100%;left:4px;width:1px}.minimized{border:none!important;height:auto!important;width:auto!important}.minimized .toolbar-placeholder.toolbar-placeholder-top.toolbar-placeholder-inside,.minimized .toolbars-wrapper{position:static}.drawer-toolbar.tool-minimized-toolbar,.minimized .canvas-container,.minimized .drawer-toolbar:not(.tool-minimized-toolbar),.minimized .toolbar-button.btn-fullscreen-canvas,.minimized span.redactor-drawer-resizer{display:none}.minimized .drawer-toolbar.tool-minimized-toolbar{display:inline-block}.minimized .drawer-toolbar.tool-minimized-toolbar .toolbar-content-wrapper{display:inline-block;white-space:nowrap}.canvas-caption{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:8px;color:var(--easel-color-text,#2d1b4e);display:inline-block;line-height:32px;list-style-type:none;margin:0 5px;padding:0 12px;text-align:center;vertical-align:middle}.editable-canvas-colorpicker{-webkit-appearance:none;appearance:none;background:var(--easel-color-surface,#fff);border:none;height:32px;position:relative;width:32px}.editable-canvas-colorpicker::-webkit-color-swatch-wrapper{padding:0}.editable-canvas-colorpicker::-webkit-color-swatch{border:none}ul.drawer-toolbar li.editable-easel-plugin-color .toolbar-label{position:relative;top:-9px}ul.drawer-toolbar li.editable-easel-plugin-color{padding-left:10px;text-align:left;width:auto}.editable-canvas-stroke-width .toolbar-item-description{display:inline-block}.editable-canvas-stroke-width input.editable-canvas-stroke-width-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.editable-canvas-stroke-width .editable-canvas-stroke-width-label{padding-left:10px}span.toolbar-label.editable-canvas-stroke-width-indicator{display:inline-block;margin-right:5px;width:50px}label.background-transparency{display:inline!important;font-weight:400;padding-left:10px!important;width:auto}.toolbar-button .fa-line{-ms-transform:rotate(24deg);-webkit-transform:rotate(24deg);-moz-transform:rotate(24deg);transform:rotate(24deg);width:14px}.toolbar-button .fa-line:before{content:\\\"/\\\";font-size:19px!important;font-weight:700;line-height:10px;position:relative;top:2px}.drawer-tool-mouse-tooltip .fa-line{left:5px;position:relative;top:2px}.popup-wrapper{bottom:0;left:0;position:absolute;right:0;top:0;z-index:1106}.popup-wrapper .popup-content-wrapper{background-color:var(--easel-color-surface,#fff);border:1px solid rgba(45,27,78,.08);border-radius:18px;box-shadow:0 20px 45px rgba(15,23,42,.12);max-width:420px;position:absolute;z-index:1}.popup-wrapper .popup-content-wrapper.popup-transparent{opacity:0}.popup-wrapper .popup-content-wrapper .popup-arrow{height:10px;margin-left:-5px;margin-top:-5px;position:absolute;width:10px;z-index:111}.popup-wrapper .popup-content-wrapper .popup-arrow:after,.popup-wrapper .popup-content-wrapper .popup-arrow:before{border:0 solid;content:\\\"\\\";display:block;margin-left:-5px;margin-top:-5px;position:absolute}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow{bottom:auto!important;top:100%!important}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:before{border-width:10px 10px 0;margin-top:5px}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:after{border-color:var(--easel-color-surface,#fff) transparent transparent transparent;margin-top:3px}.popup-wrapper .popup-content-wrapper[data-position=top] .popup-arrow:before{border-color:var(--easel-color-border,#ccc) transparent transparent transparent}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow{left:100%!important;right:auto!important}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:before{border-width:10px 0 10px 10px;margin-left:5px}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:after{border-color:transparent transparent transparent var(--easel-color-surface,#fff);margin-left:3px}.popup-wrapper .popup-content-wrapper[data-position=left] .popup-arrow:before{border-color:transparent transparent transparent var(--easel-color-border,#ccc)}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow{left:auto!important;right:100%!important}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:before{border-width:10px 10px 10px 0;margin-left:0}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:after{border-color:transparent var(--easel-color-surface,#fff) transparent transparent;margin-left:2px}.popup-wrapper .popup-content-wrapper[data-position=right] .popup-arrow:before{border-color:transparent var(--easel-color-border,#ccc) transparent transparent}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow{bottom:100%!important;margin-top:0;top:auto!important}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:after,.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:before{border-width:0 10px 10px}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:after{border-color:transparent transparent var(--easel-color-surface,#fff) transparent;margin-top:2px}.popup-wrapper .popup-content-wrapper[data-position=bottom] .popup-arrow:before{border-color:transparent transparent var(--easel-color-border,#ccc) transparent;margin-top:0}.popup-wrapper .popup-content{--popup-grid-min-column:260px;align-content:flex-start;align-items:stretch;box-sizing:border-box;display:grid;gap:20px;grid-template-columns:repeat(auto-fit,minmax(0,max-content));justify-content:flex-start;max-height:70vh;overflow-y:auto;padding:20px;width:100%}.popup-wrapper .popup-content .toolbar-placeholder{background:var(--easel-color-surface,#fff);border:1px solid rgba(45,27,78,.08);border-radius:16px;box-shadow:0 12px 30px rgba(15,23,42,.08);display:grid;gap:14px;grid-auto-rows:minmax(0,max-content);justify-self:flex-start;list-style:none;margin:0;max-width:100%;padding:18px;width:max-content}.popup-wrapper .popup-content .drawer-toolbar{background:transparent;border:none;box-shadow:none;max-width:100%;width:100%}.popup-wrapper .popup-content .drawer-toolbar .toolbar-content-wrapper{gap:12px;width:100%}.popup-wrapper .popup-overlay{background-color:rgba(45,27,78,.12);bottom:0;left:0;opacity:1;position:absolute;right:0;top:0}@media (max-width:640px){.popup-wrapper .popup-content-wrapper{max-width:calc(100% - 24px)}.popup-wrapper .popup-content{gap:16px;grid-template-columns:1fr;max-height:80vh}}.popup-wrapper .popup-close-btn{border-radius:50%;color:var(--easel-color-text-muted,#6d5c88);cursor:pointer;height:32px;line-height:32px;position:absolute;right:8px;text-align:center;top:8px;transition:all .2s cubic-bezier(.4,0,.2,1);width:32px;z-index:1007}.popup-wrapper .popup-close-btn:hover{background:var(--easel-color-primary-light,#d6c6ff);color:var(--easel-color-primary-dark,#7c4ed9);transform:scale(1.1)}.popup-wrapper .popup-content .toolbar-placeholder{position:static}.popup-wrapper .popup-content .toolbar-item-wrapper{display:flex;flex-direction:column;gap:6px;width:100%}.popup-wrapper .popup-content .toolbar-item-label{color:var(--easel-color-text-muted,#6d5c88);font-size:.7rem;letter-spacing:.08em;line-height:1;margin:0;text-transform:uppercase}.popup-wrapper .popup-content .toolbar-item-wrapper .toolbar-item-icon{position:relative}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range{align-items:center;background:var(--easel-color-surface-muted,#faf8ff);border-radius:12px;column-gap:12px;display:grid;grid-template-columns:minmax(0,1fr) auto;grid-template-rows:auto auto;min-width:100%;padding:8px 12px 12px;row-gap:6px;width:100%}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range input[type=range]{grid-column:1/-1;margin:0;width:100%}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range .toolbar-item-description{align-items:center;display:grid;gap:8px;grid-column:1/-1;grid-template-columns:minmax(0,1fr) auto;padding:0;position:static}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range .toolbar-label{padding:0;text-align:left}.popup-wrapper .popup-content .toolbar-placeholder .toolbar-item-range .toolbar-label.toolbar-label-indicator{text-align:right}.btn-diamond .fa-diamond,.drawer-tool-mouse-tooltip .fa-diamond{font-size:14px}.drawer-tool-mouse-tooltip{background:#f5f5f5;border:1px solid #efefef;border-radius:4px;box-shadow:0 2px 3px rgba(0,0,0,.03);margin-left:10px;margin-top:10px;opacity:0;padding:5px 10px;pointer-events:none;position:absolute;transition:opacity .2s;white-space:nowrap;z-index:99999}.editable-canvas-border-type{padding-left:8px;position:relative;width:auto!important}.popup-content-wrapper .popup-content .editable-canvas-border-type .toolbar-label{margin-right:6px}.editable-canvas-border-type .border-type-indicator{background-position:50%;background-repeat:no-repeat;height:20px;line-height:20px;margin-top:8px;padding:0 8px;width:60px!important}.border-type-dropdown,.editable-canvas-border-type .border-type-indicator{border:1px solid var(--easel-color-border,#ccc);box-sizing:content-box;display:inline-block;text-align:center}.border-type-dropdown{background:var(--easel-color-surface,#fff);left:auto;padding:5px;position:absolute;right:0;transform:none;width:66px}.border-type-dropdown ul li{background-position-y:50%;background-repeat:no-repeat;cursor:pointer;display:block;height:20px;line-height:20px;width:100%}.border-type-dropdown ul li:hover{background-color:var(--easel-color-primary,#a277ff)}.popup-content-wrapper .popup-content .border-type-dropdown,.toolbar-placeholder-bottom .border-type-dropdown{bottom:100%}.toolbar-placeholder-top .border-type-dropdown{top:100%}.toolbar-placeholder-left .border-type-dropdown{left:100%;top:0}.toolbar-placeholder-right .border-type-dropdown{right:100%;top:0}.border-type-dropdown.toolbar-dropdown-block.border-type-dropdown-cloned{text-align:center;width:66px}.border-type-dropdown-cloned ul{padding:0}.touch li.easel-plugin-brushsize{padding-left:10px!important;padding-top:10px!important}ul.drawer-toolbar li.editable-canvas-brushsize{padding-left:10px!important;padding-right:10px;width:auto}li.editable-canvas-brushsize .editable-canvas-brushsize-indicator{display:inline-block;margin-right:5px;width:50px}.popup-wrapper .popup-content .drawer-toolbar li.editable-canvas-brushsize{box-sizing:border-box;margin:0;min-width:100%;padding:0 10px;text-align:right;width:100%}.popup-wrapper .popup-content .drawer-toolbar li.editable-canvas-brushsize .editable-canvas-brushsize-input{float:right}.popup-wrapper .popup-content li.editable-canvas-brushsize .editable-canvas-brushsize-indicator{float:none;text-align:left}li.editable-canvas-brushsize .editable-canvas-brushsize-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.list-item-range{align-items:stretch;display:flex!important;flex-direction:column}.editable-canvas-opacity-option-indicator{display:inline-block;margin-right:5px;width:50px}li.editable-canvas-opacity-option .editable-canvas-opacity-option-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.editable-canvas-opacity-option-label{padding-left:10px}.popup-content .drawer-toolbar li.editable-canvas-opacity-option{box-sizing:border-box;margin:0;min-width:100%;padding:0 10px;text-align:right;width:100%}.popup-content li.editable-canvas-opacity-option .editable-canvas-opacity-option-input{float:right}.popup-content .drawer-toolbar li.editable-canvas-opacity-option .editable-canvas-opacity-option-indicator{float:none;text-align:left}.toolbar-button .fa.fa-arrows-h,.toolbar-button .fa.fa-long-arrow-right{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);-moz-transform:rotate(-45deg);transform:rotate(-45deg)}.editable-canvas-line-width .toolbar-item-description{display:inline-block}.editable-canvas-line-width input.editable-canvas-line-width-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.editable-canvas-line-width .editable-canvas-line-width-label{padding-left:10px}span.toolbar-label.editable-canvas-line-width-indicator{display:inline-block;margin-right:5px;width:50px}button.stop-polygon{background:#fff;border:1px solid #e2e2e2;box-shadow:0 0 5px rgba(0,0,0,.1);padding:6px 15px;position:absolute;right:0;top:0;z-index:1000}.editable-canvas-shape-context-menu{background:hsla(0,0%,100%,.98);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:16px;box-shadow:0 12px 48px rgba(122,77,217,.2),0 4px 16px rgba(0,0,0,.1);height:auto!important;overflow:hidden;padding:8px;position:absolute;text-align:left;width:200px;z-index:99999}.editable-canvas-shape-context-menu li a{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.editable-canvas-shape-context-menu li{list-style-type:none;width:100%}.editable-canvas-shape-context-menu li a{border-radius:10px;cursor:pointer;display:inline-block;margin:0;padding:10px 16px;text-align:left;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.editable-canvas-shape-context-menu li a:hover{background:var(--easel-color-primary,#a277ff);color:var(--easel-color-surface,#fff);text-decoration:none;transform:translateX(4px)}.editable-canvas-text-option{box-sizing:border-box;display:flex;flex-direction:column;gap:10px;padding-left:10px;padding-right:10px;width:100%}.editable-canvas-text-option select{margin:7px auto;width:100%}.editable-canvas-text-option .toolbar-item-description{align-items:center;display:flex;flex-wrap:wrap;gap:8px;justify-content:space-between;width:100%}.editable-canvas-text-option .toolbar-dropdown-block{display:block;overflow:visible;position:relative;width:100%}.editable-canvas-text-option .toolbar-combobox-wrapper{width:100%}.editable-canvas-text-option .toolbar-combobox-wrapper .dropdown-box{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-shadow:0 16px 32px rgba(15,23,42,.22);left:0;max-height:260px;min-width:100%;overflow-y:auto;padding:10px 0;position:absolute;right:0;top:calc(100% + 8px);z-index:30}.editable-canvas-text-option .toolbar-combobox-wrapper .dropdown-box.collapsed,.editable-canvas-text-option .toolbar-combobox-wrapper.collapsed .dropdown-box{display:none}.editable-canvas-text-option .toolbar-combobox-wrapper .option-list{max-height:220px;overflow-y:auto}ul.drawer-toolbar li.editable-canvas-fontfamily{cursor:pointer;height:auto;position:relative;width:100%}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#e3d8ff);border-radius:12px;box-shadow:0 16px 32px rgba(15,23,42,.22);box-sizing:border-box;left:0;max-height:260px;max-width:100%;overflow-y:auto;padding:8px;position:absolute;right:auto;top:calc(100% + 8px);width:min(320px,calc(100% + 40px));z-index:40}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown li{background:transparent;display:block;height:auto;text-align:left;width:100%}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown li a{border-radius:8px;color:var(--easel-color-text,#2d1b4e);display:block;padding:6px 10px;text-decoration:none;transition:all .2s cubic-bezier(.4,0,.2,1)}ul.drawer-toolbar li.editable-canvas-fontfamily .fonts-dropdown li a:hover{background:var(--easel-color-primary-light,#d6c6ff);color:var(--easel-color-primary-dark,#7c4ed9)}ul.drawer-toolbar.toolbar-topRight li.editable-canvas-fontfamily .fonts-dropdown{left:auto;right:0}.editable-canvas-color-button .color-input-wrapper{align-items:center;display:flex;gap:12px;position:relative;width:100%}.editable-canvas-color-button .html5-color-input{background:var(--easel-color-surface,#fff);border:none;border-radius:12px;box-shadow:inset 0 0 0 1px rgba(45,27,78,.12);cursor:pointer;flex:1;height:40px;outline:none;padding:0;transition:all .2s cubic-bezier(.4,0,.2,1);width:100%}.editable-canvas-color-button .html5-color-input::-webkit-color-swatch-wrapper{border-radius:12px;padding:0}.editable-canvas-color-button .html5-color-input::-moz-color-swatch,.editable-canvas-color-button .html5-color-input::-webkit-color-swatch{border:none;border-radius:10px}.editable-canvas-color-button .html5-color-input:focus,.editable-canvas-color-button .html5-color-input:hover{box-shadow:inset 0 0 0 2px var(--easel-color-primary,#a277ff)}.editable-canvas-color-button .color-indicator{display:none}.colorpicker-control .color-dropdown{padding:5px;position:absolute}li.colorpicker-control{padding-left:10px!important;width:auto!important}.colorpicker-control span.color-indicator{background-color:var(--easel-color-surface,#fff);display:inline-block;height:32px;position:relative;top:0;width:32px}.colorpicker-control .color-swatch{border:1px solid var(--easel-color-surface,#fff);box-sizing:border-box;float:left;height:32px;margin:0;padding:0;width:32px}.colorpicker-control .color-swatch.transparent{background-color:var(--easel-color-surface,#fff);margin:0;text-align:center;width:100%}.control-hidden{visibility:hidden!important}.toolbar-colorpicker-dropdown{display:none}.color-dropdown.palette-with-scroll{display:block}.popup-content-wrapper .popup-content li.colorpicker-control{min-width:50%}.popup-content-wrapper .popup-content li.colorpicker-control.editable-canvas-text-option{height:40px;line-height:40px!important;min-width:177px}.popup-content-wrapper .popup-content li.colorpicker-control span.color-indicator{float:right;right:8px}.popup-content-wrapper .popup-content li.colorpicker-control.editable-canvas-text-option span.color-indicator{float:right;right:1px;top:4px}.popup-content-wrapper .popup-content .color-dropdown{background:var(--easel-color-surface,#fff);border:1px solid var(--easel-color-border,#ccc);overflow:auto}.popup-content-wrapper .popup-content .color-dropdown:not([data-position]){-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;width:365px}.popup-content-wrapper .popup-content[data-position=top] .color-dropdown,.toolbar-placeholder-bottom .color-dropdown{bottom:100%;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-wrap:wrap-reverse;-ms-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;left:0;max-width:365px}.popup-content-wrapper .popup-content[data-position=bottom] .color-dropdown,.toolbar-placeholder-top .color-dropdown{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;left:0;max-width:375px;top:100%}.popup-content-wrapper .popup-content[data-position=right] .color-dropdown,.toolbar-placeholder-left .color-dropdown{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;left:100%;max-height:375px;top:0}.popup-content-wrapper .popup-content[data-position=left] .color-dropdown,.toolbar-placeholder-right .color-dropdown{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-flex-wrap:wrap-reverse;-ms-flex-wrap:wrap-reverse;flex-wrap:wrap-reverse;max-height:375px;padding-bottom:14px;right:100%;top:0}li.editable-canvas-color-redactor{padding-left:10px!important;width:auto!important}li.editable-canvas-color-redactor span.color-dropdown{left:0;position:absolute;top:30px;width:290px}li.editable-canvas-color-redactor span.color-indicator{background-color:var(--easel-color-surface,#fff);display:inline-block;height:32px;position:relative;top:0;width:32px}.toolbar-topRight li.editable-canvas-color-redactor span.color-dropdown{left:auto;right:0}ul.drawer-toolbar li.editable-canvas-opacity-label{padding-left:3px;padding-right:3px;width:auto}ul.drawer-toolbar li.editable-canvas-opacity{margin-left:10px;margin-right:10px;width:auto}.opacity-indicator{background:linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc),linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc);background-position:0 0,4px 4px;background-size:8px 8px;border:2px solid var(--easel-color-border,#e3d8ff);border-radius:10px;box-shadow:inset 0 2px 4px rgba(0,0,0,.1);display:inline-block;height:28px;margin:0 8px;vertical-align:middle;width:28px}li.editable-canvas-opacity .editable-canvas-opacity-input{display:inline-block;margin-left:7px;margin-right:7px;position:relative;right:0;vertical-align:top;width:100px}.popup-content .drawer-toolbar li.editable-canvas-opacity{box-sizing:border-box;margin:0;min-width:100%;padding:0 10px;text-align:right;width:100%}.popup-content li.editable-canvas-opacity .editable-canvas-opacity-input{float:right}.popup-content .drawer-toolbar li.editable-canvas-opacity .editable-canvas-opacity-indicator{float:none;text-align:left}:root{--easel-color-primary:#a277ff;--easel-color-primary-dark:#7c4ed9;--easel-color-primary-light:#d6c6ff;--easel-color-accent:#c594ff;--easel-color-surface:#fff;--easel-color-surface-muted:#faf8ff;--easel-color-border:#e3d8ff;--easel-color-border-strong:#cbb6ff;--easel-color-text:#2d1b4e;--easel-color-text-muted:#6d5c88;--easel-color-danger:#d45a78;--drawer-shadow-soft:0px 14px 40px rgba(122,77,217,.15)}body{background:var(--easel-color-surface-muted,#f7f3ff);color:var(--easel-color-text,#2d1b4e);font-family:Arial,sans-serif;overflow:scroll!important}.hidden{display:none!important;visibility:hidden!important}#easel-canvas-box .sp-replacer{height:32px;margin:0;padding:0;width:32px}#easel-canvas-box .sp-preview{height:100%;margin:0;padding:0;width:100%}#easel-canvas-box .sp-preview-inner{height:100%;width:100%}#easel-canvas-box .sp-dd{display:none}#redactor-drawer-box{background:var(--easel-color-surface-muted,transparent);box-sizing:content-box;color:inherit;outline:none;top:35px;transition:none;vertical-align:middle}#easel-canvas-box.animated{transition:height .5s ease-out,width .5s ease-out 0s,left .5s ease-out 0s,top .5s ease-out 0s}body.easel-moving #easel-canvas-box.easel-instance-container,body.easel-moving #easel-canvas-box.easel-instance-container .canvas-container,body.easel-resizing #easel-canvas-box.easel-instance-container,body.easel-resizing #easel-canvas-box.easel-instance-container .canvas-container{transition:none}body.drawer-zoom-moving,body.drawer-zoom-moving *{cursor:-webkit-grabbing!important;cursor:grabbing!important}body.drawer-moving,body.drawer-moving *{cursor:move!important}body.drawer-resizing,body.drawer-resizing *{cursor:nwse-resize!important}.drawer-floating-control{pointer-events:auto;z-index:400}.drawer-floating-control.text-edit-corner{cursor:pointer}#easel-canvas-box .canvas-container{box-shadow:var(--drawer-shadow-soft,0 0 50px rgba(0,0,0,.03));margin:0;overflow:hidden;position:relative;transition:none;z-index:200}#easel-canvas-box.animated .canvas-container{transition:height .5s ease-out,width .5s ease-out 0s,left .5s ease-out 0s,top .5s ease-out 0s}#easel-canvas-box .canvas-container canvas{background:transparent}.noselect{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#redactor-drawer-properties .drawer-properties-height,#redactor-drawer-properties .drawer-properties-width{text-align:center;width:45%}#redactor-drawer-properties .size-separator{display:inline-block;text-align:center;width:10%}#easel-canvas-box{font-family:Arial,sans-serif}.redactor-editor .btn-group ul{background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.1);left:-2px;padding:0;position:absolute;top:30px}.editable-canvas-image{opacity:1}.editable-canvas-image.edit-mode{opacity:0}#redactor-modal,#redactor-modal-box,#redactor-modal-overlay{z-index:1100!important}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/instances/CropImageToolbar.js\"))","module.exports = \"(function (global) {\\n  'use strict';\\n\\n  /**\\n   * Path created by eraser brush.\\n   */\\n  fabric.EraserPath = fabric.util.createClass(fabric.Path, {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'EraserPath',\\n\\n    // to avoid issue in fabric.js with clipping of cached objects [bounding rect do not include brush size]\\n    objectCaching : false,\\n    evented : false,\\n    selectable : false,\\n\\n    initialize: function (path, options) {\\n      options = options || {};\\n\\n      this.polygonOffsetX = options.polygonOffsetX || null;\\n      this.polygonOffsetY = options.polygonOffsetY || null;\\n\\n      this.callSuper('initialize', path, options);\\n    },\\n\\n    /**\\n     * Returns string representation of an instance\\n     * @return {String} string representation of an instance\\n     */\\n    toString: function () {\\n      return '#<fabric.EraserPath (' + this.complexity() +\\n        '): { \\\"top\\\": ' + this.top + ', \\\"left\\\": ' + this.left + ' }>';\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function (propertiesToInclude) {\\n      var o = fabric.util.object.extend(\\n        this.callSuper('toObject', propertiesToInclude), {\\n          path: this.path.map(function (item) {\\n            return item.slice();\\n          }),\\n          pathOffset: this.pathOffset\\n        });\\n      if (this.sourcePath) {\\n        o.sourcePath = this.sourcePath;\\n      }\\n      if (this.transformMatrix) {\\n        o.transformMatrix = this.transformMatrix;\\n      }\\n\\n      if(this.polygonOffsetX && this.polygonOffsetY){\\n        o.polygonOffsetX = this.polygonOffsetX;\\n        o.polygonOffsetY = this.polygonOffsetY;\\n      }\\n\\n      return o;\\n    }\\n  });\\n\\n  fabric.EraserPath.fromObject = function (object, callback) {\\n    if (typeof object.path === 'string') {\\n      fabric.loadSVGFromURL(object.path, function (elements) {\\n        var path = elements[0],\\n          pathUrl = object.path;\\n\\n        delete object.path;\\n\\n        fabric.util.object.extend(path, object);\\n        path.setSourcePath(pathUrl);\\n\\n        callback(path);\\n      });\\n    }\\n    else {\\n      callback(new fabric.EraserPath(object.path, object));\\n    }\\n  };\\n\\n  /**\\n   * Indicates that instances of this type are async\\n   * @static\\n   * @memberOf fabric.Path\\n   * @type Boolean\\n   * @default\\n   */\\n  fabric.EraserPath.async = true;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-shape-contextmenu/ShapeContextMenu.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-rectangle/Rectangle.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/BaseOptionTool.js\"))","module.exports = \"(function ($, pluginsNamespace) {\\n  'use strict';\\n\\n  /**\\n   * Provides a modal popup for controlling canvas properties\\n   * like width,height, and aligment.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * @param {Object} options\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var CanvasProperties = function CanvasPropertiesConstructor(drawerInstance, options) {\\n    var _this = this;\\n    if (!drawerInstance.redactorInstance) {\\n      console.error(\\\"'CanvasProperties' plugin can work only in redactor mode!\\\");\\n      return;\\n    }\\n\\n    this.drawerInstance = drawerInstance;\\n    this.drawer = drawerInstance;\\n    this.name = 'EaselPluginCanvasProperties';\\n    this.LOGTAG = _this.name;\\n\\n    this._setupOptions(options);\\n\\n    _this.drawerInstance.on(_this.drawerInstance.EVENT_CONFIG_TOOLBAR_CREATED,\\n      function (event, toolbar) {\\n        var redactorInstance = _this.drawerInstance.redactorInstance;\\n\\n        var modalTemplate = '' +\\n          '<section id=\\\"redactor-drawer-properties\\\">' +\\n            '<label class=\\\"drawer-properties-size-label\\\">' +\\n              drawerInstance.t('Size (px)') +\\n            '</label>' +\\n            '<input class=\\\"drawer-properties-width\\\" type=\\\"number\\\" ' +\\n                   'value=\\\"' + drawerInstance.width + '\\\" />' +\\n            '<span class=\\\"size-separator\\\">x</span>' +\\n            '<input class=\\\"drawer-properties-height\\\" type=\\\"number\\\" ' +\\n                   'value=\\\"' + drawerInstance.height + '\\\"/>' +\\n            '<label class=\\\"drawer-properties-align-label\\\">' +\\n              drawerInstance.t('Position') +\\n            '</label>' +\\n            '<select class=\\\"drawer-properties-align\\\">' +\\n              '<option value=\\\"inline\\\">' +\\n                drawerInstance.t('Inline') +\\n              '</option>' +\\n              '<option value=\\\"left\\\">' +\\n                drawerInstance.t('Left') +\\n              '</option>' +\\n              '<option value=\\\"center\\\">' +\\n                drawerInstance.t('Center') +\\n              '</option>' +\\n              '<option value=\\\"right\\\">' +\\n                drawerInstance.t('Right') +\\n              '</option>' +\\n              '<option value=\\\"floating\\\">' +\\n                drawerInstance.t('Floating') +\\n              '</option>' +\\n            '</select>' +\\n            '<span class=\\\"group-transparency\\\">' +\\n              '<label class=\\\"drawer-properties-background\\\">' +\\n                drawerInstance.t('Background') +\\n              '</label>' +\\n              '<input type=\\\"checkbox\\\" id=\\\"background-transparency\\\" ' +\\n                     'class=\\\"background-transparency\\\"/>' +\\n              '<label for=\\\"background-transparency\\\" ' +\\n                     'class=\\\"background-transparency\\\">' +\\n                drawerInstance.t('transparent') +\\n              '</label>'+\\n            '</span>' +\\n          '</section>';\\n\\n        redactorInstance.modal.addTemplate('drawer-properties', modalTemplate);\\n\\n        var clickHandler = function canvasPropsClickHandler() {\\n              _this.openPopup();\\n              return false;\\n            },\\n            buttonConfig = {\\n              buttonOrder: 9,\\n              additionalClass: 'btn-canvas-properties',\\n              iconClass: 'fa-cog',\\n              tooltipText: drawerInstance.t('Canvas properties'),\\n              clickHandler: clickHandler\\n            };\\n        toolbar.addButton(buttonConfig);\\n      });\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  CanvasProperties.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  CanvasProperties.prototype.openPopup = function () {\\n    var _this = this;\\n\\n    var redactorInstance = _this.drawerInstance.redactorInstance;\\n    var drawerInstance = _this.drawerInstance;\\n    var $image = _this.drawerInstance.$imageElement;\\n\\n    redactorInstance.modal.load(\\n      'drawer-properties', drawerInstance.t('Canvas properties'), 260\\n    );\\n\\n    redactorInstance.modal.createCancelButton();\\n    $('.redactor-modal-close-btn').html(drawerInstance.t('Cancel'));\\n    var button = redactorInstance.modal.createActionButton(\\n      drawerInstance.t('Save'));\\n\\n    var $properties = $('#redactor-drawer-properties');\\n\\n    var currentAlign = drawerInstance.getAlign();\\n\\n    $properties.find('select').val(currentAlign);\\n    $properties.find('.drawer-properties-width').val(drawerInstance.width);\\n    $properties.find('.drawer-properties-height').val(drawerInstance.height);\\n\\n    _this.currentAlign = currentAlign;\\n    _this.currentHeight = drawerInstance.height;\\n    _this.currentWidth = drawerInstance.width;\\n\\n    // transparency checkbox var\\n    _this.$backgroundTransparencyInput =\\n      $properties.find('input.background-transparency');\\n    // set it\\n    _this.$backgroundTransparencyInput.attr('checked', drawerInstance.options.transparentBackground);\\n\\n    // transparency checkbox click handler\\n    $properties.find('.background-transparency').click(function () {\\n      var checked = _this.$backgroundTransparencyInput.attr('checked');\\n      _this.$backgroundTransparencyInput.attr('checked', !checked);\\n    });\\n\\n    button.on('click', function () {\\n      _this.saveProperties();\\n    });\\n\\n    var $alignControl = $properties.find('.drawer-properties-align');\\n\\n    function updateTransparencyVisible() {\\n      var selectedAlign = $properties.find('.drawer-properties-align').val();\\n      if(selectedAlign == 'floating') {\\n        $properties.find('.group-transparency').show();\\n      } else {\\n        $properties.find('.group-transparency').hide();\\n      }\\n    }\\n\\n    updateTransparencyVisible();\\n\\n    $alignControl.change(function () {\\n      updateTransparencyVisible();\\n    });\\n\\n    redactorInstance.modal.show();\\n\\n    // restore body overflow immediately to avoid content jumping\\n    // Jumping happens because with overflow:hidden page has no scrollbar\\n    // and its size extends by 24px\\n    $(document.body)\\n      .css('overflow', redactorInstance.modal.bodyOveflow);\\n  };\\n\\n  CanvasProperties.prototype.saveProperties = function () {\\n    var _this = this;\\n\\n    var redactorInstance = _this.drawerInstance.redactorInstance;\\n    var drawerInstance = _this.drawerInstance;\\n\\n    var fullscreenPlugin =\\n      _this.drawerInstance.getPluginInstance('Fullscreen');\\n\\n    var modal = $('#redactor-drawer-properties');\\n    var width = modal.find('input.drawer-properties-width').val();\\n    var height = modal.find('input.drawer-properties-height').val();\\n    var align = modal\\n      .find('select.drawer-properties-align option:selected')\\n      .val();\\n\\n    if(_this.currentWidth != width || _this.currentHeight != height){\\n      if(fullscreenPlugin && fullscreenPlugin.isInFullscreenMode()){\\n        fullscreenPlugin.exitFullscreen();\\n      }\\n\\n      drawerInstance.setSize(width, height);\\n    }\\n\\n    drawerInstance.options.align = align;\\n    if(_this.currentAlign != align){\\n      if(fullscreenPlugin && fullscreenPlugin.isInFullscreenMode()){\\n        fullscreenPlugin.exitFullscreen();\\n      }\\n\\n      drawerInstance.setAlign(align);\\n    }\\n\\n    var transparent = _this.$backgroundTransparencyInput.attr('checked');\\n    drawerInstance.options.transparentBackground = !!transparent;\\n\\n    redactorInstance.modal.close();\\n    drawerInstance.onCanvasModified();\\n\\n    drawerInstance.trigger(drawerInstance.EVENT_OPTIONS_CHANGED);\\n  };\\n\\n  pluginsNamespace.CanvasProperties = CanvasProperties;\\n}(jQuery, Easel.plugins));\"","module.exports = \"(function (Easel) {\\n  /**\\n   * This event is triggered every time user clicks on canvas to edit it.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_EDIT_START = 'editStart';\\n  /**\\n   * This event is triggered every time user stops editing canvas.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_EDIT_STOP = 'editStop';\\n  /**\\n   * This event is triggered when canvas is deserialized\\n   * from image's attributes.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_LOADED_FROM_JSON = 'loadedFromJson';\\n  /**\\n   * This event is triggered when canvas is deserialized, and is ready to work.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_CANVAS_READY = 'ready';\\n  /**\\n   * This event is triggered after canvas resizing starts\\n   * from image's attributes.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_CANVAS_START_RESIZE = 'canvas:resize:start';\\n\\n  /**\\n   * This event is triggered after canvas resizing starts\\n   * from image's attributes.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_BEFORE_RENDER = 'before:render';\\n\\n\\n  /**\\n   * This event is triggered after canvas resizing starts\\n   * from image's attributes.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_AFTER_RENDER = 'after:render';\\n  /**\\n   * This event is triggered in process of canvas resize\\n   * from image's attributes.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_CANVAS_RESIZING = 'canvas:resize:resizing';\\n  /**\\n   * This event is triggered after canvas resize stopped\\n   * from image's attributes.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_CANVAS_STOP_RESIZE = 'canvas:resize:stop';\\n  /**\\n   * This event is triggered every time user changes a brush size.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_BRUSH_SIZE_CHANGED = 'brushSizeChanged';\\n  /**\\n   * This event is triggered every time user selects a tool that changes\\n   * free drawing brush.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_BRUSH_CHANGED = 'brushChanged';\\n\\n  /**\\n   * Triggering this event will cause tool based on BaseTool to activate\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_DO_ACTIVATE_TOOL = 'activateTool';\\n  /**\\n   * Triggering this event will cause tool based on BaseTool to deactivate\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_DO_DEACTIVATE_TOOL = 'deactivateTool';\\n  /**\\n   * Triggering this event will cause to all tools based on BaseTool to deactivate.\\n   * This event is part of lifecycle of EVENT_DO_ACTIVATE_TOOL,\\n   * and is triggered every time after tool reacts on EVENT_DO_ACTIVATE_TOOL\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_DO_DEACTIVATE_ALL_TOOLS = 'deactivateAllTools';\\n\\n  /**\\n   * Event emitted, when options have changed.\\n   * In most cases - if user opened used 'CanvasProperties' plugin.\\n   * @type {String}\\n   */\\n  Easel.prototype.EVENT_OPTIONS_CHANGED = 'options.changed';\\n  /**\\n   * This event is triggered when user removes canvas from page.\\n   * @type {string}\\n   */\\n  Easel.prototype.EVENT_DESTROY = 'destroy';\\n\\n\\n  Easel.prototype.EVENT_TOOL_ACTIVATED = 'toolActivated';\\n\\n  Easel.prototype.EVENT_TOOL_DEACTIVATED = 'toolDeactivated';\\n\\n  Easel.prototype.EVENT_TOOLS_TOOLBAR_CREATED = 'toolsToolbarCreated';\\n\\n  /**\\n   * This event is triggered when options toolbar is created and provides a way\\n   * to add buttons to it.\\n   * The second argument for this event is {EaselToolbar} and can be used\\n   * to manipulate with t.\\n   *\\n   * @type {string}\\n   */\\n\\n  Easel.prototype.BEFORE_CREATE_TOOLBARS ='beforeCreateToolbars';\\n\\n  Easel.prototype.AFTER_CREATE_TOOLBARS ='afterCreateToolbars';\\n\\n  Easel.prototype.EVENT_OPTIONS_TOOLBAR_CREATED ='optionsToolbarCreated';\\n\\n  Easel.prototype.EVENT_CONFIG_TOOLBAR_CREATED = 'configToolbarCreated';\\n\\n  Easel.prototype.EVENT_IMAGECROP_TOOLBAR_CREATED = 'imageCropToolbarCreated';\\n\\n  Easel.prototype.EVENT_FLOATING_TOOLBAR_CREATED = 'floatingToolbarCreated';\\n\\n  Easel.prototype.EVENT_MINIMIZED_TOOLBAR_CREATED = 'minimizedToolbarCreated';\\n\\n  Easel.prototype.EVENT_TOOLBAR_DESTROYED = 'toolbarDestroyed';\\n\\n  Easel.prototype.EVENT_TOOLBAR_CHANGE_STATE = 'toolbarChangeState';\\n\\n  Easel.prototype.EVENT_TOOLBAR_CLEAR_STATE = 'toolbarClearState';\\n\\n  Easel.prototype.EVENT_TOOLBAR_STATE_HIDDEN_OFF = 'toolbarShow';\\n\\n  Easel.prototype.EVENT_TOOLBAR_STATE_HIDDEN_ON = 'toolbarHide';\\n\\n  Easel.prototype.EVENT_TOOLBAR_STATE_OVERLAY_ON = 'toolbarOverlayShow';\\n\\n  Easel.prototype.EVENT_TOOLBAR_STATE_OVERLAY_OFF = 'toolbarOverlayHide';\\n\\n  Easel.prototype.EVENT_TOOLBAR_STATE_DISABLED_ON = 'toolbarDisableOn';\\n\\n  Easel.prototype.EVENT_TOOLBAR_STATE_DISABLED_OFF = 'toolbarDisableOff';\\n\\n  Easel.prototype.EVENT_RESTORE_DEFAULT_ZOOM = 'restoreDefaultZoom';\\n\\n  Easel.prototype.EVENT_CONTEXTMENU = 'contextmenu';\\n\\n  Easel.prototype.EVENT_KEYDOWN = 'keydown';\\n\\n  Easel.prototype.EVENT_BEFORE_SHAPE_ADD = 'beforeShapeAdd';\\n\\n  Easel.prototype.EVENT_AFTER_SHAPE_ADD = 'afterShapeAdd';\\n\\n  Easel.prototype.EVENT_ZOOM_SET = 'EVENT_ZOOM_SET';\\n\\n  Easel.prototype.EVENT_ZOOM_UNSET = 'EVENT_ZOOM_UNSET';\\n\\n  Easel.prototype.EVENT_ZOOM_UPPER_SET = 'EVENT_ZOOM_UPPER_SET';\\n\\n  Easel.prototype.EVENT_ZOOM_UPPER_UNSET = 'EVENT_ZOOM_UPPER_UNSET';\\n\\n  Easel.prototype.EVENT_ZOOM_UPPER_RESTORE = 'EVENT_ZOOM_UPPER_RESTORE';\\n\\n  Easel.prototype.EVENT_ZOOM_RESTORE = 'EVENT_ZOOM_RESTORE';\\n\\n\\n  Easel.prototype.EVENT_ZOOM_CHANGE = 'zoomChange';\\n\\n  Easel.prototype.EVENT_CANVAS_MODIFIED = 'canvasModified';\\n\\n  Easel.prototype.EVENT_OBJECT_ADDED = 'objectAdded';\\n\\n  Easel.prototype.EVENT_OBJECT_SELECTED = 'objectSelected';\\n\\n  Easel.prototype.EVENT_OBJECT_MOVING = 'objectMoving';\\n\\n  Easel.prototype.EVENT_SELECTION_CLEARED = 'selectionCleared';\\n\\n  Easel.prototype.EVENT_TEXT_SELECTION_CHANGED = 'textSelectionChanged';\\n\\n  Easel.prototype.EVENT_TEXT_EDITING_ENTERED = 'textEditingEntered';\\n\\n  Easel.prototype.EVENT_TEXT_EDITING_EXITED = 'textEditingExited';\\n\\n  Easel.prototype.EVENT_TEXT_STYLES_CHANGED = 'textStylesChanged';\\n\\n  Easel.prototype.EVENT_TEXT_GET_STYLES = 'textGetStyles';\\n\\n  Easel.prototype.EVENT_OVERCANVAS_POPUP_SHOW = 'overcanvasPopupShow';\\n\\n  Easel.prototype.EVENT_OVERCANVAS_POPUP_HIDE = 'overcanvasPopupHide';\\n\\n  Easel.prototype.EVENT_OVERCANVAS_BUTTON_SHOW = 'overcanvasButtonShow';\\n\\n  Easel.prototype.EVENT_OVERCANVAS_BUTTON_HIDE = 'overcanvasButtonHide';\\n\\n  Easel.prototype.EVENT_IMAGE_CROP = 'initImageCrop';\\n\\n  Easel.prototype.EVENT_RESIZER_HIDE = 'resizerHide';\\n\\n  Easel.prototype.EVENT_RESIZER_SHOW = 'resizerShow';\\n\\n  Easel.prototype.EVENT_CREATE_TOOLTIP = 'createTooltip';\\n\\n  Easel.prototype.EVENT_HIDE_TOOLTIPS = 'hideTooltips';\\n\\n  Easel.prototype.EVENT_DESTROY_TOOLTIPS = 'destroyTooltips';\\n\\n  /**\\n   * Remove event listeners by event name and(or) callback\\n   *\\n   * @param eventName\\n   * @param callback\\n   * @returns {*}\\n   */\\n  Easel.prototype.off = function (eventName, callback) {\\n    return this._eventEmitter.off(eventName, callback);\\n  };\\n\\n  /**\\n   * Add event listener to canvas element events.\\n   *\\n   * @param eventName\\n   * @param callback\\n   */\\n  Easel.prototype.on = function (eventName, callback) {\\n    return this._eventEmitter.on(eventName, callback);\\n  };\\n\\n  /**\\n   * Trigger any canvas event.\\n   *\\n   * @param eventName\\n   * @param [args]\\n   * @returns {*}\\n   */\\n  Easel.prototype.trigger = function (eventName, args) {\\n    var eventResult,\\n        needToLogErors = !this.insideEvent;\\n    try {\\n      this.insideEvent = true;\\n      eventResult = this._eventEmitter.trigger(eventName, args);\\n    } catch(err) {\\n      if (this.options.debug) {\\n        var errorName = 'Catched error - ' + eventName;\\n        console.groupCollapsed(errorName);\\n        this.log('Event name',eventName);\\n        this.log('Arguments', args);\\n        this.error(err);\\n        console.groupEnd(errorName);\\n      }\\n    }\\n    if (needToLogErors) {\\n      this.insideEvent = false;\\n    }\\n    return eventResult;\\n  };\\n})(Easel.Easel);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasableRect.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/ui-plugins/ToolbarComboBox.js\"))","module.exports = \"(function ($, pluginsNamespace, util, EaselApi) {\\n  \\\"use strict\\\";\\n\\n  var isFF = util.checkBrowser('mozilla'),\\n      isSafari = util.checkBrowser('safari'),\\n      isWebkit = util.checkBrowser('webkit'),\\n      emptyFunc = function () {},\\n      isTouchDevice;\\n\\n  /**\\n   * Provides a button to minimize canvas.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * @param {Object} options\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var FullscreenModeButton = function FullscreenModeButtonConstructor(drawer, options) {\\n    /**\\n     * @type {Easel}\\n     */\\n    this.name = 'FullscreenModeButton';\\n    this.drawer = drawer;\\n    isTouchDevice = this.drawer.touchDevice;\\n\\n    this._setupOptions(options);\\n    this._attachEvents();\\n    this._setupFullscreenHandlers();\\n\\n    this.drawer.on(this.drawer.EVENT_CONFIG_TOOLBAR_CREATED, this._onConfigToolbarCreated.bind(this));\\n  };\\n\\n  /**\\n   * Attach global events\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._attachEvents = function () {\\n    var self = this,\\n        eventsList = '' +\\n            'onfullscreenchange.FullscreenModeButton ' +\\n            'webkitfullscreenchange.FullscreenModeButton ' +\\n            'fullscreenchange.FullscreenModeButton '+\\n            'mozfullscreenchange.FullscreenModeButton ' +\\n            'MSFullscreenChange.FullscreenModeButton ';\\n    $(document).off(eventsList).on(eventsList, function () {\\n      self.globalFullscreenMode = !self.globalFullscreenMode;\\n      self.reactOnResize = true;\\n      util.setTimeout(function () {\\n        self.reactOnResize = false;\\n      }, 2000);\\n      if (self.globalFullscreenMode) {\\n        self.setFullscreenStateOn(true);\\n      } else {\\n        self.setFullscreenStateOff(true);\\n      }\\n    });\\n\\n    window.removeEventListener('resize', self._onWindowResize.bind(self));\\n    window.addEventListener('resize', self._onWindowResize.bind(self));\\n\\n    $(document).off('keypress.FullscreenModeButton').on('keypress.FullscreenModeButton', function(e) {\\n      var isFullscreen = (self.globalFullscreenMode && self.fullscreenMode),\\n          isEscKey = e.keyCode == 27,\\n          turnOffFullscreen = isFullscreen && isEscKey;\\n      if (turnOffFullscreen) { // ESC key\\n            self.fullscreenOff(true);\\n      }\\n    });\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  FullscreenModeButton.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * React on window resize\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._onWindowResize = function () {\\n    var self = this;\\n\\n    if (isFF && !self.reactOnResize && !self.globalFullscreenMode) {\\n      self._saveCurrentSizes();\\n    }\\n\\n    if (self.reactOnResize) {\\n      if (!self.globalFullscreenMode) {\\n        self._restoreNormalSizes();\\n      } else {\\n        self._refreshFullscreenSize(false);\\n      }\\n    }\\n\\n\\n\\n    var turnOff = false && !isFF, //global, but not for firefox\\n        ffTurnOff = !self.fullscreenMode && self.reactOnResize && isFF && !self.globalFullscreenMode,\\n        webkitTurnOff = self.fullscreenMode && !self.globalFullscreenMode && isWebkit,\\n        needToTurnOff = turnOff || ffTurnOff || webkitTurnOff;\\n    if (needToTurnOff) {\\n      self.setFullscreenStateOff();\\n    }\\n    self.reactOnResize = false;\\n  };\\n\\n  FullscreenModeButton.prototype._saveCurrentSizes = function (oldWidth, oldHeight) {\\n    if (!oldWidth || !oldHeight) {\\n      // Check if canvasEditContainer exists before accessing it\\n      if (!this.drawer.$canvasEditContainer) {\\n        return;\\n      }\\n      oldWidth = this.drawer.$canvasEditContainer.outerWidth();\\n      oldHeight = this.drawer.$canvasEditContainer.outerHeight();\\n    }\\n\\n    this.savedWidth = oldWidth;\\n    this.savedHeight = oldHeight;\\n  };\\n\\n  /**\\n   * Set drawer size - all available space\\n   * @param {Boolean} [save] - save current size for further restore\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._refreshFullscreenSize = function (save) {\\n    var $window = $(window),\\n        viewportWidth = $window.width(),\\n        viewportHeight = $window.height(),\\n        oldWidth = this.drawer.width,\\n        oldHeight = this.drawer.height,\\n        $editContainer = this.drawer.$canvasEditContainer,\\n        drawerHaveAnimatedClass = $editContainer.hasClass('animated');\\n\\n    if (save) {\\n      this._saveCurrentSizes(oldWidth, oldHeight);\\n    }\\n    $editContainer.removeClass('animated');\\n    this.drawer.setSize(\\n        viewportWidth,\\n        viewportHeight\\n    );\\n    this.drawer.trigger(this.drawer.EVENT_RESTORE_DEFAULT_ZOOM);\\n    $editContainer.toggleClass('animated', !!drawerHaveAnimatedClass);\\n  };\\n\\n  /**\\n   * Restore drawer size\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._restoreNormalSizes = function () {\\n    var self = this,\\n        $editContainer = this.drawer.$canvasEditContainer,\\n        drawerHaveAnimatedClass = $editContainer.hasClass('animated');\\n    $editContainer.removeClass('animated');\\n    $editContainer.css('position', this.savedPosition);\\n    console.info(this.savedWidth,this.savedHeight);\\n    this.drawer.setSize(\\n        this.savedWidth,\\n        this.savedHeight\\n    );\\n    util.setTimeout(function () {\\n      self.drawer.adjustEditContainer();\\n      self.drawer.trigger(self.drawer.EVENT_RESTORE_DEFAULT_ZOOM);\\n      util.setTimeout(function () {\\n        $editContainer.toggleClass('animated', !!drawerHaveAnimatedClass);\\n      },0);\\n    }, 0);\\n  };\\n\\n  /**\\n   * Setup request/cancel handlers depending on browser\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._setupFullscreenHandlers = function () {\\n    var element = document.documentElement,\\n        fullscreenCancelFunc,\\n        fullscreenRequest_defaultFunc = function () {\\n          element.requestFullScreen();\\n        },\\n        fullscreenRequest_default = element.requestFullScreen && fullscreenRequest_defaultFunc,\\n\\n        fullscreenRequest_msFunc = function () {\\n          element.msRequestFullscreen();\\n        },\\n        fullscreenRequest_ms = element.msRequestFullscreen && fullscreenRequest_msFunc,\\n        fullscreenRequest_mozillaFunc = function () {\\n          element.mozRequestFullScreen();\\n        },\\n        fullscreenRequest_mozilla = element.mozRequestFullScreen && fullscreenRequest_mozillaFunc,\\n        fullscreenRequest_webkitFunc = function () {\\n          element.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);\\n        },\\n        fullscreenRequest_webkit = element.webkitRequestFullScreen && fullscreenRequest_webkitFunc;\\n\\n    this.fullscreenRequest =  fullscreenRequest_default ||\\n                              fullscreenRequest_ms ||\\n                              fullscreenRequest_mozilla ||\\n                              fullscreenRequest_webkit ||\\n                              this.setFullscreenStateOn.bind(this);\\n    fullscreenCancelFunc =  document.cancelFullScreen ||\\n                            document.msExitFullscreen ||\\n                            document.mozCancelFullScreen ||\\n                            document.webkitCancelFullScreen ||\\n                            this.setFullscreenStateOff.bind(this);\\n    this.fullscreenCancel = function() {\\n      fullscreenCancelFunc.call(document);\\n    };\\n  };\\n\\n\\n  /**\\n   * React on toolbar created - create tool button.\\n   * @param {fabric.Event} ev\\n   * @param {EaselToolbar} toolbar\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._onConfigToolbarCreated = function (ev, toolbar) {\\n    this.fullscreenEl = this.drawer.$canvasEditContainer.get(0);\\n    this._createAndAddButton(toolbar);\\n  };\\n\\n  /**\\n   * Deletes tool button.\\n   * If  doDeleteToolbarCreationListeners is true - removes listeners of toolbar creation event.\\n   * So, tool will not appear on toolbar next time, when toolbar is created.\\n   *\\n   * @param {boolean} [doDeleteToolbarCreationListeners]\\n   */\\n  FullscreenModeButton.prototype.removeTool = function (doDeleteToolbarCreationListeners) {\\n    if (this.deleteControls) {\\n      this.deleteControls();\\n    }\\n    // stop listening toolbar creation\\n    if (doDeleteToolbarCreationListeners) {\\n      this.drawer.off(this.drawer.EVENT_CONFIG_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n    }\\n  };\\n\\n\\n  /**\\n   * Creates and adds minimize button to toolbar.\\n   * @param  {EaselToolbar} toolbar\\n   */\\n  FullscreenModeButton.prototype._createAndAddButton = function (toolbar) {\\n    var toggleModeButtonConfig = {\\n          buttonOrder: 10,\\n          additionalClass: 'btn-fullscreen-canvas',\\n          iconClass: 'fa-window-restore',\\n          tooltipText: this.drawer.t('Toggle fullscreen mode'),\\n          clickHandler: this._onFullscreenModeButtonClick.bind(this)\\n        },\\n        $fullscreenModeButton = toolbar.addButton(toggleModeButtonConfig);\\n    this.$fullscreenModeButton = $fullscreenModeButton;\\n  };\\n\\n  /**\\n   * Toggle fullscreen state\\n   * @param {Boolean} [forceCancel]\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._toggleFullScreen = function (forceCancel) {\\n    var currStateIsFullscreen_default = (document.fullScreenElement && document.fullScreenElement !== null),\\n        currStateIsFullscreen_moz = (!document.mozFullScreen && !document.webkitIsFullScreen),\\n        currStateIsFullscreen = currStateIsFullscreen_default || currStateIsFullscreen_moz,\\n        turnOn = forceCancel === false || (!forceCancel && currStateIsFullscreen);\\n    if (turnOn) {\\n      this.fullscreenRequest();\\n    } else {\\n      this.fullscreenCancel();\\n    }\\n  };\\n\\n  /**\\n   * On minimize button click handler\\n   * @private\\n   */\\n  FullscreenModeButton.prototype._onFullscreenModeButtonClick = function () {\\n    if (this.fullscreenMode) {\\n      this.fullscreenOff();\\n    } else {\\n      this.fullscreenOn();\\n    }\\n  };\\n\\n  /**\\n   * Easel - remove fullscreen state\\n   */\\n  FullscreenModeButton.prototype.setFullscreenStateOff = function () {\\n    var canvasContainerIsValid = this.drawer.$canvasEditContainer || this.drawer.$canvasEditContainer.length,\\n        currStateIsValid = canvasContainerIsValid;\\n    this.changeStateInProgress = true;\\n    if (currStateIsValid) {\\n      this.drawer.trigger(this.drawer.EVENT_DO_DEACTIVATE_ALL_TOOLS);\\n      this.drawer.trigger(this.drawer.EVENT_DESTROY_TOOLTIPS);\\n      var self = this,\\n          $editContainer = this.drawer.$canvasEditContainer,\\n          drawerHaveAnimatedClass = $editContainer.hasClass('animated');\\n\\n      this.fullscreenMode = false;\\n      this.drawer.fullscreenMode = false;\\n      $editContainer.addClass('fullscreen-in-progress');\\n      $editContainer.removeClass('animated');\\n      $editContainer.removeClass('fullscreen');\\n\\n      this.drawer.$imageElement.show();\\n      this._restoreNormalSizes();\\n\\n      util.setTimeout(function () {\\n        self.drawer.toolbars.resetAllToolbars();\\n        if (self.$fullscreenModeButton) {\\n          self.$fullscreenModeButton.removeClass('active');\\n        }\\n        if (isSafari) {\\n          self._restoreNormalSizes();\\n        }\\n        $editContainer.toggleClass('animated', !!drawerHaveAnimatedClass);\\n        $editContainer.removeClass('fullscreen-in-progress');\\n        self.changeStateInProgress = false;\\n      }, 0);\\n    }\\n  };\\n\\n  /**\\n   * Easel - set fullscreen state\\n   */\\n  FullscreenModeButton.prototype.setFullscreenStateOn = function () {\\n    this.changeStateInProgress = true;\\n    var canvasContainerIsValid = this.drawer.$canvasEditContainer || this.drawer.$canvasEditContainer.length,\\n        currStateIsValid = canvasContainerIsValid;\\n    if (currStateIsValid) {\\n      this.drawer.trigger(this.drawer.EVENT_DO_DEACTIVATE_ALL_TOOLS);\\n      this.drawer.trigger(this.drawer.EVENT_DESTROY_TOOLTIPS);\\n      var self = this,\\n          $editContainer = this.drawer.$canvasEditContainer,\\n          drawerHaveAnimatedClass = $editContainer.hasClass('animated');\\n\\n      this.fullscreenMode = true;\\n      this.drawer.fullscreenMode = true;\\n      this.savedPosition = $editContainer.css('position');\\n\\n      $editContainer.addClass('fullscreen-in-progress');\\n      $editContainer.removeClass('animated');\\n      $editContainer.addClass('fullscreen');\\n      this.drawer.$imageElement.hide();\\n\\n      self._refreshFullscreenSize(!isFF);\\n\\n      util.setTimeout(function () {\\n        self.drawer.toolbars.resetAllToolbars();\\n        self.drawer.toolbars.settingsToolbar.$toolbar.parent().addClass('fullscreenOverOther');\\n        if (self.$fullscreenModeButton) {\\n          self.$fullscreenModeButton.addClass('active');\\n        }\\n        $editContainer.toggleClass('animated', !!drawerHaveAnimatedClass);\\n        $editContainer.removeClass('fullscreen-in-progress');\\n        self.changeStateInProgress = false;\\n      }, 50);\\n    }\\n  };\\n\\n  /**\\n   * Turn fullscreen mode on\\n   */\\n  FullscreenModeButton.prototype.fullscreenOn = function () {\\n    this._toggleFullScreen(false);\\n  };\\n\\n  /**\\n   * Turn fullscreen mode off\\n   */\\n  FullscreenModeButton.prototype.fullscreenOff = function () {\\n    this._toggleFullScreen(true);\\n  };\\n\\n  /**\\n   * Provide API method - fullscreenOn\\n   */\\n  EaselApi.prototype.fullscreenOn = function () {\\n    var tool = this.drawer.getPluginInstance('FullscreenModeButton');\\n    tool.fullscreenOn();\\n  };\\n\\n  /**\\n   * Provide API method - fullscreenOff\\n   */\\n  EaselApi.prototype.fullscreenOff = function () {\\n    var tool = this.drawer.getPluginInstance('FullscreenModeButton');\\n    tool.fullscreenOff();\\n  };\\n\\n  pluginsNamespace.FullscreenModeButton = FullscreenModeButton;\\n})(jQuery, Easel.plugins, Easel.util, Easel.EaselApi);\"","module.exports = \"(function ($, BaseBrush, pluginsNamespace, util) {\\n  'use strict';\\n\\n  /**\\n   * Provides a pencil button which activates free drawing mode.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {String} options.cursorUrl\\n   * Custom CSS url for pencil cursor.\\n   *\\n   * 'pencil' value could be specified: in this case built-in\\n   * pencil cursor will be user which is located in\\n   * <code>assets/cursor-fa-pencil.cur</code>\\n   *\\n   * Example:\\n   * <code><pre>url(path/to/cursor.cur), default</pre></code>\\n   *\\n   * Note the word 'default' at the end: that is the name of cursor that will\\n   * be used when url is unavailable.\\n   *\\n   * More information about css cursor property could be found here:\\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}\\n   *\\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}\\n   *\\n   * @param {Number} options.brushSize\\n   * Default brush size.\\n   *\\n   * @memberof Easel.plugins\\n   *\\n   * @constructor\\n   * @augments Easel.plugins.BaseBrush\\n   */\\n  var Pencil = function (drawerInstance, options) {\\n    var _this = this;\\n\\n    BaseBrush.call(_this, drawerInstance);\\n\\n    this.name = 'Pencil';\\n\\n    /**\\n     * List of tool options to show when tool is activated.\\n     * Deviating from BaseShape tool, Line has no 'color', only 'border'.\\n     * @type {String[]}\\n     */\\n    this.toolOptionsList = ['color', 'opacity', 'brushSize'];\\n\\n    this.btnClass = 'btn-pencil';\\n    this.faClass = 'fa-pencil';\\n    this.tooltip = drawerInstance.t('Free drawing mode');\\n\\n    _this._defaultOptions = {\\n      cursorUrl: 'pencil',\\n      brushSize: 2\\n    };\\n\\n    this._setupOptions(options);\\n\\n    if (_this.options.cursorUrl == 'pencil') {\\n      var drawerFolderUrl = util.getEaselFolderUrl();\\n      if(drawerFolderUrl){\\n        _this.options.cursorUrl = 'url(' + drawerFolderUrl +\\n        'assets/cursor-fa-pencil.cur), default';\\n      }\\n    }\\n  };\\n\\n  Pencil.prototype = Object.create(BaseBrush.prototype);\\n  Pencil.prototype.constructor = Pencil;\\n\\n  Pencil.prototype.createBrush = function(){\\n    var brush = new fabric.ErasablePencilBrush(this.drawerInstance.fCanvas);\\n\\n    brush.color = this.drawerInstance.activeColor;\\n    brush.opacity = this.drawerInstance.activeOpacity;\\n    brush.width = this.options.brushSize;\\n\\n    return brush;\\n  };\\n\\n  /**\\n   * This method is called in BaseBrush._activateTool()\\n   * Children of BaseBrush MUST implement afterActivateTool.\\n   *\\n   * Save previous fabricJs cursor.\\n   */\\n  Pencil.prototype.afterActivateTool = function () {\\n    var fCanvas = this.drawerInstance.fCanvas;\\n\\n    this._previousCursor = fCanvas.freeDrawingCursor;\\n    fCanvas.freeDrawingCursor = this.options.cursorUrl;\\n  };\\n\\n\\n  /**\\n   * This method is called in BaseBrush._deactivateTool()\\n   * Children of BaseBrush MUST implement afterDeactivateTool.\\n   *\\n   * Restore previous fabricJs cursor.\\n   */\\n  Pencil.prototype.afterDeactivateTool = function () {\\n    var fCanvas = this.drawerInstance.fCanvas;\\n    fCanvas.freeDrawingCursor = this._previousCursor;\\n  };\\n\\n  pluginsNamespace.Pencil = Pencil;\\n\\n}(jQuery, Easel.plugins.BaseBrush, Easel.plugins, Easel.util));\"","module.exports = \"/**\\n * Toolbar placeholder.\\n *\\n * @param {Easel.Easel} drawerInstance\\n * @param {string} position\\n * @param {string} [positionType]\\n * @param {string} [customAnchorSelector]\\n *\\n * @constructor\\n */\\nvar ToolbarPlaceholder = function(drawerInstance, position, positionType, customAnchorSelector) {\\n  this.drawerInstance = drawerInstance;\\n  if (!drawerInstance) {\\n    throw new Error(\\\"ToolbarPlaceholder: drawerInstance is not provided!\\\");\\n  }\\n\\n  this._setupOptions(position, positionType, customAnchorSelector);\\n\\n\\n  // Create element\\n  this._setupElement();\\n  this._attachEventHandlers();\\n  this._attachEaselEventHandlers();\\n};\\n\\n// positions of placeholder\\nToolbarPlaceholder.prototype.TOP_POSITION = 'top';\\nToolbarPlaceholder.prototype.BOTTOM_POSITION = 'bottom';\\nToolbarPlaceholder.prototype.LEFT_POSITION = 'left';\\nToolbarPlaceholder.prototype.RIGHT_POSITION = 'right';\\nToolbarPlaceholder.prototype.OVER_CANVAS_POSITION = 'canvas';\\nToolbarPlaceholder.prototype.POPUP_POSITION = 'popup';\\n\\nToolbarPlaceholder.prototype.POSITION_TYPE_OUTSIDE = 'outside';\\nToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE = 'inside';\\nToolbarPlaceholder.prototype.POSITION_TYPE_CUSTOM = 'custom';\\n\\nToolbarPlaceholder.prototype.CUSTOM_POSITION = 'custom';\\n\\n// orientations of placeholder\\nToolbarPlaceholder.prototype.HORIZONTAL_ORIENTATION = 'horizontal';\\nToolbarPlaceholder.prototype.VERTICAL_ORIENTATION = 'vertical';\\n\\n// States of placeholder\\nToolbarPlaceholder.prototype.STATE_HIDDEN = 'hidden';\\nToolbarPlaceholder.prototype.STATE_OVERLAY = 'overlay';\\nToolbarPlaceholder.prototype.STATE_DISABLED = 'disabled';\\n\\n\\n// placeholder html\\nToolbarPlaceholder.prototype._html_default =  '' +\\n    '<ul class=\\\"noselect toolbar-placeholder\\\" contenteditable=false>' +\\n      '<li class=\\\"toolbar-placeholder-overlay\\\"></li>' +\\n    '</ul>';\\n\\nToolbarPlaceholder.prototype._html_popup =  '' +\\n    '<div class=\\\"noselect toolbar-placeholder hidden\\\" contenteditable=false>' +\\n      '<div class=\\\"close-btn\\\">' +\\n        '<span class=\\\"fa fa-close\\\"></span>' +\\n      '</div>' +\\n      '<div class=\\\"overlay\\\"></div>' +\\n    '</div>';\\n\\n/**@\\n * Save and process options\\n * @param {String} position one of predefined positions - look at ToolbarPlaceholder.prototype.*_POSITION\\n * @param {String} [positionType] one of predefined types - look at ToolbarPlaceholder.prototype.POSITION_TYPE_*\\n * @param {String} [customAnchorSelector]\\n * @private\\n */\\nToolbarPlaceholder.prototype._setupOptions = function (position, positionType, customAnchorSelector) {\\n  if (position === this.POPUP_POSITION) {\\n    var $popupWrapper = this.drawerInstance.$popupWrapper,\\n        $popupContent = $popupWrapper && $popupWrapper.find('.popup-content');\\n    if ($popupContent && $popupContent.length) {\\n      position = this.CUSTOM_POSITION;\\n      this.$customAnchor = $popupContent;\\n    }\\n  }\\n\\n  this.position = position;\\n  this.positionType = positionType;\\n  this.customAnchorSelector = customAnchorSelector;\\n};\\n\\n\\n/**\\n * Setup event handlers\\n * @private\\n */\\nToolbarPlaceholder.prototype._attachEventHandlers = function () {\\n\\n};\\n\\n/**\\n * Setup event handlers for Easel\\n * @private\\n */\\nToolbarPlaceholder.prototype._attachEaselEventHandlers = function () {\\n  // remove on edit stop\\n  var self = this;\\n  this.drawerInstance.on(this.drawerInstance.EVENT_EDIT_STOP, function() {\\n    self.$element.remove();\\n  });\\n\\n  var checkElements = function ($elements) {\\n    var excludeElements = $elements && $elements.length ? $elements : $(),\\n        isParent,\\n        isChild,\\n        excludeElementsMatched;\\n\\n    excludeElements.each(function (i, element) {\\n      var $currEl = $(element);\\n      if (!excludeElementsMatched) {\\n        isParent = self.$element.find($currEl).length;\\n        isChild = self.$element.closest($currEl).length;\\n        excludeElementsMatched = isParent || isChild;\\n      }\\n    });\\n\\n    return excludeElementsMatched;\\n  };\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_CHANGE_STATE, function(fEvent, data) {\\n    var dataForChange = $.extend(true, {}, data || {});\\n    self.changeState(dataForChange);\\n  });\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_CLEAR_STATE, function(fEvent, data) {\\n    var excludeElements = data && data.excludeElements,\\n        isParent = self.$element.find(excludeElements).length,\\n        isChild = self.$element.closest(excludeElements).length,\\n        customPosition = self.position === self.POSITION_TYPE_CUSTOM,\\n        excludeElementsMatched = isParent || isChild;\\n    if (!excludeElementsMatched && !customPosition) {\\n      self.turnOffOverlay();\\n      self.turnOffDisabled();\\n      self._showPlaceholder();\\n    }\\n  });\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_STATE_HIDDEN_OFF, function(fEvent, data) {\\n    var dataForChange = $.extend(true, {}, data || {});\\n    dataForChange.state = 'hidden';\\n    dataForChange.turnOn = false;\\n    self.changeState(dataForChange);\\n  });\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_STATE_HIDDEN_ON, function(fEvent, data) {\\n    var dataForChange = $.extend(true, {}, data || {});\\n    dataForChange.state = 'hidden';\\n    dataForChange.turnOn = true;\\n    self.changeState(dataForChange);\\n  });\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_STATE_OVERLAY_ON, function(fEvent, data) {\\n    var dataForChange = $.extend(true, {}, data || {});\\n    dataForChange.state = 'overlay';\\n    dataForChange.turnOn = true;\\n    self.changeState(dataForChange);\\n  });\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_STATE_OVERLAY_OFF, function(fEvent, data) {\\n    var dataForChange = $.extend(true, {}, data || {});\\n    dataForChange.state = 'overlay';\\n    dataForChange.turnOn = false;\\n    self.changeState(dataForChange);\\n  });\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_STATE_DISABLED_ON, function(fEvent, data) {\\n    var dataForChange = $.extend(true, {}, data || {});\\n    dataForChange.state = 'disabled';\\n    dataForChange.turnOn = true;\\n    self.changeState(dataForChange);\\n  });\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_STATE_DISABLED_OFF, function(fEvent, data) {\\n    var dataForChange = $.extend(true, {}, data || {});\\n    dataForChange.state = 'disabled';\\n    dataForChange.turnOn = false;\\n    self.changeState(dataForChange);\\n  });\\n};\\n\\n/**\\n * Sets placeholder positioning.\\n *\\n * @param {String} [position] - one of predefined positions - look at ToolbarPlaceholder.prototype.*_POSITION\\n * @param {String} [positionType] one of predefined types - look at ToolbarPlaceholder.prototype.POSITION_TYPE_*\\n * @param {String} [customAnchorSelector]\\n * @private\\n */\\nToolbarPlaceholder.prototype._setPosition = function(position, positionType, customAnchorSelector) {\\n  position = position || this.position;\\n  positionType = positionType || this.positionType;\\n  customAnchorSelector = customAnchorSelector || this.customAnchorSelector;\\n\\n  this.position = position;\\n  if (position == this.CUSTOM_POSITION) {\\n      this.customAnchorSelector = customAnchorSelector;\\n\\n\\n      var anchorFromElement = $(window.document).find(this.$customAnchor),\\n          anchorFromSelector = $(window.document).find(customAnchorSelector),\\n          $anchor = anchorFromElement.length ? anchorFromElement : (anchorFromSelector.length ? anchorFromSelector : false);\\n      if ($anchor) {\\n        // @todo - why this limitation?\\n        // at the moment - only horizontal position for custom anchors\\n        this.orientation = this.HORIZONTAL_ORIENTATION;\\n\\n        // wrap anchor in jQuery\\n        this.$customAnchor = $anchor;\\n        this.$customAnchor.append(this.$element);\\n      } else {\\n        this.drawerInstance.error(\\\"ToolbarPlaceholder : no anchor element found for custom toolbar by selector '\\\" + customAnchorSelector + \\\"'\\\");\\n\\n        // custom placeholder will be existing top placeholder\\n        this.position = this.TOP_POSITION;\\n      }\\n  } else {\\n\\n    switch (position) {\\n      case this.TOP_POSITION :\\n        this.$element.addClass('toolbar-placeholder-top');\\n        this.orientation = this.HORIZONTAL_ORIENTATION;\\n      break;\\n      case this.BOTTOM_POSITION :\\n        this.$element.addClass('toolbar-placeholder-bottom');\\n        this.orientation = this.HORIZONTAL_ORIENTATION;\\n      break;\\n      case this.LEFT_POSITION :\\n        this.$element.addClass('toolbar-placeholder-left');\\n        this.orientation = this.VERTICAL_ORIENTATION;\\n      break;\\n      case this.RIGHT_POSITION :\\n        this.$element.addClass('toolbar-placeholder-right');\\n        this.orientation = this.VERTICAL_ORIENTATION;\\n      break;\\n      case this.OVER_CANVAS_POSITION :\\n        this.$element.addClass('toolbar-placeholder-overcanvas');\\n        this.orientation = this.HORIZONTAL_ORIENTATION;\\n        break;\\n      default:\\n        this.position = this.TOP_POSITION;\\n        this.$element.addClass('toolbar-placeholder-top');\\n        this.orientation = this.HORIZONTAL_ORIENTATION;\\n    }\\n\\n    if (positionType && positionType === this.POSITION_TYPE_INSIDE) {\\n      this.$element.addClass('toolbar-placeholder-inside');\\n    }\\n    this.$element.attr('data-position', position);\\n\\n    // add placeholder to container\\n    var container = this.drawerInstance.$toolbarsWrapper;\\n    container.append(this.$element);\\n  }\\n};\\n\\n/**@\\n * Init placeholder element - create and setup\\n * @private\\n */\\nToolbarPlaceholder.prototype._setupElement = function () {\\n  var elementHtml = this._getHtmlOfElement();\\n  this.$element = $(elementHtml);\\n  this.$overlay = this.$element.find('.toolbar-placeholder-overlay');\\n  this._setPosition();\\n};\\n\\n/**\\n * Get html of template\\n * @private\\n */\\nToolbarPlaceholder.prototype._getHtmlOfElement = function () {\\n  var result;\\n  result = this._html_default;\\n  if (this.position === this.POPUP_POSITION) {\\n    result = this._html_popup;\\n  }\\n  return result;\\n};\\n\\n\\n/**\\n * Toggle state of placeholder\\n * @param {Object} data - Configuration object\\n * @param {String} data.state - Type of state\\n * @param {Boolean} [data.turnOn] - Turn on/off selected state\\n * @param {jQuery} [data.excludeElements] - Do not change state of placeholder if it is parent/child at least of one of the next elements\\n */\\nToolbarPlaceholder.prototype.changeState = function (data) {\\n  var self = this,\\n      checkElements;\\n\\n  checkElements = function ($elements) {\\n    var excludeElements = $elements && $elements.length ? $elements : $(),\\n        isParent,\\n        isChild,\\n        excludeElementsMatched;\\n\\n    excludeElements.each(function (i, element) {\\n      var $currEl = $(element);\\n      if (!excludeElementsMatched) {\\n        isParent = self.$element.find($currEl).length;\\n        isChild = self.$element.closest($currEl).length;\\n        excludeElementsMatched = isParent || isChild;\\n      }\\n    });\\n\\n    return excludeElementsMatched;\\n  };\\n\\n  var excludeElements = data && data.excludeElements.length ? data.excludeElements : $(),\\n      excludeElementsMatched = checkElements(excludeElements),\\n      customPosition = self.position === self.POSITION_TYPE_CUSTOM,\\n      ignore = excludeElementsMatched || customPosition;\\n  if (!ignore) {\\n    switch (data.state) {\\n      case this.STATE_OVERLAY :\\n        this.toggleOverlay(data.turnOn);\\n        break;\\n      case this.STATE_HIDDEN :\\n        if (data.turnOn) {\\n          this._hidePlaceholder();\\n        } else {\\n          this._showPlaceholder();\\n        }\\n        break;\\n      case this.STATE_DISABLED :\\n        if (data.turnOn) {\\n          this.turnOnDisabled();\\n        } else {\\n          this.turnOffDisabled();\\n        }\\n        break;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Hide placeholder element\\n * @private\\n */\\nToolbarPlaceholder.prototype._hidePlaceholder = function () {\\n  this.$element.addClass('hidden');\\n};\\n\\n/**\\n * Show placeholder element\\n * @private\\n */\\nToolbarPlaceholder.prototype._showPlaceholder = function () {\\n  this.$element.removeClass('hidden');\\n};\\n\\n/**\\n * Toggle state of overlay\\n * @param {Boolean} [turnOn] - force to turn on overlay state\\n */\\nToolbarPlaceholder.prototype.toggleOverlay = function (turnOn) {\\n  if (turnOn) {\\n    this.turnOnOverlay();\\n  } else {\\n    this.turnOffOverlay();\\n  }\\n};\\n\\n/**\\n * Turn on \\\"disabled\\\" state\\n */\\nToolbarPlaceholder.prototype.turnOnDisabled = function () {\\n  this.$element.addClass('placeholder-disabled');\\n};\\n\\n/**\\n * Turn off \\\"disabled\\\" state\\n */\\nToolbarPlaceholder.prototype.turnOffDisabled = function () {\\n  this.$element.removeClass('placeholder-disabled');\\n};\\n\\n/**\\n * Turn on \\\"overlay\\\" state\\n */\\nToolbarPlaceholder.prototype.turnOnOverlay = function () {\\n  this.$element.addClass('placeholder-overlayed');\\n};\\n\\n/**\\n * Turn off \\\"overlay\\\" state\\n */\\nToolbarPlaceholder.prototype.turnOffOverlay = function () {\\n  this.$element.removeClass('placeholder-overlayed');\\n};\\n\\n/**\\n * Adds toolbar to placeholder.\\n * Shifts placeholder css position to retain its positioning\\n *\\n * @param {EaselToolbar} toolbar to add\\n */\\nToolbarPlaceholder.prototype.addToolbar = function(toolbar) {\\n  var $toolbar = toolbar.$toolbar;\\n  this.$element.append($toolbar);\\n\\n  // set toolbar position equal to placeholder position\\n  toolbar.position = this.position;\\n\\n  // set toolbar orientation\\n  var horizontalClass = EaselToolbar.HORIZONTAL_CLASS || 'drawer-toolbar--horizontal';\\n  var verticalClass = EaselToolbar.VERTICAL_CLASS || 'drawer-toolbar--vertical';\\n  $toolbar.removeClass(horizontalClass).removeClass(verticalClass);\\n  if (this.orientation == this.HORIZONTAL_ORIENTATION) {\\n    $toolbar.addClass(horizontalClass);\\n  } else {\\n    $toolbar.addClass(verticalClass);\\n  }\\n\\n  // Add dropdown toggle button for right vertical toolbars\\n  if (this.position === this.RIGHT_POSITION && this.orientation === this.VERTICAL_ORIENTATION) {\\n    this._addDropdownToggle($toolbar);\\n  }\\n\\n};\\n\\n/**\\n * Add dropdown toggle button for vertical toolbars\\n * @param {jQuery} $toolbar\\n * @private\\n */\\nToolbarPlaceholder.prototype._addDropdownToggle = function($toolbar) {\\n  var self = this;\\n  \\n  // Create hamburger button if it doesn't exist\\n  if (!$toolbar.find('.toolbar-dropdown-toggle').length) {\\n    var $toggleButton = $('<button class=\\\"toolbar-dropdown-toggle\\\">' +\\n      '<i class=\\\"fa fa-ellipsis-v\\\"></i>' +\\n      '</button>');\\n    \\n    // Prepend the button before the content wrapper\\n    $toolbar.prepend($toggleButton);\\n    \\n    // Add click handler to toggle dropdown\\n    $toggleButton.on('click', function(e) {\\n      e.preventDefault();\\n      e.stopPropagation();\\n      $toolbar.toggleClass('dropdown-open');\\n    });\\n    \\n    // Close dropdown when clicking outside\\n    $(document).on('click.toolbar-dropdown', function(e) {\\n      var toolbarSelector = '.' + (EaselToolbar.BASE_CLASS || 'drawer-toolbar');\\n      if (!$(e.target).closest(toolbarSelector).length) {\\n        $toolbar.removeClass('dropdown-open');\\n      }\\n    });\\n  }\\n};\"","module.exports = \"(function ($, pluginsNamespace, util) {\\n  \\\"use strict\\\";\\n\\n  /**\\n   * Provides ability to use image cropper\\n   *\\n   * @param {Easel.Easel} drawer\\n   * @param {object} [options]\\n   * options\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ImageCrop = function ImageCropConstructor(drawer, options) {\\n    /**\\n     * @type {Easel}\\n     */\\n    this.name = 'ImageCrop';\\n    this.drawer = drawer;\\n    this._setupOptions(options);\\n    this.drawer.on(this.drawer.EVENT_CANVAS_READY, this._init.bind(this));\\n    this.drawer.on(this.drawer.BEFORE_CREATE_TOOLBARS, this._init.bind(this));\\n    this.drawer.on(this.drawer.EVENT_IMAGECROP_TOOLBAR_CREATED, this._onToolbarCreated.bind(this));\\n    this.drawer.on(this.drawer.EVENT_IMAGE_CROP, this._onImageCropTrigger.bind(this));\\n  };\\n\\n  ImageCrop.prototype._defaultOptions = {\\n    toolbarState: 'hidden'\\n  };\\n  ImageCrop.prototype._defaultCropOptions = {};\\n\\n  /**\\n   * Init cropper - create elements and instance of crop plugin\\n   * @private\\n   */\\n  ImageCrop.prototype._init = function () {\\n    var hasCanvasContainer = this.drawer.$canvasEditContainer && this.drawer.$canvasEditContainer.length;\\n    if (!hasCanvasContainer) {\\n      this.enabled = false;\\n      return false;\\n    }\\n\\n    this.enabled = this.drawer.options.enableImageCrop && !!pluginsNamespace.ImageCropPlugin;\\n    if (!this.enabled) {\\n      return false;\\n    }\\n\\n    var cropOptions = this._setupCropOptions();\\n    this._removeElements();\\n    this._createElements();\\n    this.cropper = new pluginsNamespace.ImageCropPlugin(this.drawer, this.$cropperContainer, cropOptions);\\n    return true;\\n  };\\n\\n  ImageCrop.prototype._ensureInitialized = function () {\\n    var ready = this.enabled && this.cropper && this.$cropperContainer && this.$cropperContainer.length;\\n    if (ready) {\\n      return true;\\n    }\\n    return this._init();\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  ImageCrop.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * React on create of toolbar\\n   * @param  {fabric.Event} fEvent\\n   * @param  {EaselToolbar} toolbar\\n   */\\n  ImageCrop.prototype._onToolbarCreated = function (fEvent, toolbar) {\\n    this.cropContainerSizesUpdated = false;\\n    this.$toolbar = toolbar.$toolbar;\\n    this._resizeCropWrapper();\\n    this._createToolbarButtons(toolbar);\\n  };\\n\\n  /**\\n   * Creates and adds buttons to crop toolbar\\n   * @param  {EaselToolbar} toolbar\\n   * @private\\n   */\\n  ImageCrop.prototype._createToolbarButtons = function (toolbar) {\\n    var $anotherCropButton,\\n        $applyButton,\\n        $undoCropButton,\\n        $useOriginButton,\\n        $cancelButton,\\n        anotherCropButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-another-crop',\\n          iconClass: 'fa-scissors',\\n          tooltipText: this.drawer.t('Crop image'),\\n          clickHandler: this._onAnotherCropButtonClick.bind(this)\\n        },\\n        applyButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-apply-crop',\\n          iconClass: 'fa-check',\\n          tooltipText: this.drawer.t('Apply current image'),\\n          clickHandler: this._onApplyCropButtonClick.bind(this)\\n        },\\n        undoCropButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-undo-crop',\\n          iconClass: 'fa-undo',\\n          tooltipText: this.drawer.t('Undo crop'),\\n          clickHandler: this._onUndoCropButtonClick.bind(this)\\n        },\\n        useOriginButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-useorigin-crop',\\n          iconClass: 'fa-image',\\n          tooltipText: this.drawer.t('Use origin image'),\\n          clickHandler: this._onUseOriginButtonClick.bind(this)\\n        },\\n        cancelButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-cancel-crop',\\n          iconClass: 'fa-ban',\\n          tooltipText: this.drawer.t('Cancel'),\\n          clickHandler: this._onCancelCropButtonClick.bind(this)\\n        };\\n\\n\\n\\n    $anotherCropButton = toolbar.addButton(anotherCropButtonConf);\\n    $applyButton = toolbar.addButton(applyButtonConf);\\n    $undoCropButton = toolbar.addButton(undoCropButtonConf);\\n    // $useOriginButton = toolbar.addButton(useOriginButtonConf);\\n    $cancelButton = toolbar.addButton(cancelButtonConf);\\n\\n    this.$anotherCropButton = $anotherCropButton;\\n    this.$applyButton = $applyButton;\\n    this.$undoCropButton = $undoCropButton;\\n    this.$useOriginButton = $useOriginButton;\\n    this.$cancelButton = $cancelButton;\\n  };\\n\\n  /**\\n   * On 'another crop' button click handler\\n   * @private\\n   */\\n  ImageCrop.prototype._onAnotherCropButtonClick = function () {\\n    this.cropper.applyCrop(true);\\n    this.$undoCropButton.removeClass('disabled');\\n  };\\n\\n  /**\\n   * On 'apply crop' button click handler\\n   * @private\\n   */\\n  ImageCrop.prototype._onApplyCropButtonClick = function () {\\n    this.cropper.applyCrop();\\n  };\\n\\n\\n  /**\\n   * On 'undo crop' button click handler\\n   * @private\\n   */\\n  ImageCrop.prototype._onUndoCropButtonClick = function () {\\n    var cropper = this.cropper,\\n        ableToUndo = cropper.prevImages && cropper.prevImages.length;\\n    if (ableToUndo) {\\n      cropper.undoCrop(true);\\n      if (!cropper.prevImages.length) {\\n        this.$undoCropButton.addClass('disabled');\\n      }\\n    }\\n  };\\n\\n  /**\\n   * On 'use origin' button click handler\\n   * @private\\n   */\\n  ImageCrop.prototype._onUseOriginButtonClick = function () {\\n    var cropper = this.cropper;\\n    cropper.success(cropper.originalImage);\\n  };\\n\\n  /**\\n   * On 'cancel' button click handler\\n   * @private\\n   */\\n  ImageCrop.prototype._onCancelCropButtonClick = function () {\\n    this.cropper.success();\\n  };\\n\\n  /**\\n   * On 'another crop' button click handler\\n   * @private\\n   */\\n  ImageCrop.prototype._resizeCropWrapper = function () {\\n    var imageCropToolbar = this.drawer.toolbars.cropImageToolbar,\\n        toolbarHeight = imageCropToolbar && imageCropToolbar.$toolbar && imageCropToolbar.$toolbar.height(),\\n        $cropperContainer = this.cropper && this.cropper.$element;\\n    if ($cropperContainer) {\\n      $cropperContainer.css('top', toolbarHeight || 0);\\n    }\\n    if (toolbarHeight && toolbarHeight > 0) { // some webkit issue - sometimes height can be less than 0 (??)\\n      this.cropContainerSizesUpdated = true;\\n    }\\n  };\\n\\n  /**\\n   * React on crop plugin activity\\n   * @param {Function} callback\\n   * @returns {Function}\\n   * @private\\n   */\\n  ImageCrop.prototype._getCropCallback = function (callback) {\\n    var self = this;\\n    return function (result) {\\n      if (callback && typeof callback === 'function') {\\n        callback(result);\\n      }\\n      self.hideCropper();\\n      self.hideCropToolbar();\\n      self.cropper.reset();\\n    };\\n  };\\n\\n  /**\\n   * Init image crop\\n   * @param {fabric.Event} fEvent\\n   * @param {Object} data\\n   * @private\\n   */\\n  ImageCrop.prototype._onImageCropTrigger = function (fEvent, data) {\\n    if (!this._ensureInitialized()) {\\n      this.drawer.log('ImageCrop', 'Cropper is not initialized');\\n      return;\\n    }\\n\\n    if (!this.enabled) {\\n      this.drawer.log('ImageCrop', 'Cropper is disabled');\\n      return;\\n    }\\n\\n    var dataIsValid = data && data.url;\\n    if (!dataIsValid) {\\n      this.drawer.log('ImageCrop', 'Cropping data missing URL payload');\\n      return;\\n    }\\n\\n    data.newImage = true;\\n    var callback = this._getCropCallback(data.callback);\\n    this.showCropToolbar();\\n    this.showCropper();\\n    this.cropper._bind(data, callback);\\n  };\\n\\n  /**\\n   * Setup options for crop plugin\\n   * @param {Object} [cropOptions]\\n   * @private\\n   */\\n  ImageCrop.prototype._setupCropOptions = function (cropOptions) {\\n    var result = {};\\n    $.extend(true, result, this._defaultCropOptions, cropOptions || {});\\n    this.cropOptions = result;\\n  };\\n\\n  /**\\n   * Create helper elements\\n   * @private\\n   */\\n  ImageCrop.prototype._createElements = function () {\\n    var placeCropperInsideCanvas = true,\\n        cropperContainerHtml = '<div class=\\\"image-crop-wrapper hidden\\\"></div>',\\n        $cropperContainer = $(cropperContainerHtml),\\n        $container;\\n\\n    if (placeCropperInsideCanvas) {\\n      $container = this.drawer.$canvasEditContainer;\\n    } else {\\n      $container = $('body');\\n    }\\n\\n    if (!$container || !$container.length) {\\n      $container = $('body');\\n    }\\n\\n    $container.append($cropperContainer);\\n\\n    this.drawer.$cropperContainer = $cropperContainer;\\n    this.$cropperContainer = $cropperContainer;\\n  };\\n\\n  /**\\n   * Remove helper elements\\n   * @private\\n   */\\n  ImageCrop.prototype._removeElements = function () {\\n    if (this.$cropperContainer) {\\n      this.$cropperContainer.remove();\\n      delete this.$cropperContainer;\\n    }\\n\\n    if (this.drawer.$cropperContainer) {\\n      delete this.drawer.$cropperContainer;\\n    }\\n    if (this.cropper) {\\n      this.cropper._destroy();\\n      delete this.cropper;\\n    }\\n  };\\n\\n  /**\\n   * Show crop container\\n   */\\n  ImageCrop.prototype.showCropToolbar = function () {\\n    this.$undoCropButton.addClass('disabled');\\n    this.drawer.trigger(this.drawer.EVENT_RESIZER_HIDE);\\n    this.drawer.trigger(this.drawer.EVENT_TOOLBAR_CHANGE_STATE, [{\\n      excludeElements: this.$toolbar,\\n      state: this.options.toolbarState,\\n      turnOn: true\\n    }]);\\n    this.drawer.trigger(this.drawer.EVENT_OVERCANVAS_BUTTON_HIDE, [true]);\\n\\n    this.drawer.toolbars.cropImageToolbar.showToolbar();\\n    if (!this.cropContainerSizesUpdated) {\\n      this._resizeCropWrapper();\\n    }\\n  };\\n\\n  /**\\n   * Hide crop container\\n   */\\n  ImageCrop.prototype.hideCropToolbar = function () {\\n    this.drawer.toolbars.cropImageToolbar.hideToolbar();\\n    this.drawer.trigger(this.drawer.EVENT_RESIZER_SHOW);\\n    this.drawer.trigger(this.drawer.EVENT_TOOLBAR_CLEAR_STATE);\\n    this.drawer.trigger(this.drawer.EVENT_OVERCANVAS_BUTTON_SHOW);\\n  };\\n\\n\\n  /**\\n   * Show crop container\\n   */\\n  ImageCrop.prototype.showCropper = function () {\\n    if (this.$cropperContainer && this.$cropperContainer.length) {\\n      this.$cropperContainer.removeClass('hidden');\\n      // Force display block to override !important from .hidden class\\n      this.$cropperContainer.css('display', 'block');\\n      this.$cropperContainer.css('visibility', 'visible');\\n    } else {\\n      this.drawer.log('ImageCrop', 'Cropper container not available');\\n    }\\n  };\\n\\n  /**\\n   * Hide crop container\\n   */\\n  ImageCrop.prototype.hideCropper = function () {\\n    if (this.$cropperContainer && this.$cropperContainer.length) {\\n      this.$cropperContainer.addClass('hidden');\\n      this.$cropperContainer.css('display', 'none');\\n      this.$cropperContainer.css('visibility', 'hidden');\\n    }\\n  };\\n\\n  pluginsNamespace.ImageCrop = ImageCrop;\\n})(jQuery, Easel.plugins, Easel.util);\"","module.exports = \"Easel.texts = {\\n  'Add Easel': 'Add Easel',\\n  'Insert Easel': 'Insert Easel',\\n  'Insert': 'Insert',\\n  'Free drawing mode': 'Free drawing mode',\\n  'Export as SVG': 'Export as SVG',\\n  'Selection mode': 'Selection mode',\\n  'SimpleWhiteEraser': 'SimpleWhiteEraser',\\n  'Eraser': 'Eraser',\\n  'Delete this canvas': 'Delete this canvas',\\n  'Are you sure want to delete this canvas?': 'Are you sure want to delete this canvas?',\\n\\n  // canvas properties popup\\n  'Size (px)': 'Size (px)',\\n  'Position': 'Position',\\n  'Inline': 'Inline',\\n  'Left': 'Left',\\n  'Center': 'Center',\\n  'Right': 'Right',\\n  'Floating': 'Floating',\\n  'Canvas properties': 'Canvas properties',\\n  'Background': 'Background',\\n  'transparent': 'transparent',\\n  'Cancel': 'Cancel',\\n  'Save': 'Save',\\n\\n  // Fullscreen plugin\\n  'Enter fullscreen mode': 'Enter fullscreen mode',\\n  'Exit fullscreen mode': 'Exit fullscreen mode',\\n\\n  // shape context menu plugin\\n  'Bring forward': 'Bring forward',\\n  'Send backwards': 'Send backwards',\\n  'Bring to front': 'Bring to front',\\n  'Send to back': 'Send to back',\\n  'Duplicate': 'Duplicate',\\n  'Remove': 'Remove',\\n\\n  // brush size plugin\\n  'Size:': 'Size:',\\n\\n  // colorpicker plugin\\n  'Fill:': 'Fill:',\\n  'Transparent': 'Transparent',\\n\\n  // shape border plugin\\n  'Border:': 'Border:',\\n  'None': 'None',\\n\\n  // arrow plugin\\n  'Draw an arrow': 'Draw an arrow',\\n  'Draw a two-sided arrow': 'Draw a two-sided arrow',\\n  'Lines and arrows': 'Lines and arrows',\\n\\n  // circle plugin\\n  'Draw a circle': 'Draw a circle',\\n\\n  // line plugin\\n  'Draw a line': 'Draw a line',\\n\\n  // rectangle plugin\\n  'Draw a rectangle': 'Draw a rectangle',\\n\\n  // diamond plugin\\n  'Draw a diamond': 'Draw a diamond',\\n\\n  // polygon plugin\\n  'Draw a Polygon': 'Draw a Polygon',\\n  'Stop drawing a polygon': 'Stop drawing a polygon (esc)',\\n  'Click to start a new line': 'Click to start a new line',\\n\\n  // text plugin\\n  'Draw a text': 'Draw a text',\\n  'Click to place a text': 'Click to place a text',\\n  'Font:': 'Font:',\\n\\n  // movable floating mode plugin\\n  'Move canvas': 'Move canvas',\\n\\n  // base shape\\n  'Click to start drawing a ': 'Click to start drawing a '\\n};\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-color/Color.js\"))","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing text color;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextColor = function TextColorConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    // init options\\n    this._setupOptions(options);\\n    this.colorControl = new pluginsNamespace.ColorpickerControl(this.drawer, this.options);\\n  };\\n\\n  TextColor.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextColor.prototype.constructor = BaseTextOptionTool;\\n\\n  TextColor.prototype.name = 'TextColor';\\n  TextColor.prototype.optionName = 'TextColor';\\n  TextColor.prototype.focusTextOnChange = true;\\n  TextColor.prototype.onlyPredefined = true;\\n\\n  TextColor.prototype._defaultOptions = {\\n    colorText: 'Font color:',\\n    defaultValues: {\\n      fill: ''\\n    },\\n  };\\n\\n  TextColor.prototype.valueType = {\\n    fill: 'color'\\n  };\\n\\n  TextColor.prototype.updateSingleControl = function (valueName, value) {\\n    if (valueName === 'fill') {\\n      this.colorControl.setColor(value);\\n    }\\n  };\\n\\n  TextColor.prototype.getStylesFromControls = function () {};\\n\\n  TextColor.prototype.getStylesFromChangeEvent = function (data) {\\n    var result;\\n    if (data) {\\n      if (typeof data === 'object') {\\n        result = data.styles;\\n      }\\n      if (typeof data === 'string') {\\n        result = {\\n          fill: data\\n        };\\n      }\\n    }\\n    this._lastData = result;\\n    return result;\\n  };\\n\\n  TextColor.prototype.setupControl = function (toolbar, $toolControl, changeCallback) {\\n    this.colorChangeHandler = changeCallback;\\n\\n    this.$toolControl = this.colorControl.createControl(toolbar,  this.onInputChange.bind(this));\\n    // cache control components\\n    this.$toolControl.$colorIndicator = this.$toolControl.find('.color-indicator');\\n    this.$toolControl.$colorDropdown = this.$toolControl.find('.color-dropdown');\\n\\n    this.$toolControl.$colorIndicator.attr('data-name', 'fill');\\n    this.$toolControl.$colorIndicator.addClass('controls-value-item');\\n\\n    this.$toolControl.addClass('editable-canvas-text-option editable-canvas-text-color');\\n\\n    this.colorDropdownVisible = false;\\n  };\\n\\n  pluginsNamespace.TextColor = TextColor;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/brush-pencil/Pencil.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/ToolbarPlaceholder.js\"))","module.exports = \"(function ($, pluginsNamespace, BaseTool, util) {\\n  'use strict';\\n\\n\\n  var MOUSE_UP_TIMER = util.mouseUp('BaseBrushTimer');\\n  var MOUSE_DOWN_TIMER = util.mouseDown('BaseBrushTimer');\\n  /**\\n   * Base class for all brushes/free drawing tools.\\n   *\\n   * @param drawerInstance\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var BaseBrush = function (drawerInstance) {\\n    // call super constructor\\n    BaseTool.call(this, drawerInstance);\\n\\n    // set type\\n    this.type = 'brush';\\n\\n    // @todo : use it\\n    this.brushConstructor = fabric.ErasablePencilBrush;\\n  };\\n\\n\\n  BaseBrush.prototype = Object.create(BaseTool.prototype);\\n  BaseBrush.prototype.constructor = BaseBrush;\\n\\n  BaseBrush.prototype.doNotZoomOnActivate = true;\\n\\n  BaseBrush.prototype.createButton = function (toolbar) {\\n    var _this = this,\\n        clickHandler = function () {\\n          var action = _this.active ? _this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL\\n              : _this.drawerInstance.EVENT_DO_ACTIVATE_TOOL;\\n\\n          _this.drawerInstance.trigger(action, [_this]);\\n        },\\n        buttonConfig = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: this.btnClass,\\n          iconClass: this.faClass,\\n          tooltipText: this.tooltip,\\n          clickHandler: clickHandler\\n        };\\n\\n\\n    this.$toolButton = toolbar.addButton(buttonConfig);\\n  };\\n\\n  BaseBrush.prototype._activateTool = function () {\\n    // call _activateTool() of parent\\n    BaseTool.prototype._activateTool.call(this);\\n    this.drawerInstance.log('TOOL', this.name + ' : activateTool [BaseBrush]');\\n\\n    var _this = this;\\n    var fCanvas = _this.drawerInstance.fCanvas;\\n\\n    fCanvas.freeDrawingCursor =\\n      \\\"url(/redactor.plugin.drawer/dist/cursor-fa-eraser.cur), default\\\";\\n    fCanvas.isDrawingMode = true;\\n\\n    // create brush\\n    if (!_this.brush) {\\n      if (!_this.createBrush) {\\n        _this.brush = new fabric.ErasablePencilBrush(_this.drawerInstance.fCanvas);\\n      } else {\\n        _this.brush = _this.createBrush();\\n      }\\n    }\\n\\n    // save prev brush and set new\\n    _this.previousBrush = _this.drawerInstance.getBrush();\\n    _this.drawerInstance.setBrush(_this.brush);\\n\\n    _this.drawerInstance.trigger(this.drawerInstance.EVENT_TOOL_ACTIVATED, [this]);\\n    // this method will be redefined in BaseBrush descendants\\n    this.afterActivateTool();\\n    this._attachTimerEvents();\\n  };\\n\\n  /**\\n   * Attach event that indicates \\\"Brush\\\" drawing mode\\n   * @private\\n   */\\n  BaseBrush.prototype._attachTimerEvents = function () {\\n    var upperCanvasEl = this.drawerInstance.fCanvas.upperCanvasEl,\\n        $upperCanvasEl = $(upperCanvasEl);\\n\\n    this._removeTimerEvents();\\n    // handle mouse down and mouse up\\n    $upperCanvasEl.on(MOUSE_DOWN_TIMER, this._onMouseDownTimer.bind(this));\\n    $(window.document).on(MOUSE_UP_TIMER, this._onMouseUpTimer.bind(this));\\n  };\\n\\n  /**\\n   * Update indicator on mouse down\\n   * @private\\n   */\\n  BaseBrush.prototype._onMouseDownTimer = function () {\\n    this.drawerInstance.isBrushDrawing = true;\\n  };\\n\\n  /**\\n   * Update indicator on mouse up\\n   * @private\\n   */\\n  BaseBrush.prototype._onMouseUpTimer = function () {\\n    var self = this;\\n    util.setTimeout(function(){\\n      self.drawerInstance.isBrushDrawing = false;\\n    },0);\\n  };\\n\\n  /**\\n   * Remove events\\n   * @private\\n   */\\n  BaseBrush.prototype._removeTimerEvents = function () {\\n    var upperCanvasEl = this.drawerInstance.fCanvas.upperCanvasEl,\\n        $upperCanvasEl = $(upperCanvasEl);\\n\\n    // handle mouse down and mouse up\\n    $upperCanvasEl.off(MOUSE_DOWN_TIMER);\\n    $(window.document).off(MOUSE_UP_TIMER);\\n  };\\n\\n  /**\\n   *\\n   *\\n   * @private\\n   */\\n  BaseBrush.prototype._deactivateTool = function () {\\n    // call _deactivateTool() of parent\\n    BaseTool.prototype._deactivateTool.call(this);\\n    this.drawerInstance.log('TOOL', this.name + ' : deactivateTool [BaseBrush]');\\n\\n    this.drawerInstance.fCanvas.isDrawingMode = false;\\n\\n    // remove mouse events listening\\n    $(this.drawerInstance.fCanvas.upperCanvasEl)\\n      .off('mousedown.BaseBrush touchstart.BaseBrush');\\n\\n    $(this.drawerInstance.fCanvas.upperCanvasEl)\\n      .off('mouseup.BaseBrush touchend.BaseBrush');\\n\\n    this._removeTimerEvents();\\n    // restore prev brush\\n    this.drawerInstance.setBrush(this.previousBrush);\\n    this.brush = null;\\n\\n    this.drawerInstance.trigger(this.drawerInstance.EVENT_TOOL_DEACTIVATED, [this]);\\n    // this method will be redefined in BaseBrush descendants\\n    this.afterDeactivateTool();\\n  };\\n\\n\\n  /**\\n   * Method MUST be redefined in descendants.\\n   * Method is called in the end of _deactivateTool().\\n   */\\n  BaseBrush.prototype.afterActivateTool = function () {\\n    throw new Error(this.name + ' should implement afterActivateTool() method.');\\n  };\\n\\n  /**\\n   * Method MUST be redefined in descendants.\\n   * Method is called in the end of _deactivateTool().\\n   */\\n  BaseBrush.prototype.afterDeactivateTool = function () {\\n    throw new Error(this.name + ' should implement afterDeactivateTool() method.');\\n  };\\n\\n  pluginsNamespace.BaseBrush = BaseBrush;\\n\\n}(jQuery, Easel.plugins, Easel.plugins.BaseTool, Easel.util));\\n\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/instances/SettingsToolbar.js\"))","module.exports = \"(function ($, pluginsNamespace) {\\n    'use strict';\\n\\n    /**\\n     * Base class for all drawing tools.\\n     *\\n     * @param drawerInstance\\n     * @param options\\n     * @constructor\\n     * @memberof Easel.plugins\\n     */\\n    var BaseTool = function (drawerInstance, options) {\\n        if (!drawerInstance) {\\n            throw new Error(\\\"BaseTool CTOR : drawerInstance is not set!\\\");\\n        }\\n        this._setupOptions(options);\\n\\n        this.drawerInstance = drawerInstance;\\n        this.drawer = drawerInstance;\\n\\n        // set handlers\\n        this._bindedOnToolbarCreated = this._onToolbarCreated.bind(this);\\n        this.drawerInstance.on(this.drawerInstance.EVENT_TOOLS_TOOLBAR_CREATED,  this._bindedOnToolbarCreated);\\n    };\\n\\n    BaseTool.prototype.name = '';          // tool name\\n    BaseTool.prototype.type = null;        // tool type\\n    BaseTool.prototype.active = false;     // is active at the moment\\n    BaseTool.prototype.btnClass = 'btn';   // tool button css class\\n    BaseTool.prototype.faClass = '';       // tool icon css class\\n    BaseTool.prototype.tooltip = '';       //\\n    BaseTool.prototype.toolbar = null;     /** @type {EaselToolbar} */\\n    BaseTool.prototype.$toolButton = null; // cached jQuery wrapper of button\\n    BaseTool.prototype.drawerInstance = null; // instance of Easel\\n\\n\\n    /**\\n     * Handler for EVENT_DO_DEACTIVATE_ALL_TOOLS.\\n     */\\n    BaseTool.prototype._onDeactivateAllTools = function () {\\n        if (this.active) {\\n          var ns = '.tool-' + this.name;\\n          this.drawerInstance.trigger(this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL + ns, [this]);\\n        }\\n    };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n    BaseTool.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n      pluginName = pluginName || this.name;\\n      var drawer = this.drawerInstance || this.drawer,\\n          optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n          result = $.extend(true,\\n              {},\\n              this._defaultOptions || {},\\n              optionsFromEasel || {},\\n              options || {}\\n          );\\n\\n      if (!doNotSave) {\\n        this.options = result;\\n      }\\n      return result;\\n    };\\n\\n    /**\\n     * On toolbar created - create tool button.\\n     * @param {fabric.Event} ev\\n     * @param {EaselToolbar} toolbar\\n     * @private\\n     */\\n    BaseTool.prototype._onToolbarCreated = function (ev, toolbar) {\\n        this.toolbar = toolbar;\\n        this.createButton(toolbar);\\n\\n        this._setHandlers();\\n\\n        if (this.onToolbarCreated) {\\n            this.onToolbarCreated(ev, toolbar);\\n        }\\n    };\\n\\n\\n    /**\\n     * On toolbar destroyed - destroy button, if it was our toolbar.\\n     */\\n    BaseTool.prototype.onToolbarDestroyed = function (ev, toolbar) {\\n        if (this.toolbar == toolbar) {\\n            this.removeTool();\\n        }\\n    };\\n\\n    /**\\n     * Deletes tool button.\\n     * If  doDeleteToolbarCreationListeners is true - removes listenin on toolbar creation event.\\n     * So, tool will not appear on toolbar next time, when toolbar is created.\\n     *\\n     * @param {boolean} doDeleteToolbarCreationListeners\\n     */\\n    BaseTool.prototype.removeTool = function(doDeleteToolbarCreationListeners) {\\n        // removes button and unbind click on it\\n        if (this.$toolButton) {\\n            this.toolbar.removeButton(this.$toolButton);\\n        }\\n\\n        // stop listening toolbar creation\\n        if (doDeleteToolbarCreationListeners) {\\n            this._unsetHandlers();\\n            this.drawerInstance.off(this.drawerInstance.EVENT_TOOLS_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n        }\\n    };\\n\\n\\n    BaseTool.prototype._setHandlers = function () {\\n        var ns = '.tool-' + this.name;\\n\\n        this.drawerInstance.on(this.drawerInstance.EVENT_TOOLBAR_DESTROYED + ns, this.onToolbarDestroyed.bind(this));\\n\\n        this.drawerInstance.on(this.drawerInstance.EVENT_DO_DEACTIVATE_ALL_TOOLS + ns, this._onDeactivateAllTools.bind(this));\\n        this.drawerInstance.on(this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL + ns, this._onDeactivateTool.bind(this));\\n        this.drawerInstance.on(this.drawerInstance.EVENT_DO_ACTIVATE_TOOL, this._onActivateTool.bind(this));\\n    };\\n\\n    BaseTool.prototype._unsetHandlers = function () {\\n        var ns = '.tool-' + this.name;\\n        this.drawerInstance.off(this.drawerInstance.EVENT_TOOLBAR_DESTROYED + ns);\\n        this.drawerInstance.off(this.drawerInstance.EVENT_DO_DEACTIVATE_ALL_TOOLS + ns);\\n        this.drawerInstance.off(this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL + ns);\\n        this.drawerInstance.off(this.drawerInstance.EVENT_DO_ACTIVATE_TOOL + ns);\\n    };\\n\\n    /**\\n     * Handler for EVENT_DO_DEACTIVATE_TOOL.\\n     * @param e event obj\\n     * @param tool tool object\\n     */\\n    BaseTool.prototype._onDeactivateTool = function (e, tool) {\\n        if (!tool || !tool.name) {\\n            throw new Error('BaseTool.onDeactivateTool() : no tool name is provided!');\\n        }\\n        if (this.active && (tool.name == this.name)) {\\n          this._deactivateTool();\\n        }\\n    };\\n\\n\\n    /**\\n     * Handler for EVENT_DO_ACTIVATE_TOOL.\\n     * @param e event obj\\n     * @param tool tool object\\n     */\\n    BaseTool.prototype._onActivateTool = function (e, tool) {\\n        if (!tool || !tool.name) {\\n            throw new Error('BaseTool._onActivateTool() : no tool name is provided!');\\n        }\\n        // Ignore, if event was for other tool, or if tool is already active\\n        if (tool.name === this.name && !this.active) {\\n          // ok, event is for this tool, and it is not active, so continue.\\n          // deactivate all tools.\\n          var dataToEvent = {\\n            beforeActivateTool: true\\n          };\\n          this.drawerInstance.trigger(this.drawerInstance.EVENT_DO_DEACTIVATE_ALL_TOOLS, dataToEvent);\\n          // now activate our tool!\\n          this._activateTool();\\n        }\\n    };\\n\\n\\n    /**\\n     * Creates tool button in toolbar provided.\\n     * @param {EaselToolbar} toolbar toolbar, where this tool button will be created\\n     */\\n    BaseTool.prototype.createButton = function (toolbar) {\\n      var buttonConfig = {\\n            buttonOrder: this.options.buttonOrder,\\n            additionalClass: this.btnClass,\\n            iconClass: this.faClass,\\n            tooltipText: this.tooltip,\\n            clickHandler: this.onButtonClick.bind(this)\\n          };\\n\\n      if (this.group) {\\n        buttonConfig.group = this.group;\\n        this.$toolButton = toolbar.addButtonToGroup(buttonConfig);\\n      } else {\\n        this.$toolButton = toolbar.addButton(buttonConfig);\\n      }\\n    };\\n\\n    /**\\n     * On tool button click - trigger event to activate/deactivate tool\\n     */\\n    BaseTool.prototype.onButtonClick = function () {\\n        //    e.preventDefault();\\n        //    e.stopPropagation();\\n\\n        var action = this.active ? this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL\\n                                 : this.drawerInstance.EVENT_DO_ACTIVATE_TOOL;\\n\\n        this.drawerInstance.trigger(action, [this]);\\n    };\\n\\n    /**\\n     * Base tool activation.\\n     * @protected\\n     */\\n    BaseTool.prototype._activateTool = function () {\\n        this.drawerInstance.log('TOOL', '['+ this.name + '] .activateTool() [BaseTool]');\\n\\n        this.drawerInstance.fCanvas.discardActiveObject();\\n        this.drawerInstance.fCanvas.renderAll();\\n\\n        this.active = true;\\n        this.drawerInstance.activeDrawingTool = this;\\n\\n        this.highlightButton();\\n        this.drawerInstance.trigger(this.drawerInstance.EVENT_TOOL_ACTIVATED, [this]);\\n    };\\n\\n\\n    /**\\n     * Base tool deactivation.\\n     * @protected\\n     */\\n    BaseTool.prototype._deactivateTool = function () {\\n        this.drawerInstance.log('TOOL', '[' + this.name + '] : deactivateTool [BaseTool]');\\n\\n        this.active = false;\\n        if (this.drawerInstance.activeDrawingTool === this) {\\n            this.drawerInstance.activeDrawingTool = null;\\n        }\\n\\n        // make tool button not active\\n        this.highlightButtonOff();\\n\\n        this.drawerInstance.fCanvas.renderAll();\\n        this.drawerInstance.trigger(this.drawerInstance.EVENT_TOOL_DEACTIVATED, [this]);\\n    };\\n\\n    BaseTool.prototype.highlightButton = function () {\\n        if (this.group) {\\n            this.toolbar._setGroupButtonActive(this.group.name, this.btnClass);\\n        } else {\\n            this.toolbar.setActiveButton(this.btnClass);\\n        }\\n    };\\n\\n    BaseTool.prototype.highlightButtonOff = function () {\\n        this.toolbar.clearActiveButton();\\n    };\\n\\n    pluginsNamespace.BaseTool = BaseTool;\\n}(jQuery, Easel.plugins));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-shape-contextmenu/ContextMenu.Api.js\"))","module.exports = \"(function (window, $, util, utilPlugins) {\\n  'use strict';\\n  var emptyFunc = function () {},\\n      eventNameSpace = '.ToolbarComboBox';\\n\\n  /**\\n   * @typeDef {Object} returnObj\\n   * @memberOf ToolbarComboBox\\n   * @property {ToolbarComboBox} instance - instance of combo box\\n   * @property {ToolbarComboBox#updateSelectedValues} updateSelectedValues - Update selected values func\\n   * @property {ToolbarComboBox#hideDropdown} hideDropdown - Hide dropdown func\\n   * @property {ToolbarComboBox#showDropdown} showDropdown - Show dropdown func\\n   **/\\n\\n  /**\\n   * @param {HTMLElement} element - trigger element\\n   * @param {ToolbarComboBox.defaultOptions} [options] - configuration object\\n   * @returns {ToolbarComboBox.returnObj}\\n   * @memberOf Easel.utilPlugins\\n   * @constructs ToolbarComboBox\\n   */\\n  var ToolbarComboBox = function(element, options){\\n    this.$element = $(element);\\n    \\n    this._setupOptions(options);\\n    this._setupCombobox();\\n    this._attachEventHandlers();\\n    this._attachEaselEventHandlers();\\n\\n    return {\\n      instance: this,\\n      updateSelectedValues: this.updateSelectedValues.bind(this),\\n      hideDropdown: this.hideDropdown.bind(this),\\n      showDropdown: this.hideDropdown.bind(this)\\n    };\\n  };\\n\\n  /**\\n   * @memberOf ToolbarComboBox\\n   * @typeDef {Object} defaultOptions\\n   * @property {String} wrapper=\\\"toolbar-combobox-wrapper\\\" - wrapper class\\n   * @property {Boolean} editable=false - wrapper class\\n   * @property {Boolean} addNewOptions=false - wrapper class\\n   * @property {Boolean} buttonMode=false - wrapper class\\n   * @property {Array} items - wrapper class\\n   *\\n   **/\\n\\n  /**\\n   *\\n   * @type {ToolbarComboBox.defaultOptions}\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._defaultOptions = {\\n    wrapper: 'toolbar-combobox-wrapper',\\n    editable: false,\\n    addNewOptions: false,\\n    buttonMode: false,\\n    items: []\\n  };\\n\\n  /**\\n   * Setup options\\n   * @param {ToolbarComboBox.defaultOptions | Object} [options] - Configuration object\\n   * @returns {ToolbarComboBox.defaultOptions}\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._setupOptions = function(options) {\\n    var optionsFromElement = this._collectOptionsFromElement();\\n    this.options = $.extend(true, {}, this._defaultOptions || {}, optionsFromElement || {}, options || {});\\n    this._initialOptions = $.extend(true, {}, options);\\n    this._initialOptionsFromElement = $.extend(true, {}, optionsFromElement);\\n    return this.options;\\n  };\\n\\n  /**\\n   * Setup combobox element\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._setupCombobox = function() {\\n    var comboboxHtml = this._generateTemplate(),\\n        $comboboxElement = $(comboboxHtml);\\n\\n    $comboboxElement.insertAfter(this.$element);\\n    this.$element.addClass('hidden');\\n\\n    this.$combobox = $comboboxElement;\\n    this.$options = this.$combobox.find('ul');\\n    this.$dropdown = this.$combobox.find(\\\".dropdown-box\\\");\\n    this.$input = this.$combobox.find(\\\"input\\\");\\n    this.$closestToolbarItem = this.$element.closest('.toolbar-item-wrapper');\\n  };\\n\\n  /**\\n   * Generate html of combobox\\n   * @returns {string}\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._generateTemplate = function() {\\n    var _self = this,\\n      optionsHtml = '',\\n        html;\\n\\n\\n    this.options.items.forEach(function(item){\\n      var isObj = typeof item === 'object',\\n          valueToFill = isObj ? item.value : item,\\n          textToFill = isObj ? item.text || valueToFill : valueToFill,\\n          styleToFill = isObj ? item.style || '' : '',\\n          currItemHtml;\\n      currItemHtml = _self._generateNewOptionItem(textToFill, valueToFill, false, true, styleToFill);\\n      optionsHtml +=currItemHtml;\\n    });\\n\\n    this.wrapperClasses = this.options.wrapper +\\n        (this.options.buttonMode ? ' button-mode ' : '') +\\n        (this.options.editable ? ' edit-mode ' : '');\\n\\n    html = '' +\\n        '<div class=\\\"' + this.wrapperClasses + ' collapsed\\\" tabindex=\\\"-1\\\">' +\\n          '<div class=\\\"selected\\\">' +\\n            '<span></span>' +\\n            '<a class=\\\"ui-button\\\"><i class=\\\"fa fa-angle-down\\\"></i></a>' +\\n          '</div>' +\\n          '<div class=\\\"dropdown-box\\\">' +\\n            '<ul class=\\\"option-list\\\">' +\\n              optionsHtml +\\n            '</ul>' +\\n          '</div>' +\\n        '</div>';\\n    return html;\\n  };\\n\\n  /**\\n   *\\n   * @param {String} [txt] - Text value of option\\n   * @param {String} val - Value of option\\n   * @param {Boolean} [isSelected] - This option is selected\\n   * @param {Boolean} returnHtml - Need return html string\\n   * @param {String} [style] - Inline styles of option\\n   * @returns {jQuery|String}\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._generateNewOptionItem = function (txt, val, isSelected, returnHtml, style) {\\n    txt = txt || '';\\n    style = style || '';\\n    var optionItemHtml = '' +\\n        '<li ' +\\n          'style=\\\"' + style + '\\\"' +\\n          'data-val=\\\"' + val + '\\\"' +\\n          'class=\\\"option-item\\\">' +\\n            '<div class=\\\"option-item-text\\\">' + txt + '</div>' +\\n        '</li>';\\n    var $optionItem = $(optionItemHtml);\\n    if (isSelected) {\\n      this.$combobox.find(\\\".selected\\\").attr(\\\"data-val\\\", val).find('span').text(txt);\\n      $optionItem.addClass('selected');\\n    }\\n    return returnHtml ? $optionItem.get(0).outerHTML : $optionItem;\\n  };\\n\\n  /**\\n   * Setup size of dropdown\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._setupDropDownSize = function() {\\n    var comboboxWidth = this.$combobox.width();\\n    if (comboboxWidth) {\\n\\n      this.sizesUpdated = true;\\n    }\\n  };\\n\\n  /**\\n   * Setup/attach drawer handlers\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._attachEaselEventHandlers = function() {\\n    var _self = this,\\n        $closestToolbarItem = this.$element.closest('.toolbar-item-wrapper');\\n\\n    if ($closestToolbarItem && $closestToolbarItem.length) {\\n\\n      util.bindClick($('body'), '_optionTool_toggleDropdown', function (event) {\\n        var $target = $(event.target),\\n            $clickToolbarItem = $target.closest('.toolbar-item-wrapper'),\\n            isCanvas = $target.is('canvas'),\\n            sameToolControl = $closestToolbarItem.get(0) === $clickToolbarItem.get(0),\\n            needToHide = !sameToolControl && !isCanvas;\\n        if (needToHide) {\\n          $closestToolbarItem.find('.toolbar-dropdown-block').addClass('collapsed');\\n          _self.hideDropdown();\\n        }\\n      });\\n\\n      util.bindClick($closestToolbarItem.find('.toolbar-item-icon'), '_optionTool_toggleDDropdown', function (event) {\\n        var needRemoveClass = $closestToolbarItem.find('.toolbar-dropdown-block').hasClass('collapsed'),\\n            toolbarHaveScrollable;\\n        if (needRemoveClass) {\\n          var toolbar = _self.options && _self.options.drawer && _self.options.drawer.toolbars && _self.options.drawer.toolbars.toolOptionsToolbar,\\n              toolbarOptions = toolbar && toolbar.options,\\n              notInsidePopup = toolbarOptions && toolbarOptions.position !== 'popup',\\n              outside = toolbarOptions && toolbarOptions.positionType === 'outside',\\n              insideScrollable = toolbarOptions && toolbarOptions.compactType === 'scrollable';\\n          toolbarHaveScrollable = notInsidePopup && outside && insideScrollable;\\n          if (toolbarHaveScrollable) {\\n            var clone = _self.$combobox.clone(true);\\n            // _self.$cloneControl = $('<div class=\\\"colorpicker-control\\\"></div>');\\n            // _self.$cloneDropdown = this.$colorButton.$colorDropdown.clone(true);\\n            // _self.$cloneControl.append(this.$cloneDropdown);\\n            $closestToolbarItem.closest('.toolbar-placeholder').append(clone);\\n            clone.addClass('combobox-cloned');\\n            _self.$clonedCombobox = clone;\\n\\n            var drawerSizes = util.getScrollOffset(_self.options.drawer.$canvasEditContainer),\\n                parentSizes = util.getScrollOffset(_self.$element.parent()),\\n                canvasRect = _self.options.drawer.$canvasEditContainer.get(0).getBoundingClientRect();\\n\\n            var left = _self.$element.parent().get(0).getBoundingClientRect().left,\\n                clonedComboboxLeft = (left - canvasRect.left - (parentSizes.left - drawerSizes.left)) - _self.$clonedCombobox.width() / 2;\\n            _self.$clonedCombobox.css({\\n              'left': clonedComboboxLeft\\n            });\\n          }\\n        }\\n\\n        if (!toolbarHaveScrollable) {\\n          $closestToolbarItem.find('.toolbar-dropdown-block').toggleClass('collapsed', !needRemoveClass);\\n        }\\n\\n      });\\n    }\\n  };\\n\\n  /**\\n   * Setup/attach event handlers\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._attachEventHandlers = function() {\\n    var _self = this;\\n    if (this.options.editable) {\\n      var $input = this.$input,\\n          bEdit;\\n\\n      $input.off('focus' + eventNameSpace).on('focus' + eventNameSpace, function(e){\\n        _self.$combobox.addClass('focus');\\n        bEdit = true;\\n      });\\n\\n      $input.off('blur' + eventNameSpace).on('blur' + eventNameSpace, function(e){\\n        bEdit = false;\\n        _self.$combobox.trigger('blur');\\n      });\\n\\n      $input.off('keypress' + eventNameSpace).on('keypress' + eventNameSpace, function(e){\\n        if (e.keyCode == \\\"13\\\") {\\n          var val = $input.val();\\n\\n          $input.val('');\\n\\n\\n          var $originalSelect = $(\\\"<option>\\\").val(val).text(val).attr('data-is-input', 1);\\n          _self.$element.append($originalSelect);\\n\\n          if (_self.options.addNewOptions) {\\n            var $opt = _self._generateNewOptionItem(val, val, true);\\n            _self.$options.append($opt);\\n          }\\n\\n          _self.changeActiveOption(val);\\n        }\\n      });\\n    }\\n\\n    this.$element.off('valueChanged' + eventNameSpace).on('valueChanged' + eventNameSpace, function(e, valueObj){\\n      var valueFromElement = _self.$element.val(),\\n          valueFromObject = valueObj ? valueObj.value : undefined,\\n          value = valueObj ? valueFromObject : valueFromElement,\\n          classes;\\n\\n      if (valueObj) {\\n        classes = valueObj.classString;\\n      }\\n\\n      _self.updateSelectedValues(value, classes);\\n    });\\n\\n    this.$element.off('change' + eventNameSpace).on('change' + eventNameSpace, function(e){\\n      if (!_self.addNewOptions) {\\n        var $element = _self.$element,\\n            prevValue = $element.attr('prev-value'),\\n            prevValueIsNotInitial = _self.options.valuesArr.indexOf(prevValue) === -1;\\n        if (prevValueIsNotInitial) {\\n          $element.find('option[data-val=\\\"' + prevValue + '\\\"]').remove();\\n        }\\n      }\\n    });\\n\\n\\n    this.$combobox.off('mouseleave' + eventNameSpace).on('mouseleave' + eventNameSpace, function(e){\\n      var $closestToolbarItem = _self.$element.closest('.toolbar-item-wrapper');\\n      $closestToolbarItem.find('.toolbar-dropdown-block').addClass('collapsed');\\n      _self.hideDropdown();\\n    });\\n\\n    this.$combobox.off('click' + eventNameSpace + '_optionSelect').on('click' + eventNameSpace + '_optionSelect', '.option-item', this._onOptionSelect.bind(this));\\n\\n    this.$combobox.off('click' + eventNameSpace + '_toggleDropdown').on('click' + eventNameSpace + '_toggleDropdown', '.selected', function(){\\n      _self.toggleDropdown();\\n    });\\n\\n    this.$combobox.off('blur' + eventNameSpace).on('blur' + eventNameSpace, function (e) {\\n      e.preventDefault();\\n      setTimeout(function () {\\n        if (bEdit) return;\\n        _self.hideDropdown();\\n      }, 100);\\n      _self.$combobox.removeClass('focus');\\n    });\\n  };\\n\\n  /**\\n   * Collect array of available options from trigger element\\n   * @returns {Object}\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._collectOptionsFromElement = function() {\\n    var result = {};\\n    \\n    var isEditable = this.$element.attr('data-editable') && this.$element.attr('data-editable') === 'true';\\n\\n    result.items = [];\\n    result.valuesArr = [];\\n    this.$element.find('option').each(function (i, item) {\\n      var $item = $(item),\\n          value = $item.val(),\\n          text = $item.text(),\\n          style = $item.attr('style') || '',\\n          currItemObj = {\\n            value: value,\\n            text: text,\\n            style: style\\n          };\\n      result.valuesArr.push(value);\\n      result.items.push(currItemObj);\\n    });\\n\\n    result.editable = isEditable;\\n\\n    return result;\\n  };\\n\\n  /**\\n   * React on select of option\\n   * @param {Event} event\\n   * @private\\n   */\\n  ToolbarComboBox.prototype._onOptionSelect = function(event) {\\n    var $selectedOption = $(event.currentTarget),\\n        alreadySelected = $selectedOption.hasClass('selected'),\\n        selectedValue = !alreadySelected ?  $selectedOption.attr('data-val') : '',\\n        selectedText = $selectedOption.text();\\n    this.hideDropdown();\\n    this.changeActiveOption(selectedValue, selectedText);\\n    event.stopPropagation();\\n    event.preventDefault();\\n  };\\n\\n  /**\\n   * Change current active option\\n   * @param {String} [value] - Value of new active option\\n   * @param {*} [text] - Text of new active option\\n   */\\n  ToolbarComboBox.prototype.changeActiveOption = function(value, text) {\\n    var prevValue = this.$element.val();\\n\\n    this.$element.attr('prev-value', prevValue);\\n    this.$element.val(value);\\n\\n    this.updateSelectedValues(value);\\n\\n    this.$element.trigger('toolbarOptionChange');\\n  };\\n\\n  /**\\n   * Update selected values\\n   * @param {*} [value] - Value of selected option\\n   * @param {String} [classes] - Additional classes\\n   * @param {String} [optionName] - Name of option\\n   */\\n  ToolbarComboBox.prototype.updateSelectedValues = function(value, classes, optionName) {\\n    value = value || '';\\n    var $allOptions = this.$combobox.find('.option-item'),\\n        $neededOption = $allOptions.filter('[data-val=\\\"' + value + '\\\"]'),\\n        neededText = $neededOption && $neededOption.length ? $neededOption.text() : value,\\n        collapsedClass = this.$combobox.hasClass('collapsed') ? ' collapsed' : '',\\n        wrapperClasses = this.wrapperClasses + ' ' + (classes || '') + collapsedClass;\\n\\n\\n    this.$combobox.attr('class', wrapperClasses);\\n    this.$combobox.find(\\\".selected span\\\").text(neededText);\\n\\n    $allOptions.removeClass('selected');\\n    if ($neededOption) {\\n      $neededOption.addClass('selected');\\n      this.$input.val('');\\n    } else {\\n      this.$input.val(value);\\n    }\\n  };\\n\\n\\n  /**\\n   * Show combobox dropdown\\n   */\\n  ToolbarComboBox.prototype.showDropdown = function() {\\n    this.dropdownIsVisible = true;\\n    if (!this.sizesUpdated) {\\n      this._setupDropDownSize();\\n    }\\n    this.$combobox.find('.ui-button .fa').addClass('fa-angle-down').removeClass('fa-angle-up');\\n    this.$combobox.removeClass('collapsed');\\n  };\\n\\n  /**\\n   * Hide combobox dropdown\\n   */\\n  ToolbarComboBox.prototype.hideDropdown = function() {\\n    this.dropdownIsVisible = false;\\n    this.$combobox.addClass('collapsed');\\n    this.$combobox.find('.ui-button .fa').removeClass('fa-angle-down').addClass('fa-angle-up');\\n\\n    if (this.$clonedCombobox) {\\n      this.$clonedCombobox.remove();\\n    }\\n  };\\n\\n  /**\\n   * Toggle visibility of combobox dropdown\\n   * @param {Boolean} [show] - new state of dropdown\\n   */\\n  ToolbarComboBox.prototype.toggleDropdown = function(show) {\\n    var needToShow = show !== undefined ? show : !this.dropdownIsVisible;\\n    this.dropdownIsVisible = needToShow;\\n\\n    if (needToShow) {\\n      this.showDropdown();\\n    } else {\\n      this.hideDropdown();\\n    }\\n  };\\n\\n  /**\\n   * @Function\\n   * @param options\\n   * @returns {ToolbarComboBox[]}\\n   * @memberOf external:\\\"jQuery.fn\\\"\\n   */\\n  $.fn.ToolbarComboBox = function (options) {\\n    var instances = [];\\n    $(this).each(function (i, element) {\\n      var newInstance = new ToolbarComboBox(element, options);\\n      $(element).data('comboBox', newInstance);\\n      instances.push(newInstance);\\n    });\\n    return instances;\\n  };\\n\\n  /**\\n   * @Function\\n   * @memberOf external:\\\"jQuery.fn\\\"\\n   * @returns {ToolbarComboBox|ToolbarComboBox[]}\\n   */\\n  $.fn.getComboBox = function () {\\n    var instances = [];\\n    $(this).each(function (i, element) {\\n      var currInstance = $(element).data('comboBox');\\n      if (currInstance) {\\n        instances.push(currInstance);\\n      }\\n    });\\n    return instances.length > 1 ? instances : instances[0];\\n  };\\n\\n  utilPlugins.ToolbarComboBox = ToolbarComboBox;\\n})(window, jQuery, Easel.util, Easel.utilPlugins);\"","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions, util) {\\n  \\\"use strict\\\";\\n\\n  /**\\n   * Provides toolbar controls for configuring border size and color.\\n   * Uses colorpicker plugin, so depends on it.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {String} options.color\\n   * Default border color.\\n   *\\n   * @param {String} options.borderTypes\\n   * Object with all borders that will be available for selection\\n   * <br><br>\\n   *\\n   * Example:\\n   * <code>\\n   * <pre>\\n   * \\\"None\\\": {\\n   *   width: 0,\\n   *   description: 'None'\\n   * },\\n   * \\\"Solid thin\\\": {\\n   *   width: 1,\\n   *   preview: this.assetsFolder + 'border-solid-thin.png'\\n   * },\\n   * </pre>\\n   * </code>\\n   *\\n   * @param {String} options.defaultBorder\\n   * Border that will be selected when object is created.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ShapeBorder = function BorderConfigPlugin(drawer, options) {\\n    this.optionName = 'border';\\n    this.name = 'ShapeBorder';\\n    // call super constructor\\n    BaseToolOptions.call(this, drawer);\\n\\n    /**\\n     * Option name. On selecting tool/object, if this.toolName is in array of\\n     * object allowed options - tool will show controls\\n     * @type {String}\\n     */\\n\\n    // Easel is created, so basePath is set and  util.getEaselFolderUrl() works properly.\\n    // so we can set assets folder\\n    this.assetsFolder = util.getEaselFolderUrl() + 'assets/';\\n\\n    // complete default option paths by assets path.\\n    this._setGlobalClickHandler();\\n    this._completeDefaultOptionsPaths();\\n\\n    // setup colorpicker for border color\\n    this.colorpicker = new pluginsNamespace.ColorpickerControl(this.drawer, this.options);\\n\\n    this.currentColor = this.options.color;\\n    this.currentBorder = this.options.borderTypes[this.options.defaultBorder];\\n    this.activeToolIsShape = false;\\n\\n    this.drawer.on(this.drawer.EVENT_CANVAS_START_RESIZE, this.hideStyleDropdown.bind(this));\\n    this.drawer.on(this.drawer.EVENT_OBJECT_ADDED, this._onObjectAdded.bind(this));\\n  };\\n\\n  ShapeBorder.prototype = Object.create(BaseToolOptions.prototype);\\n  ShapeBorder.prototype.constructor = BaseToolOptions;\\n\\n\\n//////////////////////////////////////////////////////////////////////////////////////////\\n  ShapeBorder.prototype._defaultOptions = {\\n      color: '#111111',\\n      borderTypes: {\\n        \\\"None\\\": {\\n          width: 0,\\n          description: 'None',\\n          color: 'transparent'\\n        },\\n        \\\"Solid thin\\\": {\\n          width: 1,\\n          preview: 'border-solid-thin.png'\\n        },\\n        \\\"Solid bold\\\": {\\n          width: 7,\\n          preview: 'border-solid-bold.png'\\n        },\\n        \\\"Dashed thin\\\": {\\n          width: 1,\\n          dashArray: [8, 8],\\n          preview: 'border-dashed-thin.png'\\n        },\\n        \\\"Dashed bold\\\": {\\n          width: 7,\\n          dashArray: [8, 8],\\n          preview: 'border-dashed-bold.png'\\n        }\\n      },\\n      defaultBorder: \\\"Solid bold\\\"\\n    };\\n\\n\\n    /**\\n     * Complete path to previews by prepending path to assets folder to them\\n     */\\n    ShapeBorder.prototype._completeDefaultOptionsPaths = function() {\\n      for (var borderType in this.options.borderTypes) {\\n        var borderOption = this.options.borderTypes[borderType];\\n        if (borderOption.preview) {\\n          borderOption.preview = this.assetsFolder + borderOption.preview;\\n        }\\n      }\\n    };\\n\\n  /**\\n   * Set listeners for clicks - to properly close controls on outside clicks\\n   */\\n  ShapeBorder.prototype._setGlobalClickHandler = function() {\\n    var self = this;\\n    $(window.document).off('click.EaselShapeBorder').on('click.EaselShapeBorder', function (e) {\\n      var $target = $(e.target),\\n          isIndicator = $target.hasClass('border-type-indicator');\\n      if (self.isDropdownVisible && !isIndicator) {\\n        self.hideStyleDropdown();\\n      }\\n    });\\n  };\\n\\n\\n  /**\\n   * When an object is selected on canvas we want to reflect that object's color and border type\\n   * on the toolbar.\\n   *\\n   * This method checks selected object type and if it's a shape it gets that shape's color\\n   * and border type and sets them as active on the color/border selection toolbar.\\n   *\\n   * @param fabricEvent\\n   * @param fabricEvent\\n   */\\n  ShapeBorder.prototype.updateControlsFromObject = function (target) {\\n    // get color\\n    this.updateColorFromObject(target);\\n    // get stroke\\n    this.updateStrokeFromObject(target);\\n    // now update controls state\\n    this.updateControls();\\n  };\\n\\n\\n  /**\\n   * Sets this.currentColor same as object stroke color,\\n   * or TRASPARENT if object has no stroke\\n   *\\n   * @param  {fabric.Object} object\\n   */\\n  ShapeBorder.prototype.updateColorFromObject = function (object) {\\n    var color = null;\\n    color = object.get('stroke');\\n    if (color) {\\n      this.currentColor = color;\\n    } else {\\n      this.currentColor = pluginsNamespace.ColorpickerControl.TRANSPARENT;\\n    }\\n  };\\n\\n\\n  /**\\n   * Sets this.currentBorder same as object stroke,\\n   * if object border patten matches with one of predefined patterns.\\n   *\\n   * @param  {fabric.Object} object\\n   */\\n  ShapeBorder.prototype.updateStrokeFromObject = function(object) {\\n      // get stroke params\\n      var shapeDashArray = object.get('strokeDashArray');\\n      var shapeDashWidth = object.get('strokeWidth');\\n      // search for pattern\\n      for (var b in this.options.borderTypes) {\\n        if (Object.prototype.hasOwnProperty.call(this.options.borderTypes, b)) {\\n          var bType = this.options.borderTypes[b];\\n\\n          var dashArrayEquals = JSON.stringify(bType.dashArray) === JSON.stringify(shapeDashArray);\\n\\n          if (!bType.dashArray && !shapeDashArray) {\\n            dashArrayEquals = true;\\n          }\\n\\n          if (dashArrayEquals && bType.width == shapeDashWidth) {\\n            this.currentBorder = bType;\\n          }\\n        }\\n      }\\n  };\\n\\n\\n  /**\\n   * Apply selected border style to added object.\\n   *\\n   * @param evt\\n   * @param fabricEvent\\n   */\\n  ShapeBorder.prototype._onObjectAdded = function (evt, fabricEvent) {\\n    // do not react on object:added, if canvas is not loaded fully\\n    if (this.drawer.mode != this.drawer.MODE_ACTIVE)\\n      return;\\n\\n    var currentShape = fabricEvent.target;\\n\\n    this.applyBorderStyle(currentShape);\\n    this.drawer.fCanvas.renderAll();\\n  };\\n\\n\\n  /**\\n   * Update controls a\\n   * If activated tool is Line/Arrow:\\n   * 1) save old values of borderColor and border type\\n   * 2) make current border color same as drawer active color\\n   * 3) make current border 'Solid thin'\\n   * @param {BaseTool} tool\\n   */\\n  ShapeBorder.prototype.onActivateTool = function ( tool) {\\n\\n    if (tool instanceof pluginsNamespace.Line ||\\n      tool instanceof pluginsNamespace.ArrowOneSide ||\\n      tool instanceof pluginsNamespace.ArrowTwoSide) {\\n        this.colorBeforeLineShape = this.currentColor;\\n        this.borderBeforeLineShape = this.currentBorder;\\n\\n        this.currentColor = this.drawer.activeColor;\\n        this.currentBorder = this.options.borderTypes[\\\"Solid thin\\\"];\\n        this.updateControls();\\n    } else if (this.colorBeforeLineShape !== undefined) {\\n        this.currentColor = this.colorBeforeLineShape;\\n        this.currentBorder = this.borderBeforeLineShape;\\n\\n        delete this.colorBeforeLineShape;\\n        delete this.borderBeforeLineShape;\\n        this.updateControls();\\n    }\\n  };\\n\\n\\n\\n  /**\\n   * Creates controls and adds them to toolbar.\\n   * @param {EaselToolbar} toolbar to add control to\\n   */\\n  ShapeBorder.prototype.createControls = function (toolbar) {\\n    var _this = this;\\n\\n    // ------ color button -----------\\n    this.colorButton = this.colorpicker.createControl(toolbar, this.onColorSelected.bind(this));\\n    this.colorpicker.setColor(this.options.color);\\n\\n    // rewrite this, ugh...\\n    this.colorButton.css('display', 'inline-block');\\n    this.colorButton.find('.toolbar-label').text(this.drawer.t('Border:'));\\n    // ------ /color button -----------\\n\\n    // ------ border type button -----------\\n    _this.$borderTypeButton = $(\\n      '<li class=\\\"editable-canvas-border-type\\\" ' +\\n          'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n          '>' +\\n      '<span class=\\\"toolbar-label editable-canvas-border-type-label list-item-range\\\">' +\\n      this.drawer.t('Border type:') + ' ' +\\n      '</span>' +\\n      '<span class=\\\"border-type-indicator\\\" ' +\\n            'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n            '>' +\\n      '</span>' +\\n      '<span class=\\\"border-type-dropdown toolbar-dropdown-block hidden\\\" ' +\\n            'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n            // 'data-editable-canvas-cssrules=\\\"top\\\"' +\\n      '>' +\\n      '</span>' +\\n      '</li>');\\n\\n\\n    _this.isDropdownVisible = false;\\n\\n    _this.$borderTypeButton.$dropdown = _this.$borderTypeButton.find('.border-type-dropdown');\\n    _this.$borderTypeButton.$indicator = _this.$borderTypeButton.find('.border-type-indicator');\\n\\n    util.bindClick(_this.$borderTypeButton, 'border-type-dropdown', _this.toggleStyleDropdown.bind(_this));\\n\\n    var $borderTypes = $('<ul></ul>');\\n    _this.$borderTypeButton.$dropdown.append($borderTypes);\\n\\n    var borderTypeHandler = function (event) {\\n      var $target = $(event.target),\\n          borderTypeName = $target.attr('data-border-type');\\n      if (borderTypeName) {\\n        _this.currentBorder = _this.options.borderTypes[borderTypeName];\\n        _this.onColorSelected();\\n\\n        event.stopPropagation();\\n        event.preventDefault();\\n      }\\n    };\\n\\n    for (var borderTypeName in this.options.borderTypes) {\\n      if (Object.prototype.hasOwnProperty.call(this.options.borderTypes, borderTypeName)) {\\n        var borderDefinition = this.options.borderTypes[borderTypeName];\\n\\n        var li = $(\\n          '<li data-border-type=\\\"' + borderTypeName + '\\\"' +\\n          'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n          // 'data-editable-canvas-cssrules=\\\"height,line-height\\\">' +\\n          // 'data-editable-canvas-cssrules=\\\"line-height\\\">' +\\n          '</li>');\\n        if (borderDefinition.preview) {\\n          li.css('background-image', 'url(' + borderDefinition.preview + ')');\\n        }\\n        if (borderDefinition.description) {\\n          li.text(borderDefinition.description);\\n        }\\n        util.bindClick(li, 'border-type', borderTypeHandler);\\n\\n        $borderTypes.append(li);\\n      }\\n    }\\n\\n    toolbar.addControl(_this.$borderTypeButton, this.options.buttonOrder);\\n    // ------ /border type button -----------\\n\\n    _this.onColorSelected();\\n    _this.hideControls();\\n  };\\n\\n\\n  /**\\n   * React on user color selection\\n   * @param  {String} selectedColor\\n   */\\n  ShapeBorder.prototype.onColorSelected = function (selectedColor) {\\n    if (selectedColor) {\\n      this.currentColor = selectedColor;\\n    }\\n\\n    this.updateControls();\\n\\n    if (this.drawer.fCanvas) {\\n      var currentShape = this.drawer.fCanvas.getActiveObject();\\n      if (currentShape) {\\n        this.applyBorderStyle(currentShape);\\n      }\\n      this.drawer.fCanvas.renderAll();\\n    }\\n  };\\n\\n\\n  /**\\n   * Apply current border style to object\\n   * @todo @refactor\\n   * @param  {fabric.Object} fabricObject\\n   */\\n  ShapeBorder.prototype.applyBorderStyle = function (fabricObject) {\\n    if (util.isShape(fabricObject) || fabricObject instanceof fabric.Line) {\\n      if (this.currentBorder.color) {\\n        fabricObject.set('stroke', this.currentBorder.color);\\n      } else {\\n        fabricObject.set('stroke', this.currentColor);\\n      }\\n\\n      fabricObject.set('strokeWidth', this.currentBorder.width);\\n      if (this.currentBorder.dashArray) {\\n        fabricObject.set('strokeDashArray', this.currentBorder.dashArray);\\n      } else {\\n        fabricObject.set('strokeDashArray', null);\\n      }\\n\\n      util.applyStrokePenStyle(fabricObject);\\n    }\\n  };\\n\\n\\n  /**\\n   * Updates UI to reflect selected border and color.\\n   * Hides colorpicker if current border is 'None'\\n   */\\n  ShapeBorder.prototype.updateControls = function () {\\n    // update color button\\n    this.colorpicker.setColor(this.currentColor);\\n\\n    // hide dropdowns when something is selected\\n    this.hideStyleDropdown();\\n\\n    // also hide color button when border None is selected\\n    if (this.currentBorder.description == 'None') {\\n      this.colorpicker.hideControls();\\n    } else {\\n      this.colorpicker.showControls();\\n    }\\n\\n    // set indicator background\\n    var $indicator = this.$borderTypeButton.find('.border-type-indicator');\\n    var background = this.currentBorder.preview ? 'url(' + this.currentBorder.preview + ')'\\n                                                : 'none';\\n    $indicator.css('background-image',background);\\n\\n    // set indicator text\\n    if (this.currentBorder.description) {\\n      $indicator.text(this.drawer.t(\\n        this.currentBorder.description\\n      ));\\n    } else {\\n      $indicator.text('');\\n    }\\n  };\\n\\n\\n  ShapeBorder.prototype.showControls = function () {\\n    this.colorpicker.showControls();\\n    this.$borderTypeButton.show();\\n  };\\n\\n  ShapeBorder.prototype.hideControls = function () {\\n    this.colorpicker.hideControls();\\n    this.$borderTypeButton.hide();\\n  };\\n\\n\\n  ShapeBorder.prototype.toggleStyleDropdown = function() {\\n    var needToShow = !this.isDropdownVisible;\\n    if (needToShow) {\\n      this.showStyleDropdown();\\n    } else {\\n      this.hideStyleDropdown();\\n    }\\n  };\\n\\n  ShapeBorder.prototype.hideStyleDropdown = function() {\\n    this.$borderTypeButton.$dropdown.addClass('hidden');\\n    this.isDropdownVisible = false;\\n    if (this.$clonedDropdown) {\\n      this.$clonedDropdown.remove();\\n    }\\n  };\\n\\n  ShapeBorder.prototype.showStyleDropdown = function() {\\n    this.$borderTypeButton.$dropdown.removeClass('hidden');\\n    this.isDropdownVisible = true;\\n\\n    var toolbar = this.drawer && this.drawer.toolbars && this.drawer.toolbars.toolOptionsToolbar,\\n        toolbarOptions = toolbar && toolbar.options,\\n        notInsidePopup = toolbarOptions && toolbarOptions.position !== 'popup',\\n        outside = toolbarOptions && toolbarOptions.positionType === 'outside',\\n        insideScrollable = toolbarOptions && toolbarOptions.compactType === 'scrollable',\\n        toolbarHaveScrollable = notInsidePopup && outside && insideScrollable;\\n    if (toolbarHaveScrollable) {\\n      var $dropdown = this.$borderTypeButton.$dropdown,\\n          clone;\\n\\n      $dropdown.removeClass('hidden');\\n      clone = $dropdown.clone(true);\\n\\n      this.$borderTypeButton.$dropdown.closest('.toolbar-placeholder').append(clone);\\n      clone.addClass('border-type-dropdown-cloned');\\n      this.$clonedDropdown = clone;\\n\\n      var drawerSizes = util.getScrollOffset(this.drawer.$canvasEditContainer),\\n          parentSizes = util.getScrollOffset(this.$borderTypeButton),\\n          canvasRect = this.drawer.$canvasEditContainer.get(0).getBoundingClientRect();\\n\\n      var buttonSizes = this.$borderTypeButton.get(0).getBoundingClientRect(),\\n          buttonCenter = buttonSizes.left + buttonSizes.width/2,\\n          clonedDropdownOffset = (buttonCenter - canvasRect.left - (parentSizes.left - drawerSizes.left)) - this.$clonedDropdown.width() / 2;\\n\\n      var offsetRightFromCss = 12,\\n          toRightOffset = buttonSizes.left + buttonSizes.width - canvasRect.left - (parentSizes.left - drawerSizes.left) - this.$clonedDropdown.width() - offsetRightFromCss;\\n      this.$clonedDropdown.css({\\n        'left': toRightOffset\\n      });\\n      $dropdown.addClass('hidden');\\n    }\\n  };\\n\\n  pluginsNamespace.ShapeBorder = ShapeBorder;\\n\\n}(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions, Easel.util));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-text/Text.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/Clipping.js\"))","module.exports = \"/**\\n * Drawing tools toolbar\\n *\\n * @param {Easel.Easel} drawerInstance\\n * @param {Object} [options]\\n * @extends EaselToolbar\\n * @constructor\\n */\\nvar DrawingToolsToolbar = function (drawerInstance, options) {\\n  options.toolbarClass = 'drawing-tools-toolbar';\\n  this.eventNameSpace = '.toolbar-drawingTools';\\n\\n  // call super constructor\\n  EaselToolbar.call(this, drawerInstance, options);\\n  this._injectExportButton();\\n  this._setEaselHandlers();\\n  drawerInstance.trigger(drawerInstance.EVENT_TOOLS_TOOLBAR_CREATED, [this]);\\n};\\n\\nDrawingToolsToolbar.prototype = Object.create(EaselToolbar.prototype);\\nDrawingToolsToolbar.prototype.constructor = EaselToolbar;\\n\\n/**\\n * Attach drawer events handlers\\n * @private\\n */\\nDrawingToolsToolbar.prototype._setEaselHandlers = function() {\\n  var drawerInstance = this.drawerInstance,\\n      ns = this.eventNameSpace;\\n  // @todo - move this to some other place!\\n  // on activating tool - remember it in lastUsedPluginName\\n  drawerInstance.off(drawerInstance.EVENT_DO_ACTIVATE_TOOL + ns);\\n  drawerInstance.on(drawerInstance.EVENT_DO_ACTIVATE_TOOL + ns, function (e, tool) {\\n    drawerInstance.lastUsedPluginName = tool.name;\\n  });\\n\\n  // @todo - move this to some other place!\\n  // if tool was manually switched off - reset lastUsedPluginName\\n  drawerInstance.off(drawerInstance.EVENT_DO_DEACTIVATE_TOOL + ns);\\n  drawerInstance.on(drawerInstance.EVENT_DO_DEACTIVATE_TOOL + ns, function(e, tool) {\\n    if (drawerInstance.lastUsedPluginName == tool.name) {\\n      drawerInstance.lastUsedPluginName = null;\\n    }\\n  });\\n\\n  drawerInstance.off(drawerInstance.AFTER_CREATE_TOOLBARS + ns);\\n  drawerInstance.on(drawerInstance.AFTER_CREATE_TOOLBARS + ns, function() {\\n    drawerInstance.activateDefaultPlugin();\\n  });\\n};\\n\\nDrawingToolsToolbar.prototype._injectExportButton = function () {\\n  var drawerInstance = this.drawerInstance;\\n  if (!drawerInstance) {\\n    return;\\n  }\\n\\n  var pluginConfig = drawerInstance.options && drawerInstance.options.pluginsConfig;\\n  var exportConfig = pluginConfig && pluginConfig.ExportSVG;\\n  var pluginHandlesButton = exportConfig && exportConfig.renderToolbarButton === true;\\n\\n  if (pluginHandlesButton) {\\n    return;\\n  }\\n\\n  var buttonConfig = {\\n    additionalClass: 'btn-export-svg',\\n    iconClass: 'fa-download',\\n    tooltipText: drawerInstance.t('Export as SVG'),\\n    buttonOrder: 900,\\n    clickHandler: function (event) {\\n      event.preventDefault();\\n      this._triggerExportSvg();\\n    }.bind(this)\\n  };\\n\\n  this.addButton(buttonConfig);\\n};\\n\\nDrawingToolsToolbar.prototype._triggerExportSvg = function () {\\n  var exportPlugin = this._getOrCreateExportPlugin();\\n  if (exportPlugin && typeof exportPlugin.exportCanvas === 'function') {\\n    exportPlugin.exportCanvas();\\n  }\\n};\\n\\nDrawingToolsToolbar.prototype._getOrCreateExportPlugin = function () {\\n  var drawerInstance = this.drawerInstance;\\n  if (!drawerInstance) {\\n    return null;\\n  }\\n\\n  var plugin = this._findExportPluginInstance();\\n  if (plugin) {\\n    return plugin;\\n  }\\n\\n  drawerInstance.options = drawerInstance.options || {};\\n  drawerInstance.options.pluginsConfig = drawerInstance.options.pluginsConfig || {};\\n  drawerInstance.options.pluginsConfig.ExportSVG = drawerInstance.options.pluginsConfig.ExportSVG || {};\\n  if (typeof drawerInstance.options.pluginsConfig.ExportSVG.renderToolbarButton === 'undefined') {\\n    drawerInstance.options.pluginsConfig.ExportSVG.renderToolbarButton = false;\\n  }\\n\\n  if (!Array.isArray(drawerInstance.options.corePlugins)) {\\n    drawerInstance.options.corePlugins = [];\\n  }\\n  if (drawerInstance.options.corePlugins.indexOf('ExportSVG') === -1) {\\n    drawerInstance.options.corePlugins.push('ExportSVG');\\n  }\\n\\n  if (typeof drawerInstance.loadPlugin === 'function') {\\n    drawerInstance.loadPlugin('ExportSVG');\\n    plugin = this._findExportPluginInstance();\\n  }\\n\\n  return plugin;\\n};\\n\\nDrawingToolsToolbar.prototype._findExportPluginInstance = function () {\\n  var drawerInstance = this.drawerInstance;\\n  if (!drawerInstance || !drawerInstance._pluginsInstances) {\\n    return null;\\n  }\\n\\n  return drawerInstance._pluginsInstances.ExportSVG || null;\\n};\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextFontFamily.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasablePath.js\"))","module.exports = \"(function($, BaseShape, pluginsNamespace, util) {\\n  /**\\n   * Provides a diamond button which can be used to draw rhombus shapes.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {String} [options.centeringMode='normal']\\n   * Defines centering method when drawing a shape.\\n   * <br><br>\\n   * Valid values are:\\n   * <br><br>\\n   * <code>normal</code>: diamond's top left corner will be placed to the\\n   * position of first mouse click and will be resized from that point.\\n   * <br><br>\\n   * <code>from_center</code>: diamond's center point will be placed to the\\n   * position of first mouse click and will be resized from center.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var Diamond = function DiamondConstructor(drawerInstance, options) {\\n    var _this = this;\\n\\n    BaseShape.call(_this, drawerInstance);\\n\\n    this.name = 'Diamond';\\n    this.btnClass = 'btn-diamond';\\n    this.faClass = 'fa-diamond';\\n    this.tooltip = drawerInstance.t('Draw a diamond');\\n\\n    this.options = options || {};\\n    this.centeringMode =\\n      this.options.centeringMode || BaseShape.CENTERING_MODE.NORMAL;\\n  };\\n\\n  Diamond.prototype = Object.create(BaseShape.prototype);\\n  Diamond.prototype.constructor = Diamond;\\n\\n  BaseShape.prototype.minShapeSize = 8;\\n\\n  Diamond.prototype.createShape = function (left, top) {\\n    this.startLeft = left;\\n    this.startTop = top;\\n\\n    var diamond = new fabric.PDiamond({\\n      width: 1,\\n      height: 1,\\n      left: left,\\n      top: top,\\n      fill: this.drawerInstance.activeColor,\\n      opacity: this.drawerInstance.activeOpacity,\\n      stroke: this.drawerInstance.activeColor,\\n      strokeWidth: 2\\n    });\\n\\n    util.applyStrokePenStyle(diamond);\\n\\n    return diamond;\\n  };\\n\\n  Diamond.prototype.updateShape = function (diamond, newLeft, newTop) {\\n    var width = newLeft - this.startLeft;\\n    var height = newTop - this.startTop;\\n\\n    if (this.centeringMode === BaseShape.CENTERING_MODE.FROM_CENTER) {\\n      width *= 2;\\n      height *= 2;\\n      diamond.set('left', newLeft - width);\\n      diamond.set('top', newTop - height);\\n    }\\n\\n    if (width > 0) {\\n      diamond.set('width', width);\\n    } else {\\n      diamond.set('left', newLeft);\\n      diamond.set('width', width * -1);\\n    }\\n\\n    if (height > 0) {\\n      diamond.set('height', height);\\n    } else {\\n      diamond.set('top', newTop);\\n      diamond.set('height', height * -1);\\n    }\\n  };\\n\\n  pluginsNamespace.Diamond = Diamond;\\n\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins, Easel.util));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Localization_en.js\"))","module.exports = \"(function ($, pluginsNamespace, util) {\\n  \\\"use strict\\\";\\n\\n  var emptyFunc = function () {};\\n\\n  var MOUSE_UP = util.mouseUp('ToggleVisibilityButton');\\n  var MOUSE_DOWN = util.mouseDown('ToggleVisibilityButton');\\n  var MOUSE_MOVE = util.mouseMove('ToggleVisibilityButton');\\n\\n  /**\\n   * Provides a button toggle toolbars visibility\\n   *\\n   * @param {Easel} drawer - Instance of {@link Easel}\\n   * @param {Object} options\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ToggleVisibilityButton = function ToggleVisibilityButtonConstructor(drawer, options) {\\n    /**\\n     * @type {Easel}\\n     */\\n    this.drawer = drawer;\\n    this._setupOptions(options);\\n    this.drawer.on(this.drawer.EVENT_FLOATING_TOOLBAR_CREATED, this._onToolbarCreated.bind(this));\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  ToggleVisibilityButton.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * React on overcanvas mode\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._onOverCanvasMode = function () {\\n    this.showNextItem();\\n    if (!this.positionInitialized) {\\n      this._setInitialPosition();\\n    }\\n  };\\n\\n  /**\\n   * On toolbar created - create tool button.\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._onToolbarCreated = function (ev, toolbar) {\\n    this.toolbar = toolbar;\\n\\n    var needToInitButton = this.checkConfigForButton();\\n    if (needToInitButton) {\\n      this.createControls(toolbar);\\n      this._onOverCanvasMode();\\n    }\\n  };\\n\\n  /**\\n   *\\n   * @param toolbar\\n   * @returns {Boolean}\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._checkToolbarForButton = function (toolbar) {\\n    var result = false;\\n    if (toolbar) {\\n    var haveButton = toolbar.options.toggleVisibilityButton,\\n        isPopup = toolbar.options.compactType === 'popup';\\n      result = haveButton && !isPopup;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Check current config of drawer for toolbars that need button\\n   * @returns {Boolean}\\n   */\\n  ToggleVisibilityButton.prototype.checkConfigForButton = function () {\\n    var drawingToolsToolbar = this.drawer.toolbars.drawingToolsToolbar,\\n        toolOptionsToolbar = this.drawer.toolbars.toolOptionsToolbar,\\n        settingsToolbar = this.drawer.toolbars.settingsToolbar,\\n\\n        drawingToolsHave = this._checkToolbarForButton(drawingToolsToolbar),\\n        toolOptionsHave = this._checkToolbarForButton(toolOptionsToolbar),\\n        settingsHave = this._checkToolbarForButton(settingsToolbar),\\n        needToInit = drawingToolsHave || toolOptionsHave || settingsHave,\\n        toolbarsForToggle = [];\\n    if (drawingToolsHave) {\\n      toolbarsForToggle.push(drawingToolsToolbar);\\n    }\\n    if (toolOptionsHave) {\\n      toolbarsForToggle.push(toolOptionsToolbar);\\n    }\\n    if (settingsHave) {\\n      toolbarsForToggle.push(settingsToolbar);\\n    }\\n    this.toolbarsForToggle = toolbarsForToggle;\\n    return needToInit;\\n  };\\n\\n  /**\\n   * @param toolbar\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype.createControls = function (toolbar) {\\n    this._createAndAddButton(toolbar);\\n    this.showButton();\\n  };\\n\\n  /**\\n   * Deletes tool button.\\n   * If  doDeleteToolbarCreationListeners is true - removes listeners of toolbar creation event.\\n   * So, tool will not appear on toolbar next time, when toolbar is created.\\n   *\\n   * @param {boolean} doDeleteToolbarCreationListeners\\n   */\\n  ToggleVisibilityButton.prototype.removeTool = function (doDeleteToolbarCreationListeners) {\\n    if (this.deleteControls) {\\n      this.deleteControls();\\n    }\\n\\n    // stop listening toolbar creation\\n    if (doDeleteToolbarCreationListeners) {\\n      this.drawer.off(this.drawer.EVENT_FLOATING_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n    }\\n  };\\n\\n\\n  /**\\n   * Move button over canvas\\n   * @param {Number} [left] - new offset of button\\n   * @param {Number} [top] - new offset of button\\n   */\\n  ToggleVisibilityButton.prototype.moveButton = function (left, top) {\\n    if (!this.positionLimit) {\\n      this.refreshPositionLimits();\\n    }\\n    left = left > this.positionLimit.left ? this.positionLimit.left : left;\\n    top = top > this.positionLimit.top ? this.positionLimit.top : top;\\n\\n    left = left < 0 ? 0 : left;\\n    top = top < 0 ? 0 : top;\\n\\n\\n    this.latestState = {\\n      left: left || 0,\\n      top: top || 0\\n    };\\n    this.$button.css({\\n      left: left + 'px',\\n      top: top + 'px'\\n    });\\n  };\\n\\n  /**\\n   * Restore initial position/state of button\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._setInitialPosition = function () {\\n    var offsetLeft = 0,\\n        offsetTop = 0,\\n        insidePlaceholders = this.drawer.toolbars.toolbarPlaceholders.inside,\\n        $insideTopPlaceholderEl = insidePlaceholders && insidePlaceholders.top && insidePlaceholders.top.$element,\\n        $insideLeftPlaceholderEl = insidePlaceholders && insidePlaceholders.left && insidePlaceholders.left.$element;\\n    if ($insideTopPlaceholderEl && $insideTopPlaceholderEl.length) {\\n      offsetTop += $insideTopPlaceholderEl.height();\\n    }\\n    if ($insideLeftPlaceholderEl && $insideLeftPlaceholderEl.length) {\\n      offsetLeft += $insideLeftPlaceholderEl.width();\\n    }\\n    this.positionInitialized = true;\\n    this.moveButton(offsetLeft, offsetTop);\\n  };\\n\\n\\n  /**\\n   * Creates and adds button to toolbar.\\n   * @param  {EaselToolbar} toolbar\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._createAndAddButton = function (toolbar) {\\n    var $button,\\n        $body = $('body'),\\n        toggleVisibilityButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-toggle-canvas hidden',\\n          iconClass: 'fa-eye',\\n          tooltipText: this.drawer.t('Toggle toolbar vision')\\n        };\\n    $button = toolbar.addButton(toggleVisibilityButtonConf);\\n\\n    this.$button = $button;\\n\\n    var buttonLeft = (this.latestState && this.latestState.left) || 0,\\n        buttonTop = (this.latestState && this.latestState.top) || 0;\\n    this.moveButton(buttonLeft, buttonTop);\\n    // set all mouse handlers:\\n    // handle mouse move while tool is active\\n    $body.off(MOUSE_MOVE).on(MOUSE_MOVE, this._onMouseMove.bind(this));\\n\\n    // handle mouse down and mouse up\\n    $button.off(MOUSE_DOWN).on(MOUSE_DOWN, this._onMouseDown.bind(this));\\n    $body.off(MOUSE_UP).on(MOUSE_UP, this._onMouseUp.bind(this));\\n\\n    // util.bindLongPress($button, 'move-button');\\n\\n  };\\n\\n\\n\\n  /**\\n   * React on mouse down\\n   * @param {Event} event\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._onMouseDown = function (event) {\\n    // turn erasing on\\n    var self = this;\\n    this.moveNow = true;\\n    this.triggerClick = true;\\n\\n    this.refreshSizes();\\n    this.refreshPositionLimits();\\n\\n    util.setTimeout(function () {\\n      self.triggerClick = false;\\n    }, 200);\\n  };\\n\\n\\n  /**\\n   * React on mouse up\\n   * @param {Event} event\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._onMouseUp = function (event) {\\n    var self = this,\\n        isButton = event.target === this.$button.get(0) || this.$button.find(event.target).length;\\n    this.moveNow = false;\\n    this.dragNow = false;\\n    this.$button.removeClass('dragging');\\n    if (isButton && this.triggerClick && !this.touchRightNow) {\\n      this.triggerClick = false;\\n      this.touchRightNow = true;\\n      util.setTimeout(function () {\\n        self.touchRightNow = false;\\n      }, 400);\\n      this.showNextItem();\\n    }\\n  };\\n\\n  /**\\n   * Listens for mouse movement\\n   * @param {Event} event\\n   * @private\\n   */\\n  ToggleVisibilityButton.prototype._onMouseMove = function (event) {\\n    if (this.moveNow) {\\n\\n      if (!this.dragNow) {\\n        this.$button.addClass('dragging');\\n        this.dragNow = true;\\n      }\\n      if (!this.latestSizes) {\\n        this.refreshSizes();\\n      }\\n      var eventPos = util.getEventPosition(event),\\n          latestSizes = this.latestSizes,\\n          canvasSize = latestSizes.canvas;\\n\\n      var left = eventPos.left - canvasSize.left - latestSizes.button.width/2 - latestSizes.scroll.left;\\n      var top = eventPos.top - canvasSize.top - latestSizes.button.height/2 - latestSizes.scroll.top;\\n\\n      this.triggerClick = false;\\n      this.moveButton(left, top);\\n\\n      event.preventDefault();\\n      event.stopPropagation();\\n    }\\n  };\\n\\n  /**\\n   * Refresh max sizes of button offset\\n   */\\n  ToggleVisibilityButton.prototype.refreshSizes = function () {\\n    var result = {};\\n\\n    var fCanvas = this.drawer.fCanvas,\\n        canvasSizeBox = fCanvas.upperCanvasEl.getBoundingClientRect(),\\n        buttonSizeBox = this.$button[0].getBoundingClientRect();\\n    result.canvas = canvasSizeBox;\\n    result.button = buttonSizeBox;\\n    result.scroll = util.getScrollTopFromElement(this.$button);\\n    this.latestSizes = result;\\n    return result;\\n  };\\n\\n  /**\\n   *\\n   */\\n  ToggleVisibilityButton.prototype.refreshPositionLimits = function () {\\n    var buttonSize = this.$button.get(0).getBoundingClientRect(),\\n        borderSize = 2;\\n    this.positionLimit = {\\n      left: this.drawer.width - buttonSize.width - borderSize,\\n      top: this.drawer.height - buttonSize.height - borderSize,\\n    };\\n  };\\n\\n  /**\\n   * Show button\\n   */\\n  ToggleVisibilityButton.prototype.showButton = function () {\\n    this.$button.removeClass('hidden');\\n  };\\n  \\n  /**\\n   * Hide button\\n   */\\n  ToggleVisibilityButton.prototype.hideButton = function () {\\n    this.$button.addClass('hidden');\\n  };\\n\\n  /**\\n   * Toggle current visible toolbar\\n   */\\n  ToggleVisibilityButton.prototype.showNextItem = function () {\\n    var self = this,\\n        haveVisible,\\n        nextToolbar,\\n        firstToolbar = this.toolbarsForToggle[0];\\n    this.toolbarsForToggle.forEach(function(toolbar, i){\\n      if (!toolbar.invisible) {\\n        var indexOfNextToolbar = i +1;\\n        haveVisible = true;\\n        nextToolbar = self.toolbarsForToggle[indexOfNextToolbar];\\n      }\\n      toolbar.hideToolbar();\\n    });\\n    if (haveVisible) {\\n      if (nextToolbar) {\\n        nextToolbar.showToolbar();\\n      }\\n    } else {\\n      firstToolbar.showToolbar();\\n    }\\n  };\\n\\n  pluginsNamespace.ToggleVisibilityButton = ToggleVisibilityButton;\\n})(jQuery, Easel.plugins, Easel.util);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/BaseShape.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/instances/OverCanvasToolbar.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-fullscreen/FullscreenModeButton.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/options-shape-border/ShapeBorder.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Easel.Events.js\"))","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions, util) {\\n  'use strict';\\n\\n  /**\\n   * Provides input for changing width of line/arrow.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} [options] - Configuration object\\n   * @param {Number} [options.digitsAfterDecimalPoint=0] - The number of digits to appear after the decimal point;\\n   *\\n   * @constructor\\n   * @memberof Easel.options\\n   * @extends {Easel.plugins.BaseToolOptions}\\n   */\\n  var StrokeWidth = function StrokeWidthConstructor(drawer, options) {\\n    // call super c-tor\\n    BaseToolOptions.call(this, drawer);\\n    this._setupOptions(options);\\n  };\\n\\n  StrokeWidth.prototype = Object.create(BaseToolOptions.prototype);\\n  StrokeWidth.prototype.constructor = BaseToolOptions;\\n\\n  StrokeWidth.prototype.name = 'StrokeWidth';\\n  StrokeWidth.prototype.optionName = 'strokeWidth';\\n  // StrokeWidth.prototype.useCombobox = true;\\n  // StrokeWidth.prototype.buttonMode = true;\\n  // StrokeWidth.prototype.preventHightlight = true;\\n  StrokeWidth.prototype.useCombobox = false;\\n  StrokeWidth.prototype.preventHightlight = false;\\n  StrokeWidth.prototype.buttonMode = false;\\n\\n  StrokeWidth.prototype.buttonIconClass = 'fa-arrows-h';\\n\\n  StrokeWidth.prototype._defaultOptions = {\\n    digitsAfterDecimalPoint: 0\\n  };\\n\\n  StrokeWidth.prototype.onSelectionCleared = function (toolbar) {\\n    this.data = false;\\n  };\\n\\n  StrokeWidth.prototype.createControls = function (toolbar) {\\n    this.createControl(toolbar);\\n    this._attachEvents();\\n  };\\n\\n  /**\\n   * Get html of control\\n   * @returns {string} result - html of controls\\n   * @private\\n   */\\n  StrokeWidth.prototype._generateHtml = function () {\\n    var result,\\n        selectHtml;\\n\\n    selectHtml = '' +\\n        '<select ' +\\n        'class=\\\"editable-canvas-stroke-width-input controls-value-item\\\" ' +\\n        'name=\\\"drawer-size\\\"' +\\n        'data-name=\\\"strokeWidth\\\"' +\\n        '>' +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper toolbar-item-range editable-canvas-stroke-width hidden',\\n        optionItemAdditionalClasses = '' +\\n            (this.buttonMode ? ' toolbar-button-item ' : '') +\\n            (this.preventHightlight ? ' prevent-highlight ' : ''),\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n          '<div class=\\\"toolbar-item-description\\\">' +\\n            '<span class=\\\"toolbar-label editable-canvas-stroke-width-label\\\">' +\\n              this.drawer.t('Stroke width:') + ' ' +\\n            '</span>' +\\n            '<span class=\\\"toolbar-label toolbar-label-indicator editable-canvas-stroke-width-indicator\\\"></span>' + '' +\\n          '</div>' +\\n          '<input ' +\\n            'class=\\\"editable-canvas-stroke-width-input controls-value-item\\\" ' +\\n            'name=\\\"drawer-stroke-width\\\"' +\\n            'data-name=\\\"strokeWidth\\\"' +\\n            'type=\\\"range\\\"' +\\n            'min=\\\"1\\\"' +\\n            'max=\\\"50\\\"' +\\n          '>' +\\n        '</li>';\\n    return result;\\n  };\\n\\n  /**\\n   * Create/add controls\\n   * @param {EaselToolbar} toolbar\\n   * @returns {jQuery}\\n   * @private\\n   */\\n  StrokeWidth.prototype.createControl = function (toolbar) {\\n    var toolControlHtml = this._generateHtml();\\n    this.$toolControl = $(toolControlHtml);\\n    this.$valueIndicator = this.$toolControl.find('.editable-canvas-stroke-width-indicator');\\n    toolbar.addControl(this.$toolControl, this.options.buttonOrder);\\n    return this.$toolControl;\\n  };\\n\\n  /**\\n   * Attach events for control element\\n   * @private\\n   */\\n  StrokeWidth.prototype._attachEvents = function () {\\n    if (this.$toolControl) {\\n      this.$toolControl.on('input change toolbarOptionChange', this.onInputChange.bind(this));\\n    }\\n  };\\n\\n\\n  /**\\n   * Validate width value\\n   * @param rawValue\\n   * @returns {*}\\n   */\\n  StrokeWidth.prototype.validateValue = function (rawValue) {\\n    rawValue = parseInt(rawValue, 10);\\n    var result,\\n        rawValueIsValid = typeof rawValue === 'number' && isFinite(rawValue) && rawValue;\\n    if (rawValueIsValid) {\\n      var decimalRatio = Math.pow(10, this.options.digitsAfterDecimalPoint),\\n          formattedValue = parseInt(rawValue * decimalRatio, 10) / decimalRatio;\\n      result = formattedValue;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Set line width of current active object\\n   * @param {number|string} value - Width of line/arrow in px\\n   */\\n  StrokeWidth.prototype.setStrokeWidth = function (value) {\\n    value =  parseInt(value, 10);\\n    var fCanvas = this.drawer.fCanvas,\\n        target = fCanvas.getActiveObject();\\n    this.drawer.lineStrokeWidth = value;\\n    if (target) {\\n      if (!this.data) {\\n        this.collectDataFromObject(target);\\n      }\\n      target.set('left',this.data.left);\\n      target.set('top',this.data.top);\\n      target.set('strokeWidth', parseInt(value, 10));\\n      fCanvas.renderAll();\\n    }\\n  };\\n\\n  /**\\n   * This function is called every time user changes width via control\\n   * @private\\n   */\\n  StrokeWidth.prototype.onInputChange = function () {\\n    var $opacityInput = $(this.$toolControl).find('input'),\\n        rawValue = $opacityInput.val(),\\n        validatedValue = this.validateValue(rawValue);\\n    this.$valueIndicator.text(validatedValue + 'px');\\n    this.setStrokeWidth(validatedValue);\\n  };\\n\\n  StrokeWidth.prototype.collectDataFromObject = function (target) {\\n    var result = {},\\n        decimalRatio = Math.pow(10, this.options.digitsAfterDecimalPoint),\\n        strokeWidth = target.strokeWidth;\\n    result.strokeWidth = strokeWidth;\\n    result.top = target.top;\\n    result.left = target.left;\\n\\n    this.data = result;\\n    return result;\\n  };\\n\\n  StrokeWidth.prototype.updateControls = function (dataToFill) {\\n    dataToFill = dataToFill || this.data;\\n    var rawValue = dataToFill.strokeWidth,\\n        validatedValue = this.validateValue(rawValue);\\n    this.drawer.lineStrokeWidth = validatedValue;\\n    this.$toolControl.find('input').val(validatedValue);\\n    this.$valueIndicator.text(validatedValue + 'px');\\n  };\\n\\n  StrokeWidth.prototype.showControls = function () {\\n    this.$toolControl.removeClass('hidden');\\n  };\\n\\n  StrokeWidth.prototype.hideControls = function (force) {\\n    this.$toolControl.addClass('hidden');\\n  };\\n\\n  pluginsNamespace.StrokeWidth = StrokeWidth;\\n}(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions, Easel.util));\"","module.exports = \"(function ($, EaselApi, util) {\\n  'use strict';\\n  var emptyFunc = function(){};\\n\\n  /**\\n   * Check if image have valid width/height\\n   * @param {Image} image\\n   * @returns {Boolean}\\n   */\\n  function checkImageSizes(image) {\\n    var result = false;\\n    if (image) {\\n      var widthIsValid = image.naturalWidth !== undefined && image.naturalWidth !== 0,\\n          heightIsValid = image.naturalHeight !== undefined && image.naturalHeight !== 0,\\n          sizesAreValid = widthIsValid && heightIsValid;\\n      result = sizesAreValid;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * Set image from url as inactive background image of drawer\\n   * @param {String} imageUrl - url of image\\n   * @private\\n   */\\n  function _setImageAsInactiveBackground(imageUrl) {\\n    var styleSelector = '.editable-canvas-not-edited',\\n        styleRules = '' +\\n            'background: url(' + imageUrl + ') !important;' +\\n            'background-repeat: no-repeat !important;' +\\n            'background-position: center !important;' +\\n            'background-size: contain !important;';\\n    util.addStyleToStyleSheet(styleSelector, styleRules, '#canvasInactiveImage', true);\\n  }\\n\\n\\n  /**\\n   * Sets background image for inactive canvas from given image object.\\n   *\\n   * @param {Image|String} image - js Image object or url string\\n   */\\n  EaselApi.prototype.setInactiveEaselImage = function (image) {\\n    if (image) {\\n      var valueIsUrl = typeof image === 'string' && image.length,\\n          valueIsImage = image instanceof Image,\\n          valueIsValid = valueIsUrl || valueIsImage,\\n          urlOfImage = valueIsUrl ? image : image.src,\\n          imgIsLoaded,\\n          imgIsValid;\\n\\n      if (valueIsValid) {\\n        imgIsLoaded = valueIsImage && image.complete && checkImageSizes(image);\\n        if (imgIsLoaded) {\\n          _setImageAsInactiveBackground(urlOfImage);\\n        } else {\\n          util.loadImage(urlOfImage, null, null, true).then(function (imgFromPromise) {\\n            imgIsValid = checkImageSizes(imgFromPromise);\\n            if (imgIsValid) {\\n              _setImageAsInactiveBackground(imgFromPromise.src);\\n            }\\n          });\\n        }\\n      }\\n    }\\n  };\\n\\n\\n\\n})(jQuery, Easel.EaselApi, Easel.util);\"","module.exports = \"    (function (global) {\\n\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {}),\\n        extend = fabric.util.object.extend;\\n\\n    /**\\n     * @class\\n     * @extends fabric.IText\\n     */\\n    fabric.PText = fabric.util.createClass(fabric.IText, {\\n        type: 'PText',\\n\\n        _defaultOptions : {\\n            editIconMode    : true,\\n        },\\n\\n        /**\\n         * List of options to show when object is selected\\n         * @type {Array}\\n         */\\n        objectOptionsList : [\\n          'border',\\n          'opacity'\\n        ],\\n\\n        /**\\n         * Initializes object.\\n         * @param  {String} text\\n         * @param  {Object} options\\n         * @param  {boolean} options.editIconMode edit icon size, in pixels\\n         * @param  {number|String} options.editIconSize edit icon size, in pixels or strings:  small, medium, large\\n         */\\n        initialize: function (text, options) {\\n            this.callSuper('initialize', text, options);\\n\\n            this.options =  $.extend(true, this._defaultOptions || {}, options || {});\\n\\n            // create icon\\n            var iconPath = null,\\n                editIconSize = this.options.editIconSize || 32,\\n                domSize = Math.max(12, Math.round(editIconSize / 2));\\n\\n            // initialize control\\n          if (this.options.editIconMode) {\\n            var controlOptions = $.extend(true, {}, this.options, {\\n              useDomControl: true,\\n              domClassName: 'crop-corner crop-top-right text-edit-corner',\\n              domSize: domSize,\\n              domOffsetX: domSize / 2 + 4,\\n              domOffsetY: -domSize / 2 - 4\\n            });\\n\\n            this.startEditControl = new ObjectFloatingControl(this, iconPath, this._iconClickHandler.bind(this), controlOptions);\\n          }\\n        },\\n      /**\\n       * Copied from fabric js - add support of useCopiedStyles\\n       * Handles onInput event\\n       * @param {Event} e Event object\\n       */\\n      onInput: function(e) {\\n        if (!this.isEditing || this.inCompositionMode) {\\n          return;\\n        }\\n        var offset = this.selectionStart || 0,\\n            offsetEnd = this.selectionEnd || 0,\\n            textLength = this.text.length,\\n            newTextLength = this.hiddenTextarea.value.length,\\n            diff, charsToInsert, start;\\n        if (newTextLength > textLength) {\\n          //we added some character\\n          start = this._selectionDirection === 'left' ? offsetEnd : offset;\\n          diff = newTextLength - textLength;\\n          charsToInsert = this.hiddenTextarea.value.slice(start, start + diff);\\n        }\\n        else {\\n          //we selected a portion of text and then input something else.\\n          //Internet explorer does not trigger this else\\n          diff = newTextLength - textLength + offsetEnd - offset;\\n          charsToInsert = this.hiddenTextarea.value.slice(offset, offset + diff);\\n        }\\n        var emptySelection = this.selectionStart === this.selectionEnd,\\n            useCopiedStyles = emptySelection && this.canvas.copiedTextStyle;\\n        this.insertChars(charsToInsert, useCopiedStyles);\\n        e.stopPropagation();\\n      },\\n\\n      renderCursorOrSelection: function (ctx) {\\n        this.canvas.fire('canvas:zoom:upper:set');\\n        this.callSuper('renderCursorOrSelection', ctx);\\n        this.canvas.fire('canvas:zoom:upper:restore');\\n\\n      },\\n\\n\\n        /**\\n         * Overriding IText mouseup handler.\\n         * This version do not trigger editing mode on second click.\\n         * This functionality is inside _iconClickHandler\\n         */\\n        initMouseupHandler: function() {\\n            this.on('mouseup', function(evt) {\\n                if (this.options.editIconMode) {\\n                    this.onMouseUpHandler(evt);\\n                } else {\\n                    this.onMouseUpSuperHandler(evt);\\n                }\\n            });\\n        },\\n\\n\\n        onMouseUpHandler : function (evt) {\\n            this.__isMousedown = false;\\n            if (!this.editable || (this._isObjectMoved && this._isObjectMoved(evt.e))) {\\n              return;\\n            }\\n\\n            this.selected = true;\\n        },\\n\\n        /**\\n         *\\n         * @see fabric.js Text.onMouseUpSuperHandler\\n         * @param  {fabric.Event} evt\\n         */\\n        onMouseUpSuperHandler : function(evt) {\\n            this.__isMousedown = false;\\n            if (!this.editable || (this._isObjectMoved && this._isObjectMoved(evt.e))) {\\n                return;\\n            }\\n\\n            if (this.__lastSelected && !this.__corner) {\\n                this.enterEditing(evt.e);\\n                if (this.selectionStart === this.selectionEnd) {\\n                    this.initDelayedCursor(true);\\n                }\\n                else {\\n                    this.renderCursorOrSelection();\\n                }\\n            }\\n\\n            this.selected = true;\\n        },\\n\\n\\n        /**\\n         * Checks, if click on canvas is inside icon rect.\\n         * If yes - launches editing mode\\n         *\\n         * @param  {fabric.Event} evt\\n         */\\n        _iconClickHandler : function(evt) {\\n            //  select current object again, it is required for proper UI work\\n            this.canvas.setActiveObject(this);\\n\\n            // enter editing and do stuff. Code is copied from IText.initMouseupHandler\\n            this.enterEditing(evt.e);\\n            if (this.selectionStart === this.selectionEnd) {\\n                this.initDelayedCursor(true);\\n            }\\n            else {\\n                this.renderCursorOrSelection();\\n            }\\n        },\\n      /**\\n       * Collect all styles which affects text\\n       *\\n       * @param  {fabric.Object} [obj] - text object\\n       * @returns {object} - styles object\\n       */\\n        getObjStyles: function (obj) {\\n          obj = obj || this;\\n          var styles = {\\n            fontSize: obj.fontSize,\\n            fill: obj.fill,\\n            textBackgroundColor: obj.textBackgroundColor,\\n            textDecoration: obj.textDecoration,\\n            fontFamily: obj.fontFamily,\\n            fontWeight: obj.fontWeight,\\n            fontStyle: obj.fontStyle,\\n            lineHeight: obj.lineHeight,\\n            stroke: obj.stroke,\\n            strokeWidth: obj.strokeWidth\\n          };\\n          return styles;\\n        },\\n\\n\\n        /**\\n         * Draws text and edit icon\\n         * @param  {Context2D} ctx\\n         */\\n        render : function (ctx) {\\n          this.callSuper('render', ctx);\\n        },\\n\\n\\n        toObject: function (propertiesToInclude) {\\n            return extend(this.callSuper('toObject', propertiesToInclude));\\n        }\\n\\n    });\\n\\n\\n    /**\\n     * Creates fabric object from data.\\n     * Is sync, so simply returns new object.\\n     *\\n     * @param objData\\n     * @param {function} callback\\n     */\\n    fabric.PText.fromObject = function (objData) {\\n        return new fabric.PText(objData.text, objData);\\n    };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\"","module.exports = \"(function($, BaseTool, pluginsNamespace, util) {\\n    /**\\n     * Tool to add and upload image to canvas.\\n     *\\n     * @param {Easel.Easel} drawerInstance\\n     * Instance of {@link Easel.Easel}.\\n     *\\n     * @param {Object} options\\n     * Configuration object.\\n     *\\n     * @param {Boolean} [options.scaleDownLargeImage=true]\\n     * If set to true - images. larger then canvas, will be scaled down\\n     *\\n     * @param {String[]} [options.acceptedMIMETypes=['image/jpeg', 'image/png', 'image/gif']]\\n     * If set to true - images. larger then canvas, will be scaled down\\n     *\\n     * @constructor\\n     * @memberof Easel.plugins\\n     */\\n    var ImageTool = function ImageConstructor(drawerInstance, options) {\\n        var _this = this;\\n\\n        BaseTool.call(_this, drawerInstance);\\n\\n        this.drawer = drawerInstance;\\n        this.name = 'Image';\\n        this.btnClass = 'btn-image';\\n        this.faClass = 'fa-image';\\n        this.tooltip = drawerInstance.t('Insert an image');\\n\\n        this._setupOptions(options);\\n    };\\n\\n    // Derive ImageTool from BaseTool\\n    ImageTool.prototype = Object.create(BaseTool.prototype);\\n    ImageTool.prototype.constructor = ImageTool;\\n\\n    /**\\n     * Default options\\n     * @type {{defaultMaxSize: string, scaleDownLargeImage: boolean, acceptedMIMETypes: string[]}}\\n     */\\n    ImageTool.prototype._defaultOptions = { scaleDownLargeImage : true,\\n                                           centerImage : true,\\n                                           cropIsActive : true,\\n                                           acceptedMIMETypes: ['image/jpeg', 'image/png', 'image/gif'] };\\n\\n\\n    /**\\n     * Tool activation method.\\n     * Is called in lifecycle of event Easel.EVENT_DO_ACTIVATE_TOOL.\\n     * Calls  BaseTool._activateTool .\\n     *\\n     * @private\\n     */\\n    ImageTool.prototype._activateTool = function() {\\n        var _this = this;\\n        this.drawerInstance.log('TOOL', 'Image._activateTool()');\\n        BaseTool.prototype._activateTool.call(this);\\n\\n        this._showDialog();\\n\\n        // deactivate tool. Slight delay is needed, because without it\\n        // tool is deactivated before listeners on EVENT_DO_ACTIVATE_TOOL in drawer are executed\\n        // which lead to incorrect way of setting drawer.lastUsedPluginName\\n        util.setTimeout(function(){\\n            _this.drawerInstance.trigger(_this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL, [_this]);\\n        }, 300);\\n\\n    };\\n\\n\\n    /**\\n     * Shows file open dialog\\n     * @private\\n     */\\n    ImageTool.prototype._showDialog = function() {\\n        var _this = this;\\n        var acceptedMIMEStr = this.options.acceptedMIMETypes.join(',');\\n        var $el = $('<input type=\\\"file\\\" accept=\\\"' + acceptedMIMEStr + '\\\" style=\\\"display:none;\\\">');\\n        \\n        $el.on('change', function(e) {\\n            _this._processFileInput(e);\\n            // Remove after processing\\n            setTimeout(function() {\\n                $el.remove();\\n            }, 100);\\n        });\\n        \\n        // Append to canvas container when possible so Easel does not exit edit mode\\n        var $appendTarget = this.drawerInstance.$canvasEditContainer || $('body');\\n        $appendTarget.append($el);\\n        $el.trigger('click');\\n\\n    };\\n\\n    /**\\n     * Callback to process user selected files.\\n     *\\n     * @param {Event} e\\n     * @private\\n     */\\n    ImageTool.prototype._processFileInput = function(e)  {\\n        var _this = this;\\n        var files = e.target.files;\\n        \\n        // check there was file choosen\\n        if (files.length < 1) {\\n            _this.drawerInstance.showError(this.drawerInstance.t('No file was selected!'));\\n            return;\\n        }\\n        var file = files[0];\\n\\n        // check file\\n        if (!this._checkFile(file)) {\\n            return;\\n        }\\n\\n        var fileReader = new FileReader();\\n        // on file load - create HTML5 Image from it\\n        fileReader.onload = function (onloadEvent) {\\n            _this.drawerInstance.log('IMAGE LOADED:', file.name);\\n            var triggerImageCrop = _this.options.cropIsActive && _this.drawer._pluginsInstances.ImageCrop;\\n            \\n            if (triggerImageCrop) {\\n                _this._triggerImageCrop(fileReader.result);\\n            } else {\\n                _this.loadImage(fileReader.result);\\n            }\\n        };\\n        fileReader.readAsDataURL(file);\\n    };\\n\\n\\n    /**\\n     * Makes some checks  to file.\\n     *\\n     * @param {File} file\\n     * @returns {boolean}\\n     * @private\\n     */\\n    ImageTool.prototype._checkFile = function(file) {\\n        var _this = this;\\n        // crude check of file type\\n        if(file.type.indexOf('image') < 0) {\\n            _this.drawerInstance.showError(this.drawerInstance.t('Incorrect file type!'));\\n            return false;\\n        }\\n\\n        return true;\\n    };\\n\\n\\n    /**\\n     * Load image from url/dataUrl, then call addImage()\\n     *\\n     * @param {string} dataUrl src of image or dataUrl\\n     * @private\\n     */\\n    ImageTool.prototype.loadImage = function(dataUrl, options) {\\n        var _this = this;\\n        var image = new Image();\\n\\n        // after Image was created from file data - create fabric.Image from it\\n        image.onload = function() {\\n            _this.addImage(image, options);\\n        };\\n\\n        // show error on fail\\n        image.onerror = function() {\\n            var err = _this.drawerInstance.t('Image failed to create!');\\n            _this.drawerInstance.showError(err);\\n        };\\n\\n        // this will start creating image\\n        image.src = dataUrl;\\n    };\\n\\n  /**\\n   * Init crop plugin\\n   * @param {string} image - src of image, can be base64 encoded url\\n   * @private\\n   */\\n  ImageTool.prototype._triggerImageCrop = function (image) {\\n    var dataToEvent = {\\n      url: image,\\n      callback: this.loadImage.bind(this)\\n    };\\n    this.drawerInstance.trigger(this.drawerInstance.EVENT_IMAGE_CROP, dataToEvent);\\n  };\\n\\n    /**\\n     * Adds image to canvas.\\n     *\\n     * @param {Image} image\\n     */\\n    ImageTool.prototype.addImage = function(image, options) {\\n        var fCanvas = this.drawerInstance.fCanvas;\\n        var fabricImage = new fabric.ErasableImage(image);\\n\\n        options = options ? options : this.options;\\n        if (options.scaleDownLargeImage) {\\n            this._fitLargeImage(fabricImage);\\n        } else {\\n            fabricImage.left = options.left ? options.left : 0;\\n            fabricImage.top  = options.top ? options.top : 0;\\n            fabricImage.scaleX = options.scaleX ? options.scaleX : 1;\\n            fabricImage.scaleY = options.scaleY ? options.scaleY : 1;\\n        }\\n      fabricImage.opacity = this.drawerInstance.activeOpacity;\\n\\n\\n        if (options.centerImage) {\\n            fCanvas.centerObject(fabricImage);\\n        }\\n\\n        fCanvas.add(fabricImage);\\n        fCanvas.setActiveObject(fabricImage);\\n    };\\n\\n\\n    /**\\n     * If option options.scaleDownLargeImage is set,\\n     * scales images, larger then canvas to fit it.\\n     *\\n     * @param {fabric.Image} fImage\\n     * @private\\n     */\\n    ImageTool.prototype._fitLargeImage = function(fImage) {\\n        var fCanvas = this.drawerInstance.fCanvas;\\n\\n        var w = fCanvas.width * 0.95;\\n        var h = fCanvas.height  * 0.95;\\n        var scaleX = 1.0, scaleY = 1.0;\\n        if (fImage.width > w) {\\n            scaleX =  w / fImage.width;\\n        }\\n        if (fImage.height > h) {\\n            scaleY =  h / fImage.height;\\n        }\\n        var scale = Math.min(scaleX, scaleY);\\n        fImage.set({ 'scaleX' : scale, 'scaleY' : scale});\\n    };\\n\\n    pluginsNamespace.Image = ImageTool;\\n\\n}(jQuery, Easel.plugins.BaseTool, Easel.plugins, Easel.util));\\n\"","module.exports = \"(function (namespace) {\\n\\n  /**\\n   * EraserBrush class.\\n   * The main purpose of this class is to replace created Path objects\\n   * with custom EraserPath so canvas could know how to render them.\\n   *\\n   * @class EraserBrush\\n   * @extends fabric.PencilBrush\\n   *\\n   * @memberof Easel.brushes\\n   */\\n  namespace.EraserBrush = fabric.util.createClass(fabric.PencilBrush, {\\n\\n    /**\\n     * Constructor\\n     * @param {fabric.Canvas} canvas\\n     * @return {Easel.EraserBrush} Instance of a eraser brush\\n     */\\n    initialize: function (canvas) {\\n      this.callSuper('initialize', canvas);\\n    },\\n\\n    /**\\n     * Overriding fabric.PencilBrush._render\\n     * Method code is exactly copy of fabric.PencilBrush._render,\\n     * only change is trigger events\\n     *\\n     * @see {fabric.PencilBrush._render}\\n     * @private\\n     */\\n    _render: function () {\\n      this.canvas.fire('pencil:move:before');\\n      this.callSuper('_render');\\n      this.canvas.fire('pencil:move:after');\\n    },\\n\\n    /**\\n     * Creates fabric.Path object to add on canvas\\n     * @param {String} pathData Path data\\n     * @return {fabric.Path} Path to add on canvas\\n     */\\n    createPath: function (pathData) {\\n      var path = new fabric.EraserPath(pathData, {\\n        fill: null,\\n        stroke: this.color,\\n        strokeWidth: this.width,\\n        strokeLineCap: this.strokeLineCap,\\n        strokeLineJoin: this.strokeLineJoin,\\n        strokeDashArray: this.strokeDashArray,\\n        originX: 'center',\\n        originY: 'center'\\n      });\\n\\n      if (this.shadow) {\\n        this.shadow.affectStroke = true;\\n        path.setShadow(this.shadow);\\n      }\\n\\n      return path;\\n    }\\n  });\\n\\n})(Easel.brushes);\"","module.exports = \"(function ($, brushes, BaseBrush, pluginsNamespace, util) {\\n  'use strict';\\n\\n  var MOUSE_UP = util.mouseUp('Eraser');\\n  var MOUSE_DOWN = util.mouseDown('Eraser');\\n  var MOUSE_MOVE = util.mouseMove('Eraser');\\n  var MOUSE_ENTER_CURSOR = 'mouseenter.EraserCursor';\\n  var MOUSE_LEAVE_CURSOR = 'mouseleave.EraserCursor';\\n\\n  /**\\n   * Provides an eraser which allows to erase any drawing/shapes.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {number} options.brushSize\\n   * Eraser default brush size\\n   *\\n   * @memberof Easel.plugins\\n   *\\n   * @constructor\\n   * @augments Easel.plugins.BaseBrush\\n   */\\n  var Eraser = function (drawerInstance, options) {\\n    var _this = this;\\n\\n    BaseBrush.call(_this, drawerInstance);\\n\\n    this.name = 'Eraser';\\n    this.btnClass = 'btn-eraser';\\n    this.faClass = 'fa-eraser';\\n    this.tooltip = drawerInstance.t('Eraser');\\n\\n    this.separatePathOnShapes = true;\\n\\n    _this._defaultOptions = {\\n      cursorUrl: 'none',\\n      brushSize: 3,\\n      useCoordsQueue: false,\\n      removeWholeObject: true\\n    };\\n\\n    this._setupOptions(options);\\n\\n    /**\\n     * List of tool options to show when tool is activated.\\n     * Deviating from BaseShape tool, Line has no 'color', only 'border'.\\n     * @type {String[]}\\n     */\\n    this.toolOptionsList = ['brushSize'];\\n\\n    /**\\n     *\\n     * @type {boolean}\\n     */\\n    this.forceOptionsHide = true;\\n\\n    /**\\n     * Color value before eraser tool.\\n     * @type {String}\\n     */\\n    this.previousColor = null;\\n\\n    /**\\n     * BrushSize before eraser tool. Used to separate eraser brush size from\\n     * other brushes.\\n     * @type {Number}\\n     */\\n    this.previousBrushSize = null;\\n\\n    /**\\n     * Last used eraser brush size. Used to restore eraser size after another\\n     * brush tool.\\n     * @type {Number}\\n     */\\n    this.savedBrushSize = this.options.brushSize;\\n\\n    /**\\n     * Boolean flag showing if we are in erasing mode\\n     * @type {Boolean}\\n     */\\n    this.erasingNow = false;\\n\\n    /**\\n     * Eraser brush\\n     * @type {fabric.Brush}\\n     */\\n    this.brush = null;\\n  };\\n\\n\\n  Eraser.prototype = Object.create(BaseBrush.prototype);\\n  Eraser.prototype.constructor = Eraser;\\n\\n\\n  ////// STATR/STOP TOOL METHODS ////////////////////////////////////////////////////////////////////\\n  /**\\n   * This method is called in BaseBrush._activateTool()\\n   * Children of BaseBrush MUST implement afterActivateTool()\\n   */\\n  Eraser.prototype.afterActivateTool = function () {\\n    var drw = this.drawerInstance;\\n    var fCanvas = drw.fCanvas;\\n\\n    // set cursor\\n    this._previousCursor = drw.fCanvas.freeDrawingCursor;\\n    drw.fCanvas.freeDrawingCursor = this.options.cursorUrl;\\n\\n    // set eraser brush\\n    this.brush = this._createBrush();\\n    drw.setBrush(this.brush);\\n\\n    // on brush size change - update our cursor size\\n    drw.on(drw.EVENT_BRUSH_SIZE_CHANGED, this._updateCursorShapeSize.bind(this));\\n\\n    // set all mouse handlers:\\n    // handle mouse move while tool is active\\n    $(fCanvas.upperCanvasEl).on(MOUSE_MOVE,  this._onMouseMove.bind(this));\\n\\n    // handle mouse down and mouse up\\n    $(fCanvas.upperCanvasEl).on(MOUSE_DOWN, this._onMouseDown.bind(this));\\n    $(fCanvas.upperCanvasEl).on(MOUSE_UP, this._onMouseUp.bind(this));\\n\\n    // create cursor\\n    this._createEraserCursorShape();\\n\\n    // handle mouse leave / enter canvas (to hide/show cursor)\\n    $(fCanvas.upperCanvasEl).on(MOUSE_ENTER_CURSOR, this._showEraserCursorShape.bind(this));\\n    $(fCanvas.upperCanvasEl).on(MOUSE_LEAVE_CURSOR, this._hideEraserCursorShape.bind(this));\\n\\n\\n    // on eraser path created - do work\\n    fCanvas.on('path:created', this._onEraserPathCreated.bind(this));\\n  };\\n\\n\\n  /**\\n   * After tool deactivation - remove all event handlers\\n   * This method is called in BaseBrush._activateTool()\\n   * Children of BaseBrush MUST implement afterDeactivateTool.\\n   */\\n  Eraser.prototype.afterDeactivateTool = function () {\\n    var fCanvas = this.drawerInstance.fCanvas;\\n\\n    // switch erasing off\\n    this.erasingNow = false;\\n\\n    fCanvas.off('path:created');\\n\\n    // restore cursor\\n    fCanvas.freeDrawingCursor = this._previousCursor;\\n    // remove cursorShape\\n    this._removeEraserCursorShape();\\n\\n    $(fCanvas.upperCanvasEl).off(MOUSE_MOVE);\\n    $(fCanvas.upperCanvasEl).off(MOUSE_UP);\\n    $(fCanvas.upperCanvasEl).off(MOUSE_DOWN);\\n\\n    $(fCanvas.upperCanvasEl).off(MOUSE_ENTER_CURSOR);\\n    $(fCanvas.upperCanvasEl).off(MOUSE_LEAVE_CURSOR);\\n  };\\n\\n\\n  /**\\n   * Create eraser brush\\n   */\\n  Eraser.prototype._createBrush = function () {\\n    var brush = new brushes.EraserBrush(this.drawerInstance.fCanvas);\\n\\n    brush.color = '#fff';\\n    brush.opacity = this.drawerInstance.activeOpacity;\\n    brush.width = this.options.brushSize;\\n\\n    return brush;\\n  };\\n\\n\\n  ////// ERASER CURSOR METHODS //////////////////////////////////////////////////////////////////////\\n  /**\\n   * Create shape, that will be used as eraser cursor\\n   */\\n  Eraser.prototype._createEraserCursorShape = function () {\\n    // eraser shape setup\\n    var eraserPolyRadius = this.drawerInstance.getBrushSize() / 2;\\n\\n    this.eraserCursorShape = new fabric.PCircle({\\n      radius: eraserPolyRadius\\n    });\\n\\n    this.drawerInstance.fCanvas.add(this.eraserCursorShape);\\n\\n    this.eraserCursorShape.isEraserBrush = true;\\n    this.eraserCursorShape.set('fill', 'transparent');\\n    this.eraserCursorShape.set('stroke', 'black');\\n    this.eraserCursorShape.set('strokeWidth', 1);\\n    this.eraserCursorShape.set('originX', 'center');\\n    this.eraserCursorShape.set('originY', 'center');\\n\\n    this._updateCursorShapeSize();\\n  };\\n\\n\\n  /**\\n   * Remove eraser shape, that was used as eraser cursor\\n   */\\n  Eraser.prototype._removeEraserCursorShape = function () {\\n    if(this.eraserCursorShape){\\n      this.eraserCursorShape.remove();\\n      delete this.eraserCursorShape;\\n    }\\n  };\\n\\n  /**\\n   * Show eraser cursor shape\\n   */\\n  Eraser.prototype._showEraserCursorShape = function () {\\n    this.eraserCursorShape.set('visible', true);\\n    this.drawerInstance.fCanvas.renderAll();\\n  };\\n\\n  /**\\n   * Hide eraser cursor shape\\n   */\\n  Eraser.prototype._hideEraserCursorShape = function () {\\n    this.eraserCursorShape.set('visible', false);\\n    this.drawerInstance.fCanvas.renderAll();\\n  };\\n\\n\\n  /**\\n   * Update our cursor shape size to be same as brush size\\n   */\\n  Eraser.prototype._updateCursorShapeSize = function () {\\n    if (!this.eraserCursorShape) {\\n      return;\\n    }\\n\\n    var eraserPolyRadius = this.drawerInstance.getBrushSize() / 2;\\n    var eraserPolyDashSize = (2 * Math.PI * eraserPolyRadius) / 20;\\n    this.eraserCursorShape.set('radius', eraserPolyRadius);\\n    this.eraserCursorShape.set('strokeDashArray', [\\n      eraserPolyDashSize, eraserPolyDashSize\\n    ]);\\n  };\\n\\n\\n\\n  ////// ERASER PATH METHODS //////////////////////////////////////////////////////////////////////\\n  /**\\n   * After eraser path was created - apply it to all affected shapes.\\n   * @param  {fabric.Event} e\\n   */\\n  Eraser.prototype._onEraserPathCreated = function (e) {\\n    var fCanvas = this.drawerInstance.fCanvas;\\n\\n    e.path.set('eraserPath', true);\\n    e.path.set('visible', true);\\n\\n    if (this.options.removeWholeObject) {\\n      e.path.remove();\\n      return;\\n    }\\n\\n    for (var i = 0; i < this.affectedShapes.length; i++) {\\n      var shape = this.affectedShapes[i];\\n      delete shape.eraserAffected;\\n      shape.addEraserPath(e.path);\\n    }\\n\\n    fCanvas.renderAll();\\n  };\\n\\n\\n  /**\\n   * Look, which erasable objects are under eraser.\\n   * Add them to affectedShapes[]\\n   *\\n   * @param {number} x\\n   * @param {number} y\\n   * @private\\n   */\\n  Eraser.prototype._affectShapesUnderCoords = function (x, y) {\\n    var fCanvas = this.drawerInstance.fCanvas;\\n    var allObjects = fCanvas.getObjects();\\n\\n    this.eraserCursorShape._lastCenterPosition = {x: x, y: y};\\n    for (var i = allObjects.length - 1; i >= 0; i--) {\\n      var obj = allObjects[i];\\n      // if object is non-erasable or if already affected by our eraser- skip it\\n      if (!obj.isErasable || obj.eraserAffected || obj.isEraserBrush)\\n        continue;\\n\\n      var addPathToObject = this._checkObjectIntersection(obj, x, y);\\n      if (addPathToObject) {\\n        obj.eraserAffected = true;\\n        if (this.options.removeWholeObject) {\\n          this._removeShape(obj);\\n        } else {\\n          this.affectedShapes.push(obj);\\n        }\\n      }\\n    }\\n  };\\n  \\n  Eraser.prototype._removeShape = function (shape) {\\n    if (!shape) {\\n      return;\\n    }\\n    var api = this.drawerInstance && this.drawerInstance.api;\\n    if (api && typeof api.removeObject === 'function') {\\n      api.removeObject(shape);\\n    } else {\\n      shape.remove();\\n      this.drawerInstance.fCanvas.renderAll();\\n    }\\n  };\\n\\n    /**\\n     * Check if object is intersected with eraser brush\\n     *\\n     * @param {object} obj\\n     * @param {number} x\\n     * @param {number} y\\n     * @private\\n     */\\n\\n    Eraser.prototype._checkObjectIntersection = function (obj, x, y) {\\n      var result,\\n          circleObj = this.eraserCursorShape,\\n          rectsAreIntersects = circleObj.intersectsWithObject(obj),\\n          objContainsCenterOfBrush,\\n          objContainsPointFromPerimeter;\\n\\n      if (rectsAreIntersects) {\\n        objContainsCenterOfBrush = !obj.canvas.isTargetTransparent(obj, x, y);\\n        if (!objContainsCenterOfBrush) {\\n          var deltaX = circleObj._lastCenterPosition ? x - circleObj._lastCenterPosition.x : undefined,\\n              deltaY = circleObj._lastCenterPosition ? y - circleObj._lastCenterPosition.y : undefined,\\n              perimeterPoints = circleObj.getPerimeterPoints(deltaX, deltaY);\\n          perimeterPoints.forEach(function (pointCoords, i) {\\n            if (!objContainsPointFromPerimeter) {\\n              objContainsPointFromPerimeter = !obj.canvas.isTargetTransparent(obj, pointCoords.x, pointCoords.y);\\n            }\\n          });\\n        }\\n      }\\n      result = objContainsCenterOfBrush || objContainsPointFromPerimeter;\\n      return result;\\n    };\\n\\n\\n  ////// MOSUE HANDLERS //////////////////////////////////////////////////////////////////////\\n  /**\\n   * Set erasingNow to true.\\n   * Eraser path will start by current brush, independently.\\n   * @param {Event} e - mouse down event\\n   */\\n  Eraser.prototype._onMouseDown = function (e) {\\n    var rightClick = e.which === 3,\\n        middleClick = e.which === 2;\\n    if (!rightClick && !middleClick) {\\n      // reset affectedShapes[]\\n      this.affectedShapes = [];\\n      // turn erasing on\\n      this.erasingNow = true;\\n      this._eraseAtPointer(e);\\n    }\\n  };\\n\\n\\n  /**\\n   * On mouse up - set erasingNow to false.\\n   * Eraser path will be created soon, and\\n   * main work on erasing will be  done in _onEraserPathCreated()\\n   */\\n  Eraser.prototype._onMouseUp = function () {\\n    this.erasingNow = false;\\n    this.drawerInstance.fCanvas.renderAll();\\n  };\\n\\n  /**\\n   * Listens for mouse movement when eraser is active.\\n   *\\n   * @param {Event} event\\n   * @private\\n   */\\n  Eraser.prototype._onMouseMove =  function (event) {\\n    // calc mouse event coords relative to canvas\\n    var pointCoords = this.drawerInstance.fCanvas.getPointer(event);\\n    var left = pointCoords.x;\\n    var top = pointCoords.y;\\n\\n    // move eraser shape to make it follow mouse pointer\\n    if(this.eraserCursorShape){\\n      // eraser shape could not be created on touch devices because there's no mouseenter events\\n      this.eraserCursorShape.set('left', pointCoords.x);\\n      this.eraserCursorShape.set('top', pointCoords.y);\\n      this.eraserCursorShape.setCoords();\\n\\n      this.drawerInstance.fCanvas.renderAll();\\n    }\\n\\n    if (this.erasingNow) {\\n        // Look, if there are erasable shapes under cursor\\n        if (this.separatePathOnShapes) {\\n          this._affectShapesUnderCoords(left, top);\\n        }\\n    }\\n  };\\n\\n\\n  Eraser.prototype._eraseAtPointer = function(event) {\\n    if (!event || !this.drawerInstance || !this.drawerInstance.fCanvas) {\\n      return;\\n    }\\n    var pointer = this.drawerInstance.fCanvas.getPointer(event);\\n    if (!pointer) {\\n      return;\\n    }\\n    this._affectShapesUnderCoords(pointer.x, pointer.y);\\n  };\\n\\n\\n\\n  pluginsNamespace.Eraser = Eraser;\\n\\n}(\\n  jQuery,\\n  Easel.brushes,\\n  Easel.plugins.BaseBrush,\\n  Easel.plugins,\\n  Easel.util\\n));\"","module.exports = \"(function  (Easel, util) {\\n\\n  /**\\n   * Returns canvas data(information about all objects presented on canvas).\\n   *\\n   * The order of sources is following:\\n   * - fabricjs canvas instance(if available) toJSON method.\\n   * - options.contentConfig.loadCanvasData(if available)\\n   * - options.contentCOnfig.canvasDataContainer(if available)\\n   * - data-canvas-serialized attribute\\n   *   (if options.contentConfig.saveToHtml=true)\\n   *\\n   * @return {Object} serialized canvas data\\n   */\\n  Easel.prototype.getCanvasData = function () {\\n    var serializedCanvas = null;\\n\\n    if (this.fCanvas) {\\n      serializedCanvas = this.fCanvas.toJSON();\\n    } else if (this.options.contentConfig.loadCanvasData) {\\n      serializedCanvas = this.options.contentConfig.loadCanvasData(this.id);\\n    } else if (this.$canvasDataContainer) {\\n      var canvasDataText = this.$canvasDataContainer.text();\\n      if (canvasDataText) {\\n        serializedCanvas = JSON.parse(canvasDataText)[this.id];\\n      }\\n    }\\n    else {\\n      var attr = this.$imageElement.attr('data-canvas-serialized');\\n      if (attr) {\\n        serializedCanvas = JSON.parse(attr);\\n      }\\n    }\\n\\n    return serializedCanvas;\\n  };\\n\\n\\n  /**\\n   * Returns data-url with image encoded to base64\\n   *\\n   * Firstly this method will try to get image data from fabric canvas instance.\\n   * If that is not available (for example when in edit mode)\\n   * it will check options for loadImageData function. If it is specified,\\n   * it will be invoked with this.id argument.\\n   *\\n   * If options.contentConfig.loadImageData is not set,\\n   * options.contentConfig.imagesContainer will be checked for data.\\n   *\\n   * @returns {String} image data encoded in base64/png.\\n   */\\n  Easel.prototype.getImageData = function () {\\n    if (this.fCanvas) {\\n      this.imageData = this.fCanvas.toDataURL();\\n    } else if (this.options.contentConfig.loadImageData) {\\n      this.imageData = this.options.contentConfig.loadImageData(this.id);\\n      if (this.imageData[0] == '\\\"' &&\\n        this.imageData[this.imageData.length - 1] == '\\\"') {\\n        this.imageData = this.imageData.substr(1, this.imageData.length - 2);\\n      }\\n    } else if (this.$imagesContainer) {\\n      var imagesDataText = this.$imagesContainer.text();\\n      if (imagesDataText) {\\n        var imagesData = JSON.parse(imagesDataText);\\n        this.imageData = imagesData[this.id];\\n      }\\n    }\\n\\n    return this.imageData;\\n  };\\n\\n\\n\\n\\n  /**\\n   * Loads canvas from serialized data.\\n   * Triggers EVENT_LOADED_FROM_JSON on complete.\\n   */\\n  Easel.prototype.loadCanvas = function (serializedCanvas) {\\n    var _this = this;\\n    if (serializedCanvas) {\\n      this.fCanvas.loadFromJSON(serializedCanvas, function() {\\n        // now when we load everything we should adjust object's properties\\n        // for selection controls based on our config\\n        var allObjects = _this.fCanvas.getObjects();\\n        for (var o in allObjects) {\\n          _this._updateObjectsControls(allObjects[o]);\\n        }\\n\\n        // set mode to ACTIVE and trigger event\\n        _this.mode = _this.MODE_ACTIVE;\\n        _this.trigger(_this.EVENT_LOADED_FROM_JSON);\\n\\n        _this.fCanvas.renderAll();\\n        _this.onCanvasLoaded();\\n      });\\n    } else {\\n      // yes, we have not set all listeners, and better place for this\\n      // is in the end of startEditing(), but it does not affect anything,\\n      // so I let it here\\n      _this.mode = this.MODE_ACTIVE;\\n      _this.onCanvasLoaded();\\n    }\\n  };\\n\\n\\n  Easel.prototype.onCanvasLoaded = function () {\\n    var _this = this;\\n    // subscribe to events only after deserialization to avoid triggering\\n    // for all objects while loading\\n    this.fCanvas.on('object:added', function (fEvent) {\\n      _this._updateObjectsControls(fEvent.target);\\n      _this.trigger(_this.EVENT_OBJECT_ADDED, fEvent);\\n      _this.onCanvasModified();\\n    });\\n    this.fCanvas.on('object:moving', function (fEvent) {\\n      _this.trigger(_this.EVENT_OBJECT_MOVING, fEvent);\\n    });\\n    this.fCanvas.on('object:modified', function () {\\n      _this.onCanvasModified();\\n    });\\n    this.fCanvas.on('before:render', function (fEvent) {\\n      _this.trigger(_this.EVENT_BEFORE_RENDER, fEvent);\\n    });\\n    this.fCanvas.on('after:render', function (fEvent) {\\n      _this.trigger(_this.EVENT_AFTER_RENDER, fEvent);\\n    });\\n    this.fCanvas.on('canvas:zoom:lower:set', function (fEvent) {\\n      _this.trigger(_this.EVENT_ZOOM_SET, fEvent);\\n    });\\n    this.fCanvas.on('canvas:zoom:lower:restore', function (fEvent) {\\n      _this.trigger(_this.EVENT_ZOOM_RESTORE, fEvent);\\n    });\\n    this.fCanvas.on('canvas:zoom:upper:set', function (fEvent) {\\n      _this.trigger(_this.EVENT_ZOOM_UPPER_SET, fEvent);\\n    });\\n    this.fCanvas.on('canvas:zoom:upper:restore', function (fEvent) {\\n      _this.trigger(_this.EVENT_ZOOM_UPPER_RESTORE, fEvent);\\n    });\\n    this.fCanvas.on('pencil:move:before', function (fEvent) {\\n      _this.trigger(_this.EVENT_ZOOM_UPPER_SET, fEvent);\\n    });\\n    this.fCanvas.on('pencil:move:after', function (fEvent) {\\n      _this.trigger(_this.EVENT_ZOOM_UPPER_RESTORE, fEvent);\\n    });\\n\\n\\n    this.fCanvas.on('object:removed', function () {\\n      _this.onCanvasModified();\\n    });\\n    this.fCanvas.on('object:selected', function (fEvent) {\\n      _this.trigger(_this.EVENT_OBJECT_SELECTED, fEvent);\\n    });\\n    this.fCanvas.on('selection:cleared', function (fEvent) {\\n      _this.trigger(_this.EVENT_SELECTION_CLEARED, fEvent);\\n    });\\n    this.fCanvas.on('text:selection:changed', function (fEvent) {\\n      _this.trigger(_this.EVENT_TEXT_SELECTION_CHANGED, fEvent);\\n    });\\n    this.fCanvas.on('text:editing:entered', function (fEvent) {\\n      _this.trigger(_this.EVENT_TEXT_EDITING_ENTERED, fEvent);\\n    });\\n    this.fCanvas.on('text:editing:exited', function (fEvent) {\\n      _this.trigger(_this.EVENT_TEXT_EDITING_EXITED, fEvent);\\n    });\\n\\n    // restore brush and color settings\\n    this.setColor();\\n    // this.setBrushSize();\\n\\n    // create all toolbars. Toolbars must be created after fCanvas is initialized.\\n    this.toolbars.createAllToolbars();\\n\\n    // give upper-canvas some id to properly handle clicks inside it\\n    $(this.fCanvas.upperCanvasEl).attr('data-id', 1);\\n\\n    this.setSize(this.width, this.height);\\n\\n    this.$canvasEditContainer.on('contextmenu', function (event) {\\n      // disable context menu in drawer for any other plugins, but trigger an\\n      // event for all drawer-plugins to handle\\n      _this.trigger(_this.EVENT_CONTEXTMENU, [event]);\\n      return false;\\n    });\\n\\n    util.bindLongPress(this.$canvasEditContainer, 'canvasEdit',\\n        function (event) {\\n          _this.trigger(_this.EVENT_CONTEXTMENU, [event]);\\n        });\\n\\n    this.trigger(this.EVENT_EDIT_START);\\n    \\n    this.$canvasEditContainer.on('keydown', function (event) {\\n      _this.trigger(_this.EVENT_KEYDOWN, event);\\n\\n      var isDelKey = event.which == 8,\\n          isBackspaceKey = event.which == 46,\\n          removeKeyTriggered = isDelKey || isBackspaceKey,\\n          needToDeleteActiveObj = removeKeyTriggered;\\n\\n      if (needToDeleteActiveObj) {\\n        _this.fCanvas.renderOnAddRemove = false;\\n        var activeObject = _this.fCanvas.getActiveObject();\\n        if (activeObject) {\\n          activeObject.remove();\\n\\n          event.preventDefault();\\n          event.stopPropagation();\\n        }\\n\\n        var activeGroup = _this.fCanvas.getActiveGroup();\\n        if (activeGroup) {\\n          activeGroup.getObjects().map(function (canvasObject) {\\n            canvasObject.remove();\\n          });\\n\\n          _this.fCanvas.discardActiveGroup();\\n\\n          event.preventDefault();\\n          event.stopPropagation();\\n        }\\n\\n        _this.fCanvas.renderAll();\\n        _this.fCanvas.renderOnAddRemove = true;\\n\\n        return false;\\n      }\\n    });\\n\\n    this.trigger(this.EVENT_CANVAS_READY);\\n  };\\n\\n  Easel.prototype.getSerializedCanvas = function () {\\n    var serializedCanvas = this.fCanvas.toJSON();\\n    var serializedCanvasStr = JSON.stringify(serializedCanvas);\\n    return serializedCanvasStr;\\n  };\\n\\n\\n  Easel.prototype.beforeSync = function () {\\n    // we do not want redactor to see image's data in its tag since it could be\\n    // huge.\\n    if (this.options.contentConfig && !this.options.contentConfig.saveInHtml) {\\n      this.$imageElement.attr('src', '');\\n    }\\n\\n    if (this.fCanvas) {\\n      this.beforeSyncActiveObject = this.fCanvas.getActiveObject();\\n      this.beforeSyncActiveGroup = this.fCanvas.getActiveGroup();\\n      this.fCanvas.deactivateAll();\\n    }\\n  };\\n\\n  Easel.prototype.afterSync = function () {\\n    if (this.beforeSyncActiveObject) {\\n      this.fCanvas.setActiveObject(this.beforeSyncActiveObject);\\n      delete this.beforeSyncActiveObject;\\n    }\\n\\n    if (this.beforeSyncActiveGroup) {\\n      this.fCanvas.setActiveGroup(this.beforeSyncActiveGroup);\\n      delete this.beforeSyncActiveGroup;\\n    }\\n\\n    if (this.options.contentConfig && !this.options.contentConfig.saveInHtml) {\\n      this.$imageElement.attr('src', this.getImageData());\\n    }\\n  };\\n\\n  /**\\n   * Synchronizes canvas data with storages specified in options.contentConfig.\\n   *\\n   * @param deleteItself\\n   */\\n  Easel.prototype.syncCanvasData = function (deleteItself) {\\n    var _this = this;\\n\\n    if (!_this.fCanvas) {\\n      return;\\n    }\\n\\n    var serializedCanvasStr = this.getSerializedCanvas();\\n\\n    if (_this.$canvasDataContainer) {\\n      var existingDataText = _this.$canvasDataContainer.text();\\n      var existingData = {};\\n      if (existingDataText.length > 0) {\\n        existingData = JSON.parse(existingDataText);\\n      }\\n\\n      if (!deleteItself) {\\n        if (_this.fCanvas) {\\n          existingData[_this.id] = serializedCanvasStr;\\n        }\\n      } else {\\n        delete existingData[_this.id];\\n      }\\n\\n      _this.$canvasDataContainer.text(JSON.stringify(existingData, null, 2));\\n\\n      _this.log('sync', 'sync with data container done.');\\n    }\\n\\n    if (this.options.contentConfig.saveCanvasData) {\\n      this.options.contentConfig.saveCanvasData(this.id, serializedCanvasStr);\\n    }\\n\\n    if (this.options.contentConfig.saveInHtml) {\\n      this.$imageElement.attr('data-canvas-serialized', serializedCanvasStr);\\n    }\\n  };\\n\\n\\n  /**\\n   * Synchronizes image data(base64/png) string with storages defined in\\n   * options.contentConfig.\\n   *\\n   * @param deleteItself\\n   */\\n  Easel.prototype.syncImageData = function (deleteItself) {\\n    var _this = this;\\n\\n    var imageData = _this.getImageData();\\n\\n    if (_this.$imagesContainer) {\\n\\n      var existingDataText = _this.$imagesContainer.text();\\n      var existingData = {};\\n      if (existingDataText.length > 0) {\\n        existingData = JSON.parse(existingDataText);\\n      }\\n\\n      if (!deleteItself) {\\n        existingData[_this.id] = imageData;\\n      } else {\\n        delete existingData[_this.id];\\n      }\\n\\n      _this.$imagesContainer.text(JSON.stringify(existingData, null, 2));\\n\\n      _this.log('sync', 'sync with images container done.');\\n    }\\n\\n    if (_this.options.contentConfig.saveImageData) {\\n      _this.options.contentConfig.saveImageData(this.id, imageData);\\n    }\\n  };\\n\\n\\n})(Easel.Easel, Easel.util);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/lib/fabric.1.7.1.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextColor.js\"))","module.exports = \"(function (global) {\\n\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {}),\\n        extend = fabric.util.object.extend;\\n\\n    fabric.ErasableObject = fabric.util.createClass(fabric.Object, {\\n        /**\\n         * Type of an object\\n         * @type String\\n         * @default\\n         */\\n        type: 'erasableObject',\\n\\n        /**\\n         * Constructor\\n         * @param {Object} objData object\\n         * @return {fabric.ErasableObject}\\n         */\\n        initialize: function (objData) {\\n            objData = objData || {};\\n\\n            // call super[fabric.Object].initialize()\\n            this.callSuper('initialize', objData);\\n        }\\n    });\\n\\n\\n    /**\\n     * Creates fabric object from data.\\n     *\\n     * @param objData\\n     * @param {function} callback\\n     * @return {fabric.ErasableObject} Instance of fabric.ErasableObject\\n     */\\n    fabric.ErasableObject.fromObject = function (objData) {\\n        return new fabric.ErasableObject(objData);\\n    };\\n\\n    // make our object erasable via ErasableMixin.\\n    fabric.makeObjectErasable(fabric.ErasableObject);\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-zoom/ZoomViewport.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-color/ColorpickerControl.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-selection/SelectionTool.js\"))","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing font size of text;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextFontWeight = function TextFontWeightConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    // init options\\n    this._setupOptions(options);\\n  };\\n\\n  TextFontWeight.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextFontWeight.prototype.constructor = BaseTextOptionTool;\\n\\n\\n  TextFontWeight.prototype.name = 'TextFontWeight';\\n  TextFontWeight.prototype.optionName = 'TextFontWeight';\\n  TextFontWeight.prototype.focusTextOnChange = true;\\n  TextFontWeight.prototype.onlyPredefined = true;\\n  TextFontWeight.prototype.buttonIconClass = 'fa-bold';\\n\\n  TextFontWeight.prototype._defaultOptions = {\\n    defaultValues: {\\n      fontWeight: 'normal'\\n    },\\n    predefined: {\\n      fontWeight: ['normal', 'bold', 'light', 100, 200, 300, 400, 500, 600, 700, 800, 900]\\n    }\\n  };\\n  \\n  TextFontWeight.prototype.controlTemplate = function () {\\n    var result,\\n        $predefined,\\n        selectHtml;\\n\\n    $predefined = this.options.predefined.fontWeight.map(function (size, i) {\\n      return '<option value=\\\"' + size + '\\\">' + size + '</option>';\\n    }).join('');\\n\\n    selectHtml = '' +\\n        '<select ' +\\n        'class=\\\"editable-canvas-text-fontweight-input controls-value-item\\\" ' +\\n        'name=\\\"drawer-size\\\"' +\\n        'data-name=\\\"fontWeight\\\"' +\\n        'value=\\\"' + this.options.defaultValues.fontWeight + '\\\">' +\\n        $predefined +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper editable-canvas-text-option editable-canvas-text-fontweight hidden',\\n        optionItemAdditionalClasses = this.buttonMode ? ' toolbar-button-item ': '',\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n        '<span class=\\\"toolbar-item-label\\\">' +\\n        this.drawer.t('Font Weight:') + ' ' +\\n        '</span>' +\\n        '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n        '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n        '</div>' +\\n        '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n        selectHtml +\\n        '</div>' +\\n        '</li>';\\n\\n    return result;\\n  };\\n\\n  pluginsNamespace.TextFontWeight = TextFontWeight;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextLineHeight.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/EaselToolbar.js\"))","module.exports = \"(function ($, BaseShape, pluginsNamespace, util) {\\n  \\\"use strict\\\";\\n\\n  var MOUSE_DOWN = util.mouseDown('Polygon');\\n  var MOUSE_MOVE = util.mouseMove('Polygon');\\n  var MOUSE_UP = util.mouseUp('Polygon');\\n\\n  /**\\n   * Provides a polygon button which can be used to draw polygons.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var Polygon = function PolygonConstructor(drawerInstance, options) {\\n    var _this = this;\\n\\n    BaseShape.call(_this, drawerInstance);\\n\\n    this.name = 'Polygon';\\n    this.btnClass = 'btn-polygon';\\n    this.faClass = 'fa-star';\\n    this.tooltip = drawerInstance.t('Draw a Polygon');\\n    this.helpTooltipText = drawerInstance.t('Click to start a new line');\\n\\n    this.options = options || {};\\n    this.centeringMode =\\n      this.options.centeringMode || BaseShape.CENTERING_MODE.NORMAL;\\n\\n    drawerInstance.on(drawerInstance.EVENT_EDIT_STOP, function () {\\n      _this.finishDraw();\\n    });\\n\\n    drawerInstance.on(drawerInstance.EVENT_DO_ACTIVATE_TOOL,\\n      function (event, tool) {\\n        if (!(tool instanceof Polygon)) {\\n          _this.finishDraw();\\n        }\\n      });\\n  };\\n\\n  Polygon.prototype = Object.create(BaseShape.prototype);\\n  Polygon.prototype.constructor = Polygon;\\n\\n  Polygon.prototype.setUpHandlers = function () {\\n    var _this = this;\\n\\n    _this.drawerInstance.fCanvas._oldSelectionState = _this.drawerInstance.fCanvas.selection;\\n    _this.drawerInstance.fCanvas.selection = false;\\n\\n    _this.$stopButton = $('<button class=\\\"stop-polygon\\\">' +\\n      _this.drawerInstance.t('Stop drawing a polygon') +\\n    '</button>');\\n    _this.drawerInstance.$canvasEditContainer.append(_this.$stopButton);\\n    _this.$stopButton.click(function () {\\n      _this.finishDraw();\\n    });\\n\\n    _this.drawerInstance\\n      .on(_this.drawerInstance.EVENT_KEYDOWN, function (event, originalEvent) {\\n        if (originalEvent.which == 27) {\\n          _this.finishDraw();\\n        }\\n      });\\n\\n    var drawingArea = $(this.drawerInstance.fCanvas.upperCanvasEl);\\n\\n    var newPointHandler = function (event) {\\n      _this.addNewPoint(event);\\n\\n      if (!_this.poly.__mouseEventSet) {\\n        _this.setUpMoveEvent();\\n        _this.poly.__mouseEventSet = true;\\n      }\\n\\n      _this.drawerInstance.fCanvas.renderAll();\\n    };\\n\\n    if (_this.drawerInstance.touchDevice) {\\n      drawingArea.on(MOUSE_DOWN, function (event) {\\n        newPointHandler(event);\\n        event.preventDefault();\\n        event.stopPropagation();\\n        return false;\\n      });\\n\\n      drawingArea.on(MOUSE_UP, function (event) {\\n        drawingArea.off(MOUSE_MOVE);\\n        _this.poly.__mouseEventSet = false;\\n        event.preventDefault();\\n        event.stopPropagation();\\n        return false;\\n      });\\n    } else {\\n      drawingArea.on(MOUSE_DOWN, function (event) {\\n        newPointHandler(event);\\n        event.preventDefault();\\n        event.stopPropagation();\\n        return false;\\n      });\\n    }\\n  };\\n\\n  Polygon.prototype.addNewPoint = function (event) {\\n    var _this = this,\\n        pointCoords = this.drawer.fCanvas.getPointer(event),\\n        left = pointCoords.x,\\n        top = pointCoords.y;\\n\\n    if (!_this.poly) {\\n      _this.startLeft = left;\\n      _this.startTop = top;\\n\\n      _this.poly = new fabric.SegmentablePolygon([[\\n        {\\n          x: 0,\\n          y: 0\\n        }\\n      ]]);\\n      _this.poly.set('fill', _this.drawerInstance.activeColor);\\n      _this.poly.set('opacity', _this.drawerInstance.activeOpacity);\\n      _this.poly.set('left', left);\\n      _this.poly.set('top', top);\\n      _this.poly.set('evented', false);\\n      _this.poly.set('selectable', false);\\n      _this.drawerInstance.fCanvas.add(_this.poly);\\n    }\\n\\n    var points = _this.poly.get('points');\\n\\n    var centerPoint = _this.poly.getCenterPoint();\\n    left = left - centerPoint.x;\\n    top = top - centerPoint.y;\\n\\n    points[0].push({\\n      x: left,\\n      y: top\\n    });\\n\\n    _this.poly.set('points', points);\\n\\n    _this.fixPosition();\\n  };\\n\\n  Polygon.prototype.setUpMoveEvent = function () {\\n    var _this = this;\\n    var drawingArea = $(this.drawerInstance.fCanvas.upperCanvasEl);\\n\\n    drawingArea.on(MOUSE_MOVE, function (event) {\\n      var points = _this.poly.get('points'),\\n          pointCoords = _this.drawerInstance.fCanvas.getPointer(event),\\n          centerPoint = _this.poly.getCenterPoint(),\\n          left = pointCoords.x - centerPoint.x,\\n          top = pointCoords.y - centerPoint.y;\\n\\n      if (points[0].length >= 2) {\\n        points[0][points[0].length - 1].x = left;\\n        points[0][points[0].length - 1].y = top;\\n\\n        _this.poly.set('points', points);\\n\\n        _this.fixPosition();\\n\\n        _this.drawerInstance.fCanvas.renderAll();\\n      }\\n    });\\n  };\\n\\n  Polygon.prototype.fixPosition = function () {\\n    var _this = this;\\n\\n    _this.poly._fixPoints();\\n    _this.poly.setCoords();\\n\\n    var points = _this.poly.get('points');\\n\\n    var centerPoint = _this.poly.getCenterPoint();\\n    var firstPointX = centerPoint.x + points[0][0].x;\\n    var firstPointY = centerPoint.y + points[0][0].y;\\n\\n    var firstPointGlobalX = firstPointX;\\n    var firstPointGlobalY = firstPointY;\\n\\n    var xDiff = _this.startLeft - firstPointGlobalX;\\n    var yDiff = _this.startTop - firstPointGlobalY;\\n    _this.poly.set('left', _this.poly.get('left') + xDiff);\\n    _this.poly.set('top', _this.poly.get('top') + yDiff);\\n  };\\n\\n  Polygon.prototype.finishDraw = function () {\\n    var _this = this;\\n\\n    _this.drawerInstance.fCanvas.selection = _this.drawerInstance.fCanvas._oldSelectionState;\\n\\n    var drawingArea = $(this.drawerInstance.fCanvas.upperCanvasEl);\\n\\n    drawingArea.off(MOUSE_MOVE);\\n    drawingArea.off(MOUSE_DOWN);\\n    drawingArea.off(MOUSE_UP);\\n\\n    util.unbindLongPress(drawingArea, 'polygon');\\n\\n    if (_this.poly) {\\n      // only remove last point for non-touch device\\n      if (!_this.drawerInstance.touchDevice) {\\n        var points = this.poly.get('points');\\n        points[0].splice(points[0].length - 1, 1);\\n        this.poly.set('points', points);\\n      }\\n\\n      this.fixPosition();\\n\\n      _this.poly.set('evented', true);\\n      _this.poly.set('selectable', true);\\n\\n      var cloned = this.poly.clone();\\n      this.drawerInstance.fCanvas.add(cloned);\\n      this.drawerInstance.fCanvas.remove(this.poly);\\n    }\\n\\n    this.poly = null;\\n\\n    this.drawerInstance.fCanvas.renderAll();\\n    if (_this.$stopButton) {\\n      util.setTimeout(function () {\\n        _this.$stopButton.remove();\\n      }, 1);\\n    }\\n\\n    this._deactivateTool();\\n  };\\n\\n  pluginsNamespace.Polygon = Polygon;\\n\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins, Easel.util));\"","module.exports = \"(function(global) {\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {});\\n\\n    fabric.ErasablePencilBrush = fabric.util.createClass(fabric.PencilBrush, {\\n\\n        type: 'ErasablePencilBrush',\\n\\n        /**\\n         * List of tool options to show when object is selected\\n         * @type {String[]}\\n         */\\n        objectOptionsList : ['color', 'opacity', 'brush'],\\n        enableHandDrawnEffect: false,\\n        handDrawnStyle: 'sketch',\\n        handDrawnRoughness: 0.85,\\n        handDrawnShadowOffset: 0.9,\\n        handDrawnSketchLines: 1,\\n        handDrawnSketchOffset: 0.65,\\n        penDecimate: 3,\\n        penSmoothing: 2,\\n\\n\\n      /**\\n       * Overriding fabric.PencilBrush.onMouseMove\\n       * Method code is exactly copy of fabric.PencilBrush.onMouseMove,\\n       * only change is trigger events\\n       *\\n       * @param {Object} pointer - object with \\\"x\\\" and \\\"y\\\" values\\n       * @see {fabric.PencilBrush.onMouseMove}\\n       */\\n      onMouseMove: function(pointer) {\\n        this._captureDrawingPath(pointer);\\n        // redraw curve\\n        // clear top canvas\\n\\n        this.canvas.clearContext(this.canvas.contextTop);\\n        // this.canvas.fire('pencil:move:before');\\n        this._render();\\n        // this.canvas.fire('pencil:move:after');\\n        this.canvas.renderAll();\\n      },\\n\\n      /**\\n       * Overriding fabric.PencilBrush._render\\n       * Method code is exactly copy of fabric.PencilBrush._render,\\n       * only change is trigger events\\n       *\\n       * @see {fabric.PencilBrush._render}\\n       * @private\\n       */\\n      _render: function () {\\n        this.canvas.fire('pencil:move:before');\\n        this.callSuper('_render');\\n        this.canvas.fire('pencil:move:after');\\n      },\\n\\n      _finalizeAndAddPath: function () {\\n        if (this._shouldApplyPenPreprocessing()) {\\n          this._preprocessPenPoints();\\n        }\\n        this.callSuper('_finalizeAndAddPath');\\n      },\\n\\n        initialize: function(canvas, options) {\\n            options = options || {};\\n            // parent c-tor has no options argument, so adding them here\\n            this.options = options;\\n            // call parent c-tor\\n            this.callSuper('initialize', canvas);\\n        },\\n\\n\\n        /**\\n         * Overriding fabric.PencilBrush.createPath\\n         * Method code is exactly copy of fabric.PencilBrush.createPath,\\n         * only change is creating fabric.ErasablePath instead of fabric.Path\\n         *\\n         * Creates fabric.ErasablePath object to add on canvas\\n         * @param {String} pathData Path data\\n         * @return {fabric.Path} Path to add on canvas\\n         * @see {fabric.PencilBrush.createPath}\\n         */\\n        createPath: function(pathData) {\\n            var path = new fabric.ErasablePath(pathData, {\\n                fill: null,\\n                stroke: this.color,\\n                opacity: this.opacity,\\n                strokeWidth: this.width,\\n                strokeLineCap: this.strokeLineCap,\\n                strokeLineJoin: this.strokeLineJoin,\\n                strokeDashArray: this.strokeDashArray,\\n                originX: 'center',\\n                originY: 'center'\\n            });\\n\\n            if (this.shadow) {\\n                this.shadow.affectStroke = true;\\n                path.setShadow(this.shadow);\\n            }\\n\\n            if (this.enableHandDrawnEffect) {\\n              this._applyHandDrawnEffect(path);\\n            }\\n\\n            return path;\\n          },\\n\\n          _applyHandDrawnEffect: function (path) {\\n            this._simplifyPenPath(path);\\n            if (this.handDrawnStyle === 'pen') {\\n              this._applyPenEffect(path);\\n              return;\\n            }\\n\\n            var baseCommands = this._roughenPath(path);\\n            if (this.handDrawnSketchLines > 1 && baseCommands) {\\n              this._addSketchOutlines(path, baseCommands);\\n            }\\n            this._applyStrokeShadow(path);\\n          },\\n\\n          _applyPenEffect: function (path) {\\n            if (!path) {\\n              return;\\n            }\\n            path.strokeLineCap = 'round';\\n            path.strokeLineJoin = 'round';\\n            path.strokeMiterLimit = 2;\\n            path.strokeUniform = true;\\n            path.paintFirst = 'stroke';\\n            if (path.setShadow) {\\n              path.setShadow(null);\\n            } else {\\n              path.shadow = null;\\n            }\\n            path.dirty = true;\\n          },\\n\\n          _roughenPath: function (path) {\\n            if (!path || !path.path) {\\n              return null;\\n            }\\n            var baseCopy = this._clonePathCommands(path.path);\\n            var jitterScale = this._resolveJitterScale(path);\\n            var wobbledPath = [];\\n            for (var i = 0; i < path.path.length; i++) {\\n              var command = path.path[i];\\n              var updatedCommand = [command[0]];\\n              for (var j = 1; j < command.length; j++) {\\n                var value = command[j];\\n                if (typeof value === 'number') {\\n                  updatedCommand[j] = value + this._sketchRandom(jitterScale, command[0]);\\n                } else {\\n                  updatedCommand[j] = value;\\n                }\\n              }\\n              wobbledPath.push(updatedCommand);\\n            }\\n            path.path = wobbledPath;\\n            path.dirty = true;\\n            return baseCopy;\\n          },\\n\\n          _resolveJitterScale: function (path) {\\n            var width = path.strokeWidth || this.width || 1;\\n            var base = Math.max(width * 0.35, 0.6);\\n            return base * (this.handDrawnRoughness || 1);\\n          },\\n\\n          _sketchRandom: function (scale, commandName) {\\n            var multiplier = (commandName === 'Q' || commandName === 'C') ? 1.8 : 1.2;\\n            return (Math.random() - 0.5) * 2 * scale * multiplier;\\n          },\\n\\n          _addSketchOutlines: function (path, baseCommands) {\\n            var outlines = Math.max(0, Math.round(this.handDrawnSketchLines || 1) - 1);\\n            if (!outlines) {\\n              return;\\n            }\\n            var baseScale = this._resolveJitterScale(path) * (this.handDrawnSketchOffset || 0.65);\\n            for (var i = 0; i < outlines; i++) {\\n              var scale = baseScale * (1 + (i * 0.35));\\n              var outlineCommands = this._buildOutlineCommands(baseCommands, scale);\\n              if (outlineCommands.length) {\\n                if (outlineCommands[0][0] !== 'M' && outlineCommands[0][0] !== 'm') {\\n                  outlineCommands[0][0] = 'M';\\n                }\\n                path.path = path.path.concat(outlineCommands);\\n              }\\n            }\\n            path.dirty = true;\\n          },\\n\\n          _buildOutlineCommands: function (commands, scale) {\\n            var outline = [];\\n            for (var i = 0; i < commands.length; i++) {\\n              var command = commands[i];\\n              var cloned = [command[0]];\\n              for (var j = 1; j < command.length; j++) {\\n                var value = command[j];\\n                if (typeof value === 'number') {\\n                  cloned[j] = value + this._sketchRandom(scale, command[0]);\\n                } else {\\n                  cloned[j] = value;\\n                }\\n              }\\n              outline.push(cloned);\\n            }\\n            return outline;\\n          },\\n\\n          _clonePathCommands: function (commands) {\\n            var clone = [];\\n            for (var i = 0; i < commands.length; i++) {\\n              var command = commands[i];\\n              var copied = [];\\n              for (var j = 0; j < command.length; j++) {\\n                copied[j] = command[j];\\n              }\\n              clone.push(copied);\\n            }\\n            return clone;\\n          },\\n\\n          _applyStrokeShadow: function (path) {\\n            if (!path) {\\n              return;\\n            }\\n            var offset = this.handDrawnShadowOffset || 0.9;\\n            path.strokeLineCap = 'round';\\n            path.strokeLineJoin = 'round';\\n            if (!path.shadow) {\\n              path.setShadow(new fabric.Shadow({\\n                color: path.stroke,\\n                blur: 0,\\n                offsetX: offset,\\n                offsetY: offset,\\n                opacity: 0.5\\n              }));\\n              path.shadow.affectStroke = true;\\n            }\\n          },\\n\\n          _simplifyPenPath: function (path) {\\n            if (!path || !path.path) {\\n              return;\\n            }\\n            var simplified = [];\\n            var lastX;\\n            var lastY;\\n            for (var i = 0; i < path.path.length; i++) {\\n              var command = path.path[i];\\n              var clone = command.slice();\\n              var lastIndex = command.length - 2;\\n              if (lastIndex >= 1) {\\n                var x = command[lastIndex];\\n                var y = command[lastIndex + 1];\\n                if (typeof x === 'number' && typeof y === 'number') {\\n                  if (lastX === x && lastY === y) {\\n                    continue;\\n                  }\\n                  lastX = x;\\n                  lastY = y;\\n                }\\n              }\\n              simplified.push(clone);\\n            }\\n            path.path = simplified;\\n          },\\n\\n          _shouldApplyPenPreprocessing: function () {\\n            return this.enableHandDrawnEffect &&\\n              this.handDrawnStyle === 'pen' &&\\n              this._points && this._points.length > 2;\\n          },\\n\\n          _preprocessPenPoints: function () {\\n            if (!this._points || !this._points.length) {\\n              return;\\n            }\\n            var minDistance = this.penDecimate || 3;\\n            var smoothingWindow = this.penSmoothing || 0;\\n            var decimated = this._decimatePenPoints(this._points, minDistance);\\n            if (smoothingWindow > 1) {\\n              decimated = this._smoothPenPoints(decimated, smoothingWindow);\\n            }\\n            this._points = decimated;\\n          },\\n\\n          _decimatePenPoints: function (points, minDistance) {\\n            if (!points || points.length < 3) {\\n              return points ? points.slice() : [];\\n            }\\n            var threshold = Math.max(minDistance || 2, 1);\\n            var filtered = [];\\n            var previous = points[0];\\n            filtered.push(this._clonePoint(previous));\\n            var accumulated = 0;\\n\\n            for (var i = 1; i < points.length - 1; i++) {\\n              var current = points[i];\\n              var distance = previous.distanceFrom ? previous.distanceFrom(current) :\\n                Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\\n              accumulated += distance;\\n              if (accumulated >= threshold) {\\n                filtered.push(this._clonePoint(current));\\n                previous = current;\\n                accumulated = 0;\\n              }\\n            }\\n\\n            var lastPoint = points[points.length - 1];\\n            filtered.push(this._clonePoint(lastPoint));\\n\\n            return filtered;\\n          },\\n\\n          _smoothPenPoints: function (points, windowSize) {\\n            if (!points || points.length < 3) {\\n              return points ? points.slice() : [];\\n            }\\n            var radius = Math.max(Math.round(windowSize), 1);\\n            var smoothed = [];\\n\\n            for (var i = 0; i < points.length; i++) {\\n              var start = Math.max(0, i - radius);\\n              var end = Math.min(points.length - 1, i + radius);\\n              var count = 0;\\n              var sumX = 0;\\n              var sumY = 0;\\n\\n              for (var j = start; j <= end; j++) {\\n                sumX += points[j].x;\\n                sumY += points[j].y;\\n                count++;\\n              }\\n\\n              smoothed.push(new fabric.Point(sumX / count, sumY / count));\\n            }\\n\\n            return smoothed;\\n          },\\n\\n          _clonePoint: function (point) {\\n            if (!point) {\\n              return new fabric.Point(0, 0);\\n            }\\n            return point.clone ? point.clone() : new fabric.Point(point.x, point.y);\\n          }\\n\\n    });\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\"","module.exports = \"(function ($, pluginsNamespace) {\\n  \\\"use strict\\\";\\n\\n  /**\\n   * Provides a responsive navbar button to open the over-canvas popup\\n   *\\n   * @param {Easel.Easel} drawer\\n   * @param {Object} options\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var OpenPopupButton = function OpenPopupButtonConstructor(drawer, options) {\\n    this.drawer = drawer;\\n    this.name = 'OpenPopupButton';\\n    this._setupOptions(options);\\n    this._bindedToolbarHandler = this._onToolbarCreated.bind(this);\\n    drawer.on(drawer.EVENT_TOOLS_TOOLBAR_CREATED, this._bindedToolbarHandler);\\n  };\\n\\n  OpenPopupButton.prototype._defaultOptions = {\\n    buttonOrder: 950\\n  };\\n\\n  OpenPopupButton.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  OpenPopupButton.prototype._onToolbarCreated = function (ev, toolbar) {\\n    this.toolbar = toolbar;\\n    this.createControls(toolbar);\\n  };\\n\\n  OpenPopupButton.prototype.createControls = function (toolbar) {\\n    if (!toolbar) {\\n      return;\\n    }\\n\\n    if (this.$button && this.$button.length) {\\n      toolbar.removeButton(this.$button);\\n    }\\n\\n    var tooltip = this.drawer.t('Open options tools');\\n    var $button = toolbar.addButton({\\n      buttonOrder: this.options.buttonOrder,\\n      additionalClass: 'btn-popup-canvas',\\n      iconClass: 'fa-sliders',\\n      tooltipText: tooltip,\\n      clickHandler: function (event) {\\n        event.preventDefault();\\n        this.drawer.trigger(this.drawer.EVENT_OVERCANVAS_POPUP_SHOW, [$button]);\\n      }.bind(this)\\n    });\\n\\n    var $link = $button.find('a');\\n    $link.attr('aria-label', tooltip);\\n\\n    this.$button = $button;\\n  };\\n\\n  pluginsNamespace.OpenPopupButton = OpenPopupButton;\\n})(jQuery, Easel.plugins);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/SegmentablePolygon.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-opacity/Opacity.js\"))","module.exports = \"(function ($, pluginsNamespace) {\\n    'use strict';\\n\\n    /**\\n     * Base class for tool options plugins.\\n     *\\n     * @param drawer\\n     * @constructor\\n     * @memberof Easel.plugins\\n     */\\n    var BaseToolOptions = function (drawer, options) {\\n        if (!drawer) {\\n            throw new Error(\\\"BaseToolOptions CTOR : drawer is not set!\\\");\\n        }\\n        this.drawer = drawer;\\n        this._setupOptions(options);\\n\\n        // handle toolbar created/destroyed\\n        this._bindedOnToolbarCreated = this._onToolbarCreated.bind(this);\\n        drawer.on(drawer.EVENT_OPTIONS_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n        drawer.on(drawer.EVENT_TOOLBAR_DESTROYED, this._onToolbarDestroyed.bind(this));\\n\\n        // handle tool activation/deactivation\\n        drawer.on(drawer.EVENT_DO_DEACTIVATE_ALL_TOOLS, this._onDeactivateTool.bind(this));\\n\\n        drawer.on(drawer.EVENT_DO_DEACTIVATE_TOOL, this._onDeactivateTool.bind(this));\\n        drawer.on(drawer.EVENT_DO_ACTIVATE_TOOL, this._onActivateTool.bind(this));\\n\\n        drawer.on(drawer.EVENT_TOOL_DEACTIVATED, this._onDeactivateTool.bind(this));\\n        drawer.on(drawer.EVENT_TOOL_ACTIVATED, this._onActivateTool.bind(this));\\n\\n        // handle object selection/deselection\\n        drawer.on(drawer.EVENT_OBJECT_SELECTED, this._onObjectSelected.bind(this));\\n        drawer.on(drawer.EVENT_SELECTION_CLEARED, this._onSelectionCleared.bind(this));\\n\\n        // react on edit mode entering\\n        drawer.on(drawer.EVENT_TEXT_EDITING_ENTERED, this._onTextEditingEntered.bind(this));\\n        // react on edit mode exiting\\n        drawer.on(drawer.EVENT_TEXT_EDITING_EXITED, this._onTextEditingExited.bind(this));\\n    };\\n\\n  /**\\n   * is active at the moment\\n   * @type {boolean}\\n   */\\n  BaseToolOptions.prototype.active = false;\\n\\n  /** Instance of Easel\\n   * @type {Easel} */\\n  BaseToolOptions.prototype.drawer = null;\\n\\n  /** Instance of toolbar\\n   * @type {EaselToolbar} */\\n  BaseToolOptions.prototype.toolbar = null;\\n\\n  /**\\n   * Tool name\\n   * @const\\n   * @type {string}\\n   */\\n  BaseToolOptions.prototype.name = '';\\n\\n  /**\\n   * Tool type\\n   */\\n  BaseToolOptions.prototype.type = null;\\n\\n  /**\\n   * Tool name. On selecting tool/object, if this.optionName is in array of\\n   * object allowed options - tool will show controls\\n   * @const\\n   * @type {String}\\n   */\\n  BaseToolOptions.prototype.optionName = '';\\n\\n  /**\\n   * Css class of tool button\\n   * @default\\n   * @const\\n   * @type {String}\\n   */\\n  BaseToolOptions.prototype.btnClass = 'btn';\\n\\n  /**\\n   * Tool icon font-awesome class\\n   * @const\\n   * @type {String}\\n   */\\n  BaseToolOptions.prototype.faClass = '';\\n\\n  /**\\n   * Show tool only in edit mode\\n   * @default\\n   * @const\\n   * @type {boolean}\\n   */\\n  BaseToolOptions.prototype.showOnEditMode = false;\\n\\n  /**\\n   * Hide tool in edit mode\\n   * @default\\n   * @const\\n   * @type {boolean}\\n   */\\n  BaseToolOptions.prototype.hideOnEditMode = true;\\n\\n  /**\\n   * Current option data\\n   * @type {Object}\\n   */\\n  BaseToolOptions.prototype.data = {};\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  BaseToolOptions.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    options = options || {};\\n    var optionsFromEasel = this._collectDefaultOptions(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options\\n        );\\n\\n    var updatedResult = this._onOptionsSetup(this._defaultOptions, options, optionsFromEasel, result);\\n    result = updatedResult || result;\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Process options\\n   * @param {Object} [defaultOptions]\\n   * @param {Object} [options]\\n   * @param {Object} [optionsFromEasel]\\n   * @param {Object} [result]\\n   * @returns {Object}\\n   * @private\\n   */\\n  BaseToolOptions.prototype._onOptionsSetup = function (defaultOptions, options, optionsFromEasel, result) {\\n    return result;\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {String} [pluginName] - name of plugin\\n   * @returns {Object}\\n   * @private\\n   */\\n  BaseToolOptions.prototype._collectDefaultOptions = function (pluginName) {\\n    pluginName = pluginName || this.name || this.optionName;\\n    var drawer = this.drawerInstance || this.drawer,\\n        result = drawer && drawer.getPluginConfig(pluginName);\\n    return result;\\n  };\\n\\n\\n  /**\\n   * On toolbar created - create tool button.\\n   * @param {fabric.Event} ev\\n   * @param {EaselToolbar} toolbar\\n   * @private\\n   */\\n    BaseToolOptions.prototype._onToolbarCreated = function (ev, toolbar) {\\n        this.toolbar = toolbar;\\n        if (this.createControls) {\\n            this.createControls(toolbar);\\n        }\\n\\n      if (this.useCombobox && this.$toolControl) {\\n        var comboBoxOptions = {\\n          drawer: this.drawer,\\n          editable: !this.onlyPredefined,\\n          buttonMode: this.buttonMode\\n        },\\n        $targetSelect = this.$toolControl.find('select');\\n        $targetSelect.ToolbarComboBox(comboBoxOptions);\\n        this.comboBox = $targetSelect.getComboBox();\\n      }\\n    };\\n\\n\\n  /**\\n   * On toolbar destroyed - destroy button, if it was our toolbar.\\n   * @param {fabric.Event} ev\\n   * @param {EaselToolbar} toolbar\\n   * @private\\n   */\\n    BaseToolOptions.prototype._onToolbarDestroyed = function (ev, toolbar) {\\n        if (this.toolbar == toolbar) {\\n            this.removeTool();\\n        }\\n    };\\n\\n\\n    /**\\n     * Deletes tool button.\\n     * If  doDeleteToolbarCreationListeners is true - removes listeners of toolbar creation event.\\n     * So, tool will not appear on toolbar next time, when toolbar is created.\\n     *\\n     * @param {boolean} doDeleteToolbarCreationListeners\\n     */\\n    BaseToolOptions.prototype.removeTool = function(doDeleteToolbarCreationListeners) {\\n        if (this.deleteControls) {\\n            this.deleteControls();\\n        }\\n\\n        // stop listening toolbar creation\\n        if (doDeleteToolbarCreationListeners) {\\n            this.drawer.off(this.drawer.EVENT_OPTIONS_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n        }\\n    };\\n\\n  /**\\n   * React on edit mode entering\\n   * @param  {fabric.Event} [fEvent]\\n   * @param  {fabric.Object} tool\\n   * @private\\n   */\\n  BaseToolOptions.prototype._onTextEditingEntered = function (fEvent, tool) {\\n    tool = tool && tool.target;\\n\\n    var isEditMode = tool && tool.isEditing,\\n        showControls = !this.hideOnEditMode && (this.showOnEditMode || isEditMode);\\n    if (showControls) {\\n      this.showControls(true, tool);\\n    } else {\\n      this.hideControls();\\n    }\\n  };\\n\\n  /**\\n   * React on edit mode exiting\\n   * @param  {fabric.Event} [fEvent]\\n   * @param  {fabric.Object} [tool]\\n   * @private\\n   */\\n  BaseToolOptions.prototype._onTextEditingExited = function (fEvent, tool) {\\n    var isEditMode = tool && tool.target && tool.target.isEditing,\\n        showControls = this.hideOnEditMode && !isEditMode;\\n    if (showControls) {\\n      this.showControls();\\n    } else {\\n      this.hideControls();\\n    }\\n  };\\n\\n    /**\\n     * Handler for EVENT_DO_DEACTIVATE_TOOL.\\n     * Hides controls.\\n     * Calls this.onDeactivateTool() if it is defined\\n     *\\n     * @param e event obj\\n     * @param tool tool object\\n     * @private\\n     */\\n    BaseToolOptions.prototype._onDeactivateTool = function (e, tool) {\\n        // set active to false\\n        this.active = false;\\n        // hide controls\\n      var needToShow = this.options && this.options.alwaysVisible;\\n      if (!needToShow) {\\n        this.hideControls();\\n      } else {\\n        this.showControls();\\n      }\\n    };\\n\\n\\n    /**\\n     * Default handler for EVENT_DO_ACTIVATE_TOOL.\\n     * Calls this.updateOnTool()\\n     *\\n     * @param {fabric.Event} e event obj\\n     * @param {BaseTool} tool tool object\\n     * @private\\n     */\\n    BaseToolOptions.prototype._onActivateTool = function (e, tool) {\\n        this.updateOnTool(tool);\\n    };\\n\\n\\n    /**\\n     * Shows/hides controls depending on tool.toolOptionsList\\n     *\\n     * @param {BaseTool} tool tool object\\n     */\\n    BaseToolOptions.prototype.updateOnTool = function (tool) {\\n        // look if activated tool toolOptionsList has this option name\\n      var toolHasOption = tool.toolOptionsList && (tool.toolOptionsList.indexOf(this.optionName) !== -1),\\n          editModeIsCorrect = (!this.showOnEditMode || tool.isEditing),\\n          needToShowControls = toolHasOption && editModeIsCorrect;\\n        if (needToShowControls) {\\n            this.active = true;\\n            // show controls\\n            this.showControls();\\n            // and activate tool\\n            if (this.onActivateTool) {\\n                this.onActivateTool(tool);\\n            }\\n        } else {\\n            this.active = false;\\n            // show controls\\n            this.hideControls(tool.forceOptionsHide);\\n        }\\n    };\\n\\n\\n    /**\\n     * Shows/hides controls, depending on selected object optionName\\n     * @param  {Event} event\\n     * @param  {fabric.Event} fabricEvent [description]\\n     * @private\\n     */\\n    BaseToolOptions.prototype._onObjectSelected = function (event, fabricEvent) {\\n      var target = fabricEvent.target,\\n          toolHasOption = target.objectOptionsList && (target.objectOptionsList.indexOf(this.optionName) !== -1),\\n          editModeIsCorrect = (!this.showOnEditMode || target.isEditing),\\n          needToShowControls = toolHasOption && editModeIsCorrect;\\n      if (needToShowControls) {\\n            // show controls\\n            this.showControls();\\n            // update controls\\n            this.updateControlsFromObject(target);\\n        } else {\\n            this.hideControls();\\n        }\\n    };\\n\\n    /**\\n     * React on object deselect\\n     * @private\\n     */\\n    BaseToolOptions.prototype.onSelectionCleared = function () {\\n\\n    };\\n\\n\\n    /**\\n     * On selection cleared - hide option controls if not tool is active.\\n     * Else shows option controls for active tool.\\n     * Calls this.onSelectionCleared if defined.\\n     * @private\\n     */\\n    BaseToolOptions.prototype._onSelectionCleared = function () {\\n        // if tool is active now - show controls for it. If no - hide  controls\\n        if (this.drawer.activeDrawingTool) {\\n            this.updateOnTool(this.drawer.activeDrawingTool);\\n        } else {\\n            this.hideControls();\\n        }\\n      this.onSelectionCleared();\\n    };\\n\\n    /**\\n     * Collect necessary data from object\\n     * @param  {fabric.Object} target - fabric object\\n     * @returns {object} result\\n     */\\n    BaseToolOptions.prototype.collectDataFromObject = function (target) {\\n        var result = {};\\n        return result;\\n    };\\n\\n    /**\\n     * Update controls with actual data\\n     * @param {object} data\\n     */\\n    BaseToolOptions.prototype.updateControls = function (data) {\\n    };\\n\\n    /**\\n     * Collect and update controls with data from target object\\n     * @param  {fabric.Object} target - fabric object\\n     */\\n    BaseToolOptions.prototype.updateControlsFromObject = function (target) {\\n        this.collectDataFromObject(target);\\n        this.updateControls(this.data);\\n    };\\n\\n    /**\\n     * This have to be redefined in child class\\n     * @param {Boolean} [withUpdate] - need to update controls\\n     * @param  {fabric.Object} [tool] - for styles collecting\\n     */\\n    BaseToolOptions.prototype.showControls = function (withUpdate, tool) {\\n    };\\n\\n    /**\\n     * This have to be redefined in child class\\n     * @param {Boolean} [force] - force hide ignoring any options\\n     */\\n    BaseToolOptions.prototype.hideControls = function (force) {\\n    };\\n\\n\\n    pluginsNamespace.BaseToolOptions = BaseToolOptions;\\n}(jQuery, Easel.plugins));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/options-shape-fill/ShapeFill.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-color/OpacityControl.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/PCircle.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-zoom/Zoom.js\"))","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing font size of text;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextDecoration = function TextDecorationConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n    this._setupOptions(options);\\n  };\\n\\n  TextDecoration.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextDecoration.prototype.constructor = BaseTextOptionTool;\\n\\n  TextDecoration.prototype.name = 'TextDecoration';\\n  TextDecoration.prototype.optionName = 'TextDecoration';\\n  TextDecoration.prototype.focusTextOnChange = true;\\n  TextDecoration.prototype.onlyPredefined = true;\\n  /**\\n   * @default\\n   * @const\\n   * @override\\n   * @type {string}\\n   */\\n  TextDecoration.prototype.buttonIconClass = 'fa-strikethrough';\\n  TextDecoration.prototype.valueType = {\\n    textDecoration: 'string'\\n  };\\n\\n  /**\\n   * @type {object}\\n   * @private\\n   */\\n  TextDecoration.prototype._defaultOptions = {\\n    defaultValues: {\\n      textDecoration: ''\\n    },\\n    predefined:{\\n      textDecoration: [\\\"underline\\\", \\\"overline\\\", \\\"line-through\\\"]\\n    }\\n  };\\n  \\n  TextDecoration.prototype.controlTemplate = function () {\\n    var result,\\n        $predefined,\\n        selectHtml;\\n\\n    $predefined = this.options.predefined.textDecoration.map(function (size, i) {\\n      return '<option value=\\\"' + size + '\\\">' + size + '</option>';\\n    }).join('');\\n\\n    selectHtml = '' +\\n        '<select ' +\\n        'class=\\\"editable-canvas-text-decoration-input controls-value-item\\\" ' +\\n        'name=\\\"drawer-size\\\"' +\\n        'data-name=\\\"textDecoration\\\"' +\\n        'value=\\\"' + this.options.defaultValues.textDecoration + '\\\">' +\\n        $predefined +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper editable-canvas-text-option editable-canvas-text-decoration hidden',\\n        optionItemAdditionalClasses = this.buttonMode ? ' toolbar-button-item ': '',\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n        '<span class=\\\"toolbar-item-label\\\">' +\\n        this.drawer.t('Text Decoration:') + ' ' +\\n        '</span>' +\\n        '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n        '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n        '</div>' +\\n        '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n        selectHtml +\\n        '</div>' +\\n        '</li>';\\n\\n    return result;\\n  };\\n\\n  pluginsNamespace.TextDecoration = TextDecoration;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions, util) {\\n  'use strict';\\n\\n  /**\\n   * Base class for text options plugins.\\n   *\\n   * @param drawer\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseToolOptions\\n   */\\n  var BaseTextOptionTool = function (drawer) {\\n    BaseToolOptions.call(this, drawer);\\n    this.drawer = drawer;\\n\\n    this._setEventHandlers();\\n    this._setGlobalClickHandler();\\n  };\\n\\n  BaseTextOptionTool.prototype = Object.create(BaseToolOptions.prototype);\\n  BaseTextOptionTool.prototype.constructor = BaseToolOptions;\\n\\n  /**\\n   * Button icon class - font Awesome\\n   * @constant\\n   * @type {string}\\n   */\\n  BaseTextOptionTool.prototype.buttonIconClass = '';\\n  BaseTextOptionTool.prototype.showOnEditMode = true;\\n  BaseTextOptionTool.prototype.hideOnEditMode = false;\\n\\n  BaseTextOptionTool.prototype.focusTextOnChange = false;\\n\\n  BaseTextOptionTool.prototype.onlyPredefined = false;\\n  BaseTextOptionTool.prototype.stylesToObject = false;\\n\\n  BaseTextOptionTool.prototype.useCombobox = true;\\n  BaseTextOptionTool.prototype.buttonMode = true;\\n\\n  BaseTextOptionTool.prototype.predefined = {};\\n  BaseTextOptionTool.prototype.valueType = {};\\n\\n  BaseTextOptionTool.prototype.minValue = undefined;\\n  BaseTextOptionTool.prototype.maxValue = undefined;\\n\\n  /**\\n   * Setup events\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._setEventHandlers =function () {\\n    // react on styles changes of current text object\\n    this.drawer.on(this.drawer.EVENT_TEXT_STYLES_CHANGED, this._onStylesChanged.bind(this));\\n\\n    // get styles handler\\n    this.drawer.on(this.drawer.EVENT_TEXT_GET_STYLES, this._onGetStyles.bind(this));\\n\\n    if (this._onObjectAdded) {\\n      this.drawer.on(this.drawer.EVENT_OBJECT_ADDED, this._onObjectAdded.bind(this));\\n    }\\n  };\\n\\n  /**\\n   * Apply selected border style to added object.\\n   *\\n   * @param {fabric.Event} fEvent\\n   * @param {Object} styles\\n   * @param {Object} [objectStyles]\\n   * @param {Array} [stylesWithMultipleValues]\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._onStylesChanged = function (fEvent, styles, objectStyles, stylesWithMultipleValues) {\\n    this.updateControls(styles, objectStyles, stylesWithMultipleValues);\\n  };\\n\\n\\n  /**\\n   * Get styles of current control\\n   *\\n   * @param {fabric.Event} [fEvent]\\n   * @param {fabric.Object} [tool]\\n   * @param {Object} result\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._onGetStyles = function (fEvent, tool, result) {\\n    result = result || {};\\n\\n    //@todo get active style\\n\\n    result.defaultValues = $.extend(true, {}, result.defaultValues || {}, this.options.defaultValues || {});\\n  };\\n\\n  /**\\n   * Fill controls with data\\n   * @param {Object} [styles]\\n   * @param {Object} [objectStyles]\\n   * @param {Array} [stylesWithMultipleValues]\\n   */\\n  BaseTextOptionTool.prototype.updateControls = function (styles, objectStyles, stylesWithMultipleValues) {\\n    styles = styles || this._lastData || {};\\n    objectStyles = objectStyles || {};\\n    stylesWithMultipleValues = stylesWithMultipleValues || [];\\n\\n    var _self = this,\\n        $toolControl = this.$toolControl;\\n    if ($toolControl) {\\n      var $allControls = $toolControl.find('.controls-value-item');\\n      $allControls.each(function (i, currElement) {\\n        var $currElement = $(currElement),\\n            isInputType = $currElement.is('input, select, textarea'),\\n            currValueName = $currElement.data('name'),\\n            defaultValue = _self._defaultOptions.defaultValues[currValueName],\\n            inheritedValue = objectStyles[currValueName],\\n            multipleValues = stylesWithMultipleValues.indexOf(currValueName) !== -1,\\n            currValueIsInvalid = styles[currValueName] === undefined,\\n            neededValue = styles[currValueName] !== undefined ? styles[currValueName] : inheritedValue || defaultValue;\\n\\n        if (multipleValues) {\\n          neededValue = '';\\n        }\\n\\n        if (isInputType) {\\n          $currElement.val(neededValue);\\n        }\\n\\n        _self._updateClasses(currValueIsInvalid, currValueIsInvalid && neededValue === inheritedValue, multipleValues);\\n\\n        $toolControl.toggleClass('option-value-invalid', !!currValueIsInvalid);\\n        $toolControl.toggleClass('option-value-multiple', !!multipleValues);\\n        $toolControl.toggleClass('option-value-inherited', !!(currValueIsInvalid && neededValue === inheritedValue));\\n\\n        var haveError = currValueIsInvalid || multipleValues,\\n            inheritedClassString = currValueIsInvalid && neededValue === inheritedValue ? ' option-value-inherited ' : '',\\n            invalidClassString = currValueIsInvalid ? ' option-value-invalid ' : '',\\n            multipleClassString = multipleValues ? ' option-value-multiple ' : '',\\n            classString = '' + inheritedClassString + invalidClassString + multipleClassString ;\\n\\n        if ($currElement.data('comboBox')) {\\n          $currElement.data('comboBox').updateSelectedValues(neededValue, classString);\\n        } else {\\n          $currElement.trigger('valueChanged', [{\\n            value: neededValue,\\n            valueName: currValueName,\\n            inherited: currValueIsInvalid || neededValue === inheritedValue,\\n            multipleValues: multipleValues,\\n            classString: classString\\n          }]);\\n        }\\n\\n        _self.updateSingleControl(currValueName, neededValue);\\n      });\\n    }\\n  };\\n\\n  /**\\n   * Update indicator classes\\n   * @param {Boolean} [valueIsInvalid] - control have invalid value\\n   * @param {Boolean} [valueIsInherited] - control have value inherited from object\\n   * @param {Boolean} [valueIsMultiple] - current selection have multiple values for current style\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._updateClasses = function (valueIsInvalid, valueIsInherited, valueIsMultiple) {\\n    this.$toolControl.toggleClass('option-value-invalid', !!valueIsInvalid);\\n    this.$toolControl.toggleClass('option-value-multiple', !!valueIsInherited);\\n    this.$toolControl.toggleClass('option-value-inherited', !!valueIsMultiple);\\n  };\\n\\n  /**\\n   * React on edit mode entering\\n   * @param  {String} valueName\\n   * @param  {*} value\\n   */\\n  BaseTextOptionTool.prototype.updateSingleControl = function (valueName, value) {\\n\\n  };\\n\\n  /**\\n   * Apply styles\\n   * @param {object.<string>} [styles] - Styles object\\n   */\\n  BaseTextOptionTool.prototype.setStyles = function (styles) {\\n    //@TODO refactor - to many render\\n    styles = styles || this._lastData || this.getStylesFromControls();\\n\\n    var currText = this.drawer.fCanvas.getActiveObject();\\n    if (currText) {\\n      var selectionIsEmpty = currText.selectionEnd === currText.selectionStart;\\n      if (selectionIsEmpty) {\\n        this.drawer.setTemporaryStyles(styles);\\n      } else {\\n        this.drawer.setTemporaryStyles();\\n        if (this.stylesToObject) {\\n          for (var styleName in styles) {\\n            currText[styleName] = styles[styleName];\\n          }\\n        } else {\\n          currText.setSelectionStyles(styles);\\n        }\\n      }\\n      this._lastData = styles;\\n      if (this.focusTextOnChange) {\\n        if (this.comboBox) {\\n          this.comboBox.hideDropdown();\\n        }\\n        if (currText.hiddenTextarea) {\\n          currText.hiddenTextarea.focus();\\n        }\\n      }\\n      currText.canvas.renderAll();\\n    }\\n  };\\n\\n  /**\\n   * Validate and normalize value\\n   * @param {*} value\\n   * @param {string} valueName\\n   * @param {boolean} [doNotUseDefault]\\n   * @return {*} result - normalized value\\n   */\\n\\n  BaseTextOptionTool.prototype.normalizeValue = function (value, valueName, doNotUseDefault) {\\n    var result,\\n        defaultValue = !doNotUseDefault ? this.options.defaultSize : undefined,\\n        validValue = this.validateValue(value, valueName),\\n        overrideWithDefault = !validValue;\\n\\n    result = overrideWithDefault ? defaultValue : value;\\n\\n    if (this.minValue && this.minValue[valueName] !== undefined) {\\n      result = result < this.minValue[valueName] ? this.minValue[valueName] : result;\\n    }\\n\\n    if (this.maxValue && this.maxValue[valueName] !== undefined) {\\n      result = result > this.maxValue[valueName] ? this.maxValue[valueName] : result;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Attach events for control element\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._attachEvents = function () {\\n    if (this.$toolControl) {\\n      this.$toolControl.on('input change toolbarOptionChange', this.onInputChange.bind(this));\\n    }\\n  };\\n\\n  /**\\n   * Create controls\\n   * @returns {string} result - html of controls\\n   */\\n  BaseTextOptionTool.prototype.generateControlHtml = function () {\\n    var result = '';\\n\\n    if (this.controlTemplate) {\\n      if (typeof this.controlTemplate === 'function') {\\n        result = this.controlTemplate();\\n      } else {\\n        result = this.controlTemplate;\\n      }\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Create controls.\\n   * @param  {EaselToolbar} toolbar to add control to\\n   * @param  {Function} [changeCallback]\\n   */\\n  BaseTextOptionTool.prototype.createControls = function (toolbar, changeCallback) {\\n    this.changeCallback = changeCallback;\\n\\n    var toolControlHtml = this.generateControlHtml();\\n    this.$toolControl = $(toolControlHtml);\\n\\n    toolbar.addControl(this.$toolControl, this.options.buttonOrder);\\n    this.setupControl(toolbar, this.$toolControl, changeCallback);\\n    this._attachEvents();\\n\\n    return this.$toolControl;\\n  };\\n\\n  /**\\n   * Create controls.\\n   * @param  {EaselToolbar} toolbar - to add control to\\n   * @param  {jQuery} [$toolControl] - tool control element\\n   * @param  {Function} [changeCallback]\\n   */\\n  BaseTextOptionTool.prototype.setupControl = function (toolbar, $toolControl, changeCallback) {\\n  };\\n\\n\\n  /**\\n   * Setup data\\n   * @param {String} pluginName - name of plugin\\n   * @returns {Object}\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._collectDefaultOptions = function (pluginName) {\\n    var textConfig = this.drawer.getPluginConfig('Text'),\\n        result = {\\n          predefined: $.extend(true, {}, textConfig.predefined || {}),\\n          defaultValues: $.extend(true, {}, textConfig.defaultValues || {})\\n        };\\n    return result;\\n  };\\n\\n  /**\\n   * Process options\\n   * @param {Object} [defaultOptions]\\n   * @param {Object} [options]\\n   * @param {Object} [optionsFromEasel]\\n   * @param {Object} [result]\\n   * @returns {Object}\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._onOptionsSetup = function (defaultOptions, options, optionsFromEasel, result) {\\n    options = options || {};\\n    defaultOptions = defaultOptions || {};\\n    optionsFromEasel = optionsFromEasel || {};\\n\\n    var valueName,\\n        defVal,\\n        drawVal,\\n        optVal;\\n\\n    /**\\n     * Because https://bugs.jquery.com/ticket/9477\\n     * Bug - extend (deep) merges arrays fields instead of replacing them\\n     * **/\\n    for (valueName in result.predefined) {\\n      defVal = (defaultOptions.predefined && defaultOptions.predefined[valueName]);\\n      drawVal = (optionsFromEasel.predefined && optionsFromEasel.predefined[valueName]);\\n      optVal = (options.predefined && options.predefined[valueName]);\\n      result.predefined[valueName] = optVal !== undefined && optVal !== false ? optVal :\\n          drawVal !== undefined && drawVal !== false ? drawVal :\\n          defVal !== undefined && defVal !== false ? defVal : [];\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Handle change of values via controls\\n   * @param  {Event} e - Event that modifies control's values\\n   * @private\\n   * @todo rename as private\\n   */\\n  BaseTextOptionTool.prototype.onInputChange = function (e) {\\n    var valueFromEvent;\\n    valueFromEvent = this.getStylesFromChangeEvent(e);\\n    if (!valueFromEvent) {\\n      this.getStylesFromControls();\\n    }\\n    this.setStyles(valueFromEvent);\\n    this._updateClasses();\\n  };\\n\\n  /**\\n   * Collect data from change event\\n   * @param  {Event} e - event that modifies control's values\\n   */\\n  BaseTextOptionTool.prototype.getStylesFromChangeEvent = function (e) {\\n\\n  };\\n\\n  /**\\n   * Collect data from controls\\n   * @returns {Object}\\n   */\\n  BaseTextOptionTool.prototype.getStylesFromControls = function () {\\n    var _self = this,\\n        result = {},\\n        $toolControl = this.$toolControl;\\n    if ($toolControl) {\\n      var $allControls = $toolControl.find('input, select, textarea');\\n      $allControls.each(function (i, currElement) {\\n        var $currElement = $(currElement),\\n            currValueName = $currElement.data('name'),\\n            currValue = $currElement.val(),\\n            validatedValue = _self.normalizeValue(currValue, currValueName);\\n\\n        if (currValueName !== undefined && currValue !== undefined) {\\n          result[currValueName] = validatedValue;\\n        }\\n      });\\n    }\\n    this._lastData = result;\\n    return result;\\n  };\\n\\n  /**\\n   * Validates value\\n   * @param {*} value\\n   * @param {string} valueName\\n   * @param {Boolean} [strictMode]\\n   * @return {boolean}\\n   */\\n\\n  BaseTextOptionTool.prototype.validateValue = function (value, valueName, strictMode) {\\n    var valueIsValid,\\n        checkForMatchWithPredefined = this.onlyPredefined && this.predefined && this.predefined[valueName],\\n        equalToPredefinedValue = checkForMatchWithPredefined && this.predefined[valueName].indexOf(value) !== -1;\\n\\n    switch (this.valueType[valueName]) {\\n      case 'number':\\n        value = parseFloat(value);\\n        valueIsValid = typeof value === 'number' && isFinite(value);\\n        break;\\n      case 'string':\\n        valueIsValid = typeof value === 'string';\\n        break;\\n      case 'color':\\n        var isString = typeof value === 'string',\\n            isColorInstance = value instanceof fabric.Color;\\n        valueIsValid = strictMode ? isColorInstance : isString;\\n        break;\\n      default :\\n        valueIsValid = value !== undefined;\\n        break;\\n    }\\n\\n    valueIsValid = checkForMatchWithPredefined ? (valueIsValid && equalToPredefinedValue) : valueIsValid;\\n    return valueIsValid;\\n  };\\n\\n  /**\\n   * Hides controls\\n   */\\n  BaseTextOptionTool.prototype.hideControls = function () {\\n    if (this.$toolControl) {\\n      this.$toolControl.addClass('hidden');\\n    }\\n  };\\n\\n\\n  /**\\n   * Shows controls\\n   * @param {Boolean} [withUpdate] - need to update controls\\n   * @param  {fabric.Object} [tool] - for styles collecting\\n   */\\n  BaseTextOptionTool.prototype.showControls = function (withUpdate, tool) {\\n    if (withUpdate) {\\n      tool = tool || this.drawer.fCanvas.getActiveObject();\\n      var currentStyles = tool.getSelectionStyles(),\\n          objStyles = tool.getObjStyles();\\n      this.updateControls(currentStyles ,objStyles);\\n    }\\n    if (this.$toolControl) {\\n      this.$toolControl.removeClass('hidden');\\n    }\\n  };\\n\\n  /**\\n   * Removes tool\\n   */\\n  BaseTextOptionTool.prototype.remove = function () {\\n    if (this.$toolControl) {\\n      this.$toolControl.remove();\\n    }\\n  };\\n\\n  /** @TODO check\\n   * Set listeners for clicks - to properly close controls on outside clicks\\n   * @private\\n   */\\n  BaseTextOptionTool.prototype._setGlobalClickHandler = function () {\\n    var self = this,\\n        $html = $('html');\\n\\n    $html.off('click.textOptionTool').on('click.textOptionTool', function (e) {\\n      self.hideControls();\\n    });\\n  };\\n\\n  pluginsNamespace.BaseTextOptionTool = BaseTextOptionTool;\\n}(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions, Easel.util));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/brush-eraser/Eraser.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/instances/ToolOptionsToolbar.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/PTriangle.js\"))","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions, util) {\\n  'use strict';\\n\\n  /**\\n   * Provides color input\\n   * for changing shapes/brush color.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {String[]} options.colors\\n   * Array of colors to be used.\\n   *\\n   * @param {number} options.colorsInRow\\n   * Number of colors for one row.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @extends {Easel.plugins.BaseToolOptions}\\n   */\\n  var ColorTool = function ColorToolConstructor(drawer, options) {\\n      // call super c-tor\\n      BaseToolOptions.call(this, drawer);\\n    this._setupOptions(options);\\n\\n    /**\\n     * Instance of ColorpickerControl\\n     * @type {Easel.plugins.ColorpickerControl}\\n     */\\n      this.colorControl = new pluginsNamespace.ColorpickerControl(this.drawer, this.options);\\n    /**\\n     * Instance of OpacityControl\\n     * @type {Easel.plugins.OpacityControl}\\n     */\\n      this.opacityControl = new pluginsNamespace.OpacityControl(this.drawer, this.options);\\n      \\n    /**\\n     * Variable to save color used before switching to transparent\\n     */\\n      this.transparentSaveColor = null;\\n    };\\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n  /**\\n   * Creates controls\\n   * @param  {EaselToolbar} toolbar\\n   */\\n  ColorTool.prototype.createControls = function(toolbar) {\\n    this.colorControl.createControl(toolbar,  this._onColorSelected.bind(this));\\n    this.opacityControl.createControl(toolbar,  this._onOpacityControlChanged.bind(this));\\n    this.hideControls(true);\\n  };\\n\\n\\n  /**\\n   * This function is called everytime user clicks on color from color-dropdown\\n   * menu.\\n   *\\n   * @param {String} selectedColor Hash value of user selected color.\\n   */\\n  ColorTool.prototype._onColorSelected = function (selectedColor) {\\n    if (selectedColor == \\\"rgba(0, 0, 0, 0)\\\") {\\n      //selected transparent color\\n      this.saveColor();\\n    }\\n    this.drawer.setColor(selectedColor);\\n  };\\n\\n\\n  /**\\n   * This function is called every time user clicks on color from color-dropdown\\n   * menu.\\n   *\\n   * @param {String} opacity Hash value of user selected color.\\n   */\\n  ColorTool.prototype._onOpacityControlChanged = function (opacity) {\\n    var currentColor = this.drawer.activeColor;\\n    var colorWithAlfaRgba = this._hexToRgba(currentColor, opacity);\\n\\n    this.drawer.setColor(colorWithAlfaRgba);\\n  };\\n\\n\\n  /**\\n   * React on object selection - update controls\\n   * Is called from BaseOptionTool._onObjectSelected method\\n   *\\n   * @param  {fabric.Object} target\\n   */\\n  ColorTool.prototype.updateControlsFromObject = function (target) {\\n      var color = null;\\n\\n      // get object color\\n      if (target.path) { // free drawing shape\\n        // @todo: rework in target.getColor()\\n        color = target.get('stroke');\\n        this.colorControl.disableTransparent();\\n        this.restoreColor();\\n      }  else {\\n        color = target.get('fill');\\n        this.colorControl.enableTransparent();\\n      }\\n\\n      // update color and opacity controls\\n      if (color) {\\n        this.updateControlsWithColor(color);\\n        this.drawer.activeColor = color;\\n      }\\n  };\\n\\n\\n  /**\\n   * Updates color and opacity controls with color\\n   * @param  {String} color\\n   */\\n  ColorTool.prototype.updateControlsWithColor = function(color) {\\n        // update color control\\n        this.colorControl.setColor(color);\\n\\n        // update opacity control\\n        var fColor = new fabric.Color(color);\\n        var source = fColor._source;\\n        var opacity = source[3];\\n        this.opacityControl.setOpacity(opacity);\\n  };\\n\\n  /**\\n   * Shows / hides transparency based on current selected tool\\n   * @param {BaseTool} tool\\n   */\\n  ColorTool.prototype.onActivateTool = function (tool) {\\n      if (tool instanceof pluginsNamespace.Line ||\\n          tool instanceof pluginsNamespace.ArrowOneSide ||\\n          tool instanceof pluginsNamespace.ArrowTwoSide ||\\n          tool instanceof pluginsNamespace.Pencil) {\\n        //no transparent for them\\n        this.colorControl.disableTransparent();\\n        this.restoreColor();\\n      } else {\\n        //should be save to activate\\n        this.colorControl.enableTransparent();\\n      }\\n  };\\n  \\n  /**\\n   * Save current color into transparentSaveColor\\n   */\\n  ColorTool.prototype.saveColor = function () {\\n    if(!this.transparentSaveColor) {\\n      this.transparentSaveColor = this.drawer.activeColor;\\n    }\\n  };\\n  \\n  /**\\n   * Load color from transparentSaveColor\\n   */\\n  ColorTool.prototype.restoreColor = function () {\\n    if(this.transparentSaveColor) {\\n      this._onColorSelected(this.transparentSaveColor);\\n      this.colorControl.setColor(this.transparentSaveColor);\\n      this.transparentSaveColor = null;\\n    }\\n  };\\n\\n\\n  /**\\n   * Show color control and optionally - opacity control\\n   * @param  {Boolean} [withoutOpacity]\\n   */\\n  ColorTool.prototype.showControls = function (withoutOpacity) {\\n    withoutOpacity = withoutOpacity !== undefined ? withoutOpacity : !this.options.showOpacityControl;\\n      this.colorControl.showControls();\\n      if (withoutOpacity) {\\n        this.opacityControl.hideControls();\\n      } else {\\n        this.opacityControl.showControls();\\n      }\\n  };\\n\\n\\n  /**\\n   * Hides both controls\\n   */\\n  ColorTool.prototype.hideControls = function (force) {\\n    var alwaysVisible = this.drawer.options.toolbars.popupButtonAlwaysVisible || this.options.alwaysVisible;\\n    if (force || !alwaysVisible) {\\n      this.colorControl.hideControls();\\n      this.opacityControl.hideControls();\\n    }\\n  };\\n\\n\\n  /**\\n   * Adds opacity to color in hex form, returns rgba\\n   * @param  {String} colorHex color in hex format\\n   * @param  {Number} opacity  opacity 0..1\\n   * @return {String}          color in rgba format\\n   */\\n  ColorTool.prototype._hexToRgba = function(colorHex, opacity) {\\n    var colorWithAlfa = new fabric.Color(colorHex);\\n    colorWithAlfa._source[3] =  opacity;\\n\\n    return colorWithAlfa.toRgba();\\n  };\\n\\n\\n  pluginsNamespace.Color = ColorTool;\\n\\n}(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions, Easel.util));\\n\"","module.exports = \"(function(EaselApi) {\\n\\n  /**\\n   * Show context menu.\\n   */\\n    EaselApi.prototype.contextMenuShow = function() {\\n        this.drawer.api.checkIsActive();\\n        var tool = this.drawer.getPluginInstance('ShapeContextMenu');\\n        tool.showContextMenu();\\n    };\\n\\n  /**\\n   * Show context menu.\\n   */\\n    EaselApi.prototype.contextMenuHide = function() {\\n        this.drawer.api.checkIsActive();\\n        var tool = this.drawer.getPluginInstance('ShapeContextMenu');\\n        tool.hideContextMenu();\\n    };\\n\\n\\n  /**\\n   * Set Context menu left top origin.\\n   * @param {number} left\\n   * @param {number} top\\n   * @param {boolean} doFitInViewport if true - inca case menu is out of viewport, it's coordinates will be adjusted\\n   */\\n    EaselApi.prototype.contextMenuSetPosition= function(left, top, doFitInViewport) {\\n        this.drawer.api.checkIsActive();\\n        var tool = this.drawer.getPluginInstance('ShapeContextMenu');\\n\\n        if (doFitInViewport) {\\n          var newCoords = tool._calcCoordsToFitViewport(left, top);\\n          left = newCoords.left;\\n          top = newCoords.top;\\n        }\\n\\n        tool.setMenuPosition(left, top);\\n    };\\n\\n\\n})(Easel.EaselApi);\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/PText.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Easel.Storage.js\"))","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing font style of text;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextFontStyle = function TextFontStyleConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    // init options\\n    this._setupOptions(options);\\n  };\\n\\n  TextFontStyle.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextFontStyle.prototype.constructor = BaseTextOptionTool;\\n\\n  TextFontStyle.prototype.name = 'TextFontStyle';\\n  TextFontStyle.prototype.optionName = 'TextFontStyle';\\n  TextFontStyle.prototype.onlyPredefined = true;\\n  TextFontStyle.prototype.focusTextOnChange = true;\\n  TextFontStyle.prototype.buttonIconClass = 'fa-italic';\\n  TextFontStyle.prototype.valueType = {\\n    fontStyle: 'string'\\n  };\\n\\n  TextFontStyle.prototype._defaultOptions = {\\n    defaultValues: {\\n      fontStyle: ''\\n    },\\n    predefined: {\\n      fontStyle: [\\\"normal\\\", \\\"italic\\\", \\\"oblique\\\"]\\n    }\\n  };\\n  \\n  TextFontStyle.prototype.controlTemplate = function () {\\n    var result,\\n        $predefined,\\n        selectHtml;\\n\\n    $predefined = this.options.predefined.fontStyle.map(function (size, i) {\\n      return '<option value=\\\"' + size + '\\\">' + size + '</option>';\\n    }).join('');\\n\\n    selectHtml = '' +\\n        '<select ' +\\n        'class=\\\"editable-canvas-text-fontstyle-input controls-value-item\\\" ' +\\n        'name=\\\"drawer-size\\\"' +\\n        'data-name=\\\"fontStyle\\\"' +\\n        'value=\\\"' + this.options.defaultValues.fontStyle + '\\\">' +\\n        $predefined +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper editable-canvas-text-option editable-canvas-text-fontstyle hidden',\\n        optionItemAdditionalClasses = this.buttonMode ? ' toolbar-button-item ': '',\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n        '<span class=\\\"toolbar-item-label\\\">' +\\n        this.drawer.t('Font style:') + ' ' +\\n        '</span>' +\\n        '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n        '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n        '</div>' +\\n        '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n        selectHtml +\\n        '</div>' +\\n        '</li>';\\n\\n    return result;\\n  };\\n\\n  pluginsNamespace.TextFontStyle = TextFontStyle;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/instances/MinimizedToolbar.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-colorpicker-html5/ColorpickerHtml5.js\"))","module.exports = \"/**\\n * Toolbar with tool options\\n *\\n * @param {Easel.Easel} drawerInstance\\n * @param {Object} [options]\\n * @extends EaselToolbar\\n * @constructor\\n */\\nvar ToolOptionsToolbar = function (drawerInstance, options) {\\n  // css class for toolbar\\n  options.toolbarClass = 'tool-options-toolbar';\\n  // call EaselToolbar c-tor\\n  EaselToolbar.call(this, drawerInstance, options);\\n  this.$toolbar.addClass('element-properties-toolbar hidden');\\n  this._visibilityReasons = {\\n    manual: false,\\n    selection: false,\\n    pencil: false\\n  };\\n  this._bindSelectionVisibility();\\n  // cry loud of birth\\n  drawerInstance.trigger(drawerInstance.EVENT_OPTIONS_TOOLBAR_CREATED, [this]);\\n};\\n\\nToolOptionsToolbar.prototype = Object.create(EaselToolbar.prototype);\\nToolOptionsToolbar.prototype.constructor = EaselToolbar;\\n\\nToolOptionsToolbar.prototype._bindSelectionVisibility = function () {\\n  this._onObjectSelected = function () {\\n    this._setVisibilityReason('selection', true);\\n  }.bind(this);\\n  this._onSelectionCleared = function () {\\n    this._setVisibilityReason('selection', false);\\n  }.bind(this);\\n\\n  this._onToolActivated = function (event, tool) {\\n    if (tool && tool.name === 'Pencil') {\\n      this._setVisibilityReason('pencil', true);\\n    }\\n  }.bind(this);\\n\\n  this._onToolDeactivated = function (event, tool) {\\n    if (tool && tool.name === 'Pencil') {\\n      this._setVisibilityReason('pencil', false);\\n    }\\n  }.bind(this);\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_OBJECT_SELECTED, this._onObjectSelected);\\n  this.drawerInstance.on(this.drawerInstance.EVENT_SELECTION_CLEARED, this._onSelectionCleared);\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOL_ACTIVATED, this._onToolActivated);\\n  this.drawerInstance.on(this.drawerInstance.EVENT_TOOL_DEACTIVATED, this._onToolDeactivated);\\n};\\n\\nToolOptionsToolbar.prototype._unbindSelectionVisibility = function () {\\n  if (this._onObjectSelected) {\\n    this.drawerInstance.off(this.drawerInstance.EVENT_OBJECT_SELECTED, this._onObjectSelected);\\n    this._onObjectSelected = null;\\n  }\\n  if (this._onSelectionCleared) {\\n    this.drawerInstance.off(this.drawerInstance.EVENT_SELECTION_CLEARED, this._onSelectionCleared);\\n    this._onSelectionCleared = null;\\n  }\\n  if (this._onToolActivated) {\\n    this.drawerInstance.off(this.drawerInstance.EVENT_TOOL_ACTIVATED, this._onToolActivated);\\n    this._onToolActivated = null;\\n  }\\n  if (this._onToolDeactivated) {\\n    this.drawerInstance.off(this.drawerInstance.EVENT_TOOL_DEACTIVATED, this._onToolDeactivated);\\n    this._onToolDeactivated = null;\\n  }\\n};\\n\\nToolOptionsToolbar.prototype._setVisibilityReason = function (reason, state) {\\n  if (!this.$toolbar) {\\n    return;\\n  }\\n  this._visibilityReasons = this._visibilityReasons || {};\\n  this._visibilityReasons[reason] = !!state;\\n  var shouldShow = false;\\n  for (var key in this._visibilityReasons) {\\n    if (Object.prototype.hasOwnProperty.call(this._visibilityReasons, key) && this._visibilityReasons[key]) {\\n      shouldShow = true;\\n      break;\\n    }\\n  }\\n  if (shouldShow) {\\n    this.$toolbar.removeClass('hidden');\\n  } else {\\n    this.$toolbar.addClass('hidden');\\n  }\\n};\\n\\nToolOptionsToolbar.prototype.showToolbar = function () {\\n  this._setVisibilityReason('manual', true);\\n};\\n\\nToolOptionsToolbar.prototype.hideToolbar = function () {\\n  this._setVisibilityReason('manual', false);\\n};\\n\\nToolOptionsToolbar.prototype.remove = function () {\\n  this._unbindSelectionVisibility();\\n  EaselToolbar.prototype.remove.call(this);\\n};\\n\\nToolOptionsToolbar.prototype.customScrollMode = true;\"","module.exports = \"(function (global, $, pluginsNamespace, EaselApi, util) {\\n  'use strict';\\n  var fabric = global.fabric || (global.fabric = {});\\n\\n  var MOUSE_DOWN = util.mouseDown('Zoom');\\n  var MOUSE_MOVE = util.mouseMove('Zoom');\\n  var MOUSE_UP = util.mouseUp('Zoom');\\n  var isWebkit = util.checkBrowser('webkit'),\\n      cursorPrefix = isWebkit ? '-webkit-' : '';\\n\\n  /**\\n   * Provides ability to change zoom\\n   *\\n   * @param {Easel.Easel} drawer\\n   * @param {Easel.plugins.Zoom.defaultOptions} [options]\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var Zoom = function ZoomConstructor(drawer, options) {\\n    /**\\n     * @type {Easel}\\n     */\\n    this.drawer = drawer;\\n    this._setupOptions(options);\\n    this._init();\\n  };\\n\\n  /**\\n   * @typedef {Object} defaultOptions\\n   * @memberOf Easel.plugins.Zoom\\n   * @property {Boolean} [enabled=true] - Zoom is enabled\\n   * @property {Boolean} [enableWhenNoActiveTool=true] - Allow to move canvas when no object is selected and is no active tool.\\n   * @property {Boolean} [enableButton=true] - Add \\\"move canvas\\\" button to settings toolbar\\n   * @property {Boolean} [showZoomTooltip=true] - Show tooltip with current zoom value on any change of zoom props\\n   * @property {Boolean} [enableMove=true] - Enable move of canvas\\n   * @property {Boolean} [useWheelEvents=true] - Attach wheel events\\n   * @property {Boolean} [moveCanvasOnWheel=true] - Change center of viewport on wheel events depending on mouse position.\\n   * @property {Number} [moveCanvasOnWheelStep=0] - Attach wheel events. Valid range of value is from 0(center of\\n   * viewport will not changed) to 1(center of viewport will move to mouse position). Most comfortable value is 0.05-0.15\\n   * @property {Number} [zoomStep=1.05] - Step of each zoom change. (1.05 = 105%)\\n   * @property {Number} [defaultZoom=1] - Default zoom value\\n   * @property {Number} [minZoom=1] - Min zoom value\\n   * @property {Number} [maxZoom=32] - Max zoom value\\n   *\\n   */\\n\\n  /**\\n   * @type {Easel.plugins.Zoom.defaultOptions}\\n   * @private\\n   */\\n  Zoom.prototype._defaultOptions = {\\n    enabled: true,\\n\\n    enableWhenNoActiveTool: true,\\n    enableButton: true,\\n\\n    showZoomTooltip: true,\\n    enableMove: true,\\n    useWheelEvents: true,\\n\\n    moveCanvasOnWheel: true,\\n    moveCanvasOnWheelStep: 0,\\n\\n    zoomStep: 1.05,\\n    defaultZoom: 1,\\n    maxZoom: 32,\\n    minZoom: 1,\\n    buttonOrder: 11\\n  };\\n\\n  /**\\n   * Init zoom plugin\\n   * @private\\n   */\\n  Zoom.prototype._init = function () {\\n    this.viewport = new pluginsNamespace.ZoomViewport(this.drawer);\\n\\n    this.enabled = this.options.enabled;\\n    this.zoomIsOn = true;\\n    this.currentZoom = 1;\\n\\n    this._updateProto();\\n    if (this.enabled) {\\n      this._attachEaselEvents();\\n      this._updateEaselValues();\\n    }\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  Zoom.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Update prototype of fabric object/canvas\\n   * @private\\n   */\\n  Zoom.prototype._updateProto = function () {\\n    this.drawer.on(this.drawer.EVENT_CANVAS_READY, this._updateCanvasProto.bind(this));\\n    this.drawer.on(this.drawer.EVENT_CANVAS_READY, this._updateObjectProto.bind(this));\\n  };\\n\\n  /**\\n   * Attach drawer events\\n   * @private\\n   */\\n  Zoom.prototype._attachEaselEvents = function () {\\n    this.drawer.on(this.drawer.EVENT_TOOLS_TOOLBAR_CREATED, this._onToolbarCreated.bind(this));\\n    this.drawer.on(this.drawer.EVENT_RESTORE_DEFAULT_ZOOM, this.restoreDefaultZoom.bind(this));\\n\\n    this.drawer.on(this.drawer.EVENT_DO_ACTIVATE_TOOL, this._onActivateTool.bind(this));\\n    this.drawer.on(this.drawer.EVENT_DO_DEACTIVATE_TOOL, this._ctxUpperRestore.bind(this));\\n\\n    this.drawer.on(this.drawer.EVENT_BEFORE_RENDER, this._ctxSet.bind(this));\\n    this.drawer.on(this.drawer.EVENT_AFTER_RENDER, this._ctxRestore.bind(this));\\n\\n    this.drawer.on(this.drawer.EVENT_ZOOM_SET, this._ctxSet.bind(this));\\n    this.drawer.on(this.drawer.EVENT_ZOOM_UNSET, this._ctxUnset.bind(this));\\n    this.drawer.on(this.drawer.EVENT_ZOOM_RESTORE, this._ctxRestore.bind(this));\\n\\n    this.drawer.on(this.drawer.EVENT_ZOOM_UPPER_SET, this._ctxUpperSet.bind(this));\\n    this.drawer.on(this.drawer.EVENT_ZOOM_UPPER_UNSET, this._ctxUpperUnset.bind(this));\\n    this.drawer.on(this.drawer.EVENT_ZOOM_UPPER_RESTORE, this._ctxUpperRestore.bind(this));\\n\\n    this.drawer.on(this.drawer.EVENT_CANVAS_START_RESIZE, this._ctxSet.bind(this));\\n    this.drawer.on(this.drawer.EVENT_CANVAS_STOP_RESIZE, this._ctxRestore.bind(this));\\n\\n    this.drawer.on(this.drawer.EVENT_SELECTION_CLEARED, this._refreshButton.bind(this));\\n    this.drawer.on(this.drawer.EVENT_OBJECT_SELECTED, this._refreshButton.bind(this));\\n\\n    this.drawer.on(this.drawer.EVENT_TOOL_ACTIVATED, this._refreshButton.bind(this));\\n    this.drawer.on(this.drawer.EVENT_TOOL_DEACTIVATED, this._refreshButton.bind(this));\\n  };\\n\\n  Zoom.prototype._refreshButton = function (fEvent) {\\n    this._refreshMoveButtonState();\\n  };\\n\\n  Zoom.prototype._ctxUpperSet = function (fEvent) {\\n    var fCanvas = this.drawer.fCanvas,\\n        ctxUpper = fCanvas.contextTop;\\n    ctxUpper.save();\\n    ctxUpper.scale(this.viewport.zoom, this.viewport.zoom);\\n    ctxUpper.translate(this.viewport.position.x, this.viewport.position.y);\\n  };\\n\\n  Zoom.prototype._ctxUpperUnset = function (fEvent) {\\n    var fCanvas = this.drawer.fCanvas,\\n        ctxUpper = fCanvas.contextTop;\\n    ctxUpper.save();\\n    ctxUpper.scale(1 / this.viewport.zoom, 1 / this.viewport.zoom);\\n    ctxUpper.translate(-this.viewport.position.x, -this.viewport.position.y);\\n\\n  };\\n\\n  Zoom.prototype._ctxUpperRestore = function (fEvent) {\\n    var fCanvas = this.drawer.fCanvas,\\n        ctxUpper = fCanvas.contextTop;\\n    ctxUpper.restore();\\n  };\\n\\n  Zoom.prototype._ctxSet = function (fEvent) {\\n    var fCanvas = this.drawer.fCanvas,\\n        ctx = fCanvas.contextContainer;\\n    ctx.save();\\n    ctx.scale(this.viewport.zoom, this.viewport.zoom);\\n    ctx.translate(this.viewport.position.x, this.viewport.position.y);\\n  };\\n\\n  Zoom.prototype._ctxUnset = function (fEvent) {\\n    var fCanvas = this.drawer.fCanvas,\\n        ctx = fCanvas.contextContainer;\\n    ctx.save();\\n    ctx.scale(1 / this.viewport.zoom, 1 / this.viewport.zoom);\\n    ctx.translate(-this.viewport.position.x, -this.viewport.position.y);\\n  };\\n\\n  Zoom.prototype._ctxRestore = function (fEvent) {\\n    var fCanvas = this.drawer.fCanvas,\\n        ctx = fCanvas.contextContainer;\\n    ctx.restore();\\n  };\\n  /**\\n   * React on activate of tool\\n   * @param {fabric.Event} fEvent event obj\\n   * @param {BaseTool} tool tool object\\n   * @private\\n   */\\n  Zoom.prototype._onActivateTool = function (fEvent, tool) {\\n    if (!tool.doNotZoomOnActivate) {\\n      this._ctxUpperSet();\\n    }\\n  };\\n\\n  /**\\n   * React on deactivate of tool\\n   * @param {fabric.Event} fEvent event obj\\n   * @param {BaseTool} tool tool object\\n   * @private\\n   */\\n  Zoom.prototype._onDeactivateTool = function (fEvent, tool) {\\n    if (!tool.doNotZoomOnActivate) {\\n      this._ctxUpperRestore();\\n    }\\n  };\\n\\n  /**\\n   * On toolbar created - create tool button.\\n   * @param {fabric.Event} fEvent - event obj\\n   * @param {EaselToolbar} toolbar - Easel toolbar\\n   */\\n  Zoom.prototype._onToolbarCreated = function (fEvent, toolbar) {\\n    if (this.toolbarInitialized) {\\n      return;\\n    }\\n    this.toolbar = toolbar;\\n    this.toolbarInitialized = true;\\n\\n    this.createControls(toolbar);\\n    this._createHelperElements();\\n    this._attachEvents();\\n  };\\n\\n  /**\\n   * Remove helper elements\\n   * @private\\n   */\\n  Zoom.prototype._removeHelperElements = function () {\\n    if (this.$zoomTooltip && this.$zoomTooltip.length) {\\n      this.$zoomTooltip.remove();\\n      delete this.$zoomTooltip;\\n    }\\n  };\\n\\n  /**\\n   * Create helper elements\\n   * @private\\n   */\\n  Zoom.prototype._createHelperElements = function () {\\n    this._removeHelperElements();\\n    var zoomTooltipHtml = '<div class=\\\"zoom-tooltip transparent-tooltip\\\"></div>',\\n        $zoomTooltip = $(zoomTooltipHtml),\\n        $canvasContainer = this.drawer.$canvasEditContainer;\\n\\n    this.$zoomTooltip = $zoomTooltip;\\n    $canvasContainer.append($zoomTooltip);\\n  };\\n\\n  /**\\n   * Attach events for helper elements\\n   * @private\\n   */\\n  Zoom.prototype._attachEvents = function () {\\n    var self = this;\\n    if (this.options.showZoomTooltip) {\\n      var hideFunc = function () {\\n            self.$zoomTooltip.addClass('transparent-tooltip');\\n          },\\n          debouncedTooltipHideFunc = util.debounce(hideFunc, 1000);\\n\\n      this.drawer.on(this.drawer.EVENT_ZOOM_CHANGE, function (fEvent, zoomProps) {\\n        var zoomAsText = parseInt(zoomProps.zoom * 100, 10) + '%';\\n        self.$zoomTooltip.text(zoomAsText);\\n        self.$zoomTooltip.removeClass('transparent-tooltip');\\n        debouncedTooltipHideFunc();\\n      });\\n    }\\n    if (this.options.enableButton) {\\n      this.drawer.on(this.drawer.EVENT_ZOOM_CHANGE, function (fEvent, zoomProps) {\\n        var stateIsChanged = (zoomProps.prevValues.zoom === 1 && zoomProps.zoom !== 1) || (zoomProps.zoom === 1 && zoomProps.prevValues.zoom !== 1);\\n        if (stateIsChanged) {\\n          self._refreshMoveButtonState();\\n        }\\n      });\\n    }\\n  };\\n\\n\\n  /**\\n   * Create controls\\n   * @param {EaselToolbar} toolbar - Easel toolbar\\n   */\\n  Zoom.prototype.createControls = function (toolbar) {\\n    this._createAndAddButton(toolbar);\\n    this._attachWheelEvents();\\n    this._attachMoveEvents();\\n    this._attachTouchEvents();\\n\\n  };\\n\\n\\n  /**\\n   * Creates and adds buttons to toolbar.\\n   * @param  {EaselToolbar} toolbar\\n   */\\n  Zoom.prototype._createAndAddButton = function (toolbar) {\\n    var viewGroup = {\\n          name: 'view-controls-group',\\n          tooltip: this.drawer.t('View controls')\\n        },\\n        baseConfig = {\\n          buttonOrder: this.options.buttonOrder,\\n          group: viewGroup\\n        },\\n        zoomInButtonConf = $.extend(true, {}, baseConfig, {\\n          additionalClass: 'btn-zoom-in',\\n          iconClass: 'fa-search-plus',\\n          tooltipText: this.drawer.t('Zoom in'),\\n          clickHandler: this._onZoomIn.bind(this)\\n        }),\\n        zoomOutButtonConf = $.extend(true, {}, baseConfig, {\\n          additionalClass: 'btn-zoom-out',\\n          iconClass: 'fa-search-minus',\\n          tooltipText: this.drawer.t('Zoom out'),\\n          clickHandler: this._onZoomOut.bind(this)\\n        }),\\n        moveCanvasButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-zoom-move',\\n          iconClass: 'fa-arrows',\\n          tooltipText: this.drawer.t('Move canvas'),\\n          clickHandler: this._onMoveButtonClick.bind(this)\\n        };\\n\\n    var $zoomInButton = toolbar.addButtonToGroup(zoomInButtonConf);\\n    var $zoomOutButton = toolbar.addButtonToGroup(zoomOutButtonConf);\\n\\n    if (this.options.enableMove && this.options.enableButton) {\\n      this.$moveCanvasButton = toolbar.addButton(moveCanvasButtonConf);\\n    }\\n\\n    this.viewControlsGroup = viewGroup;\\n    this.$zoomInButton = $zoomInButton;\\n    this.$zoomOutButton = $zoomOutButton;\\n\\n    this._applyViewControlsGroupIcon();\\n  };\\n\\n  Zoom.prototype._applyViewControlsGroupIcon = function () {\\n    if (!this.toolbar || !this.viewControlsGroup) {\\n      return;\\n    }\\n    var $groupContainer = this.toolbar.buttonsGroups[this.viewControlsGroup.name];\\n    if (!$groupContainer || !$groupContainer.length) {\\n      return;\\n    }\\n\\n    $groupContainer.addClass('view-controls-trigger');\\n    var $groupIcon = $groupContainer.find('> a .fa');\\n    if ($groupIcon.length) {\\n      $groupIcon.attr('class', 'fa fa-ellipsis-v');\\n    }\\n    var $groupButton = $groupContainer.children('a');\\n    $groupButton.attr('title', this.drawer.t('View controls'));\\n  };\\n\\n  /**\\n   * React on \\\"Move canvas\\\" button click\\n   * @param {Event} event\\n   * @private\\n   */\\n  Zoom.prototype._onMoveButtonClick = function (event) {\\n    if (!this.$moveCanvasButton) {\\n      return;\\n    }\\n    var isDisabled = this.$moveCanvasButton.hasClass('disabled');\\n    if (!isDisabled) {\\n      this.moveButtonIsActive = !this.moveButtonIsActive;\\n      this._refreshMoveButtonState(true);\\n    }\\n  };\\n\\n  /**\\n   * Collect data for zoom from event\\n   * @param {Event} event\\n   * @param {Boolean} [changeZoomCenter]\\n   * @param {Boolean} [zoomIn]\\n   * @returns {Object}\\n   * @private\\n   */\\n  Zoom.prototype._getZoomPopertiesFromEvent = function (event, changeZoomCenter, zoomIn) {\\n    var result = {},\\n        newZoomCenterX,\\n        newZoomCenterY,\\n        newZoomValue = this.currentZoom * (zoomIn ? this.options.zoomStep : 1 / this.options.zoomStep);\\n    if (changeZoomCenter) {\\n      var eventPosition = this.drawer.getRelativeEventPosition(event, true),\\n          zoomCenterXFromEvent = eventPosition.left / newZoomValue - this.viewport.position.x,\\n          zoomCenterYFromEvent = eventPosition.top / newZoomValue - this.viewport.position.y,\\n          deltaX = zoomCenterXFromEvent - this.zoomCenterX,\\n          deltaY = zoomCenterYFromEvent - this.zoomCenterY;\\n\\n      newZoomCenterX = this.zoomCenterX + deltaX * this.options.moveCanvasOnWheelStep;\\n      newZoomCenterY = this.zoomCenterY + deltaY * this.options.moveCanvasOnWheelStep;\\n    } else {\\n      newZoomCenterX = this.zoomCenterX;\\n      newZoomCenterY = this.zoomCenterY;\\n    }\\n    result.zoom = newZoomValue;\\n    result.zoomCenterX = newZoomCenterX;\\n    result.zoomCenterY = newZoomCenterY;\\n    return result;\\n  };\\n\\n  /**\\n   * Trigger zoom in event\\n   * @param {Event} event\\n   * @param {Boolean} [changeZoomCenter]\\n   * @private\\n   */\\n  Zoom.prototype._onZoomIn = function (event, changeZoomCenter) {\\n    if (this.zoomIsOn) {\\n      var zoomProps = this._getZoomPopertiesFromEvent(event, changeZoomCenter, true);\\n      this.setZoom(zoomProps.zoom, zoomProps.zoomCenterX, zoomProps.zoomCenterY, true);\\n    }\\n  };\\n\\n  /**\\n   * Trigger zoom out event\\n   * @param {Event} event\\n   * @param {Boolean} [changeZoomCenter]\\n   * @private\\n   */\\n  Zoom.prototype._onZoomOut = function (event, changeZoomCenter) {\\n    if (this.zoomIsOn) {\\n      var zoomProps = this._getZoomPopertiesFromEvent(event, changeZoomCenter, false);\\n      this.setZoom(zoomProps.zoom, zoomProps.zoomCenterX, zoomProps.zoomCenterY, true);\\n    }\\n  };\\n\\n  /**\\n   * Attach wheel event to canvas\\n   * @private\\n   */\\n  Zoom.prototype._attachWheelEvents = function () {\\n    if (this.options.useWheelEvents) {\\n      this.wheelEventsAttached = true;\\n      var canvasContainer = this.drawer.$canvasEditContainer.find('.canvas-container').get(0);\\n      util.addWheelListener(canvasContainer, this._onWheelEvent.bind(this), true); //@todo capture\\n    }\\n  };\\n\\n  /**\\n   * Attach move events\\n   * @private\\n   */\\n  Zoom.prototype._attachMoveEvents = function () {\\n    if (this.options.enableMove) {\\n      var $document = $(window.document),\\n          $canvasContainer = this.drawer.$canvasEditContainer.find('.canvas-container');\\n\\n      $canvasContainer.off(MOUSE_DOWN).on(MOUSE_DOWN, this._moveOnMouseDown.bind(this));\\n      $document.off(MOUSE_MOVE).on(MOUSE_MOVE, this._moveOnMouseMove.bind(this));\\n      $document.off(MOUSE_UP).on(MOUSE_UP, this._moveOnMouseUp.bind(this));\\n    }\\n  };\\n\\n  /**\\n   * Move canvas - React on mouse down.\\n   * @param {Event} e\\n   * @private\\n   */\\n  Zoom.prototype._moveOnMouseDown = function (e) {\\n    var currActiveObj = this.drawer.fCanvas.getActiveObject(),\\n        selectedTool = this.drawer.activeDrawingTool,\\n        buttonIsActive = this.moveButtonIsActive,\\n\\n        buttonPermission = this.options.enableButton && buttonIsActive,\\n        noActiveToolPermission = this.options.enableWhenNoActiveTool && (!this.options.enableButton || buttonPermission),\\n        preventMove = this.currentZoom === 1 || currActiveObj || selectedTool,\\n        initMove = !preventMove && (buttonPermission || noActiveToolPermission);\\n\\n    if (initMove) {\\n      var currPoint = this.drawer.getRelativeEventPosition(e);\\n\\n      this.drawer.movingNow = true;\\n      this.isMoving = true;\\n      this.moveStartPoint = currPoint;\\n      this.moveLastPoint = currPoint;\\n\\n      var $body = $('body');\\n      this.drawer.fCanvas.defaultCursor = cursorPrefix + 'grabbing';\\n      this.drawer.fCanvas.setCursor(cursorPrefix + 'grabbing');\\n      $body.addClass('drawer-dragging drawer-zoom-moving');\\n\\n      e.preventDefault();\\n      e.stopPropagation();\\n      return false;\\n    }\\n  };\\n\\n  /**\\n   *\\n   * @private\\n   */\\n  Zoom.prototype._refreshMoveButtonState = function (doNotSaveState) {\\n    this.savedDefaultCursor = this.savedDefaultCursor || this.drawer.fCanvas.defaultCursor;\\n    if (this.options.enableButton) {\\n      if (!this.$moveCanvasButton) {\\n        return;\\n      }\\n      if (this.currentZoom === 1) {\\n        this.$moveCanvasButton.addClass('disabled');\\n        this._setMoveButtonActiveState(false);\\n        this.drawer.fCanvas.defaultCursor = this.savedDefaultCursor;\\n        this.drawer.fCanvas.setCursor(this.savedDefaultCursor);\\n      } else {\\n        if (!doNotSaveState) {\\n          var enableToMove = this._checkMovePermission(!doNotSaveState);\\n          this.moveButtonIsActive = enableToMove;\\n        }\\n\\n        this.$moveCanvasButton.removeClass('disabled');\\n        if (this.moveButtonIsActive) {\\n          this._prepareEaselForZoom();\\n          this.drawer.fCanvas.defaultCursor = cursorPrefix + 'grab';\\n          this.drawer.fCanvas.setCursor(cursorPrefix + 'grab');\\n          $('body').addClass('drawer-zoom-move-available');\\n          this._setMoveButtonActiveState(true);\\n        } else {\\n          this.drawer.fCanvas.defaultCursor = this.savedDefaultCursor;\\n          this.drawer.fCanvas.setCursor(this.savedDefaultCursor);\\n          $('body').removeClass('drawer-zoom-move-available');\\n          this._setMoveButtonActiveState(false);\\n        }\\n      }\\n    } else {\\n      this.drawer.fCanvas.defaultCursor = cursorPrefix + 'grab';\\n      this.drawer.fCanvas.setCursor(cursorPrefix + 'grab');\\n      $('body').addClass('drawer-zoom-move-available');\\n    }\\n  };\\n\\n  Zoom.prototype._setMoveButtonActiveState = function (isActive) {\\n    if (!this.$moveCanvasButton) {\\n      return;\\n    }\\n    var $icon = this.$moveCanvasButton.find('.toolbar-button-icon');\\n    $icon.toggleClass('active', !!isActive);\\n  };\\n\\n  Zoom.prototype._prepareEaselForZoom = function () {\\n    this.drawer.trigger(this.drawer.EVENT_DO_DEACTIVATE_ALL_TOOLS);\\n    this.drawer.fCanvas._clearSelection();\\n    this.drawer.fCanvas.renderAll();\\n  };\\n\\n\\n\\n  /**\\n   *\\n   * @private\\n   */\\n  Zoom.prototype._checkMovePermission = function (withButtonState) {\\n    var currActiveObj = this.drawer.fCanvas.getActiveObject(),\\n        selectedTool = this.drawer.activeDrawingTool,\\n        buttonStateIsActive = withButtonState && this.moveButtonIsActive,\\n        result = !currActiveObj && !selectedTool && (this.options.enableWhenNoActiveTool || buttonStateIsActive);\\n    return result;\\n  };\\n\\n  /**\\n   * Move canvas - React on mouse move.\\n   * @param {Event} e\\n   * @private\\n   */\\n  Zoom.prototype._moveOnMouseMove = function (e) {\\n    if (this.isMoving && this.currentZoom !== 1) {\\n      var self = this,\\n          moveEventPos = this.drawer.getRelativeEventPosition(e),\\n          moveLastPoint = this.moveLastPoint,\\n          deltaX = (moveLastPoint.left - moveEventPos.left),\\n          deltaY = (moveLastPoint.top - moveEventPos.top),\\n          newCenterX = this.zoomCenterX + deltaX,\\n          newCenterY = this.zoomCenterY + deltaY,\\n          moveEaselFunc = function moveEaselFunc() {\\n            self.setZoom(self.currentZoom, newCenterX, newCenterY, true);\\n          };\\n\\n      this.moveLastPoint = moveEventPos;\\n      util.requestAnimationFrame(moveEaselFunc);\\n\\n      e.preventDefault();\\n      e.stopPropagation();\\n      return false;\\n    }\\n  };\\n\\n  /**\\n   * Move canvas - React on mouse up.\\n   * @param {Event} e\\n   * @private\\n   */\\n  Zoom.prototype._moveOnMouseUp = function (e) {\\n    if (this.isMoving) {\\n      var $body = $('body'),\\n          self = this;\\n\\n      util.setTimeout(function () {\\n        self.drawer.movingNow = false;\\n      }, 0);\\n      this.isMoving = false;\\n      this.drawer.fCanvas.defaultCursor = cursorPrefix + 'grab';\\n      this.drawer.fCanvas.setCursor(cursorPrefix + 'grab');\\n      $body.removeClass('drawer-dragging drawer-zoom-moving');\\n\\n      e.preventDefault();\\n      e.stopPropagation();\\n      return false;\\n    }\\n  };\\n\\n  /**\\n   * Attach wheel event to canvas\\n   * @private\\n   */\\n  Zoom.prototype._attachTouchEvents = function () {\\n      var self = this,\\n          $canvasContainer = this.drawer.$canvasEditContainer,\\n          startDiff,\\n          lastDiff;\\n\\n    function getDistance(p1,p2) {\\n      var result;\\n      result = Math.sqrt(Math.pow(p1.left - p2.left, 2) + Math.pow(p1.top - p2.top, 2));\\n      return result;\\n    }\\n\\n    $canvasContainer.off('touchstart.drawerZoom').on('touchstart.drawerZoom', function (event) {\\n      var touches = event.touches ? event.touches : event.originalEvent.touches;\\n      if (self.zoomIsOn && touches && touches.length > 1) {\\n        var pointPos1 = getEventPosition(event, 0),\\n            pointPos2 = getEventPosition(event, 1);\\n        if (!pointPos1.left || !pointPos1.top) {\\n          pointPos1 = getEventPosition(window.event, 0);\\n          pointPos2 = getEventPosition(window.event, 1);\\n        }\\n        startDiff = getDistance(pointPos1, pointPos2);\\n        lastDiff = startDiff;\\n        self._prepareEaselForZoom();\\n      }\\n    });\\n    $canvasContainer.off('touchmove.drawerZoom').on('touchmove.drawerZoom', function (event) {\\n      var touches = event.touches ? event.touches : event.originalEvent.touches,\\n          zoominit = self.zoomIsOn && touches && touches.length > 1;\\n      if (zoominit) {\\n        var pointPos1 = util.getEventPosition(event, 0),\\n            pointPos2 = util.getEventPosition(event, 1);\\n        if (!pointPos1.left || !pointPos1.top) {\\n          pointPos1 = util.getEventPosition(window.event, 0);\\n          pointPos2 = util.getEventPosition(window.event, 1);\\n        }\\n        var currDiff = getDistance(pointPos1, pointPos2),\\n            isZoomIn = lastDiff < currDiff,\\n            zoom = self.currentZoom * (isZoomIn ? self.options.zoomStep : 1 / self.options.zoomStep),\\n            scrollOffset = util.getScrollOffset($canvasContainer),\\n            canvasContainer = $canvasContainer.get(0),\\n            canvasContainerSizes = canvasContainer.getBoundingClientRect(),\\n            touchCenterX = pointPos1.left - (pointPos1.left - pointPos2.left) / 2,\\n            touchCenterY = pointPos1.top - (pointPos1.top - pointPos2.top) / 2,\\n            zoomCenterX = touchCenterX - canvasContainerSizes.left - scrollOffset.left,\\n            zoomCenterY = touchCenterY - canvasContainerSizes.top - scrollOffset.top;\\n\\n        self.setZoom(zoom, zoomCenterX, zoomCenterY, true);\\n        lastDiff = currDiff;\\n        event.stopPropagation();\\n        event.preventDefault();\\n      }\\n    });\\n  };\\n\\n  /**\\n   * React on wheel event\\n   * @param {Event} e\\n   * @private\\n   */\\n  Zoom.prototype._onWheelEvent = function (e) {\\n    if (this.zoomIsOn) {\\n      var delta = e.deltaY || e.detail || e.wheelDelta;\\n      this._prepareEaselForZoom();\\n      if (delta > 0) {\\n        this._onZoomOut(e, true);\\n      } else {\\n        this._onZoomIn(e, true);\\n      }\\n      e.stopPropagation();\\n      e.preventDefault();\\n    }\\n  };\\n\\n  /**\\n   * Update zoom values of drawer/plugin\\n   * @param {Object} [data]\\n   * @private\\n   */\\n  Zoom.prototype._updateEaselValues = function (data) {\\n    data = data || {};\\n    var width = this.drawer.width,\\n        height = this.drawer.height,\\n        zoomCenter = this.viewport.getZoomCenter();\\n\\n    this.zoomCenterX = this.zoomCenterX !== undefined ? this.zoomCenterX : zoomCenter.x;\\n    this.zoomCenterY = this.zoomCenterY !== undefined ? this.zoomCenterY : zoomCenter.y;\\n\\n    var zoomCenterX = data.zoomCenterX !== undefined ? data.zoomCenterX : this.zoomCenterX,\\n        zoomCenterY = data.zoomCenterY !== undefined ? data.zoomCenterY : this.zoomCenterY,\\n        currentZoom = data.zoom;\\n\\n    if (typeof currentZoom !== 'number' || !isFinite(currentZoom)) {\\n      currentZoom = this.currentZoom;\\n      if (typeof currentZoom !== 'number' || !isFinite(currentZoom)) {\\n        currentZoom = this.options.defaultZoom;\\n      }\\n    }\\n\\n    if (zoomCenterX > width) {\\n      zoomCenterX = width;\\n    }\\n    if (zoomCenterY > height) {\\n      zoomCenterY = width;\\n    }\\n    if (zoomCenterX < 0) {\\n      zoomCenterX = 0;\\n    }\\n    if (zoomCenterY < 0) {\\n      zoomCenterY = 0;\\n    }\\n    if (typeof this.options.minZoom === 'number') {\\n      currentZoom = Math.max(currentZoom, this.options.minZoom);\\n    }\\n    if (typeof this.options.maxZoom === 'number') {\\n      currentZoom = Math.min(currentZoom, this.options.maxZoom);\\n    }\\n\\n    this.drawer.currentZoom = this.currentZoom = currentZoom;\\n    this.drawer.zoomCenterX = this.zoomCenterX = zoomCenterX;\\n    this.drawer.zoomCenterY = this.zoomCenterY = zoomCenterY;\\n  };\\n\\n  /**\\n   * Set zoom\\n   * @param {Number} value - new zoom value\\n   * @param {Number} [zoomCenterX] - x coord of new canvas center\\n   * @param {Number} [zoomCenterY] - y coord of new canvas center\\n   * @param {Boolean} [strict] - Set zoom center without changes\\n   */\\n  Zoom.prototype.setZoom = function (value, zoomCenterX, zoomCenterY, strict) {\\n    var zoomValueIsValid = typeof value === 'number' && isFinite(value),\\n        strictMode = strict !== undefined ? strict : !this.options.moveCanvasOnWheel,\\n        prevValues,\\n        zoomResult;\\n    if (zoomValueIsValid) {\\n      prevValues = {\\n        zoom: this.currentZoom,\\n        zoomCenterX: this.zoomCenterX,\\n        zoomCenterY: this.zoomCenterY\\n      };\\n      this._updateEaselValues({\\n        zoom: value,\\n        zoomCenterX: zoomCenterX,\\n        zoomCenterY: zoomCenterY\\n      });\\n\\n      zoomResult = this.viewport.setViewport(this.currentZoom, this.zoomCenterX, this.zoomCenterY, strictMode);\\n      zoomResult.prevValues = prevValues;\\n      this._updateEaselValues(zoomResult);\\n      this.drawer.trigger(this.drawer.EVENT_ZOOM_CHANGE, [zoomResult]);\\n    } else {\\n      console.info('invalid zoom value');\\n    }\\n  };\\n\\n  /**\\n   * Update prototype of fabric tools\\n   * @priv\\n   */\\n  Zoom.prototype._updateObjectProto = function () {\\n    var self = this,\\n        _drawControl = fabric.Object.prototype._drawControl,\\n        drawControls = fabric.Object.prototype.drawControls,\\n        getPointByOrigin = fabric.Object.prototype.getPointByOrigin,\\n        _setCornerCoords = fabric.Object.prototype._setCornerCoords;\\n\\n\\n    /*\\n    fabric.Object.prototype._drawControl = function (control, ctx, methodName, left, top) {\\n      var viewport = self.viewport,\\n          zoom = viewport ? viewport.zoom : 1;\\n      ctx.lineWidth = 1 / Math.max(this.scaleX, this.scaleY);\\n      return _drawControl.apply(this, [control, ctx, methodName, left, top]);\\n    };\\n\\n    fabric.Object.prototype.drawControls = function (ctx) {\\n      var viewport = self.viewport,\\n          zoom = viewport ? viewport.zoom : 1,\\n          result;\\n      this.cornerSize = this.cornerSize / zoom;\\n      result = drawControls.apply(this, [ctx]);\\n      this.cornerSize = this.cornerSize * zoom;\\n      return result;\\n    };\\n    */\\n\\n    fabric.Object.prototype._setCornerCoords = function () {\\n      var viewport = self.viewport,\\n          zoom = viewport ? viewport.zoom : 1,\\n          result;\\n      this.cornerSize = this.cornerSize / zoom;\\n      result = _setCornerCoords.apply(this, arguments);\\n      this.cornerSize = this.cornerSize * zoom;\\n      return result;\\n    };\\n\\n    fabric.Object.prototype.getPointByOrigin = function () {\\n      var viewport = self.viewport,\\n          zoom = viewport ? viewport.zoom : 1,\\n          result;\\n      this.cornerSize = this.cornerSize / zoom;\\n      result = getPointByOrigin.apply(this, arguments);\\n      this.cornerSize = this.cornerSize * zoom;\\n      return result;\\n    };\\n\\n  };\\n\\n  /**\\n   * Override native fabric functions\\n   * @private\\n   */\\n  Zoom.prototype._updateCanvasProto = function () {\\n    var self = this,\\n        fCanvas = this.drawer.fCanvas,\\n        getPointer = fCanvas.getPointer,\\n        _drawSelection = fCanvas._drawSelection;\\n\\n    fCanvas.getPointer = function (e, ignoreZoom, upperCanvasEl) {\\n      var pointer = getPointer.apply(this, arguments);\\n      if (!isFinite(pointer.x) || !isFinite(pointer.y) ) {\\n        var $canvasEditContainer = self.drawer.$canvasEditContainer,\\n            canvasEditContainerSizes = $canvasEditContainer.get(0).getBoundingClientRect(),\\n            eventPos = util.getEventPosition(window.event),\\n            offset = util.getScrollOffset(self.drawer.$canvasEditContainer),\\n            x = eventPos.left - offset.left - canvasEditContainerSizes.left,\\n            y = eventPos.top - offset.top - canvasEditContainerSizes.top;\\n        pointer = {\\n          x: x,\\n          y: y\\n        };\\n      }\\n          var offsetX = self.viewport.position.x,\\n          offsetY = self.viewport.position.y,\\n          newX = parseInt(pointer.x / self.viewport.zoom - offsetX, 10),\\n          newY = parseInt(pointer.y / self.viewport.zoom - offsetY, 10);\\n      pointer.oldX = pointer.x;\\n      pointer.oldY = pointer.y;\\n      pointer.newX = newX;\\n      pointer.newY = newY;\\n      pointer.x = newX;\\n      pointer.y = newY;\\n      return pointer;\\n    };\\n\\n    fCanvas._drawSelection = function () {\\n      var ctx;\\n      ctx = this.contextTop;\\n      ctx.save();\\n      ctx.scale(this.viewport.zoom, this.viewport.zoom);\\n      ctx.translate(this.viewport.position.x, this.viewport.position.y);\\n      _drawSelection.apply(this, arguments);\\n      ctx.restore();\\n      return ctx;\\n    };\\n  };\\n\\n  /**\\n   * Restore default state of zoom\\n   * @private\\n   */\\n  Zoom.prototype.restoreDefaultZoom = function () {\\n    var defaultZoomValue = this.options.defaultZoom,\\n        zoomCenter = this.viewport.getZoomCenter(),\\n        newZoomData;\\n    this.setZoom(defaultZoomValue, zoomCenter.x, zoomCenter.y, true);\\n    this.viewport.setToCenterOfCanvas(1);\\n    newZoomData = this.viewport.getData();\\n    this._updateEaselValues(newZoomData);\\n  };\\n\\n\\n  /**\\n   * API methods\\n   */\\n\\n  /**\\n   * Set zoom of current drawer instance\\n   * @param {Number} zoom - zoom level\\n   * @param {Number} [zoomCenterX] - x coord of new center point of canvas. From 0 to current canvas width\\n   * @param {Number} [zoomCenterY] - y coord of new center point of canvas. From 0 to current canvas height\\n   */\\n  EaselApi.prototype.setZoom = function (zoom, zoomCenterX, zoomCenterY) {\\n    var zoomTool = this.drawer.getPluginInstance('Zoom');\\n    if (zoomTool) {\\n      zoomTool.setZoom(zoom, zoomCenterX, zoomCenterY, true);\\n    }\\n  };\\n\\n  /**\\n   * Restore default state of zoom\\n   */\\n  EaselApi.prototype.restoreDefaultZoom = function () {\\n    var zoomTool = this.drawer.getPluginInstance('Zoom');\\n    if (zoomTool) {\\n      zoomTool.restoreDefaultZoom();\\n    }\\n  };\\n\\n  pluginsNamespace.Zoom = Zoom;\\n}(this, jQuery, Easel.plugins, Easel.EaselApi, Easel.util));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/ui-plugins/ToolbarTooltip.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasablePencilBrush.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Globals.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/brush-eraser-simplewhite/SimpleWhiteEraser.js\"))","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions, util) {\\n  'use strict';\\n\\n  /**\\n   * Provides input for changing width of line/arrow.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} [options] - Configuration object\\n   * @param {Number} [options.digitsAfterDecimalPoint=0] - The number of digits to appear after the decimal point;\\n   *\\n   * @constructor\\n   * @memberof Easel.options\\n   * @extends {Easel.plugins.BaseToolOptions}\\n   */\\n  var LineWidth = function LineWidthConstructor(drawer, options) {\\n    // call super c-tor\\n    BaseToolOptions.call(this, drawer);\\n    this._setupOptions(options);\\n  };\\n\\n  LineWidth.prototype = Object.create(BaseToolOptions.prototype);\\n  LineWidth.prototype.constructor = BaseToolOptions;\\n\\n  LineWidth.prototype.name = 'LineWidth';\\n  LineWidth.prototype.optionName = 'lineWidth';\\n  // LineWidth.prototype.useCombobox = true;\\n  // LineWidth.prototype.buttonMode = true;\\n  // LineWidth.prototype.preventHightlight = true;\\n  LineWidth.prototype.useCombobox = false;\\n  LineWidth.prototype.preventHightlight = false;\\n  LineWidth.prototype.buttonMode = false;\\n\\n  LineWidth.prototype.buttonIconClass = 'fa-arrows-h';\\n\\n  LineWidth.prototype._defaultOptions = {\\n    digitsAfterDecimalPoint: 0\\n  };\\n\\n  LineWidth.prototype.onSelectionCleared = function (toolbar) {\\n    this.data = false;\\n  };\\n\\n  LineWidth.prototype.createControls = function (toolbar) {\\n    this.createControl(toolbar);\\n    this._attachEvents();\\n  };\\n\\n  /**\\n   * Get html of control\\n   * @returns {string} result - html of controls\\n   * @private\\n   */\\n  LineWidth.prototype._generateHtml = function () {\\n    var result,\\n        selectHtml;\\n\\n    selectHtml = '' +\\n        '<select ' +\\n        'class=\\\"editable-canvas-line-width-input controls-value-item\\\" ' +\\n        'name=\\\"drawer-size\\\"' +\\n        'data-name=\\\"lineWidth\\\"' +\\n        '>' +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper toolbar-item-range editable-canvas-line-width hidden',\\n        optionItemAdditionalClasses = '' +\\n            (this.buttonMode ? ' toolbar-button-item ' : '') +\\n            (this.preventHightlight ? ' prevent-highlight ' : ''),\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    /*\\n     // For button mode\\n     result = '' +\\n     '<li class=\\\"' + optionItemClasses + '\\\">' +\\n     '<div class=\\\"toolbar-item-description\\\">' +\\n     '<span class=\\\"toolbar-item-label\\\">' +\\n     this.drawer.t('Line width:') + ' ' +\\n     '</span>' +\\n     '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n     '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n     '</div>' +\\n     '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n     selectHtml +\\n     '</div>' +\\n     '</li>';\\n\\n     */\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n          '<div class=\\\"toolbar-item-description\\\">' +\\n            '<span class=\\\"toolbar-label editable-canvas-line-width-label\\\">' +\\n              this.drawer.t('Line width:') + ' ' +\\n            '</span>' +\\n            '<span class=\\\"toolbar-label toolbar-label-indicator editable-canvas-line-width-indicator\\\"></span>' + '' +\\n          '</div>' +\\n          '<input ' +\\n            'class=\\\"editable-canvas-line-width-input controls-value-item\\\" ' +\\n            'name=\\\"drawer-line-width\\\"' +\\n            'data-name=\\\"lineWidth\\\"' +\\n            'type=\\\"range\\\"' +\\n            'min=\\\"1\\\"' +\\n            'max=\\\"1000\\\"' +\\n          '>' +\\n        '</li>';\\n    return result;\\n  };\\n\\n  /**\\n   * Create/add controls\\n   * @param {EaselToolbar} toolbar\\n   * @returns {jQuery}\\n   * @private\\n   */\\n  LineWidth.prototype.createControl = function (toolbar) {\\n    var toolControlHtml = this._generateHtml();\\n    this.$toolControl = $(toolControlHtml);\\n    this.$valueIndicator = this.$toolControl.find('.editable-canvas-line-width-indicator');\\n    toolbar.addControl(this.$toolControl, this.options.buttonOrder);\\n    return this.$toolControl;\\n  };\\n\\n  /**\\n   * Attach events for control element\\n   * @private\\n   */\\n  LineWidth.prototype._attachEvents = function () {\\n    if (this.$toolControl) {\\n      this.$toolControl.on('input change toolbarOptionChange', this.onInputChange.bind(this));\\n    }\\n  };\\n\\n\\n  /**\\n   * Validate width value\\n   * @param rawValue\\n   * @returns {*}\\n   */\\n  LineWidth.prototype.validateValue = function (rawValue) {\\n    rawValue = parseInt(rawValue, 10);\\n    var result,\\n        rawValueIsValid = typeof rawValue === 'number' && isFinite(rawValue) && rawValue;\\n    if (rawValueIsValid) {\\n      var decimalRatio = Math.pow(10, this.options.digitsAfterDecimalPoint),\\n          formattedValue = parseInt(rawValue * decimalRatio, 10) / decimalRatio;\\n      result = formattedValue;\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Set line width of current active object\\n   * @param {number|string} value - Width of line/arrow in px\\n   */\\n  LineWidth.prototype.setLineWidth = function (value) {\\n    var fCanvas = this.drawer.fCanvas,\\n        target = fCanvas.getActiveObject();\\n    if (target) {\\n      if (!this.data) {\\n        this.collectDataFromObject(target);\\n      }\\n\\n      var diffRatio = parseInt(value / this.data.initialWidth * 100, 10) / 100;\\n      \\n      target.x1 = this.data.x1 * diffRatio * target.scaleX;\\n      target.x2 = this.data.x2 *  diffRatio * target.scaleX;\\n      target.y1 = this.data.y1 * diffRatio * target.scaleY;\\n      target.y2 = this.data.y2 * diffRatio * target.scaleY;\\n\\n      target.set('x1',target.x1);\\n      target.set('x2',target.x2);\\n      target.set('y1',target.y1);\\n      target.set('y2',target.y2);\\n\\n      target.set('top',this.data.top);\\n      target.set('left',this.data.left);\\n\\n      fCanvas.renderAll();\\n    }\\n  };\\n\\n  /**\\n   * This function is called every time user changes width via control\\n   * @private\\n   */\\n  LineWidth.prototype.onInputChange = function () {\\n    var $opacityInput = $(this.$toolControl).find('input'),\\n        rawValue = $opacityInput.val(),\\n        validatedValue = this.validateValue(rawValue);\\n    this.$valueIndicator.text(validatedValue + 'px');\\n    this.setLineWidth(validatedValue);\\n  };\\n\\n  LineWidth.prototype.collectDataFromObject = function (target) {\\n    var result = {},\\n        decimalRatio = Math.pow(10, this.options.digitsAfterDecimalPoint),\\n        calcWidth = function (x, y) {\\n          var result,\\n              axisSum = Math.pow(x, 2) + Math.pow(y, 2),\\n              widthRaw = Math.sqrt(axisSum),\\n              lineWidth = parseInt(widthRaw * decimalRatio) / decimalRatio;\\n          result = lineWidth;\\n          return result;\\n        },\\n        xDelta =target.x2 - target.x1,\\n        yDelta =target.y2 - target.y1,\\n        xDiffScaled = (xDelta) * target.scaleX,\\n        yDiffScaled = (yDelta) * target.scaleY,\\n        xDiff = (xDelta),\\n        yDiff = (yDelta),\\n        angleRad = Math.atan((yDelta) / (xDelta)),\\n        angleDeg = Math.abs(fabric.util.radiansToDegrees(angleRad));\\n\\n    result.lineWidth = calcWidth(xDiffScaled, yDiffScaled);\\n    result.initialWidth = calcWidth(xDiff, yDiff);\\n    result.angleRad = angleRad;\\n    result.angleDeg = angleDeg;\\n\\n    result.top = target.top;\\n    result.left = target.left;\\n    result.x1 = target.x1;\\n    result.x2 = target.x2;\\n    result.y1 = target.y1;\\n    result.y2 = target.y2;\\n\\n    this.data = result;\\n    return result;\\n  };\\n\\n  LineWidth.prototype.updateControls = function (dataToFill) {\\n    dataToFill = dataToFill || this.data;\\n    var rawValue = dataToFill.lineWidth,\\n        validatedValue = this.validateValue(rawValue);\\n    this.$toolControl.find('input').val(validatedValue);\\n    this.$valueIndicator.text(validatedValue + 'px');\\n  };\\n\\n  LineWidth.prototype.showControls = function () {\\n    this.$toolControl.removeClass('hidden');\\n  };\\n\\n  LineWidth.prototype.hideControls = function (force) {\\n    this.$toolControl.addClass('hidden');\\n  };\\n\\n  pluginsNamespace.LineWidth = LineWidth;\\n}(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions, Easel.util));\"","module.exports = \"(function ($, pluginsNamespace) {\\n  /**\\n   * Provides html5 color input for changing shapes/freedrawing brush color.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ColorpickerHtml5 = function ColorpickerHtml5Constructor(drawerInstance) {\\n    var _this = this;\\n    this.drawerInstance = drawerInstance;\\n    this.name = 'BrushSize';\\n\\n    drawerInstance.on(drawerInstance.EVENT_OPTIONS_TOOLBAR_CREATED,\\n      function (e, toolbar) {\\n        _this.createColorControl(toolbar);\\n      });\\n  };\\n\\n  /**\\n   * Create control and append it to toolbar\\n   * @param  {EaselToolbar} toolbar to add control to\\n   */\\n  ColorpickerHtml5.prototype.createColorControl = function (toolbar) {\\n    var _this = this;\\n\\n    var colorButton = $(\\n      '<li class=\\\"editable-easel-plugin-color\\\"' +\\n        'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n        'data-editable-canvas-cssrules=\\\"height\\\">' +\\n      '<span class=\\\"toolbar-label\\\"' +\\n        'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n        'data-editable-canvas-cssrules=\\\"height,line-height\\\">Color: </span>' +\\n      '<input class=\\\"editable-canvas-colorpicker\\\" type=\\\"color\\\" ' +\\n        'value=\\\"' + this.drawerInstance.activeColor + '\\\" ' +\\n        'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n        'data-editable-canvas-cssrules=\\\"height,width\\\"/>' +\\n      '</li>');\\n\\n    toolbar.addControl(colorButton, this.options.buttonOrder);\\n\\n    var colorChangeHandler = function (event) {\\n      if (!event) {\\n        return;\\n      }\\n\\n      var color = event.target.value;\\n\\n      _this.drawerInstance.setColor(color);\\n    };\\n\\n    colorButton.find('input').change(colorChangeHandler);\\n  };\\n\\n  pluginsNamespace.ColorpickerHtml5 = ColorpickerHtml5;\\n\\n}(jQuery, Easel.plugins));\\n\"","module.exports = \"(function ($, Easel) {\\n  if (!$ || !Easel || !Easel.Easel) {\\n    return;\\n  }\\n\\n  var DEFAULT_PLUGINS = [\\n    'Pencil',\\n    'Eraser',\\n    'Text',\\n    'Line',\\n    'ArrowOneSide',\\n    'ArrowTwoSide',\\n    'Diamond',\\n    'Rectangle',\\n    'Circle',\\n    'Image',\\n    'Polygon',\\n    'ImageCrop',\\n    'Color',\\n    'ShapeBorder',\\n    'ShapeFill',\\n    'BrushSize',\\n    'OpacityOption',\\n    'LineWidth',\\n    'StrokeWidth',\\n    'ShapeContextMenu',\\n    'OvercanvasPopup',\\n    'OpenPopupButton',\\n    'ToggleVisibilityButton',\\n    'MovableFloatingMode',\\n    'FullscreenModeButton',\\n    'ExportSVG'\\n  ];\\n\\n  var DEFAULT_PLUGINS_CONFIG = {\\n    Image: {\\n      scaleDownLargeImage: true,\\n      maxImageSizeKb: 10240,\\n      cropIsActive: true\\n    },\\n    Text: {\\n      editIconMode: false,\\n      editIconSize: 'large',\\n      defaultValues: {\\n        fontSize: 32,\\n        lineHeight: 1.5,\\n        textFontWeight: 'normal'\\n      },\\n      predefined: {\\n        fontSize: [8, 12, 14, 16, 32, 40, 72],\\n        lineHeight: [1, 1.5, 2, 3, 4]\\n      }\\n    },\\n    Zoom: {\\n      enabled: true,\\n      showZoomTooltip: true,\\n      useWheelEvents: true,\\n      zoomStep: 1.05,\\n      defaultZoom: 1,\\n      maxZoom: 32,\\n      minZoom: 1,\\n      smoothnessOfWheel: 0,\\n      enableMove: true,\\n      enableWhenNoActiveTool: true,\\n      enableButton: true\\n    }\\n  };\\n\\n  var DEFAULT_TOOLBARS = {\\n    drawingTools: {\\n      position: 'top',\\n      positionType: 'outside',\\n      compactType: 'scrollable',\\n      hidden: false,\\n      toggleVisibilityButton: false,\\n      fullscreenMode: {\\n        position: 'top',\\n        hidden: false,\\n        toggleVisibilityButton: false\\n      }\\n    },\\n    toolOptions: {\\n      position: 'bottom',\\n      positionType: 'inside',\\n      compactType: 'popup',\\n      hidden: false,\\n      toggleVisibilityButton: false,\\n      fullscreenMode: {\\n        position: 'bottom',\\n        compactType: 'popup',\\n        hidden: false,\\n        toggleVisibilityButton: false\\n      }\\n    },\\n    settings: {\\n      position: 'right',\\n      positionType: 'inside',\\n      compactType: 'scrollable',\\n      hidden: false,\\n      toggleVisibilityButton: false,\\n      fullscreenMode: {\\n        position: 'right',\\n        hidden: false,\\n        toggleVisibilityButton: false\\n      }\\n    }\\n  };\\n\\n  var DEFAULT_DRAWER_OPTIONS = {\\n    plugins: DEFAULT_PLUGINS.slice(),\\n    corePlugins: ['Zoom', 'SelectionTool'],\\n    exitOnOutsideClick: false,\\n    debug: false,\\n    toolbars: DEFAULT_TOOLBARS,\\n    pluginsConfig: DEFAULT_PLUGINS_CONFIG,\\n    defaultActivePlugin: { name: 'Pencil', mode: 'lastUsed' },\\n    defaultImageUrl: '/examples/redactor/images/drawer.jpg',\\n    align: 'floating',\\n    transparentBackground: true,\\n    activeColor: '#E80F07',\\n    lineAngleTooltip: { enabled: false }\\n  };\\n\\n  function resolveContainer(container) {\\n    if (!container) {\\n      return null;\\n    }\\n\\n    if (container.jquery) {\\n      return container;\\n    }\\n\\n    if (typeof container === 'string') {\\n      return $(container).first();\\n    }\\n\\n    return $(container);\\n  }\\n\\n  function SimpleEasel(options) {\\n    this.options = $.extend(true, {\\n      container: null,\\n      responsive: true,\\n      autoStart: true,\\n      autoStartDelay: 150,\\n      width: null,\\n      height: null,\\n      drawerOptions: {}\\n    }, options || {});\\n\\n    this.$container = resolveContainer(this.options.container);\\n    this.drawer = null;\\n    this._resizeTimeout = null;\\n    this._resizeNamespace = '.drawerSimpleFactory-' + Math.round(Math.random() * 1000000);\\n  }\\n\\n  SimpleEasel.prototype.init = function () {\\n    if (!this.$container || !this.$container.length) {\\n      throw new Error('Easel.create: container element not found');\\n    }\\n\\n    this._renderEasel();\\n    return this;\\n  };\\n\\n  SimpleEasel.prototype.destroy = function () {\\n    $(window).off('resize' + this._resizeNamespace);\\n    if (this._resizeTimeout) {\\n      clearTimeout(this._resizeTimeout);\\n      this._resizeTimeout = null;\\n    }\\n\\n    if (this.drawer && typeof this.drawer.destroy === 'function') {\\n      this.drawer.destroy();\\n    }\\n    this.drawer = null;\\n  };\\n\\n  SimpleEasel.prototype._renderEasel = function () {\\n    var size = this._measureSize();\\n    var drawerOptions = this._buildEaselOptions();\\n\\n    if (this.drawer && typeof this.drawer.destroy === 'function') {\\n      this.drawer.destroy();\\n    }\\n\\n    this.drawer = new Easel.Easel(null, drawerOptions, size.width, size.height);\\n    this.$container.empty().append(this.drawer.getHtml());\\n    this.drawer.onInsert();\\n\\n    if (this.options.responsive) {\\n      this._bindResponsiveSizing();\\n    }\\n\\n    if (this.options.autoStart) {\\n      this._autoStart(0);\\n    }\\n  };\\n\\n  SimpleEasel.prototype._buildEaselOptions = function () {\\n    var overrides = this.options.drawerOptions || {};\\n    return $.extend(true, {}, DEFAULT_DRAWER_OPTIONS, overrides);\\n  };\\n\\n  SimpleEasel.prototype._measureSize = function () {\\n    var width = parseInt(this.options.width, 10);\\n    var height = parseInt(this.options.height, 10);\\n\\n    if (!width || width <= 0) {\\n      width = Math.round(this.$container.outerWidth());\\n      if (!width) {\\n        width = Math.round(this.$container.parent().outerWidth()) || window.innerWidth || 800;\\n      }\\n    }\\n\\n    if (!height || height <= 0) {\\n      height = Math.round(this.$container.outerHeight());\\n      if (!height) {\\n        var parentHeight = Math.round(this.$container.parent().height());\\n        if (parentHeight > 0) {\\n          height = parentHeight;\\n        } else {\\n          var cssHeight = parseInt(this.$container.css('height'), 10);\\n          height = cssHeight > 0 ? cssHeight : 600;\\n        }\\n      }\\n    }\\n\\n    return {\\n      width: width,\\n      height: height\\n    };\\n  };\\n\\n  SimpleEasel.prototype._bindResponsiveSizing = function () {\\n    var self = this;\\n    $(window).off('resize' + this._resizeNamespace);\\n    $(window).on('resize' + this._resizeNamespace, function () {\\n      if (self._resizeTimeout) {\\n        clearTimeout(self._resizeTimeout);\\n      }\\n\\n      self._resizeTimeout = setTimeout(function () {\\n        self._resizeTimeout = null;\\n        self._syncSizeWithContainer();\\n      }, 150);\\n    });\\n  };\\n\\n  SimpleEasel.prototype._syncSizeWithContainer = function () {\\n    if (!this.drawer || typeof this.drawer.setSize !== 'function') {\\n      return;\\n    }\\n\\n    var size = this._measureSize();\\n    this.drawer.setSize(size.width, size.height);\\n  };\\n\\n  SimpleEasel.prototype._autoStart = function (attempt) {\\n    var self = this;\\n    if (!this.drawer || !this.drawer.api || typeof this.drawer.api.startEditing !== 'function') {\\n      if (attempt < 5) {\\n        setTimeout(function () {\\n          self._autoStart(attempt + 1);\\n        }, this.options.autoStartDelay);\\n      }\\n      return;\\n    }\\n\\n    try {\\n      this.drawer.api.startEditing();\\n    } catch (err) {\\n      if (window.console && window.console.warn) {\\n        console.warn('Easel auto-start failed', err);\\n      }\\n      if (attempt < 5) {\\n        setTimeout(function () {\\n          self._autoStart(attempt + 1);\\n        }, this.options.autoStartDelay * 2);\\n      }\\n    }\\n  };\\n\\n  Easel.SimpleEasel = SimpleEasel;\\n\\n  Easel.create = function (options) {\\n    var simple = new SimpleEasel(options || {});\\n    simple.init();\\n    return simple.drawer;\\n  };\\n\\n  Easel.createController = function (options) {\\n    var simple = new SimpleEasel(options || {});\\n    return simple.init();\\n  };\\n\\n})(window.jQuery, window.Easel);\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-image/ImageShape.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-arrow/ArrowTwoSideShape.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextBackgoundColor.js\"))","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing text background color;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextBackgroundColor = function TextBackgroundColorConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    // init options\\n    this._setupOptions(options);\\n\\n    this.colorControl = new pluginsNamespace.ColorpickerControl(this.drawer, this.options);\\n  };\\n\\n  TextBackgroundColor.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextBackgroundColor.prototype.constructor = BaseTextOptionTool;\\n\\n  TextBackgroundColor.prototype.name = 'TextBackgroundColor';\\n  TextBackgroundColor.prototype.optionName = 'TextBackgroundColor';\\n  TextBackgroundColor.prototype.focusTextOnChange = true;\\n  TextBackgroundColor.prototype.useCombobox = false;\\n  TextBackgroundColor.prototype.buttonMode = false;\\n\\n  TextBackgroundColor.prototype._defaultOptions = {\\n    colorText: 'Text background:',\\n    defaultValues: {\\n      textBackgroundColor: ''\\n    },\\n  };\\n\\n  TextBackgroundColor.prototype.onlyPredefined = true;\\n  TextBackgroundColor.prototype.valueType = {\\n    textBackgroundColor: 'color'\\n  };\\n\\n  TextBackgroundColor.prototype.updateSingleControl = function (valueName, value) {\\n    if (valueName === 'textBackgroundColor') {\\n      this.colorControl.setColor(value);\\n    }\\n  };\\n\\n  TextBackgroundColor.prototype.getStylesFromControls = function () {};\\n\\n  TextBackgroundColor.prototype.getStylesFromChangeEvent = function (data) {\\n    var result;\\n    if (data) {\\n      if (typeof data === 'object') {\\n        result = data.styles;\\n      }\\n      if (typeof data === 'string') {\\n        result = {\\n          textBackgroundColor: data\\n        };\\n      }\\n    }\\n    this._lastData = result;\\n    return result;\\n  };\\n\\n\\n  TextBackgroundColor.prototype.setupControl = function (toolbar, $toolControl, changeCallback) {\\n    this.colorChangeHandler = changeCallback;\\n\\n    this.$toolControl = this.colorControl.createControl(toolbar,  this.onInputChange.bind(this));\\n    // cache control components\\n    this.$toolControl.$colorIndicator = this.$toolControl.find('.color-indicator');\\n    this.$toolControl.$colorDropdown = this.$toolControl.find('.color-dropdown');\\n\\n    this.$toolControl.$colorIndicator.attr('data-name', 'textBackgroundColor');\\n    this.$toolControl.$colorIndicator.addClass('controls-value-item');\\n\\n    this.$toolControl.addClass('editable-canvas-text-option editable-canvas-text-backgroundcolor');\\n\\n    this.colorDropdownVisible = false;\\n  };\\n\\n  pluginsNamespace.TextBackgroundColor = TextBackgroundColor;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","module.exports = \"(function($, BaseShape, pluginsNamespace, util) {\\n  /**\\n   * Provides a rectangle button which can be used to draw rectangles.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {String} [options.centeringMode='normal']\\n   * Defines centering method when drawing a shape.\\n   * <br><br>\\n   * Valid values are:\\n   * <br><br>\\n   * <code>normal</code>: rectangle's top left corner will be placed to the\\n   * position of first mouse click and will be resized from that point.\\n   * <br><br>\\n   * <code>from_center</code>: rectangle's center point will be placed to the\\n   * position of first mouse click and will be resized from center.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var Rectangle = function RectangleConstructor(drawerInstance, options) {\\n    var _this = this;\\n\\n    BaseShape.call(_this, drawerInstance);\\n\\n    this.name = 'Rectangle';\\n    this.btnClass = 'btn-rectangle';\\n    this.faClass = 'fa-stop';\\n    this.tooltip = drawerInstance.t('Draw a rectangle');\\n\\n    this.options = options || {};\\n    this.centeringMode =\\n      this.options.centeringMode || BaseShape.CENTERING_MODE.NORMAL;\\n  };\\n\\n  Rectangle.prototype = Object.create(BaseShape.prototype);\\n  Rectangle.prototype.constructor = Rectangle;\\n\\n  Rectangle.prototype.createShape = function (left, top) {\\n    this.startLeft = left;\\n    this.startTop = top;\\n\\n    var rect = new fabric.ErasableRect({\\n      left: left,\\n      top: top,\\n      height: 1,\\n      width: 1,\\n      rx: 7,\\n      ry: 7,\\n      fill: this.drawerInstance.activeColor,\\n      opacity: this.drawerInstance.activeOpacity,\\n      stroke: this.drawerInstance.activeColor,\\n      strokeWidth: 2,\\n      erasable: true\\n    });\\n\\n    rect.isErasable = true;\\n    rect.set('erasable', true);\\n\\n    this._applyActiveBorderStyle(rect);\\n\\n    util.applyStrokePenStyle(rect);\\n\\n    return rect;\\n  };\\n\\n  Rectangle.prototype.updateShape = function (rectangle, newLeft, newTop) {\\n    var width = newLeft - this.startLeft;\\n    var height = newTop - this.startTop;\\n\\n    if (this.centeringMode == BaseShape.CENTERING_MODE.FROM_CENTER) {\\n      width *= 2;\\n      height *= 2;\\n      rectangle.set('left', newLeft - width);\\n      rectangle.set('top', newTop - height);\\n    }\\n\\n    if(width > 0){\\n      rectangle.set('width', width);\\n    } else {\\n      rectangle.set('left', newLeft);\\n      rectangle.set('width', width * -1);\\n    }\\n\\n    if(height > 0){\\n      rectangle.set('height', height);\\n    } else {\\n      rectangle.set('top', newTop);\\n      rectangle.set('height', height * -1);\\n    }\\n\\n  };\\n\\n  Rectangle.prototype._applyActiveBorderStyle = function (rectangle) {\\n    if (!rectangle) {\\n      return;\\n    }\\n\\n    var borderPlugin = this._getShapeBorderPlugin();\\n    if (borderPlugin && typeof borderPlugin.applyBorderStyle === 'function') {\\n      borderPlugin.applyBorderStyle(rectangle);\\n    } else if (borderPlugin && borderPlugin.currentBorder) {\\n      var border = borderPlugin.currentBorder;\\n      rectangle.set('stroke', border.color || borderPlugin.currentColor);\\n      rectangle.set('strokeWidth', border.width);\\n      rectangle.set('strokeDashArray', border.dashArray || null);\\n      util.applyStrokePenStyle(rectangle);\\n    }\\n  };\\n\\n  Rectangle.prototype._getShapeBorderPlugin = function () {\\n    var plugins = this.drawerInstance && this.drawerInstance._pluginsInstances;\\n    if (plugins && plugins.ShapeBorder) {\\n      return plugins.ShapeBorder;\\n    }\\n    return null;\\n  };\\n\\n  pluginsNamespace.Rectangle = Rectangle;\\n\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins, Easel.util));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasableMixin.js\"))","module.exports = \"(function(jQuery, BaseShape, pluginsNamespace) {\\n  /**\\n   * Provides an arrow button which can be used\\n   * to draw lines with arrow at both sides.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * Tool is using drawerInstance.options['lineAngleTooltip']\\n   * Default settings are:\\n   * { enabled: false,\\n   *    fontSize: 11,\\n   *    fontFamily:  'Arial, sans serif',\\n   *    color: 'black'};\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ArrowTwoSide = function ArrowTwoSizeConstructor(drawerInstance) {\\n    // call super\\n    BaseShape.call(this, drawerInstance);\\n\\n    this.name = 'ArrowTwoSide';\\n    /**\\n     * List of tool options to show when tool is activated.\\n     * Deviating from BaseShape tool, Arrow has no 'color', only 'border'.\\n     * @type {String[]}\\n     */\\n    this.toolOptionsList = ['border', 'opacity', 'lineWidth', 'strokeWidth'];\\n\\n    this.btnClass = 'btn-arrow-two-side';\\n    this.faClass = 'fa-arrows-h';\\n    this.tooltip = drawerInstance.t('Draw a two-sided arrow');\\n    this.group = {\\n      name: 'lines',\\n      tooltip: drawerInstance.t('Lines and arrows')\\n    };\\n\\n    this._setupOptions({});\\n    $.extend(true, this.options.lineAngleTooltip, drawerInstance.options.lineAngleTooltip || {});\\n\\n    // add fallback for fontFamily\\n    this.options.lineAngleTooltip.fontFamily += ', ' + this._defaultOptions.lineAngleTooltip.fontFamily;\\n  };\\n\\n  ArrowTwoSide.prototype = Object.create(BaseShape.prototype);\\n  ArrowTwoSide.prototype.constructor = ArrowTwoSide;\\n\\n  ArrowTwoSide.prototype.checkOnlyWidthOrHeight = true;\\n\\n  ArrowTwoSide.prototype._defaultOptions = {\\n    lineAngleTooltip: {\\n      enabled: false,\\n      fontSize: 11,\\n      fontFamily:  'Arial, sans serif',\\n      color: 'black'\\n    }\\n  };\\n\\n\\n  /**\\n   * Create new shape with minimal size.\\n   * Is called from BaseShape nmouseDown handler.\\n   *\\n   * @param  {Number} left [description]\\n   * @param  {Number} top  [description]\\n   * @return {fabric.ErasableLine}\\n   */\\n  ArrowTwoSide.prototype.createShape = function (left, top) {\\n    var arrow = new fabric.ErasableArrow([left, top, left + 1, top + 1], {\\n      oneSided: false\\n    });\\n    arrow.set('strokeWidth', this.drawerInstance.lineStrokeWidth || 1);\\n    arrow.set('stroke', this.drawerInstance.activeColor);\\n    arrow.set('opacity', this.drawerInstance.activeOpacity);\\n    arrow.set('oneSided', false);\\n\\n    this.createAngleTooltip(arrow);\\n\\n    return arrow;\\n  };\\n\\n\\n  /**\\n   * Update shape with new left, top,\\n   * Is called from BaseShape mouseMove handler\\n   *\\n   * @param  {fabric.Line} line    [description]\\n   * @param  {Number} newLeft [description]\\n   * @param  {Number} newTop  [description]\\n   */\\n  ArrowTwoSide.prototype.updateShape = function (arrow, newLeft, newTop) {\\n    arrow.set('y2', newTop);\\n    arrow.set('x2', newLeft);\\n\\n    this.updateAngleTooltip(arrow);\\n  };\\n\\n\\n  /**\\n   * Is called from BaseShape mouseUp handler.\\n   */\\n  ArrowTwoSide.prototype.finishShape = function (left, top) {\\n    this.removeAngleTooltip();\\n  };\\n\\n\\n\\n  /**\\n   * Create text object for line angle tooltip\\n   *\\n   * @param  {fabric.Line} line\\n   */\\n  ArrowTwoSide.prototype.createAngleTooltip = function (line) {\\n    if (this.options.lineAngleTooltip.enabled) {\\n      this.angleTooltip = new fabric.IText('Text');\\n      this.angleTooltip.set('fontFamily', this.options.lineAngleTooltip.fontFamily);\\n      this.angleTooltip.set('fontSize', this.options.lineAngleTooltip.fontSize);\\n      this.angleTooltip.set('left', line.x1 - this.options.lineAngleTooltip.fontSize);\\n      this.angleTooltip.set('top', line.y1 - this.options.lineAngleTooltip.fontSize);\\n      this.angleTooltip.set('stroke', this.options.lineAngleTooltip.color);\\n      this.angleTooltip.set('fill', this.options.lineAngleTooltip.color);\\n      this.angleTooltip.set('text', '');\\n\\n      this.drawerInstance.fCanvas.add(this.angleTooltip);\\n      this.updateAngleTooltip(line);\\n    }\\n  };\\n\\n\\n  /**\\n   * Update angle tooltip with line current angle\\n   *\\n   * @param  {fabric.Line} line\\n   */\\n  ArrowTwoSide.prototype.updateAngleTooltip = function (line) {\\n    if (!this.options.lineAngleTooltip.enabled)\\n      return;\\n\\n    // calc line angle\\n    var angleRad = Math.atan((line.y2 - line.y1) / (line.x2 - line.x1));\\n    var angle = Math.abs(fabric.util.radiansToDegrees(angleRad));\\n    this.angleTooltip.setText(angle.toFixed().toString());\\n\\n    // determine tooltip position\\n    var tooltipOffsetX = this.options.lineAngleTooltip.fontSize;\\n    var tooltipOffsetY = -this.options.lineAngleTooltip.fontSize;\\n    // if line is pointing to the left\\n    if (line.x2 < line.x1) {\\n      tooltipOffsetX = -(this.options.lineAngleTooltip.fontSize + 10);\\n    }\\n    // if line is pointing downside\\n    if (line.y2 > line.y1) {\\n      tooltipOffsetY = 2;\\n    }\\n\\n    this.angleTooltip.set('left', line.x1 + tooltipOffsetX);\\n    this.angleTooltip.set('top', line.y1 + tooltipOffsetY);\\n    // this is needed to overpower strange issue, when tooltip is always same color as line\\n    this.angleTooltip.set('stroke', this.options.lineAngleTooltip.color);\\n    this.angleTooltip.set('fill', this.options.lineAngleTooltip.color);\\n  };\\n\\n\\n\\n  /**\\n   * Removes angle tooltip.\\n   */\\n  ArrowTwoSide.prototype.removeAngleTooltip = function () {\\n    if (this.options.lineAngleTooltip.enabled) {\\n      if (this.angleTooltip) {\\n        this.angleTooltip.remove();\\n        delete this.tooltip;\\n      }\\n    }\\n  };\\n\\n\\n  pluginsNamespace.ArrowTwoSide = ArrowTwoSide;\\n\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins));\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n    extend = fabric.util.object.extend;\\n\\n  fabric.PDiamond = fabric.util.createClass(fabric.SegmentablePolygon, {\\n    type: 'PDiamond',\\n    initialize: function (options) {\\n      options = options || {};\\n\\n      this.width = options.width || 10;\\n      this.height = options.height || 10;\\n\\n      var points = this.makeDiamond(this.width, this.height);\\n\\n      this.callSuper('initialize', points, options);\\n    },\\n    makeDiamond: function (width, height) {\\n      var halfWidth = width / 2;\\n      var halfHeight = height / 2;\\n\\n      var points = [\\n        {x: 0, y: halfHeight * -1},\\n        {x: halfWidth, y: 0},\\n        {x: 0, y: halfHeight},\\n        {x: halfWidth * -1, y: 0}\\n      ];\\n\\n      return [points];\\n    },\\n    _render: function (ctx) {\\n      this.callSuper('_render', ctx);\\n    },\\n    _set: function (key, value) {\\n      var dimensionsChanged = false;\\n      if (key === 'width') {\\n        this.width = value;\\n        dimensionsChanged = true;\\n      }\\n      if (key === 'height') {\\n        this.height = value;\\n        dimensionsChanged = true;\\n      }\\n      if (dimensionsChanged) {\\n        this.points = this.makeDiamond(this.width, this.height);\\n        this.callSuper('_set', 'points', this.points);\\n      }\\n\\n      this.callSuper('_set', key, value);\\n    },\\n    toObject: function (propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        width: this.width,\\n        height: this.height\\n      });\\n    }\\n  });\\n\\n\\n  fabric.PDiamond.fromObject = function (object) {\\n    return new fabric.PDiamond(object, true);\\n  };\\n\\n  fabric.PDiamond.async = false;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\"","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing font size of text;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextFontSize = function TextFontSizeConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    this._setupOptions(options);\\n  };\\n\\n  TextFontSize.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextFontSize.prototype.constructor = BaseTextOptionTool;\\n\\n  TextFontSize.prototype.name = 'TextFontSize';\\n  TextFontSize.prototype.optionName = 'TextFontSize';\\n  TextFontSize.prototype.buttonIconClass = 'fa-text-height';\\n\\n  TextFontSize.prototype.valueType = {\\n    fontSize: 'number'\\n  };\\n\\n  TextFontSize.prototype._defaultOptions = {\\n    defaultValues: {\\n      fontSize: 48\\n    },\\n    predefined: {\\n      fontSize: [6, 12, 14, 16, 20, 24, 32, 40, 48, 72]\\n    }\\n  };\\n\\n  TextFontSize.prototype.controlTemplate = function () {\\n    var result,\\n        $predefined,\\n        selectHtml;\\n\\n    $predefined = this.options.predefined.fontSize.map(function (size, i) {\\n      return '<option value=\\\"' + size + '\\\">' + size + '</option>';\\n    }).join('');\\n\\n    selectHtml = '' +\\n        '<select ' +\\n          'class=\\\"editable-canvas-text-fontsize-input controls-value-item\\\" ' +\\n          'name=\\\"drawer-size\\\"' +\\n          'data-name=\\\"fontSize\\\"' +\\n          'value=\\\"' + this.options.defaultValues.fontSize + '\\\">' +\\n            $predefined +\\n        '</select>';\\n\\n      var optionItemDefaultClasses = 'toolbar-item-wrapper editable-canvas-text-option editable-canvas-text-fontsize hidden',\\n          optionItemAdditionalClasses = this.buttonMode ? ' toolbar-button-item ': '',\\n          optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n      result = '' +\\n          '<li class=\\\"' + optionItemClasses + '\\\">' +\\n              '<div class=\\\"toolbar-item-description\\\">' +\\n                '<span class=\\\"toolbar-item-label\\\">' +\\n                this.drawer.t('Font size:') + ' ' +\\n                '</span>' +\\n                '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n                '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n              '</div>' +\\n              '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n                selectHtml +\\n              '</div>' +\\n          '</li>';\\n\\n    return result;\\n  };\\n\\n  pluginsNamespace.TextFontSize = TextFontSize;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Easel.SimpleFactory.js\"))","module.exports = \"(function (global) {\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {});\\n\\n  if (!fabric.Rect) {\\n    return;\\n  }\\n\\n  fabric.ErasableRect = fabric.util.createClass(fabric.Rect, {\\n    type: 'ErasableRect',\\n    objectOptionsList: ['shapeFill', 'border', 'opacity'],\\n    initialize: function (options) {\\n      options = options || {};\\n      this.callSuper('initialize', options);\\n    },\\n    toObject: function (propertiesToInclude) {\\n      return fabric.util.object.extend(\\n        this.callSuper('toObject', propertiesToInclude),\\n        {}\\n      );\\n    }\\n  });\\n\\n  fabric.ErasableRect.fromObject = function (object) {\\n    return new fabric.ErasableRect(object);\\n  };\\n\\n  fabric.ErasableRect.async = false;\\n\\n  fabric.makeObjectErasable(fabric.ErasableRect);\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\"","module.exports = \"(function(jQuery, BaseShape, pluginsNamespace) {\\n  /**\\n   * Provides an arrow button which can be used\\n   * to draw lines with arrow at one side.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * Tool is using drawerInstance.options['lineAngleTooltip']\\n   * Default settings are:\\n   * { enabled: false,\\n   *    fontSize: 11,\\n   *    fontFamily:  'Arial, sans serif',\\n   *    color: 'black'};\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @extends {BaseShape}\\n   */\\n  var ArrowOneSide = function ArrowOneSideConstructor(drawerInstance) {\\n    // call super\\n    BaseShape.call(this, drawerInstance);\\n\\n    this.name = 'ArrowOneSide';\\n\\n    /**\\n     * List of tool options to show when tool is activated.\\n     * Deviating from BaseShape tool, Arrow has no 'color', only 'border'.\\n     * @type {String[]}\\n     */\\n    this.toolOptionsList = ['border', 'opacity', 'lineWidth', 'strokeWidth'];\\n\\n    this.btnClass = 'btn-arrow-one-side';\\n    this.faClass = 'fa-long-arrow-right';\\n    this.tooltip = drawerInstance.t('Draw an arrow');\\n    this.group = {\\n      name: 'lines',\\n      tooltip: drawerInstance.t('Lines and arrows')\\n    };\\n\\n    this._setupOptions({});\\n    $.extend(true, this.options.lineAngleTooltip, drawerInstance.options.lineAngleTooltip || {});\\n\\n    // add fallback for fontFamily\\n    this.options.lineAngleTooltip.fontFamily += ', ' + this._defaultOptions.lineAngleTooltip.fontFamily;\\n  };\\n\\n  ArrowOneSide.prototype = Object.create(BaseShape.prototype);\\n  ArrowOneSide.prototype.constructor = ArrowOneSide;\\n\\n  ArrowOneSide.prototype.checkOnlyWidthOrHeight = true;\\n\\n  ArrowOneSide.prototype._defaultOptions = {\\n    lineAngleTooltip: {\\n      enabled: false,\\n      fontSize: 11,\\n      fontFamily:  'Arial, sans serif',\\n      color: 'black'\\n    }\\n  };\\n\\n\\n  /**\\n   * Create new shape with minimal size.\\n   * Is called from BaseShape nmouseDown handler.\\n   *\\n   * @param  {Number} left [description]\\n   * @param  {Number} top  [description]\\n   * @return {fabric.ErasableLine}\\n   */\\n  ArrowOneSide.prototype.createShape = function (left, top) {\\n    var arrow = new fabric.ErasableArrow([left, top, left + 1, top + 1], {\\n      oneSided: true\\n    });\\n    arrow.set('strokeWidth', this.drawerInstance.lineStrokeWidth || 1);\\n    arrow.set('stroke', this.drawerInstance.activeColor);\\n    arrow.set('opacity', this.drawerInstance.activeOpacity);\\n    arrow.set('oneSided', true);\\n\\n    this.createAngleTooltip(arrow);\\n\\n    return arrow;\\n  };\\n\\n\\n  /**\\n   * Update shape with new left, top,\\n   * Is called from BaseShape mouseMove handler\\n   *\\n   * @param  {fabric.Line} line    [description]\\n   * @param  {Number} newLeft [description]\\n   * @param  {Number} newTop  [description]\\n   */\\n  ArrowOneSide.prototype.updateShape = function (arrow, newLeft, newTop) {\\n    arrow.set('y2', newTop);\\n    arrow.set('x2', newLeft);\\n\\n    this.updateAngleTooltip(arrow);\\n  };\\n\\n\\n  /**\\n   * Is called from BaseShape mouseUp handler.\\n   */\\n  ArrowOneSide.prototype.finishShape = function (left, top) {\\n    this.removeAngleTooltip();\\n\\n  };\\n\\n\\n  /**\\n   * Create text object for line angle tooltip\\n   *\\n   * @param  {fabric.Line} line\\n   */\\n  ArrowOneSide.prototype.createAngleTooltip = function (line) {\\n    if (this.options.lineAngleTooltip.enabled) {\\n      this.angleTooltip = new fabric.IText('Text');\\n      this.angleTooltip.set('fontFamily', this.options.lineAngleTooltip.fontFamily);\\n      this.angleTooltip.set('fontSize', this.options.lineAngleTooltip.fontSize);\\n      this.angleTooltip.set('left', line.x1 - 10);\\n      this.angleTooltip.set('top', line.y1 - 10);\\n      this.angleTooltip.set('stroke', this.options.lineAngleTooltip.color);\\n      this.angleTooltip.set('fill', this.options.lineAngleTooltip.color);\\n      this.angleTooltip.set('text', '');\\n\\n      this.drawerInstance.fCanvas.add(this.angleTooltip);\\n      this.updateAngleTooltip(line);\\n    }\\n  };\\n\\n\\n  /**\\n   * Update angle tooltip with line current angle\\n   *\\n   * @param  {fabric.Line} line\\n   */\\n  ArrowOneSide.prototype.updateAngleTooltip = function (line) {\\n    if (!this.options.lineAngleTooltip.enabled)\\n      return;\\n\\n    // calc line angle\\n    var angleRad = Math.atan((line.y2 - line.y1) / (line.x2 - line.x1));\\n    var angle = Math.abs(fabric.util.radiansToDegrees(angleRad));\\n    this.angleTooltip.setText(angle.toFixed().toString());\\n\\n    // determine tooltip position\\n    var tooltipOffsetX = this.options.lineAngleTooltip.fontSize;\\n    var tooltipOffsetY = -this.options.lineAngleTooltip.fontSize;\\n    // if line is pointing to the left\\n    if (line.x2 < line.x1) {\\n      tooltipOffsetX = -(this.options.lineAngleTooltip.fontSize + 10);\\n    }\\n    // if line is pointing downside\\n    if (line.y2 > line.y1) {\\n      tooltipOffsetY = 2;\\n    }\\n\\n    this.angleTooltip.set('left', line.x1 + tooltipOffsetX);\\n    this.angleTooltip.set('top', line.y1 + tooltipOffsetY);\\n    // this is needed to overpower strange issue, when tooltip is always same color as line\\n    this.angleTooltip.set('stroke', this.options.lineAngleTooltip.color);\\n    this.angleTooltip.set('fill', this.options.lineAngleTooltip.color);\\n  };\\n\\n\\n  /**\\n   * Removes angle tooltip.\\n   */\\n  ArrowOneSide.prototype.removeAngleTooltip = function () {\\n    if (this.options.lineAngleTooltip.enabled) {\\n      if (this.angleTooltip) {\\n        this.angleTooltip.remove();\\n        delete this.tooltip;\\n      }\\n    }\\n  };\\n\\n\\n  pluginsNamespace.ArrowOneSide = ArrowOneSide;\\n\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-overcanvas-popup/OpenPopupButton.js\"))","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {});\\n\\n  fabric.ErasableLine = fabric.util.createClass(fabric.Line, {\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'ErasableLine',\\n    originX: 'center',\\n    originY: 'center',\\n\\n    /**\\n     * List of options to show when object is selected\\n     * @type {String[]}\\n     */\\n    objectOptionsList : ['border', 'opacity', 'lineWidth', 'strokeWidth'],\\n\\n    /**\\n     * Constructor\\n     * @param {Array} points Array of points\\n     * @param {Object} [options] Options object\\n     * @return {fabric.ErasableLine}\\n     */\\n    initialize: function (points, options) {\\n      options = options || {};\\n      this.callSuper('initialize', points, options);\\n    },\\n\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Objectr representation of an instance\\n     */\\n    toObject: function (propertiesToInclude) {\\n      return this.callSuper('toObject', propertiesToInclude);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _render: function (ctx) {\\n        this.callSuper('_render', ctx);\\n    }\\n\\n  });\\n\\n  /**\\n   * Returns fabric.Polygon instance from an object representation\\n   * @static\\n   * @memberOf fabric.Polygon\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Polygon} Instance of fabric.Polygon\\n   */\\n  fabric.ErasableLine.fromObject = function (object) {\\n      // form 'points' array, for first parameter in fabric.ErasableLine c-tor\\n      var points = [object.x1, object.y1, object.x2, object.y2];\\n      return new fabric.ErasableLine(points, object);\\n  };\\n\\n\\n  // make our object erasable via ErasableMixin.\\n  fabric.makeObjectErasable(fabric.ErasableLine);\\n})(typeof exports !== 'undefined' ? exports : this);\\n\"","module.exports = \"(function ($, pluginsNamespace, BaseTool, util) {\\n  \\\"use strict\\\";\\n\\n  /**\\n   * Provides mechanism to draw shapes like in photoshop.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * @memberof Easel.plugins\\n   * @constructor\\n   */\\n  var BaseShape = function BaseShapeConstructor(drawerInstance) {\\n    if (!drawerInstance) {\\n      throw new Error(\\\"BaseShape CTOR : drawerInstance is not set!\\\");\\n    }\\n\\n    // call super constructor\\n    BaseTool.call(this, drawerInstance);\\n    var _this = this;\\n    this.drawer = drawerInstance;\\n\\n    this.type = 'shape';\\n    this.objectBaseType = 'shape';\\n    /**\\n     * List of tool options to show when tool is activated\\n     * @type {Array}\\n     */\\n    this.toolOptionsList = ['shapeFill', 'border', 'opacity'];\\n\\n    this.drawingInProgress = false;\\n    this.onlyOneItem = true;\\n\\n    this.MOUSEMOVE = this.getEventId(['mousemove', 'touchmove']);\\n    this.MOUSEDOWN = this.getEventId(['mousedown', 'touchstart']);\\n    this.MOUSEUP = this.getEventId(['mouseup', 'touchend']);\\n  };\\n\\n\\n  BaseShape.prototype = Object.create(BaseTool.prototype);\\n  BaseShape.prototype.constructor = BaseShape;\\n\\n  /**\\n   * Min size of shape in px. If less - shape will not be added\\n   * @type {number}\\n   */\\n  BaseShape.prototype.minShapeSize = 4;\\n\\n  /**\\n   * Min size of shape in px for touch devices. If less - shape will not be added\\n   * @type {number}\\n   */\\n  BaseShape.prototype.minShapeSizeForTouch = 15;\\n\\n\\n  BaseShape.CENTERING_MODE = {\\n    NORMAL: 'normal',\\n    FROM_CENTER: 'from_center'\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  BaseShape.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n  BaseShape.prototype.getEventId = function (event) {\\n    var _this = this;\\n\\n    if (event instanceof String) {\\n      event = [event];\\n    }\\n\\n    if (event instanceof Array) {\\n      return event.map(function (e) {\\n        return e + '.drawerTool' + _this.btnClass;\\n      }).join(' ');\\n    }\\n  };\\n\\n  BaseShape.prototype._activateTool = function () {\\n    if (this.active)\\n      return;\\n\\n    // call _activateTool() of parent\\n    BaseTool.prototype._activateTool.call(this);\\n\\n    this.drawerInstance.log('TOOL', this.name + ' : _activateTool() [BaseShape]');\\n\\n    var _this = this;\\n\\n    // show no tooltip on touch devices\\n    if (!this.drawerInstance.touchDevice) {\\n      _this.showHelpTooltip();\\n    }\\n\\n    var fCanvas = this.drawerInstance.fCanvas;\\n    // remove all active selection\\n    fCanvas.disableSelection();\\n\\n    fCanvas.renderAll();\\n\\n    fCanvas.defaultCursor = 'crosshair';\\n\\n    if (this.setUpHandlers) {\\n      this.setUpHandlers();\\n    } else {\\n      this._setUpHandlers();\\n    }\\n  };\\n\\n\\n  BaseShape.prototype._setUpHandlers = function () {\\n    var _this = this;\\n    var fCanvas = this.drawerInstance.fCanvas;\\n\\n    $(fCanvas.upperCanvasEl).on(_this.MOUSEDOWN, function (event) {\\n      _this.drawerInstance.log('baseShape', 'mousedown');\\n\\n      $(fCanvas.upperCanvasEl).off(_this.MOUSEDOWN);\\n\\n      // no tooltip was shown on touch devices\\n      if (!_this.drawerInstance.touchDevice) {\\n        _this.removeHelpTooltip();\\n      }\\n\\n      if (fCanvas.getActiveObject()) {\\n        return true;\\n      }\\n\\n      if (_this.drawingInProgress) {\\n        _this.finishItemDraw();\\n        return true;\\n      }\\n\\n      _this.drawingInProgress = true;\\n      _this.drawerInstance.drawingInProgress = true;\\n      var startPointCoords = _this.drawer.fCanvas.getPointer(event, true);\\n\\n      if (!_this.createShape) {\\n        throw new Error('createShape method does not exist', _this);\\n      }\\n\\n      _this.shape = _this.createShape(\\n          startPointCoords.x,\\n          startPointCoords.y\\n      );\\n\\n      _this.drawerInstance.trigger(_this.drawerInstance.EVENT_ZOOM_SET);\\n      fCanvas.add(_this.shape);\\n      _this.drawerInstance.trigger(_this.drawerInstance.EVENT_ZOOM_RESTORE);\\n\\n      $(document).on(_this.MOUSEMOVE, function (event) {\\n        var pointCoords = _this.drawer.fCanvas.getPointer(event);\\n\\n        if (!_this.updateShape) {\\n          throw new Error('updateShape method does not exist', _this);\\n        }\\n\\n        _this.updateShape(_this.shape,\\n            pointCoords.x,\\n            pointCoords.y\\n        );\\n\\n        fCanvas.renderAll();\\n      });\\n\\n      $(document).on(_this.MOUSEUP, function () {\\n        _this.drawerInstance.log('baseShape', 'mouseup');\\n        var minSize = _this.drawer.touchDevice ? _this.minShapeSizeForTouch : _this.minShapeSize,\\n            widthIsSmaller = _this.shape.width < minSize,\\n            heightIsSmaller = !_this.checkOnlyWidth && (_this.shape.height < minSize),\\n            shapeIsSmaller = _this.checkOnlyWidthOrHeight ? widthIsSmaller && heightIsSmaller : widthIsSmaller || heightIsSmaller,\\n            preventAddOfShape = shapeIsSmaller;\\n\\n        // Check, if shape is too small.\\n        // for desktop this is ok - shape will still follow mouse and\\n        // drawing will be stopped when user make a second click\\n        // but for touch devices this will not work so we simply remove a\\n        // shape if its too small but allow him to draw another.\\n\\n        if (preventAddOfShape) {\\n            _this.shape.remove();\\n            _this.shape = null;\\n\\n            _this._deactivateTool();\\n            _this._activateTool();\\n            return;\\n          }\\n\\n        // finish drawing\\n          _this.finishItemDraw();\\n\\n          // some tools are supposed to draw one shape and then deactivate\\n        if (_this.onlyOneItem) {\\n            _this.drawerInstance.trigger(_this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL, _this);\\n        }\\n\\n      });\\n    });\\n  };\\n\\n  BaseShape.prototype.finishItemDraw = function () {\\n    var _this = this;\\n    var fCanvas = _this.drawerInstance.fCanvas;\\n\\n    fCanvas.defaultCursor = 'default';\\n\\n    if (!this.drawerInstance.touchDevice) {\\n      _this.removeHelpTooltip();\\n    }\\n    fCanvas.deactivateAll();\\n    fCanvas.calcOffset();\\n\\n    _this.drawingInProgress = false;\\n    util.setTimeout(function(){\\n      _this.drawerInstance.drawingInProgress = false;\\n    });\\n    $(document).off(_this.MOUSEMOVE);\\n    $(document).off(_this.MOUSEUP);\\n\\n    // call finishShape, if it is implemented\\n    if (this.finishShape) {\\n      this.finishShape(this.shape);\\n    }\\n\\n    if (_this.shape) {\\n      if (_this.shape.width < 0) {\\n        _this.shape.set('width', _this.shape.width * -1);\\n        _this.shape.set('left', _this.shape.left - _this.shape.width);\\n        _this.shape.set('flipX', true);\\n      }\\n      if (_this.shape.height < 0) {\\n        _this.shape.set('height', _this.shape.height * -1);\\n        _this.shape.set('top', _this.shape.top - _this.shape.height);\\n        _this.shape.set('flipY', true);\\n      }\\n\\n      var newShape = _this.shape.clone();\\n\\n      _this.shape.remove();\\n      _this.shape = null;\\n\\n      fCanvas.deactivateAll();\\n\\n      fCanvas.add(newShape);\\n\\n      fCanvas.restoreSelection();\\n\\n      fCanvas.renderAll();\\n      fCanvas.calcOffset();\\n      fCanvas.renderAll();\\n    }\\n  };\\n\\n  BaseShape.prototype._deactivateTool = function () {\\n    if (!this.active) {\\n      return;\\n    }\\n    // call _deactivateTool() of parent\\n    BaseTool.prototype._deactivateTool.call(this);\\n\\n    this.drawerInstance.log('TOOL', this.name + ' : _deactivateTool() [BaseShape]');\\n\\n    this.finishItemDraw();\\n\\n    $(this.drawerInstance.fCanvas.upperCanvasEl)\\n      .off(this.MOUSEDOWN);\\n\\n    this.drawerInstance.fCanvas.restoreSelection();\\n  };\\n\\n\\n  BaseShape.prototype.showHelpTooltip = function () {\\n    var _this = this;\\n    var fCanvas = _this.drawerInstance.fCanvas;\\n\\n    var helpText = '';\\n    if (this.helpTooltipText) {\\n      helpText = this.helpTooltipText;\\n    } else {\\n      helpText = _this.drawerInstance.t('Click to start drawing a ') +\\n          '<i class=\\\"fa ' + _this.faClass + '\\\"></i>';\\n    }\\n\\n    _this.cursorTooltip = $(\\n        '<div class=\\\"easel-tool-mouse-tooltip ' + this.btnClass + '\\\">' +\\n        helpText +\\n        '</div>'\\n    );\\n\\n    $('body').append(_this.cursorTooltip);\\n    $(fCanvas.upperCanvasEl)\\n        .on('mousemove.drawer-tool-mouse-toolip', function (event) {\\n          _this.cursorTooltip.css('left', event.pageX);\\n          _this.cursorTooltip.css('top', event.pageY);\\n        });\\n\\n    $(fCanvas.upperCanvasEl).on('mouseleave', function () {\\n      _this.cursorTooltip.css('opacity', 0);\\n    });\\n\\n    $(fCanvas.upperCanvasEl).on('mouseenter', function () {\\n      _this.cursorTooltip.css('opacity', 1);\\n    });\\n  };\\n\\n  BaseShape.prototype.removeHelpTooltip = function () {\\n    if (this.cursorTooltip) {\\n      $('body').off('mousemove.drawer-tool-mouse-toolip');\\n      this.cursorTooltip.fadeOut();\\n      this.cursorTooltip.remove();\\n    }\\n  };\\n\\n\\n  pluginsNamespace.BaseShape = BaseShape;\\n\\n}(jQuery, Easel.plugins, Easel.plugins.BaseTool, Easel.util));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/FloatingControl.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-toggle-visiblity-button/ToggleVisibilityButton.js\"))","module.exports = \"(function ($, pluginsNamespace, BaseTool) {\\n  'use strict';\\n\\n  /**\\n   * Plugin to export canvas as SVG file\\n   *\\n   * @param {Easel.Easel} drawer\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ExportSVG = function ExportSVGConstructor(drawer, options) {\\n    BaseTool.call(this, drawer);\\n    this._setupOptions(options);\\n\\n    this.name = 'ExportSVG';\\n    this.btnClass = 'btn-export-svg';\\n    this.faClass = 'fa-download';\\n    this.tooltipText = drawer.t('Export as SVG');\\n  };\\n\\n  ExportSVG.prototype = Object.create(BaseTool.prototype);\\n  ExportSVG.prototype.constructor = ExportSVG;\\n\\n  ExportSVG.prototype._defaultOptions = {\\n    buttonOrder: 80,\\n    renderToolbarButton: false\\n  };\\n\\n  /**\\n   * Setup options\\n   * @param {Object} options\\n   * @private\\n   */\\n  ExportSVG.prototype._setupOptions = function (options) {\\n    options = options || {};\\n    this.options = $.extend(true, {}, this._defaultOptions, options);\\n  };\\n\\n  /**\\n   * On toolbar created - add control\\n   * @param {EaselToolbar} toolbar\\n   * @private\\n   */\\n  ExportSVG.prototype._onToolbarCreated = function (ev, toolbar) {\\n    if (this.options.renderToolbarButton === false) {\\n      return;\\n    }\\n\\n    this.toolbar = toolbar;\\n    this.createControls(toolbar);\\n  };\\n\\n  /**\\n   * Create controls\\n   * @param {EaselToolbar} toolbar\\n   */\\n  ExportSVG.prototype.createControls = function (toolbar) {\\n    this._createAndAddButton(toolbar);\\n  };\\n\\n  /**\\n   * Remove tool\\n   */\\n  ExportSVG.prototype.removeTool = function(doDeleteToolbarCreationListeners) {\\n    if (this._toolbarCreatedEvent && doDeleteToolbarCreationListeners) {\\n      this.drawerInstance.off(this.drawerInstance.EVENT_TOOLBAR_CREATED, this._toolbarCreatedEvent);\\n      this._toolbarCreatedEvent = null;\\n    }\\n  };\\n\\n  /**\\n   * Create button\\n   * @param {EaselToolbar} toolbar\\n   * @private\\n   */\\n  ExportSVG.prototype._createAndAddButton = function(toolbar) {\\n    var buttonConfig = {\\n      additionalClass: this.btnClass,\\n      iconClass: 'fa ' + this.faClass,\\n      tooltipText: this.tooltipText,\\n      buttonOrder: this.options.buttonOrder,\\n      clickHandler: this._onExportButtonClick.bind(this)\\n    };\\n    toolbar.addButton(buttonConfig);\\n  };\\n\\n  /**\\n   * On export button click - export canvas to SVG\\n   */\\n  ExportSVG.prototype._onExportButtonClick = function() {\\n    this.exportCanvas();\\n  };\\n\\n  ExportSVG.prototype.exportCanvas = function () {\\n    var canvas = this.drawer.fCanvas;\\n    if (!canvas) {\\n      return;\\n    }\\n\\n    var cleanupState = this._prepareCanvasForExport(canvas);\\n    var svgString = '';\\n\\n    try {\\n      svgString = canvas.toSVG();\\n    } finally {\\n      this._restoreCanvasAfterExport(canvas, cleanupState);\\n    }\\n\\n    this._downloadSvg(svgString);\\n  };\\n\\n  ExportSVG.prototype._prepareCanvasForExport = function (canvas) {\\n    var cleanupState = {\\n      backgroundColor: canvas.backgroundColor,\\n      backgroundImage: canvas.backgroundImage,\\n      sanitizedObjects: []\\n    };\\n\\n    canvas.backgroundColor = null;\\n    canvas.backgroundImage = null;\\n\\n    if (typeof canvas.getObjects === 'function') {\\n      var objects = canvas.getObjects();\\n      for (var i = 0; i < objects.length; i++) {\\n        var obj = objects[i];\\n        if (!obj || typeof obj.toSVG === 'function') {\\n          continue;\\n        }\\n\\n        cleanupState.sanitizedObjects.push({\\n          object: obj,\\n          hadExcludeFlag: Object.prototype.hasOwnProperty.call(obj, 'excludeFromExport'),\\n          previousValue: obj.excludeFromExport\\n        });\\n\\n        obj.excludeFromExport = true;\\n      }\\n    }\\n\\n    return cleanupState;\\n  };\\n\\n  ExportSVG.prototype._restoreCanvasAfterExport = function (canvas, cleanupState) {\\n    cleanupState = cleanupState || {};\\n\\n    if (Object.prototype.hasOwnProperty.call(cleanupState, 'backgroundColor')) {\\n      canvas.backgroundColor = cleanupState.backgroundColor;\\n    }\\n\\n    if (Object.prototype.hasOwnProperty.call(cleanupState, 'backgroundImage')) {\\n      canvas.backgroundImage = cleanupState.backgroundImage;\\n    }\\n\\n    if (cleanupState.sanitizedObjects) {\\n      for (var i = 0; i < cleanupState.sanitizedObjects.length; i++) {\\n        var entry = cleanupState.sanitizedObjects[i];\\n        if (entry.hadExcludeFlag) {\\n          entry.object.excludeFromExport = entry.previousValue;\\n        } else {\\n          delete entry.object.excludeFromExport;\\n        }\\n      }\\n    }\\n  };\\n\\n  ExportSVG.prototype._downloadSvg = function (svgString) {\\n    if (!svgString) {\\n      return;\\n    }\\n\\n    var blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });\\n    var url = URL.createObjectURL(blob);\\n    var link = document.createElement('a');\\n    link.href = url;\\n    link.download = 'canvas-export-' + Date.now() + '.svg';\\n\\n    document.body.appendChild(link);\\n    link.click();\\n    document.body.removeChild(link);\\n    URL.revokeObjectURL(url);\\n  };\\n\\n  pluginsNamespace.ExportSVG = ExportSVG;\\n\\n}(jQuery, Easel.plugins, Easel.plugins.BaseTool));\\n\"","module.exports = \"(function ($, pluginsNamespace, util) {\\n  /**\\n   * Provides ability to use popup over canvas\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var OvercanvasPopup = function ResizeConstructor(drawerInstance) {\\n    this.drawerInstance = drawerInstance;\\n    this.LOGTAG = this.name;\\n\\n    this._attachEaselEvents();\\n  };\\n\\n  /**\\n   * Instance of Easel\\n   * @type {Easel}\\n   */\\n  OvercanvasPopup.prototype.drawerInstance = null;\\n\\n  /**\\n   * Namespace for events\\n   * @const\\n   * @type {String}\\n   */\\n  OvercanvasPopup.prototype.namespace = 'OvercanvasPopup';\\n\\n  /**\\n   * Name of plugin\\n   * @const\\n   * @type {String}\\n   */\\n  OvercanvasPopup.prototype.name = 'EaselPluginOvercanvasPopup';\\n\\n  /**\\n   * Additional class of popup-wrapper element\\n   * @type {String}\\n   */\\n  OvercanvasPopup.prototype.popupClass = 'popup-wrapper';\\n  /**\\n   * Default position of popup\\n   * @type {string}\\n   */\\n  OvercanvasPopup.prototype.defaultPosition = 'bottom';\\n  /**\\n   * Array of available positions. Note that order is necessary.\\n   * @type {String[]}\\n   */\\n  OvercanvasPopup.prototype.positions = ['bottom', 'left', 'right', 'top'];\\n\\n  /**\\n   * Toolbar behavior\\n   * @type {string}\\n   */\\n  OvercanvasPopup.prototype.toolbarBehavior = 'overlay';\\n\\n  /**\\n   * Attach drawer events\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._attachEaselEvents = function () {\\n    this.drawerInstance.on(this.drawerInstance.BEFORE_CREATE_TOOLBARS, this._onBeforeCreateToolbars.bind(this));\\n    this.drawerInstance.on(this.drawerInstance.EVENT_OVERCANVAS_POPUP_SHOW, this.showPopup.bind(this));\\n    this.drawerInstance.on(this.drawerInstance.EVENT_OVERCANVAS_POPUP_HIDE, this.hidePopup.bind(this));\\n  };\\n\\n  /**\\n   * React on event - before toolbars create\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._onBeforeCreateToolbars = function () {\\n    this._createHelperElements();\\n    this._attachHelperEvents();\\n  };\\n\\n  /**\\n   * Add event handlers for popup and helpers elements\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._attachHelperEvents = function () {\\n    var $closeBtn = this.$popup.find('.popup-close-btn'),\\n        $overlay = this.$popup.find('.popup-overlay'),\\n        $body = $('body');\\n    util.bindClick($closeBtn, this.namespace, this._triggerPopupHide.bind(this));\\n    util.bindClick($overlay, this.namespace, this._triggerPopupHide.bind(this));\\n\\n    util.bindClick($body, this.namespace, this._onBodyClick.bind(this));\\n  };\\n\\n  /**\\n   * Throw \\\"hide overcanvas popup\\\" event\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._triggerPopupHide = function () {\\n    this.drawerInstance.trigger(this.drawerInstance.EVENT_OVERCANVAS_POPUP_HIDE);\\n  };\\n\\n  /**\\n   * Throw \\\"show overcanvas popup\\\" event\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._triggerPopupShow = function () {\\n    this.drawerInstance.trigger(this.drawerInstance.EVENT_OVERCANVAS_POPUP_SHOW);\\n  };\\n\\n  /**\\n   * Close popup on click outside drawer\\n   * @param event\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._onBodyClick = function (event) {\\n    if (this.popupIsVisible) {\\n      var $buttonExists = this.$button && this.$button.length,\\n          isButton = $buttonExists && (event.target === this.$button.get(0) || this.$button.find(event.target).length),\\n          isPopup = event.target === this.$popup.get(0) || this.$popup.find(event.target).length;\\n      if (!isButton && !isPopup) {\\n        this.drawerInstance.trigger(this.drawerInstance.EVENT_OVERCANVAS_POPUP_HIDE);\\n      }\\n    }\\n  };\\n  /**\\n   * Create helper elements\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._createHelperElements = function () {\\n    this._removeHelperElements();\\n\\n    var popupWrapperHtml = '' +\\n            '<div class=\\\"' + this.popupClass + ' hidden\\\">' +\\n            '<div class=\\\"popup-content-wrapper\\\">' +\\n              '<div class=\\\"popup-arrow\\\"></div>' +\\n              '<div class=\\\"popup-content\\\"></div>' +\\n            '</div>' +\\n            '<div class=\\\"popup-overlay\\\"></div>' +\\n            '<div class=\\\"popup-close-btn\\\">' +\\n            '<div class=\\\"fa fa-close\\\"></div>' +\\n            '</div>' +\\n            '</div>';\\n\\n    var $popupWrapper = $(popupWrapperHtml),\\n        container = this.drawerInstance.$canvasEditContainer;\\n\\n    container.append($popupWrapper);\\n\\n    this.drawerInstance.$popupWrapper = $popupWrapper;\\n    this.$popup = $popupWrapper;\\n    this.$arrow = $popupWrapper.find('.popup-arrow');\\n    this.$popupContentWrapper = $popupWrapper.find('.popup-content-wrapper');\\n  };\\n\\n  /**\\n   * Remove helper elements\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._removeHelperElements = function () {\\n    if (this.drawerInstance.$popupWrapper && this.drawerInstance.$popupWrapper.length) {\\n      this.drawerInstance.$popupWrapper.remove();\\n    }\\n    var $popupElement = this.drawerInstance.$canvasEditContainer.find('.' + this.popupClass);\\n    if ($popupElement && $popupElement.length) {\\n      $popupElement.remove();\\n    }\\n    this.drawerInstance.$popupWrapper = undefined;\\n    this.$popup = undefined;\\n  };\\n\\n  /**\\n   * Refresh size values\\n   * @param {jQuery} $trigger - Trigger element\\n   * @returns {Object|undefined}\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._getAvailableSpace = function ($trigger) {\\n    var result;\\n    if ($trigger && $trigger.length) {\\n      var $canvas = this.drawerInstance.$canvasEditContainer,\\n          canvasSizes = $canvas.get(0).getBoundingClientRect(),\\n          triggerSizes = $trigger.get(0).getBoundingClientRect(),\\n          popupSizes = this.$popupContentWrapper.get(0).getBoundingClientRect(),\\n          // arrowSize = this.$arrow.width(),\\n          arrowSize = 10,\\n          triggerOffsetX = triggerSizes.left - canvasSizes.left,\\n          triggerOffsetY = triggerSizes.top - canvasSizes.top;\\n      result = {};\\n\\n      result.top = triggerOffsetY;\\n      result.left = triggerOffsetX;\\n      result.right = canvasSizes.width - triggerOffsetX - triggerSizes.width;\\n      result.bottom = canvasSizes.height - triggerOffsetY - triggerSizes.height;\\n\\n      result.centerX = triggerOffsetX + triggerSizes.width/2;\\n      result.centerY = triggerOffsetY + triggerSizes.height/2;\\n\\n      result.popup = {\\n        arrowSize: arrowSize,\\n        top: popupSizes.height,\\n        bottom: popupSizes.height,\\n        left: popupSizes.width,\\n        right: popupSizes.width\\n      };\\n\\n      result.popupSizes = popupSizes;\\n      result.canvasSizes = canvasSizes;\\n      result.triggerSizes = triggerSizes;\\n    }\\n    this.sizes = result;\\n    return result;\\n  };\\n\\n  /**\\n   * Move popup to position\\n   * @param {String} position - Position of popup - top/bottom/left/right\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._movePopup = function (position) {\\n    var sizes = this.sizes,\\n        isVerticalAlign,\\n        styles = {},\\n        offsetLeft,\\n        offsetTop,\\n        arrowOffsetLeft = sizes.popupSizes.width/2,\\n        arrowOffsetTop = sizes.popupSizes.height/2,\\n        negativeDiff;\\n\\n    switch (position) {\\n      case 'left':\\n        offsetLeft = sizes.left - sizes.popupSizes.width - sizes.popup.arrowSize;\\n        offsetTop = sizes.centerY - sizes.popupSizes.height/2;\\n        break;\\n      case 'right':\\n        offsetLeft = sizes.canvasSizes.width - sizes.right + sizes.popup.arrowSize;\\n        offsetTop = sizes.centerY - sizes.popupSizes.height/2;\\n        break;\\n      case 'top':\\n        isVerticalAlign = true;\\n        offsetLeft = sizes.centerX - sizes.popupSizes.width/2;\\n        offsetTop = sizes.top - sizes.popupSizes.height - sizes.popup.arrowSize;\\n        break;\\n      case 'bottom':\\n        isVerticalAlign = true;\\n        offsetLeft = sizes.centerX - sizes.popupSizes.width/2;\\n        offsetTop = sizes.canvasSizes.height - sizes.bottom + sizes.popup.arrowSize;\\n        break;\\n    }\\n\\n    if (isVerticalAlign) {\\n      styles.top = offsetTop;\\n      negativeDiff = (offsetLeft + sizes.popupSizes.width ) - sizes.canvasSizes.width;\\n      if (negativeDiff > 0) {\\n        arrowOffsetLeft += negativeDiff;\\n        styles.right = 0;\\n      } else {\\n        if (offsetLeft < 0) {\\n          arrowOffsetLeft += offsetLeft;\\n          offsetLeft = 0;\\n        }\\n        styles.left = offsetLeft;\\n      }\\n    } else {\\n      styles.left = offsetLeft;\\n      negativeDiff = (offsetTop + sizes.popupSizes.height) - sizes.canvasSizes.height;\\n      if (negativeDiff > 0) {\\n        arrowOffsetTop += negativeDiff;\\n        styles.bottom = 0;\\n      } else {\\n        if (offsetTop < 0) {\\n          arrowOffsetTop += offsetTop;\\n          offsetTop = 0;\\n        }\\n        styles.top = offsetTop;\\n      }\\n    }\\n\\n    this.$popupContentWrapper.attr('data-position',position);\\n    this.$popupContentWrapper.removeAttr('style');\\n    this.$popupContentWrapper.css(styles);\\n    this._moveArrow(arrowOffsetLeft, arrowOffsetTop);\\n  };\\n\\n\\n  /**\\n   * Move helper element - arrow\\n   * @param {Number} left - Absolute position in px\\n   * @param {Number} top - Absolute position in px\\n   * @private\\n   */\\n  OvercanvasPopup.prototype._moveArrow = function (left, top) {\\n    this.$arrow.css({\\n      left: left,\\n      top: top\\n    });\\n  };\\n\\n  /**\\n   * Adjust position of popup according of trigger element\\n   * @param {jQuery} $element\\n   */\\n  OvercanvasPopup.prototype._adjustPosition = function ($element) {\\n    var sizes = this._getAvailableSpace($element),\\n        positionFound;\\n    this.positions.forEach(function (position, i) {\\n      var positionExists = sizes[position] && sizes.popup[position];\\n      if (!positionFound && positionExists) {\\n        var neededSpace = sizes.popup[position] + sizes.popup.arrowSize,\\n            spaceIsEnough = (sizes[position] - neededSpace) > 0;\\n        positionFound = spaceIsEnough && position;\\n      }\\n    });\\n    if (positionFound) {\\n      this._movePopup(positionFound);\\n    }\\n  };\\n\\n  /**\\n   * Show popup\\n   * @param {fabric.Event} [fEvent]\\n   * @param {jQuery} $trigger\\n   */\\n  OvercanvasPopup.prototype.showPopup = function (fEvent, $trigger) {\\n    if ($trigger && $trigger.length) {\\n      this.$button = $trigger;\\n    }\\n    this.popupIsVisible = true;\\n    this.$popup.removeClass('hidden');\\n    this._adjustPosition($trigger || this.$button);\\n    this.$popupContentWrapper.removeClass('popup-transparent');\\n    this.drawerInstance.trigger(this.drawerInstance.EVENT_TOOLBAR_CHANGE_STATE, [{\\n      excludeElements: $().add(this.$popup).add($trigger),\\n      turnOn: true,\\n      state: this.toolbarBehavior\\n    }]);\\n  };\\n\\n  /**\\n   * Hide popup\\n   */\\n  OvercanvasPopup.prototype.hidePopup = function () {\\n    this.drawerInstance.trigger(this.drawerInstance.EVENT_TOOLBAR_CLEAR_STATE);\\n    this.popupIsVisible = false;\\n    this.$popup.addClass('hidden');\\n    this.$popupContentWrapper.addClass('popup-transparent');\\n  };\\n\\n  pluginsNamespace.OvercanvasPopup = OvercanvasPopup;\\n}(jQuery, Easel.plugins, Easel.util));\"","module.exports = \"(function (global, Util) {\\n\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {}),\\n        extend = fabric.util.object.extend;\\n\\n\\n        var ObjectFloatingControl = function(obj, iconPath, callback, options) {\\n        // set object\\n        if (!obj || !(obj instanceof fabric.Object)) {\\n            throw new Error('[ObjectFloatingControl()]  invalid param : obj');\\n        }\\n        this.obj = obj;\\n\\n        // set iconClickHandler\\n        if (!callback || !(callback instanceof Function)) {\\n            throw new Error('[ObjectFloatingControl()]  invalid param : callback');\\n        }\\n        this.callback = callback;\\n\\n        // set options\\n        this.options = $.extend(true, {}, this._defaultOptions || {}, options || {});\\n                this.useDomControl = !!this.options.useDomControl;\\n\\n                if (!this.useDomControl) {\\n                    // set iconPath\\n                    if (!iconPath || !Util.isString(iconPath)) {\\n                        throw new Error('[ObjectFloatingControl()]  invalid param : iconPath');\\n                    }\\n                    this.iconPath = iconPath;\\n                } else {\\n                    this.iconPath = null;\\n                }\\n\\n        // by default control is enabled\\n        this.enabled = this.options.enabled;\\n\\n                // load icon\\n                if (!this.useDomControl && this.iconPath) {\\n                    fabric.Image.fromURL(this.iconPath, this._onIconReady.bind(this));\\n                }\\n\\n        // set handlers on object added to / removed from canvas\\n        this.obj.on('added', this._onAdded.bind(this));\\n        this.obj.on('removed', this._onRemoved.bind(this));\\n    };\\n\\n\\n    ObjectFloatingControl.prototype.SMALL_ICON  = 'small';\\n    ObjectFloatingControl.prototype.MEDIUM_ICON = 'medium';\\n    ObjectFloatingControl.prototype.LARGE_ICON  = 'large';\\n\\n    ObjectFloatingControl.prototype.LEFT_TOP  = 'left-top';\\n    ObjectFloatingControl.prototype.LEFT_BOTTOM  = 'left-bottom';\\n    ObjectFloatingControl.prototype.RIGHT_TOP  = 'right-top';\\n    ObjectFloatingControl.prototype.RIGHT_BOTTOM  = 'right-bottom';\\n\\n    ObjectFloatingControl.prototype._defaultOptions = {\\n        defaulIconSize : 32,\\n        symbolicIconSizes : {\\n            'small'  : 16,\\n            'medium' : 32,\\n            'large'  : 48\\n        },\\n        enabled : true,\\n        useDomControl: false,\\n        domClassName: '',\\n        domSize: 16,\\n        domOffsetX: 8,\\n        domOffsetY: -8,\\n        domZIndex: 400\\n    };\\n\\n\\n    ObjectFloatingControl.prototype.remove = function() {\\n        this._onRemoved();\\n    };\\n\\n\\n    ObjectFloatingControl.prototype.enable = function() {\\n        this.enabled = true;\\n    };\\n\\n\\n    ObjectFloatingControl.prototype.disable = function() {\\n        this.enabled = false;\\n    };\\n\\n    /**\\n     * After object was added to canvas - add our click handler on canvas\\n     * @param  {fabric.Event} evt\\n     */\\n    ObjectFloatingControl.prototype._onAdded = function(evt) {\\n        // object now has canvas property set\\n        this.canvas = this.obj.canvas;\\n\\n                if (this.useDomControl) {\\n                    this._ensureDomElement();\\n                } else {\\n                    // set click handlers\\n                    this._iconClickHandlerBinded = this._iconClickHandler.bind(this);\\n                    this.canvas.on('mouse:up', this._iconClickHandlerBinded);\\n                    this.canvas.on('touchend', this._iconClickHandlerBinded);\\n                }\\n\\n        // set after:render handler\\n        this._bindedAfterRender = this._onAfterRender.bind(this);\\n        this.canvas.on('after:render', this._bindedAfterRender);\\n    };\\n\\n\\n    /**\\n     * After object was removed from canvas - remove our click handler on canvas\\n     * @param  {fabric.Event} evt\\n     */\\n    ObjectFloatingControl.prototype._onRemoved = function(evt) {\\n                if (!this.canvas) {\\n                    return;\\n                }\\n\\n                if (this.useDomControl) {\\n                    this._destroyDomElement();\\n                } else {\\n                    this.canvas.off('mouse:up', this._iconClickHandlerBinded);\\n                    this.canvas.off('touchend', this._iconClickHandlerBinded);\\n                }\\n\\n                this.canvas.off('after:render', this._bindedAfterRender);\\n                this.canvas = null;\\n    };\\n\\n\\n    /**\\n     * When image is loaded - save it as this.icon,\\n     * and calc it dimensions;\\n     *\\n     * @param  {fabric.Image} image\\n     */\\n    ObjectFloatingControl.prototype._onIconReady = function(image) {\\n        var originalSize = this.options.iconSize || this.options.defaulIconSize,\\n            sizeFromOptions = this.options.editIconSize,\\n            neededSizeAsSymbolic = typeof sizeFromOptions === 'string' && this.options.symbolicIconSizes[sizeFromOptions],\\n            neededSize = neededSizeAsSymbolic || sizeFromOptions || this.options.defaulIconSize,\\n            iconScale = neededSize / originalSize;\\n\\n        this.icon = image;\\n        this.iconSize = originalSize;\\n        this.iconScale = iconScale;\\n\\n        // calc the best looking offset\\n        this.icon.offsetFromLeft = this.options.defaulIconSize * 0.66;\\n        this.icon.offsetFromTop  = -this.iconSize * 0.66;\\n\\n        this.icon.set({\\n          scaleX: iconScale,\\n          scaleY: iconScale,\\n          originX : 'center',\\n          originY : 'center',\\n          opacity: 1});\\n    };\\n\\n\\n    /**\\n     * If click on canvas is inside icon rect - launches iconClickHandler.\\n     *\\n     * @param  {fabric.Event} evt\\n     */\\n    ObjectFloatingControl.prototype._iconClickHandler = function(evt) {\\n        // checking for this.canvas to be sure, kinda hacky\\n        // checking for this.icon, as event can be fired, when icon is not ready yet\\n        if (!this.enabled || !this.canvas || !this.icon) {\\n            return;\\n        }\\n\\n        var x, y;\\n\\n        var evtCoords = this.canvas.getPointer(evt.e);\\n\\n        if (evtCoords) {\\n          x = evtCoords.x;\\n          y = evtCoords.y;\\n        } else {\\n          // if no offsetX provided (case of touch events)\\n          if (evt.e.offsetX === undefined) {\\n            var drawerLeft = drawer.left();\\n            var drawerTop = drawer.top();\\n\\n            // in case of touch event - we have no offestX, offsetY\\n                        x = evt.e.pageX - drawerLeft;\\n                        y = evt.e.pageY - drawerTop;\\n          } else {\\n            x = evt.e.offsetX;\\n            y = evt.e.offsetY;\\n          }\\n        }\\n\\n        if (this._coordInsideIcon(x, y)) {\\n            this.callback(evt, this);\\n        }\\n    };\\n\\n\\n    /**\\n     * Returns true, if coord is inside icon rect\\n     *\\n     * @param  {number} x\\n     * @param  {number} y\\n     * @return {Boolean}\\n     */\\n    ObjectFloatingControl.prototype._coordInsideIcon = function (x, y) {\\n      var rect = (this.icon.width * this.icon.scaleX) / 2,\\n          coords = this._calcIconCoords(),\\n          insideX = (x > coords.x - rect) && (x < coords.x + rect),\\n          insideY = (y > coords.y - rect)  && (y < coords.y + rect),\\n          inside = insideX && insideY;\\n\\n      return inside;\\n    };\\n\\n\\n        ObjectFloatingControl.prototype._onAfterRender = function (evt) {\\n            if (this.useDomControl) {\\n                this._positionDomControl();\\n                return;\\n            }\\n\\n            this.canvas.fire('canvas:zoom:lower:set');\\n            this._drawIcon();\\n            this.canvas.fire('canvas:zoom:lower:restore');\\n    };\\n\\n    /**\\n     * Draws edit icon, if object is selected.\\n     *\\n     * @param  {context2D} ctx\\n     */\\n    ObjectFloatingControl.prototype._drawIcon = function () {\\n        if (this.enabled && this.icon && this.obj.active) {\\n            var coords = this._calcIconCoords();\\n\\n            this.icon.left = coords.x;\\n            this.icon.top = coords.y;\\n            this.icon.render(this.canvas.getContext());\\n        }\\n    };\\n\\n\\n    /**\\n     * Calc icon coords based on object coords.\\n     * @return {Object} coords {x, y}\\n     */\\n    ObjectFloatingControl.prototype._calcIconCoords = function() {\\n        var realTopLeft = this.obj.getPointByOrigin('left', 'top');\\n\\n        var xOffsetLocal = this.icon.offsetFromLeft * this.obj.scaleX;\\n        var yOffsetLocal = this.icon.offsetFromTop;\\n\\n        var a = fabric.util.degreesToRadians(this.obj.angle);\\n        var xOffset = xOffsetLocal * Math.cos(a) - yOffsetLocal * Math.sin(a);\\n        var yOffset = xOffsetLocal * Math.sin(a) + yOffsetLocal * Math.cos(a);\\n\\n        return {x: realTopLeft.x + xOffset, y : realTopLeft.y + yOffset};\\n    };\\n\\n        ObjectFloatingControl.prototype._ensureDomElement = function () {\\n            if (!this.useDomControl || this.domElement || !this.canvas) {\\n                return;\\n            }\\n\\n            var doc = global.document;\\n            if (!doc) {\\n                return;\\n            }\\n\\n            var parent = this.options.domParent || this.canvas.wrapperEl;\\n            if (!parent) {\\n                return;\\n            }\\n\\n            var domEl = doc.createElement('div');\\n            domEl.className = 'drawer-floating-control ' + (this.options.domClassName || '');\\n            domEl.style.position = 'absolute';\\n            domEl.style.display = 'none';\\n            domEl.style.zIndex = this.options.domZIndex;\\n            domEl.style.right = 'auto';\\n            domEl.style.bottom = 'auto';\\n\\n            var size = this.options.domSize || this._defaultOptions.domSize;\\n            domEl.style.width = size + 'px';\\n            domEl.style.height = size + 'px';\\n\\n            parent.appendChild(domEl);\\n\\n            this.domElement = domEl;\\n            this.domSize = size;\\n\\n            this._domPointerHandler = function(evt) {\\n                if (!this.enabled) {\\n                    return;\\n                }\\n                evt.preventDefault();\\n                evt.stopPropagation();\\n                this.callback(evt, this);\\n            }.bind(this);\\n\\n            domEl.addEventListener('mousedown', this._domPointerHandler);\\n            domEl.addEventListener('touchstart', this._domPointerHandler);\\n            domEl.addEventListener('click', this._domPointerHandler);\\n        };\\n\\n        ObjectFloatingControl.prototype._destroyDomElement = function () {\\n            if (!this.domElement) {\\n                return;\\n            }\\n\\n            this.domElement.removeEventListener('mousedown', this._domPointerHandler);\\n            this.domElement.removeEventListener('touchstart', this._domPointerHandler);\\n            this.domElement.removeEventListener('click', this._domPointerHandler);\\n\\n            if (this.domElement.parentNode) {\\n                this.domElement.parentNode.removeChild(this.domElement);\\n            }\\n\\n            this.domElement = null;\\n        };\\n\\n        ObjectFloatingControl.prototype._positionDomControl = function () {\\n            if (!this.domElement) {\\n                return;\\n            }\\n\\n            if (!this.enabled || !this.obj.active || this.obj.isEditing) {\\n                this.domElement.style.display = 'none';\\n                return;\\n            }\\n\\n            var coords = this._calcDomCoords();\\n            if (!coords) {\\n                this.domElement.style.display = 'none';\\n                return;\\n            }\\n\\n            this.domElement.style.display = 'block';\\n            this.domElement.style.left = coords.x - (this.domSize / 2) + 'px';\\n            this.domElement.style.top = coords.y - (this.domSize / 2) + 'px';\\n        };\\n\\n        ObjectFloatingControl.prototype._calcDomCoords = function () {\\n            if (!this.canvas) {\\n                return null;\\n            }\\n\\n            if (!this.obj.oCoords) {\\n                this.obj.setCoords();\\n            }\\n\\n            var corner = this.obj.oCoords && this.obj.oCoords.tr;\\n            if (!corner) {\\n                return null;\\n            }\\n\\n            var offsetX = this.options.domOffsetX || 0;\\n            var offsetY = this.options.domOffsetY || 0;\\n            var a = fabric.util.degreesToRadians(this.obj.angle);\\n            var rotatedX = offsetX * Math.cos(a) - offsetY * Math.sin(a);\\n            var rotatedY = offsetX * Math.sin(a) + offsetY * Math.cos(a);\\n\\n            return {\\n                x: corner.x + rotatedX,\\n                y: corner.y + rotatedY\\n            };\\n        };\\n\\n    global.ObjectFloatingControl = ObjectFloatingControl;\\n\\n})(typeof exports !== 'undefined' ? exports : this,  Easel.util);\\n\"","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing font size of text;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextAlign = function TextAlignConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    // init options\\n    this._setupOptions(options);\\n  };\\n\\n  TextAlign.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextAlign.prototype.constructor = BaseTextOptionTool;\\n\\n  TextAlign.prototype.name = 'TextAlign';\\n  TextAlign.prototype.optionName = 'TextAlign';\\n  TextAlign.prototype.useCombobox = true;\\n  TextAlign.prototype.buttonMode = true;\\n  TextAlign.prototype.focusTextOnChange = true;\\n  TextAlign.prototype.preventHightlight = true;\\n  TextAlign.prototype.showOnEditMode = false;\\n  TextAlign.prototype.hideOnEditMode = true;\\n  TextAlign.prototype.stylesToObject = true;\\n  TextAlign.prototype.onlyPredefined = true;\\n  TextAlign.prototype.buttonIconClass = 'fa-align-left';\\n\\n  TextAlign.prototype.valueType = {\\n    textAlign: 'string'\\n  };\\n\\n  TextAlign.prototype._defaultOptions = {\\n    defaultValues: {\\n      textAlign: \\\"left\\\"\\n    },\\n    predefined: {\\n      textAlign: [\\\"left\\\", \\\"center\\\", \\\"right\\\", \\\"justify\\\"]\\n    },\\n    valueMap: {\\n      left: {\\n        value: 'left',\\n        classString: 'fa fa-align-left'\\n      },\\n      center: {\\n        value: 'center',\\n        classString: 'fa fa-align-center'\\n      },\\n      right: {\\n        value: 'right',\\n        classString: 'fa fa-align-right'\\n      },\\n      justify: {\\n        value: 'justify',\\n        classString: 'fa fa-align-justify'\\n      }\\n    }\\n  };\\n  \\n  TextAlign.prototype.controlTemplate = function () {\\n    var result,\\n        $predefined,\\n        selectHtml;\\n\\n    $predefined = this.options.predefined.textAlign.map(function (size, i) {\\n      return '<option value=\\\"' + size + '\\\">' + size + '</option>';\\n    }).join('');\\n\\n    selectHtml = '' +\\n        '<select ' +\\n        'class=\\\"editable-canvas-text-textalign-input controls-value-item\\\" ' +\\n        'name=\\\"drawer-size\\\"' +\\n        'data-name=\\\"textAlign\\\"' +\\n        'value=\\\"' + this.options.defaultValues.textAlign + '\\\">' +\\n        $predefined +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper editable-canvas-text-option editable-canvas-text-textalign hidden',\\n        optionItemAdditionalClasses = ''+\\n            (this.buttonMode ? ' toolbar-button-item ': '') +\\n            (this.preventHightlight ? ' prevent-highlight ': ''),\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n        '<span class=\\\"toolbar-item-label\\\">' +\\n        this.drawer.t('Font size:') + ' ' +\\n        '</span>' +\\n        '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n        '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n        '</div>' +\\n        '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n        selectHtml +\\n        '</div>' +\\n        '</li>';\\n\\n    return result;\\n  };\\n\\n  pluginsNamespace.TextAlign = TextAlign;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","module.exports = \"(function (Easel, util, texts) {\\n    Easel.prototype.defaultOptions =  {\\n      captionText: 'Easel',\\n      defaultWidth : '100%',\\n      defaultHeight : '500px',\\n\\n      enableImageCrop: true,\\n\\n      // TODO: should be fixed or removed\\n      editOnClick: true,\\n\\n      exitOnOutsideClick: true,\\n\\n      // default color for drawing/shapes\\n      activeColor: '#E80F07',\\n      activeOpacity: 1,\\n\\n      // toolbar size in px\\n      toolbarSize: 35,\\n      toolbarSizeTouch: 45,\\n\\n      // toolbars config\\n      // @todo: move it toolbars files?\\n      toolbars : {\\n        popupButtonAlwaysVisible: true,\\n        disableTooltips: true,\\n        // drawing tools toolbar config\\n        drawingTools : {\\n            position : 'bottom'         // one of [left, right, top, bottom] - changed to bottom for modern centered pill design\\n        },\\n\\n        // active tool options toolbar config\\n        toolOptions : {\\n          position : 'left',      // move element properties toolbar to the left side\\n          positionType : 'inside' // keep it attached to the canvas\\n        },\\n\\n        // drawer main toolbar config\\n        settings  : {\\n          position : 'bottom',      // one of [left, right, top, bottom] - changed to bottom for cohesive pill UI\\n          render: false             // hide legacy settings toolbar entry\\n        },\\n      },\\n\\n      tooltipCss: {\\n        background: 'black',\\n        color: 'white'\\n      },\\n\\n      // properties that will be applied to fabricjs canvas on creation\\n      canvasProperties: {\\n        selectionColor: 'rgba(255, 255, 255, 0.3)',\\n        selectionDashArray: [3, 8],\\n        selectionLineWidth: 1,\\n        selectionBorderColor: '#5f5f5f'\\n      },\\n\\n      // properties that will be applied to every created object\\n      objectControls: {\\n        borderColor: '#12dcf7ff',\\n        borderOpacityWhenMoving: 0.4,\\n        cornerColor: '#ffffffff',\\n        cornerStrokeColor: '#12dcf7ff',\\n        transparentCorners: false,\\n        cornerSize: 8,\\n        hasBorders: true\\n      },\\n\\n      objectControlsTouch: {\\n        borderColor: '#12dcf7ff',\\n        borderOpacityWhenMoving: 0.4,\\n        cornerColor: '#ffffffff',\\n        cornerStrokeColor: '#12dcf7ff',\\n        transparentCorners: false,\\n        cornerSize: 20,\\n        hasBorders: true\\n      },\\n\\n      contentConfig: {\\n        saveAfterInactiveSec: null,\\n        saveInHtml: true,\\n        canvasDataContainer: null,\\n        imagesContainer: null,\\n\\n        loadCanvasData: null,\\n        saveCanvasData: null,\\n\\n        loadImageData: null,\\n        saveImageData: null\\n      },\\n\\n      backgroundCss: 'white',\\n      borderCss: '1px dashed rgb(195, 194, 194)',\\n      borderCssEditMode: '1px dashed rgb(195, 194, 194)',\\n\\n      defaultImageUrl: 'images/drawer.jpg',\\n\\n      plugins: ['ExportSVG'],\\n      pluginsConfig: {\\n        ExportSVG: {\\n          renderToolbarButton: false\\n        }\\n      },\\n      corePlugins: ['Zoom', 'SelectionTool'],\\n\\n      texts: texts,\\n\\n      basePath: null,\\n\\n      debug: false\\n    };\\n\\n})(Easel.Easel, Easel.util, Easel.texts);\\n\"","module.exports = \"\\n/**\\n* Easel toolbar  class.\\n* @param {Easel} drawerInstance\\n*\\n* @constructor\\n*/\\nvar EaselToolbarManager = function (drawer) {\\n  this.drawerInstance = drawer;\\n  if (!drawer) {\\n    throw new Error(\\\"EaselToolbarManager : drawer must be provided!\\\");\\n  }\\n  this.toolbars = {};\\n  this.toolbarPlaceholders = {};\\n  this.TooltipManager = new Easel.utilPlugins.TooltipManager(this.drawerInstance);\\n};\\n\\n\\n/**\\n * Appends toolbar to specified location.\\n *\\n * @param {EaselToolbar} toolbar - toolbar to append\\n * @param {EaselToolbar.defaultSetOfOptions} [options] - options of toolbar\\n */\\nEaselToolbarManager.prototype.addToolbar = function (toolbar, options) {\\n  options = options || {};\\n  var customPosition = (options.position == ToolbarPlaceholder.prototype.CUSTOM_POSITION),\\n      posKey = customPosition ? options.customAnchorSelector : options.position,\\n      isCustomPositionType = posKey === ToolbarPlaceholder.prototype.POPUP_POSITION || posKey === ToolbarPlaceholder.prototype.OVER_CANVAS_POSITION,\\n      posTypeKey = isCustomPositionType ? ToolbarPlaceholder.prototype.POSITION_TYPE_CUSTOM : options.positionType || ToolbarPlaceholder.prototype.POSITION_TYPE_OUTSIDE,\\n      placeHolderByType = this.toolbarPlaceholders[posTypeKey] && this.toolbarPlaceholders[posTypeKey][posKey],\\n      placeholderByKey = this.toolbarPlaceholders[posKey],\\n      placeholder = placeHolderByType || placeholderByKey;\\n  if (placeholder) {\\n    placeholder.addToolbar(toolbar);\\n  } else {\\n    if (!customPosition) {\\n      var messageText = \\\"EaselToolbarManager.addToolbar() : no placeholder exists with name '\\\",\\n          variablesText = posTypeKey + \\\" \\\" + posKey + \\\" \\\" + options.customAnchorSelector + \\\"'\\\";\\n      this.drawerInstance.error(messageText + variablesText);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Setup/create all toolbars\\n */\\nEaselToolbarManager.prototype.createAllToolbars = function () {\\n  var _this = this;\\n\\n  this.drawerInstance.trigger(this.drawerInstance.BEFORE_CREATE_TOOLBARS, [this]);\\n\\n  // create wrapper for toolbar\\n  this._createHelperElements();\\n\\n  // create placeholders for toolbars\\n\\n  this._createToolbarsPlaceholders();\\n\\n  var toolbarsOptions = this.drawerInstance.options.toolbars,\\n      isFullscreen = this.drawerInstance.$canvasEditContainer.hasClass('fullscreen');\\n\\n  var toolOptions_conf,\\n      drawingTools_conf,\\n      settingsToolbar_conf,\\n      overCanvasToolbar_conf = toolbarsOptions.overCanvas;\\n\\n  if (!isFullscreen) {\\n    toolOptions_conf = toolbarsOptions.toolOptions;\\n    drawingTools_conf = toolbarsOptions.drawingTools;\\n    settingsToolbar_conf = toolbarsOptions.settings;\\n  } else {\\n    var overridedValues = {\\n      positionType: ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE\\n    };\\n    toolOptions_conf = $.extend(true,\\n        {},\\n        toolbarsOptions.toolOptions,\\n        toolbarsOptions.toolOptions.fullscreenMode || {},\\n        overridedValues);\\n    drawingTools_conf = $.extend(true,\\n        {},\\n        toolbarsOptions.drawingTools,\\n        toolbarsOptions.drawingTools.fullscreenMode || {},\\n        overridedValues);\\n    settingsToolbar_conf = $.extend(true,\\n        {},\\n        toolbarsOptions.settings,\\n        toolbarsOptions.settings.fullscreenMode || {},\\n        overridedValues);\\n  }\\n\\n  // order of toolbox creation MATTERS\\n  // OptionsToolbar must be created first, because in createToolsToolbar() we can activate default tool,\\n  // which will trigger updates in BrushSize and BrushColor tools.\\n  this.toolOptionsToolbar = new ToolOptionsToolbar(this.drawerInstance, toolOptions_conf);\\n  var toolOptionsToolbarOptions = {\\n    position: toolOptions_conf.position,\\n    positionType: toolOptions_conf.positionType,\\n    customAnchorSelector: toolOptions_conf.customAnchorSelector\\n  };\\n  if (toolOptions_conf.compactType === EaselToolbar.prototype.POPUP) {\\n    toolOptionsToolbarOptions.position = ToolbarPlaceholder.prototype.POPUP_POSITION;\\n    toolOptionsToolbarOptions.positionType = ToolbarPlaceholder.prototype.POSITION_TYPE_CUSTOM;\\n  }\\n  this.addToolbar(this.toolOptionsToolbar, toolOptionsToolbarOptions);\\n\\n\\n  // drawer tools\\n  this.drawingToolsToolbar = new DrawingToolsToolbar(this.drawerInstance, drawingTools_conf);\\n\\n  var drawingToolsToolbarOptions = {\\n    position: drawingTools_conf.position,\\n    positionType: drawingTools_conf.positionType,\\n    customAnchorSelector: drawingTools_conf.customAnchorSelector\\n  };\\n  this.addToolbar(this.drawingToolsToolbar, drawingToolsToolbarOptions);\\n\\n  // toolbar with close, move, options buttons (kept for plugins but hidden by default)\\n  this.settingsToolbar = new SettingsToolbar(this.drawerInstance, settingsToolbar_conf);\\n  var shouldRenderSettingsToolbar = settingsToolbar_conf.render !== false;\\n  if (shouldRenderSettingsToolbar) {\\n    var settingsToolbarOptions = {\\n      position: settingsToolbar_conf.position,\\n      positionType: settingsToolbar_conf.positionType,\\n      customAnchorSelector: settingsToolbar_conf.customAnchorSelector\\n    };\\n    this.addToolbar(this.settingsToolbar, settingsToolbarOptions);\\n  }\\n\\n  // Over canvas toolbar\\n  this.overCanvasToolbar = new OverCanvasToolbar(this.drawerInstance, overCanvasToolbar_conf);\\n  var overCanvasToolbarOptions = {\\n    position: ToolbarPlaceholder.prototype.OVER_CANVAS_POSITION,\\n    positionType: ToolbarPlaceholder.prototype.POSITION_TYPE_CUSTOM\\n  };\\n  this.addToolbar(this.overCanvasToolbar, overCanvasToolbarOptions);\\n\\n  // Over canvas toolbar\\n  this.cropImageToolbar = new CropImageToolbar(this.drawerInstance, overCanvasToolbar_conf);\\n  var cropImageToolbarOptions = {\\n    position: ToolbarPlaceholder.prototype.TOP_POSITION,\\n    positionType: ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE\\n  };\\n\\n  this.addToolbar(this.cropImageToolbar, cropImageToolbarOptions);\\n\\n  // Minimized toolbar\\n  this.minimizedToolbar = new MinimizedToolbar(this.drawerInstance);\\n  var minimizedToolbarOptions = {\\n    position: ToolbarPlaceholder.prototype.TOP_POSITION,\\n    positionType: ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE\\n  };\\n  this.addToolbar(this.minimizedToolbar, minimizedToolbarOptions);\\n\\n  // @todo: move to other place\\n  this.setToolbarButtonsSize();\\n\\n  // remove all toolbars on exit\\n  this.drawerInstance.on(this.drawerInstance.EVENT_EDIT_STOP, function () {\\n    _this.destroyAllToolbars();\\n  });\\n\\n  this.drawerInstance.trigger(this.drawerInstance.AFTER_CREATE_TOOLBARS, [this]);\\n};\\n\\n\\n/**\\n * Creates placeholders for toolbars.\\n * All placeholders are inside this.toolbarPlaceholders.\\n * Default keys are : left, right, top, bottom\\n * Custom anchor toolbars placeholders are stored as this.toolbarPlaceholders[customAnchorSelector]\\n * If no anchor element found by selector - 'top' placeholder is used instead\\n *\\n * @private\\n */\\nEaselToolbarManager.prototype._createToolbarsPlaceholders = function() {\\n  // create placeholders elements\\n  this.toolbarPlaceholders['outside'] = {};\\n  this.toolbarPlaceholders['inside'] = {};\\n  this.toolbarPlaceholders['custom'] = {};\\n\\n  this.toolbarPlaceholders['outside']['top'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.TOP_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_OUTSIDE);\\n  this.toolbarPlaceholders['outside']['left'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.LEFT_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_OUTSIDE);\\n  this.toolbarPlaceholders['outside']['right'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.RIGHT_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_OUTSIDE);\\n  this.toolbarPlaceholders['outside']['bottom'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.BOTTOM_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_OUTSIDE);\\n\\n  this.toolbarPlaceholders['inside']['top'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.TOP_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE);\\n  this.toolbarPlaceholders['inside']['left'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.LEFT_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE);\\n  this.toolbarPlaceholders['inside']['right'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.RIGHT_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE);\\n  this.toolbarPlaceholders['inside']['bottom'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.BOTTOM_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE);\\n\\n  this.toolbarPlaceholders['custom']['canvas'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.OVER_CANVAS_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_CUSTOM);\\n  this.toolbarPlaceholders['custom']['popup'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.POPUP_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_CUSTOM);\\n  this.toolbarPlaceholders['custom']['minimized'] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.TOP_POSITION, ToolbarPlaceholder.prototype.POSITION_TYPE_INSIDE);\\n\\n  // @todo: remake this!\\n  var toolbarNames = ['drawingTools', 'toolOptions', 'settings'];\\n\\n  // look for all toolbars options and see, if there are custom positions, to create placeholder\\n  for (var i = 0; i < toolbarNames.length; i++) {\\n    var toolbarConf = this.drawerInstance.options.toolbars[toolbarNames[i]];\\n    if (toolbarConf && (toolbarConf.position == ToolbarPlaceholder.prototype.CUSTOM_POSITION) && (toolbarConf.customAnchorSelector)) {\\n        var anchorSelector = toolbarConf.customAnchorSelector;\\n        this.toolbarPlaceholders[anchorSelector] = new ToolbarPlaceholder(this.drawerInstance, ToolbarPlaceholder.prototype.CUSTOM_POSITION, null, anchorSelector);\\n    }\\n  }\\n};\\n\\n/**\\n * Remove helper elements such as toolbars wrapper, etc.\\n * @private\\n */\\nEaselToolbarManager.prototype._removeHelperElements = function() {\\n  if (this.drawerInstance.$toolbarsWrapper && this.drawerInstance.$toolbarsWrapper.length) {\\n    this.drawerInstance.$toolbarsWrapper.remove();\\n  }\\n  var $toolbarsWrapper = this.drawerInstance.$canvasEditContainer.find('.toolbars-wrapper');\\n  if ($toolbarsWrapper && $toolbarsWrapper.length) {\\n    $toolbarsWrapper.remove();\\n  }\\n  this.drawerInstance.$toolbarsWrapper = undefined;\\n};\\n\\n/**\\n * Create helper elements such as toolbars wrapper, etc.\\n * @private\\n */\\nEaselToolbarManager.prototype._createHelperElements = function() {\\n  this._removeHelperElements();\\n  var toolbarsWrapperHtml = '<div class=\\\"toolbars-wrapper\\\"></div>';\\n\\n  var $toolbarsWrapper = $(toolbarsWrapperHtml),\\n      container = this.drawerInstance.$canvasEditContainer;\\n\\n  container.append($toolbarsWrapper);\\n\\n  this.drawerInstance.$toolbarsWrapper = $toolbarsWrapper;\\n};\\n\\n/**\\n * Removes all toolbars.\\n */\\nEaselToolbarManager.prototype.destroyAllToolbars = function () {\\n    if (this.settingsToolbar) {\\n      this.settingsToolbar.remove();\\n    }\\n    if (this.drawingToolsToolbar) {\\n      this.drawingToolsToolbar.remove();\\n    }\\n    if (this.toolOptionsToolbar) {\\n      this.toolOptionsToolbar.remove();\\n    }\\n};\\n\\n\\n/**\\n * Removes and then re-creates all toolbars.\\n */\\nEaselToolbarManager.prototype.resetAllToolbars = function() {\\n  this.destroyAllToolbars();\\n  this.createAllToolbars();\\n};\\n\\n\\n/**\\n * This method allows dynamical size adjustment of elements.\\n * Elements which needs to be resized should have two attributes:\\n *\\n * data-editable-canvas-sizeable=\\\"someNamespace\\\",\\n * where someNamespace is unique id for the group of elements tht will be\\n * resized together.\\n *\\n * data-editable-canvas-cssrules=width,height,font-size:($v / 2.5)\\n * which provides a list of css rules on which a new size will be applied.\\n * If resulting size needs to be modififed in some way, the one could\\n * specify a function like in font-size.\\n *\\n * @param {String} namespace\\n * @param {String} newSize\\n * @private\\n */\\nEaselToolbarManager.prototype._adjustElementsSize = function (namespace, newSize) {\\n  var elementsToResize =\\n    $('[data-editable-canvas-sizeable=' + namespace + ']');\\n\\n  for (var i = 0; i < elementsToResize.length; i++) {\\n    var elem = elementsToResize[i];\\n\\n    var attributesToChange = $(elem).attr('data-editable-canvas-cssrules');\\n    // if no attributes to change - skip\\n    if (!attributesToChange)\\n      continue;\\n\\n    var attributesToChangeArr = attributesToChange.split(',');\\n\\n    for (var a = 0; a < attributesToChangeArr.length; a++) {\\n      var attrName = attributesToChangeArr[a];\\n      var attrVal = newSize;\\n\\n      if (attrName[0] == '-') {\\n        attrName = attrName.substr(1);\\n        attrVal = '-' + newSize;\\n      }\\n\\n      var matches = attrName.match(/:\\\\((.+)\\\\)/);\\n      if (matches) {\\n        attrName = attrName.replace(matches[0], '');\\n        var expression = matches[1];\\n        expression = expression.replace('$v', attrVal);\\n        var result = new Function(\\\"return \\\" + expression)();\\n        attrVal = result;\\n      }\\n\\n      $(elem).css(attrName, attrVal + 'px');\\n    }\\n  }\\n};\\n\\n\\n\\n/**\\n * Sets the size of buttons on all toolbars.\\n *\\n * @param [size] width and height in px\\n */\\nEaselToolbarManager.prototype.setToolbarButtonsSize = function (size) {\\n  if (size) {\\n    if (this.touchDevice) {\\n      this.drawerInstance.options.toolbarSizeTouch = size;\\n    } else {\\n      this.drawerInstance.options.toolbarSize = size;\\n    }\\n  } else {\\n    if (this.touchDevice) {\\n      size = this.drawerInstance.options.toolbarSizeTouch;\\n    } else {\\n      size = this.drawerInstance.options.toolbarSize;\\n    }\\n  }\\n\\n  this._adjustElementsSize('toolbar-button', size);\\n};\\n\\nEasel.EaselToolbarManager = EaselToolbarManager;\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-image-crop/ImageCrop.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextFontWeight.js\"))","module.exports = \"(function(EaselApi) {\\n\\n    /**\\n     * Sets background image from given url.\\n     *\\n     * @param {String}   imageUrl\\n     * @param {Function} callback callback on success\\n     */\\n    EaselApi.prototype.addImageFromUrl = function(imageUrl, options) {\\n        this.drawer.api.checkIsActive();\\n        var tool = this.drawer.getPluginInstance('Image');\\n        tool.loadImage(imageUrl, options);\\n    };\\n\\n    /**\\n     * Sets background image from given image object.\\n     *\\n     * @param {Image}   image\\n     * @param {Object}   options\\n     * @param {Function} callback callback on success\\n     */\\n    EaselApi.prototype.addImage = function(image, options) {\\n        this.drawer.api.checkIsActive();\\n        var tool = this.drawer.getPluginInstance('Image');\\n        tool.addImage(image, options);\\n    };\\n\\n})(Easel.EaselApi);\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-export-svg/ExportSVG.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-movable-floating-mode/MovableFloatingMode.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasableImage.js\"))","module.exports = \"(function (global) {\\n\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {}),\\n        extend = fabric.util.object.extend;\\n\\n    /**\\n     * @class\\n     * @extends fabric.Image\\n     */\\n    fabric.ErasableImage = fabric.util.createClass(fabric.Image, {\\n        type: 'ErasableImage',\\n        async: true,\\n\\n        /**\\n         * List of options to show when object is selected\\n         * @type {String[]}\\n         */\\n        objectOptionsList : ['opacity', 'border'],\\n\\n        /**\\n         * Initializes ErasableImage with fabric.Image\\n         *\\n         * @param {fabric.Image} fabricImage\\n         * @param options\\n         */\\n        initialize: function (fabricImage, options) {\\n            var _this = this;\\n            options = options || {};\\n\\n            // set width and height\\n            this.width = options.width || 10;\\n            this.height = options.height || 10;\\n\\n            this.callSuper('initialize', fabricImage, options);\\n        },\\n\\n        _render: function (ctx) {\\n            this.callSuper('_render', ctx);\\n        },\\n\\n        _set: function (key, value) {\\n            this.callSuper('_set', key, value);\\n        },\\n\\n        toObject: function (propertiesToInclude) {\\n            return extend(this.callSuper('toObject', propertiesToInclude), {\\n                width: this.width,\\n                height: this.height\\n            });\\n        }\\n\\n    });\\n\\n\\n    /**\\n     * Creates fabric object from data.\\n     * Is async, so always use callback param.\\n     *\\n     * @param objData\\n     * @param {function} callback\\n     */\\n    fabric.ErasableImage.fromObject = function (objData, callback) {\\n        fabric.util.loadImage(objData.src, function(createdImage) {\\n            var erasableImage = new fabric.ErasableImage(createdImage, objData);\\n            // call callback with instance of our erasableImage\\n            if (callback)\\n                callback(erasableImage);\\n        });\\n    };\\n\\n    // important! set 'ErasableImage.async'\\n    // It is already set for the prototype, but if do not set here - it WILL CRASH on image load from object;\\n    // idiotic stuff...\\n    fabric.ErasableImage.async = true;\\n\\n    // make our object erasable via ErasableMixin.\\n    fabric.makeObjectErasable(fabric.ErasableImage);\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Util.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextFontSize.js\"))","module.exports = \"(function ($, pluginsNamespace, /*BaseToolOptions,*/ util) {\\n  \\\"use strict\\\";\\n  var MOUSE_DOWN = util.mouseDown('MovableFloatingMode');\\n  var MOUSE_MOVE = util.mouseMove('MovableFloatingMode');\\n  var MOUSE_UP = util.mouseUp('MovableFloatingMode');\\n\\n\\n  /**\\n   * Allows moving of canvas when it is in 'floating' mode.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * @param {Object} options\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var MovableFloatingMode = function MovableFloatingModePlugin(drawer, options) {\\n    this.drawer = drawer;\\n    this._setupOptions(options);\\n\\n    // set handlers\\n    this._bindedOnToolbarCreated = this._onToolbarCreated.bind(this);\\n    drawer.on(drawer.EVENT_CONFIG_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n    drawer.on(drawer.EVENT_MINIMIZED_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n\\n    // if options.align is set and not 'floating' - plugin will not work, warn user about this\\n    if (drawer.options.align && (drawer.options.align !== 'floating')) {\\n      console.warn(\\\"MovableFloatingMode plugin: options.align is set and it is not 'floating', so canvas will not move. Please use MovableFloatingMode plugin with 'floating' align\\\");\\n    }\\n\\n    // if align is not set - make it 'floating'\\n    if (!drawer.options.align) {\\n        drawer.options.align = 'floating';\\n    }\\n\\n    this.drawer.on(this.drawer.EVENT_CANVAS_READY,    this.onOptionsChanged.bind(this));\\n    this.drawer.on(this.drawer.EVENT_OPTIONS_CHANGED, this.onOptionsChanged.bind(this));\\n  };\\n\\n  // MovableFloatingMode.prototype = Object.create(BaseToolOptions.prototype);\\n  // MovableFloatingMode.prototype.constructor = BaseToolOptions;\\n\\n    /**\\n     * Setup data\\n     * @param {Object} [options] - options to save\\n     * @param {String} [pluginName] - name of plugin\\n     * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n     * @returns {Object} config of plugin\\n     */\\n    MovableFloatingMode.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n      pluginName = pluginName || this.name;\\n      var drawer = this.drawerInstance || this.drawer,\\n          optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n          result = $.extend(true,\\n              {},\\n              this._defaultOptions || {},\\n              optionsFromEasel || {},\\n              options || {}\\n          );\\n\\n      if (!doNotSave) {\\n        this.options = result;\\n      }\\n      return result;\\n    };\\n\\n\\n    /**\\n     * On toolbar created - create tool button.\\n     */\\n    MovableFloatingMode.prototype._onToolbarCreated = function (ev, toolbar) {\\n        this.toolbar = toolbar;\\n        this.createControls(toolbar);\\n    };\\n\\n\\n\\n    /**\\n     * Deletes tool button.\\n     * If  doDeleteToolbarCreationListeners is true - removes listeners of toolbar creation event.\\n     * So, tool will not appear on toolbar next time, when toolbar is created.\\n     *\\n     * @param {boolean} doDeleteToolbarCreationListeners\\n     */\\n    MovableFloatingMode.prototype.removeTool = function(doDeleteToolbarCreationListeners) {\\n        if (this.deleteControls) {\\n            this.deleteControls();\\n        }\\n\\n        // stop listening toolbar creation\\n        if (doDeleteToolbarCreationListeners) {\\n            this.drawer.off(this.drawer.EVENT_CONFIG_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n            this.drawer.off(this.drawer.EVENT_MINIMIZED_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n        }\\n    };\\n\\n\\n\\n  /**\\n   * Is called from Base\\n   * @param  {EaselToolbar} toolbar\\n   */\\n  MovableFloatingMode.prototype.createControls = function (toolbar) {\\n    this.makeMoveButton(toolbar);\\n  };\\n\\n  MovableFloatingMode.prototype.makeMoveButton = function (toolbar) {\\n    // create move button\\n    var moveButtonConf = {\\n          buttonOrder: this.options.buttonOrder,\\n          additionalClass: 'btn-move',\\n          iconClass: 'fa-arrows',\\n          tooltipText: this.drawer.t('Move canvas')\\n        },\\n        $moveButton = toolbar.addButton(moveButtonConf);\\n    this.$moveButton = $moveButton;\\n\\n    // set handler\\n    this.$moveButton.on(MOUSE_DOWN, this.buttonOnMouseDown.bind(this));\\n  };\\n\\n\\n  /**\\n   * Handler of mouse down on button.\\n   * @param  {MouseEvent} event [description]\\n   */\\n  MovableFloatingMode.prototype.buttonOnMouseDown = function (event) {\\n    if (event.type.indexOf('touch') > -1) {\\n      event = event.originalEvent;\\n    }\\n\\n    $('.tooltip-btn-move').css('display', 'none');\\n\\n    // save coords of drawer\\n    this.startLeft = this.drawer.$imageElement\\n        .css('left').replace('px', '') | 0;\\n    this.startTop = this.drawer.$imageElement\\n        .css('top').replace('px', '') | 0;\\n\\n    // save coords of click\\n    this.mouseStartLeft = event.pageX;\\n    this.mouseStartTop = event.pageY;\\n\\n    // set handler for mouse move\\n    var $body = $('body'),\\n        $document = $(window.document);\\n    $body.addClass('easel-moving');\\n    $document.on(MOUSE_MOVE, this.buttonOnMouseMove.bind(this));\\n    // set handler for mouse up\\n    $document.on(MOUSE_UP, this.buttonOnMouseUp.bind(this));\\n\\n    return false;\\n  };\\n\\n\\n  /**\\n   * Handler of mouse movement, when mouse button is down.\\n   * @param  {Event} moveEvent        [description]\\n   * @return {Boolean}                returns false, to stop event propagation\\n   */\\n  MovableFloatingMode.prototype.buttonOnMouseMove = function (moveEvent) {\\n    var self = this,\\n        moveEventPos = util.getEventPosition(moveEvent),\\n        moveEaselFunc = function moveEaselFunc(){\\n          self.moveEasel(moveEventPos.left, moveEventPos.top);\\n        };\\n\\n    util.requestAnimationFrame(moveEaselFunc);\\n\\n    moveEvent.preventDefault();\\n    moveEvent.stopPropagation();\\n    return false;\\n  };\\n\\n\\n  /**\\n   * Mouse up handler.\\n   * @param  {MouseEvent} event\\n   * @return {Boolean}    returns false, to stop event propagation\\n   */\\n  MovableFloatingMode.prototype.buttonOnMouseUp = function (event) {\\n      $('.tooltip-btn-move').css('display', 'block');\\n\\n      var $body = $('body'),\\n          $document = $(window.document);\\n      $body.removeClass('easel-moving');\\n    $document.off(MOUSE_MOVE);\\n    $document.off(MOUSE_UP);\\n\\n      return false;\\n  };\\n\\n\\n  /**\\n   * Moves drawer according to mouse movement.\\n   * x, y here are coords of mouse pointer.\\n   *\\n   * @param  {integer} x x coord of mouse pointer\\n   * @param  {integer} y y coord of mouse pointer\\n   */\\n  MovableFloatingMode.prototype.moveEasel = function (x, y) {\\n    // calc offset of mouse pointer from click position\\n    var diffLeft = x - this.mouseStartLeft;\\n    var diffTop = y - this.mouseStartTop;\\n\\n    // new coords of drawer\\n    var newLeft = this.startLeft + diffLeft;\\n    var newTop = this.startTop + diffTop;\\n    newLeft = (newLeft < 0) ? 0 : newLeft;\\n    newTop  = (newTop < 0)  ? 0 : newTop;\\n\\n    // change drawer position\\n    var drawer = this.drawer;\\n    drawer.$imageElement.css({\\n      left: newLeft,\\n      top: newTop\\n    });\\n\\n    drawer.updateAligmentCss();\\n    drawer.adjustEditContainer(false, true);\\n  };\\n\\n  /**\\n   * Shows/hide move button, depending on current align mode.\\n   */\\n  MovableFloatingMode.prototype.onOptionsChanged = function() {\\n    // try to get fullscreen plugin\\n    var fullScreenPlugin;\\n    try {\\n      fullScreenPlugin = this.drawer.getPluginInstance('Fullscreen');\\n    }\\n    catch (e) {\\n      // do nothing\\n    }\\n\\n    // see, if we are in fullscreen mode\\n    var isInFullscreen = fullScreenPlugin && fullScreenPlugin.isInFullscreenMode();\\n\\n    // show button if no fullscreen mode and align is 'floating'\\n    if (!isInFullscreen && (this.drawer.options.align == 'floating')) {\\n      this.showMoveButton();\\n    } else {\\n      this.hideMoveButton();\\n    }\\n  };\\n\\n\\n  /**\\n   * Shows plugin button.\\n   */\\n  MovableFloatingMode.prototype.showMoveButton = function() {\\n    if (!this.$moveButton) {\\n      console.warn('MovableFloatingMode.removeMoveButton() : no button \\\\'Move\\\\' present');\\n      return;\\n    }\\n    this.$moveButton.show();\\n  };\\n\\n  /**\\n   * Hides plugin button.\\n   */\\n  MovableFloatingMode.prototype.hideMoveButton = function() {\\n    if (!this.$moveButton) {\\n      console.warn('MovableFloatingMode.removeMoveButton() : no button \\\\'Move\\\\' present');\\n      return;\\n    }\\n    this.$moveButton.hide();\\n  };\\n\\n\\n  pluginsNamespace.MovableFloatingMode = MovableFloatingMode;\\n}(jQuery, Easel.plugins, /*Easel.plugins.BaseToolOptions,*/ Easel.util));\"","module.exports = \"(function($, BaseShape, pluginsNamespace) {\\n  /**\\n   * Provides a circle button which can be used to draw circles.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {String} [options.centeringMode='normal']\\n   * Defines centering method when drawing a shape.\\n   * <br><br>\\n   * Valid values are:\\n   * <br><br>\\n   * <code>normal</code>: circle's top left corner will be placed to the\\n   * position of first mouse click and will be resized from that point.\\n   * <br><br>\\n   * <code>from_center</code>: circle's center point will be placed to the\\n   * position of first mouse click and will be resized from center.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var Circle = function CircleConstructor(drawerInstance, options) {\\n    var _this = this;\\n\\n    BaseShape.call(_this, drawerInstance);\\n\\n    this.name = 'Circle';\\n    this.btnClass = 'btn-circle';\\n    this.faClass = 'fa-circle';\\n    this.tooltip = drawerInstance.t('Draw a circle');\\n\\n    this.options = options || {};\\n    this.centeringMode =\\n      this.options.centeringMode || BaseShape.CENTERING_MODE.NORMAL;\\n  };\\n\\n  Circle.prototype = Object.create(BaseShape.prototype);\\n  Circle.prototype.constructor = Circle;\\n\\n  Circle.prototype.minShapeSize = 5;\\n\\n  Circle.prototype.createShape = function (left, top) {\\n    this.startLeft = left;\\n    this.startTop = top;\\n\\n    var circle = new fabric.PCircle({\\n      left: left,\\n      top: top,\\n      radius: 1,\\n      fill: this.drawerInstance.activeColor,\\n      opacity:this.drawerInstance.activeOpacity\\n    });\\n\\n    return circle;\\n  };\\n\\n  Circle.prototype.updateShape = function (circle, newLeft, newTop) {\\n    var width = newLeft - this.startLeft;\\n    var height = newTop - this.startTop;\\n\\n    var widthAbs = Math.abs(width);\\n    var heightAbs = Math.abs(height);\\n\\n    var radius = widthAbs < heightAbs ? widthAbs : heightAbs;\\n\\n    radius = Math.abs(radius);\\n    radius = radius / 2;\\n\\n    if (this.centeringMode == BaseShape.CENTERING_MODE.FROM_CENTER) {\\n      radius *= 2;\\n      circle.set('left', this.startLeft - radius);\\n      circle.set('top', this.startTop - radius);\\n    }\\n\\n    if (this.centeringMode == BaseShape.CENTERING_MODE.NORMAL) {\\n      if (width < 0) {\\n        circle.set('left', this.startLeft - (radius * 2));\\n      } else {\\n        circle.set('left', this.startLeft);\\n      }\\n\\n      if (height < 0) {\\n        circle.set('top', this.startTop - (radius * 2));\\n      } else {\\n        circle.set('top', this.startTop);\\n      }\\n    }\\n\\n    circle.set('radius', radius);\\n  };\\n\\n  pluginsNamespace.Circle = Circle;\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins));\"","module.exports = \"  /**\\n   * Toolbar with floating buttons\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * @param {Object} [options]\\n   * @extends EaselToolbar\\n   * @constructor\\n   */\\n  var OverCanvasToolbar = function (drawerInstance, options) {\\n    options = options || {};\\n    // css class for toolbar\\n    options.toolbarClass = EaselToolbar.FLOATING_CLASS || 'drawer-toolbar--floating';\\n    // call EaselToolbar c-tor\\n    EaselToolbar.call(this, drawerInstance, options);\\n    // cry loud of birth\\n    drawerInstance.trigger(drawerInstance.EVENT_FLOATING_TOOLBAR_CREATED, [this]);\\n  };\\n\\n  OverCanvasToolbar.prototype = Object.create(EaselToolbar.prototype);\\n  OverCanvasToolbar.prototype.constructor = EaselToolbar;\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/BaseTool.js\"))","module.exports = \"(function (namespace, util) {\\n\\n  'use strict';\\n\\n  var getPointer = fabric.util.getPointer,\\n    degreesToRadians = fabric.util.degreesToRadians,\\n    radiansToDegrees = fabric.util.radiansToDegrees,\\n    atan2 = Math.atan2,\\n    abs = Math.abs;\\n\\n  /**\\n   * Fabricjs canvas class with customizations to allow\\n   * eraser paths, fixed rotations etc.\\n   *\\n   * @constructor\\n   * @memberof Easel\\n   */\\n  namespace.Canvas = fabric.util.createClass(fabric.Canvas, /** @lends fabric.Canvas.prototype */ {\\n\\n    /**\\n     * Constructor\\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\\n     * @param {Object} [options] Options object\\n     * @return {Object} thisArg\\n     */\\n    initialize: function (el, options) {\\n      options = options ? options : {};\\n      this.preserveObjectStacking = true;\\n\\n      this.callSuper('initialize', el, options);\\n    },\\n\\n\\n    disableSelection: function () {\\n      var obj = null;\\n      var objects = this.getObjects();\\n      this.deactivateAll();\\n\\n      for (var i = 0; i < objects.length; i++) {\\n        obj = objects[i];\\n        if (obj.__evented === undefined) {\\n          obj.__evented = obj.get('evented');\\n          obj.set('evented', false);\\n        }\\n\\n        if (obj.__selectable === undefined) {\\n          obj.__selectable = obj.get('selectable');\\n          obj.set('selectable', false);\\n        }\\n      }\\n    },\\n\\n    restoreSelection: function () {\\n      var obj = null;\\n      var objects = this.getObjects();\\n\\n      for (var i = 0; i < objects.length; i++) {\\n        obj = objects[i];\\n\\n        if (obj.__evented !== undefined) {\\n          obj.set('evented', obj.__evented);\\n          delete obj.__evented;\\n        }\\n\\n        if (obj.__selectable !== undefined) {\\n          obj.set('selectable', obj.__selectable);\\n          delete obj.__selectable;\\n        }\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Array} objectsToRender\\n     */\\n    _renderObjects: function (ctx, objectsToRender) {\\n      var i, length, obj;\\n\\n      var tempCanvas = util.getTemporaryCanvas(this);\\n      var tempContext = tempCanvas.getContext('2d');\\n      tempContext.clearRect(0, 0, this.width, this.height);\\n\\n      this.eraserPaths = [];\\n\\n      for (i = 0, length = objectsToRender.length; i < length; ++i) {\\n          obj = objectsToRender[i];\\n\\n          // we do not render eraser paths\\n          if (obj instanceof fabric.EraserPath)\\n              continue;\\n\\n          // obj.render(tempContext);\\n          obj.render(ctx);\\n      }\\n\\n        // ctx.drawImage(tempCanvas, 0, 0);\\n        // tempContext.clearRect(0, 0, this.width, this.height);\\n\\n    },\\n\\n\\n    _applyEraserPath: function (pathObject, ctx) {\\n      pathObject.visible = true;\\n      pathObject.globalCompositeOperation = 'destination-out';\\n      pathObject.render(ctx);\\n      pathObject.visible = false;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _findNewLowerIndex: function (object, idx, intersecting) {\\n      var newIdx;\\n\\n      if (intersecting) {\\n        newIdx = idx;\\n\\n        // traverse down the stack looking for the nearest intersecting object\\n        for (var i = idx - 1; i >= 0; --i) {\\n\\n          if (this._objects[i] instanceof fabric.EraserPath) {\\n            continue;\\n          }\\n\\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\\n            object.isContainedWithinObject(this._objects[i]) ||\\n            this._objects[i].isContainedWithinObject(object);\\n\\n          if (isIntersecting) {\\n            newIdx = i;\\n            break;\\n          }\\n        }\\n      }\\n      else {\\n        newIdx = idx - 1;\\n      }\\n\\n      return newIdx;\\n    },\\n    /**\\n     * @private\\n     */\\n    _findNewUpperIndex: function (object, idx, intersecting) {\\n      var newIdx;\\n\\n      if (intersecting) {\\n        newIdx = idx;\\n\\n        // traverse up the stack looking for the nearest intersecting object\\n        for (var i = idx + 1; i < this._objects.length; ++i) {\\n\\n          if (this._objects[i] instanceof fabric.EraserPath) {\\n            continue;\\n          }\\n\\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\\n            object.isContainedWithinObject(this._objects[i]) ||\\n            this._objects[i].isContainedWithinObject(object);\\n\\n          if (isIntersecting) {\\n            newIdx = i;\\n            break;\\n          }\\n        }\\n      }\\n      else {\\n        newIdx = idx + 1;\\n      }\\n\\n      return newIdx;\\n    },\\n\\n    /**\\n     * This override is needed to properly call object.set() method\\n     * instead of simple assigment.\\n     *\\n     * @private\\n     * @param {Number} x pointer's x coordinate\\n     * @param {Number} y pointer's y coordinate\\n     *\\n     * @return {boolean} always returns true, except case when _currentTransform.get('lockRotation') returns true\\n     */\\n    _rotateObject: function (x, y) {\\n      var t = this._currentTransform;\\n\\n      if (t.target.get('lockRotation')) {\\n        return;\\n      }\\n\\n      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),\\n        curAngle = atan2(y - t.top, x - t.left),\\n        angle = radiansToDegrees(curAngle - lastAngle + t.theta);\\n\\n      // normalize angle to positive value\\n      if (angle < 0) {\\n        angle = 360 + angle;\\n      }\\n\\n      t.target.set('angle', angle % 360);\\n      return true;\\n    }\\n  });\\n})(Easel, Easel.util);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasableObject.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-canvas-properties/CanvasProperties.js\"))","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n    extend = fabric.util.object.extend,\\n    min = fabric.util.array.min,\\n    max = fabric.util.array.max,\\n    toFixed = fabric.util.toFixed;\\n\\n  fabric.SegmentableLine = fabric.util.createClass(fabric.Object, {\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'SegmentableLine',\\n\\n    /**\\n     * List of options to show when object is selected\\n     * @type {String[]}\\n     */\\n    objectOptionsList : ['border', 'opacity', 'lineWidth', 'strokeWidth'],\\n\\n    /**\\n     * Points array\\n     * @type Array[]\\n     * @default\\n     */\\n    points: null,\\n\\n    /**\\n     * Minimum X from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minX: 0,\\n\\n    /**\\n     * Minimum Y from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minY: 0,\\n\\n    /**\\n     * Constructor\\n     * @param {Array} points Array of points\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Polygon} thisArg\\n     */\\n    initialize: function (points, options) {\\n      options = options || {};\\n      this.points = points;\\n      this.callSuper('initialize', options);\\n      this._calcDimensions();\\n      if (!('top' in options)) {\\n        this.top = this.minY;\\n      }\\n      if (!('left' in options)) {\\n        this.left = this.minX;\\n      }\\n    },\\n    /**\\n     * @private\\n     */\\n    _calcDimensions: function () {\\n\\n      var points = this.points;\\n\\n      var minX = null;\\n      var minY = null;\\n      var maxX = null;\\n      var maxY = null;\\n\\n      for (var i = 0; i < this.points.length; i++) {\\n        var _minX = min(this.points[i], 'x');\\n        if (minX === null || _minX < minX) {\\n          minX = _minX;\\n        }\\n\\n        var _minY = min(this.points[i], 'y');\\n        if (minY === null || _minY < minY) {\\n          minY = _minY;\\n        }\\n\\n        var _maxX = max(this.points[i], 'x');\\n        if (maxX === null || _maxX > maxX) {\\n          maxX = _maxX;\\n        }\\n\\n        var _maxY = max(this.points[i], 'y');\\n        if (maxY === null || _maxY > maxY) {\\n          maxY = _maxY;\\n        }\\n      }\\n\\n      this.width = (maxX - minX) || 1;\\n      this.height = (maxY - minY) || 1;\\n\\n      this.minX = minX;\\n      this.minY = minY;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _applyPointOffset: function () {\\n      // change points to offset polygon into a bounding box\\n      // executed one time\\n      this.points.forEach(function (pointSegment) {\\n        pointSegment.forEach(function (p) {\\n          p.x -= (this.minX + this.width / 2);\\n          p.y -= (this.minY + this.height / 2);\\n        }, this);\\n      }, this);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function (propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        points: this.points.concat(),\\n        type: this.type\\n      });\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function (reviver) {\\n      var points = [],\\n        markup = this._createBaseSVGMarkup();\\n\\n      for (var i = 0, len = this.points.length; i < len; i++) {\\n        points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');\\n      }\\n\\n      markup.push(\\n        '<', this.type, ' ',\\n        'points=\\\"', points.join(''),\\n        '\\\" style=\\\"', this.getSvgStyles(),\\n        '\\\" transform=\\\"', this.getSvgTransform(),\\n        ' ', this.getSvgTransformMatrix(),\\n        '\\\"/>\\\\n'\\n      );\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _render: function (ctx) {\\n      this.commonRender(ctx);\\n      this._renderFill(ctx);\\n      if (this.stroke || this.strokeDashArray) {\\n        //ctx.closePath();\\n        this._renderStroke(ctx);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    commonRender: function (ctx) {\\n      var point;\\n      ctx.beginPath();\\n\\n      if (this._applyPointOffset) {\\n        if (!(this.group && this.group.type === 'path-group')) {\\n          this._applyPointOffset();\\n        }\\n        this._applyPointOffset = null;\\n      }\\n\\n      var firstSegment = this.points[0];\\n\\n      ctx.moveTo(firstSegment[0].x, firstSegment[0].y);\\n      for (var i = 0, len = firstSegment.length; i < len; i++) {\\n        point = firstSegment[i];\\n        ctx.lineTo(point.x, point.y);\\n      }\\n\\n      //ctx.closePath();\\n\\n      if (this.points.length > 1) {\\n        for (var s = 1; s < this.points.length; s++) {\\n          var segmentPoints = this.points[s];\\n          ctx.moveTo(segmentPoints[0].x, segmentPoints[0].y);\\n\\n          for (var sp = 0; sp < segmentPoints.length; sp++) {\\n            ctx.lineTo(segmentPoints[sp].x, segmentPoints[sp].y);\\n          }\\n\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function () {\\n      return this.points.length;\\n    }\\n\\n  });\\n\\n  /**\\n   * Returns fabric.Polygon instance from an object representation\\n   * @static\\n   * @memberOf fabric.Polygon\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Polygon} Instance of fabric.Polygon\\n   */\\n  fabric.SegmentableLine.fromObject = function (object) {\\n    return new fabric.SegmentableLine(object.points, object, true);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  var classicDefaultValue = 1.16, // Standard value of line height\\n      fabricDefaultLineHeight = fabric.Text.prototype.lineHeight || classicDefaultValue;\\n\\n  /**\\n   * Creates controls for changing line height;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextLineHeight = function TextLineHeightConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    this._setupOptions(options);\\n  };\\n\\n  TextLineHeight.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextLineHeight.prototype.constructor = BaseTextOptionTool;\\n\\n  TextLineHeight.prototype.name = 'TextLineHeight';\\n  TextLineHeight.prototype.optionName = 'TextLineHeight';\\n  TextLineHeight.prototype.showOnEditMode = false;\\n  TextLineHeight.prototype.hideOnEditMode = true;\\n  TextLineHeight.prototype.stylesToObject = true;\\n  TextLineHeight.prototype.preventHightlight = true;\\n  TextLineHeight.prototype.buttonIconClass = 'fa-arrows-v';\\n  TextLineHeight.prototype.onlyPredefined = true;\\n\\n  TextLineHeight.prototype.valueType = {\\n    lineHeight: 'number'\\n  };\\n\\n  TextLineHeight.prototype._defaultOptions = {\\n    defaultValues: {\\n      lineHeight: fabricDefaultLineHeight\\n    },\\n    predefined: {\\n      lineHeight: [1, 1.16, 1.25, 1.5, 1.75, 2, 3]\\n    }\\n  };\\n\\n  TextLineHeight.prototype.collectDataFromObject = function (tool) {\\n    var result = {\\n      lineHeight: tool.lineHeight\\n    };\\n    this._lastData = this._lastData || {};\\n    $.extend(true, this._lastData, result);\\n    return result;\\n  };\\n\\n  TextLineHeight.prototype.controlTemplate = function () {\\n    var result,\\n        $predefined,\\n        selectHtml;\\n\\n    $predefined = this.options.predefined.lineHeight.map(function (size, i) {\\n      var sizeInPercent = parseInt(Math.round(size * 100), 10);\\n      return '<option value=\\\"' + size + '\\\">' + sizeInPercent + '%' + '</option>';\\n    }).join('');\\n\\n    selectHtml = '' +\\n        '<select ' +\\n        'class=\\\"editable-canvas-text-lineheight-input controls-value-item\\\" ' +\\n        'name=\\\"drawer-size\\\"' +\\n        'data-name=\\\"lineHeight\\\"' +\\n        'value=\\\"' + this.options.defaultValues.lineHeight + '\\\">' +\\n        $predefined +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper editable-canvas-text-option editable-canvas-text-lineheight hidden',\\n        optionItemAdditionalClasses = '' +\\n            (this.buttonMode ? ' toolbar-button-item ': '') +\\n            (this.preventHightlight ? ' prevent-highlight ': ''),\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n        '<span class=\\\"toolbar-item-label\\\">' +\\n        this.drawer.t('Line height:') + ' ' +\\n        '</span>' +\\n        '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n        '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n        '</div>' +\\n        '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n        selectHtml +\\n        '</div>' +\\n        '</li>';\\n\\n    return result;\\n  };\\n\\n  pluginsNamespace.TextLineHeight = TextLineHeight;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n    extend = fabric.util.object.extend,\\n    toFixed = fabric.util.toFixed;\\n\\n\\n  fabric.Arrow = fabric.util.createClass(fabric.Line, {\\n\\n    type: 'arrow',\\n\\n    objectCaching : false,\\n\\n    /**\\n     * List of options to show when object is selected\\n     * @type {String[]}\\n     */\\n    objectOptionsList : ['border', 'opacity', 'lineWidth', 'strokeWidth'],\\n\\n\\n    initialize: function (points, options) {\\n      this.callSuper('initialize', points, options);\\n      if (options) {\\n        this.set('oneSided', options.oneSided);\\n      }\\n    },\\n\\n\\n    // _getNonTransformedDimensions :function(argument) {\\n    //     var strokeWidth = this.strokeWidth,\\n    //     w = this.width + strokeWidth + 30,\\n    //     h = this.height + strokeWidth + 30;\\n\\n    //     return { x: w, y: h };\\n    // },\\n\\n    _render: function (ctx, noTransform) {\\n      if (\\n        (this.width < 20 && this.height < 20) ||\\n        (this.scaleX < 0.3 && this.scaleY < 0.3)\\n      ) {\\n        this.set('padding', 20);\\n      } else {\\n        this.set('padding', 10);\\n      }\\n\\n      this.canvas.calcOffset();\\n\\n      this.callSuper('_render', ctx, noTransform);\\n      var points = this.callSuper('calcLinePoints');\\n\\n      var angle = this._calcArrowAngle(points.x1, points.y1, points.x2, points.y2);\\n\\n      if (!this.oneSided) {\\n        this._drawArrow(ctx, {x: points.x1, y: points.y1}, angle + 90);\\n      }\\n      this._drawArrow(ctx, {x: points.x2, y: points.y2}, angle - 90);\\n    },\\n\\n    _drawArrow: function (ctx, point, angle) {\\n      var arrowSize = 0.5;\\n\\n      if(this.get('strokeWidth') > 1){\\n        arrowSize = arrowSize * (this.get('strokeWidth') / 2);\\n      }\\n\\n      var arrowPointOffsetX = 10;\\n      var arrowPointOffsetY = 20;\\n\\n      var frontCenterPoint = {\\n        x: point.x,\\n        y: point.y + (arrowPointOffsetX * arrowSize)\\n      };\\n      var leftPoint = {\\n        x: point.x - (arrowPointOffsetX * arrowSize),\\n        y: point.y - (arrowPointOffsetY * arrowSize)\\n      };\\n      var backCenterPoint = {\\n        x: point.x,\\n        y: point.y - (arrowPointOffsetX * arrowSize)\\n      };\\n      var rightPoint = {\\n        x: point.x + (arrowPointOffsetX * arrowSize),\\n        y: point.y - (arrowPointOffsetY * arrowSize)\\n      };\\n\\n      ctx.save();\\n\\n      ctx.translate(point.x, point.y);\\n      ctx.rotate(angle * Math.PI / 180);\\n      ctx.translate(point.x * -1, point.y * -1);\\n\\n      ctx.beginPath();\\n      ctx.moveTo(frontCenterPoint.x, frontCenterPoint.y);\\n      ctx.lineTo(leftPoint.x, leftPoint.y);\\n      ctx.lineTo(backCenterPoint.x, backCenterPoint.y);\\n      ctx.lineTo(rightPoint.x, rightPoint.y);\\n      ctx.fillStyle = this.stroke;\\n      ctx.fill();\\n\\n      ctx.restore();\\n    },\\n\\n    _calcArrowAngle: function (x1, y1, x2, y2) {\\n      var angle = 0,\\n        x, y;\\n\\n      x = (x2 - x1);\\n      y = (y2 - y1);\\n\\n      if (x === 0) {\\n        angle = (y === 0) ? 0 :\\n          (y > 0) ? Math.PI / 2 : Math.PI * 3 / 2;\\n      }\\n      else if (y === 0) {\\n        angle = (x > 0) ? 0 : Math.PI;\\n      }\\n      else {\\n        angle = (x < 0) ? Math.atan(y / x) + Math.PI :\\n          (y < 0) ? Math.atan(y / x) + (2 * Math.PI) : Math.atan(y / x);\\n      }\\n\\n      return (angle * 180 / Math.PI);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     */\\n    toObject: function (propertiesToInclude) {\\n      if (!propertiesToInclude) {\\n        propertiesToInclude = [];\\n      }\\n\\n      propertiesToInclude.push('oneSided', 'padding');\\n\\n      return fabric.util.object.extend(\\n        this.callSuper('toObject', propertiesToInclude),\\n        this.calcLinePoints()\\n      );\\n    },\\n\\n    toSVG: function (reviver) {\\n      var lineMarkup = fabric.Line.prototype.toSVG.call(this);\\n      var arrowHeadsMarkup = this._getArrowheadsSvg();\\n      var markup = lineMarkup + arrowHeadsMarkup;\\n      return reviver ? reviver(markup) : markup;\\n    },\\n\\n    _getArrowheadsSvg: function () {\\n      var points = this.calcLinePoints();\\n      if (!points) {\\n        return '';\\n      }\\n\\n      var baseAngle = this._calcArrowAngle(points.x1, points.y1, points.x2, points.y2);\\n      var markup = '';\\n\\n      if (!this.oneSided) {\\n        markup += this._buildArrowheadSvg({ x: points.x1, y: points.y1 }, baseAngle + 90);\\n      }\\n\\n      markup += this._buildArrowheadSvg({ x: points.x2, y: points.y2 }, baseAngle - 90);\\n      return markup;\\n    },\\n\\n    _buildArrowheadSvg: function (anchorPoint, angleDegrees) {\\n      if (!anchorPoint) {\\n        return '';\\n      }\\n\\n      var polygonPoints = this._calculateArrowheadPoints(anchorPoint, angleDegrees);\\n      if (!polygonPoints.length) {\\n        return '';\\n      }\\n\\n      var pointsAttr = polygonPoints.map(function (point) {\\n        return toFixed(point.x, 2) + ',' + toFixed(point.y, 2);\\n      }).join(' ');\\n\\n      return [\\n        '<polygon ',\\n          'points=\\\"', pointsAttr, '\\\" ',\\n          'fill=\\\"', this.stroke || this.fill || '#000', '\\\" ',\\n          'stroke=\\\"none\\\" ',\\n          'transform=\\\"', this.getSvgTransform(), ' ', this.getSvgTransformMatrix(), '\\\"',\\n        '/>\\\\n'\\n      ].join('');\\n    },\\n\\n    _calculateArrowheadPoints: function (anchorPoint, angleDegrees) {\\n      var arrowSize = 0.5;\\n      var strokeWidth = this.get('strokeWidth') || 1;\\n      if (strokeWidth > 1) {\\n        arrowSize = arrowSize * (strokeWidth / 2);\\n      }\\n\\n      var arrowPointOffsetX = 10;\\n      var arrowPointOffsetY = 20;\\n      var templates = [\\n        { x: 0, y: arrowPointOffsetX },\\n        { x: -arrowPointOffsetX, y: -arrowPointOffsetY },\\n        { x: 0, y: -arrowPointOffsetX },\\n        { x: arrowPointOffsetX, y: -arrowPointOffsetY }\\n      ];\\n\\n      var angleRad = fabric.util.degreesToRadians(angleDegrees);\\n      var cos = Math.cos(angleRad);\\n      var sin = Math.sin(angleRad);\\n      var result = [];\\n\\n      for (var i = 0; i < templates.length; i++) {\\n        var templatePoint = templates[i];\\n        var scaledX = templatePoint.x * arrowSize;\\n        var scaledY = templatePoint.y * arrowSize;\\n        var rotatedX = (scaledX * cos) - (scaledY * sin);\\n        var rotatedY = (scaledX * sin) + (scaledY * cos);\\n        result.push({\\n          x: anchorPoint.x + rotatedX,\\n          y: anchorPoint.y + rotatedY\\n        });\\n      }\\n\\n      return result;\\n    }\\n  });\\n\\n\\n  /**\\n   * Returns fabric.Arrow instance from an object representation\\n   */\\n  fabric.Arrow.fromObject = function (object) {\\n    var points = [object.x1, object.y1, object.x2, object.y2];\\n    return new fabric.Arrow(points, object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/BaseTextOptionTool.js\"))","module.exports = \"(function ($, pluginsNamespace, util) {\\n  'use strict';\\n\\n  /**\\n   * Creates color input for changing color; colorChangeHandler is called on color change.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {callback} colorChangeHandler will be called  with new color as parameter\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var OpacityControl = function OpacityControlConstructor(drawer, options) {\\n      /**\\n       * @type {Easel}\\n       */\\n      this.drawer = drawer;\\n\\n      // init options\\n      this.options = $.extend(true, {}, this._defaultOptions || {}, options || {});\\n\\n      this._opacity = this.options.defaultOpacity;\\n      this.drawer.on(this.drawer.AFTER_CREATE_TOOLBARS, this._moveControlToEnd.bind(this));\\n    };\\n\\n\\n  OpacityControl.prototype._defaultOptions = {\\n    defaultOpacity : 1\\n  };\\n\\n\\n  /**\\n   * Removes tool\\n   */\\n  OpacityControl.prototype.remove = function () {\\n    if (this.$opacityControl) {\\n      this.$opacityControl.remove();\\n    }\\n  };\\n\\n  /**\\n   * Move opacity control to the end of toolbar for popup\\n   * @private\\n   */\\n  OpacityControl.prototype._moveControlToEnd = function () {\\n    var needToMove = this.toolbar.options.compactType === 'popup';\\n    if (needToMove) {\\n      var $toolbar = this.$opacityControl.parent();\\n      $toolbar.append(this.$opacityControl);\\n    }\\n  };\\n\\n  /**\\n   * Hides controls\\n   */\\n  OpacityControl.prototype.hideControls = function () {\\n    if (this.$opacityControl) {\\n      this.$opacityControl.addClass('hidden');\\n    }\\n  };\\n\\n\\n  /**\\n   * Shows controls\\n   */\\n  OpacityControl.prototype.showControls = function () {\\n    if (this.$opacityControl) {\\n      this.$opacityControl.removeClass('hidden');\\n    }\\n  };\\n\\n\\n  /**\\n   * Returns current opacity\\n   * @return {Number} current opacity - number from 0 to 1\\n   */\\n  OpacityControl.prototype.getOpacity = function () {\\n      return this._opacity;\\n  };\\n\\n\\n  /**\\n   * Sets current opacity and updated tool control.\\n   * @param {Number} opacity number from 0 to 1\\n   */\\n  OpacityControl.prototype.setOpacity = function (opacity) {\\n      this._opacity = opacity;\\n\\n      this.$opacityControl.find('input').val(opacity * 100 );\\n      this.$opacityControl.find('.editable-canvas-opacity-indicator').text(opacity * 100 + '%');\\n    };\\n\\n\\n  /**\\n   * This function is called every time user clicks on color from color-dropdown\\n   * menu.\\n   *\\n   * @param {String} selectedColor Hash value of user selected color.\\n   */\\n  OpacityControl.prototype.onOpacityChange = function () {\\n    var $opacityInput = $(this.$opacityControl).find('input'),\\n        rawValue = parseInt($opacityInput.val(), 10),\\n        rawValueIsValid = typeof rawValue === 'number' &&  isFinite(rawValue),\\n        validatedValue = rawValueIsValid ? rawValue : this.options.defaultOpacity,\\n        formattedValue = parseInt(validatedValue, 10) + '%';\\n    this._opacity = validatedValue / 100;\\n\\n    this.$opacityIndicator.text(formattedValue);\\n\\n    if (this.opacityChangeCallback) {\\n      this.opacityChangeCallback(this._opacity);\\n    }\\n  };\\n\\n\\n  /**\\n   * Create controls.\\n   * @param  {EaselToolbar} toolbar to add control to\\n   */\\n  OpacityControl.prototype.createControl = function (toolbar, opacityChangeCallback) {\\n    var self = this;\\n    this.toolbar = toolbar;\\n    this.opacityChangeCallback = opacityChangeCallback;\\n\\n    this.$opacityControl = $(\\n      '<li class=\\\"editable-canvas-opacity toolbar-item-range\\\">' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n          '<span class=\\\"toolbar-label editable-canvas-opacity-label\\\">' +\\n          this.drawer.t('Fill opacity:') + ' ' +\\n          '</span>' +\\n          '<span class=\\\"toolbar-label toolbar-label-indicator editable-canvas-opacity-indicator\\\">' +\\n            '100%' +\\n          '</span>' +\\n      '</div>' +\\n        '<input class=\\\"editable-canvas-opacity-input\\\" ' +\\n               'type=\\\"range\\\" name=\\\"drawer-size\\\" min=\\\"0\\\" max=\\\"100\\\"' +\\n               'value=\\\"100\\\" />' +\\n        '</li>');\\n\\n    this.$opacityIndicator = this.$opacityControl.find('.editable-canvas-opacity-indicator');\\n\\n    toolbar.addControl(this.$opacityControl, this.options.buttonOrder);\\n\\n    $(this.$opacityControl).on('change', this.onOpacityChange.bind(this));\\n\\n    return this.$opacityControl;\\n  };\\n\\n\\n  OpacityControl.prototype.showControls = function() {\\n      // this.updateControl();\\n      this.$opacityControl.show();\\n  };\\n\\n\\n  OpacityControl.prototype.hideControls = function() {\\n      this.$opacityControl.hide();\\n  };\\n\\n\\n  // OpacityControl.prototype.updateControl = function () {\\n  //   var opactity = .5;\\n  //   this.setBrushSize\\n\\n  // };\\n\\n  pluginsNamespace.OpacityControl = OpacityControl;\\n\\n}(jQuery, Easel.plugins, Easel.util));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Easel.DefaultOptions.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/api-set-inactive-drawer-image/ApiSetInactiveEaselImage.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextFontStyle.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Easel.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/Arrow.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/brush-eraser/EraserPath.js\"))","module.exports = \"(function(global) {\\n\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {}),\\n        extend = fabric.util.object.extend;\\n\\n    fabric.ErasablePath = fabric.util.createClass(fabric.Path, {\\n\\n        type: 'ErasablePath',\\n\\n        objectCaching : false,\\n        evented : false,\\n        selectable : false,\\n\\n\\n        initialize: function(pathData, options) {\\n            options = options || {};\\n            this.callSuper('initialize', pathData, options);\\n        },\\n\\n\\n        _render: function(ctx) {\\n            this.callSuper('_render', ctx);\\n        },\\n\\n\\n        toObject: function(propertiesToInclude) {\\n            return this.callSuper('toObject', propertiesToInclude);\\n        }\\n\\n    });\\n\\n    /**\\n     * Creates object from  serialized data\\n     * @param  {Object} object\\n     * @return {ErasablePath}\\n     */\\n    fabric.ErasablePath.fromObject = function(data) {\\n        // @todo: maybe use code from fabric.Path.fromObject\\n        return new fabric.ErasablePath(data.path, data);\\n    };\\n\\n\\n    fabric.ErasablePath.async = false;\\n\\n    // make our object erasable via ErasableMixin.\\n    fabric.makeObjectErasable(fabric.ErasablePath);\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasableText.js\"))","module.exports = \"(function ($, namespace, pluginsNamespace, util, texts) {\\n  'use strict';\\n\\n  /**\\n   * Canvas editable element.\\n   *\\n   * @param redactorInstance {Object|null} Redactor's instance.\\n   *                         Could be null for standalone version.\\n   *\\n   * @param options {Object} Object with configuration parameters.\\n   *\\n   * @param {String} options.borderCss\\n   * Canvas border css styles.\\n   * <br><br>\\n   * Example:\\n   * <code>1px dashed rgb(195, 194, 194)</code>\\n   *\\n   * @param {String} options.borderCssEditMode\\n   * Canvas border css styles which will be applied when in edit mode.\\n   * <br><br>\\n   * Example:\\n   * <code>1px dashed rgb(195, 194, 194)</code>\\n   *\\n   * @param {String} options.backgroundCss\\n   * Canvas background css style which will be applied to canvas container.\\n   * <br><br>\\n   * Example:\\n   * <code>\\n   *   url(/redactor.plugin.drawer/dist/assets/transparent.png) repeat\\n   * </code>\\n   *\\n   * @param {String} options.defaultImageUrl\\n   * Image url that will be drawn on canvas when it's just created and\\n   * nothing has been drawn on it.\\n   *\\n   * @param {number} options.toolbarSize=35\\n   * Specifies drawer's toolbar buttons size in px.\\n   *\\n   * @param {number} options.toolbarSizeTouch=43\\n   * Specifies drawer's toolbar buttons size in px when running on touch device.\\n   *\\n   * @param {Object} options.toolbars - Configuration for each toolbar.\\n   * Each toolbar have next configuration object:\\n   * <code><pre>\\n   *   {\\n   *\\n   *      // All of {@link EaselToolbar.defaultSetOfOptions}\\n   *      hidden: false,\\n   *      position: 'top',\\n   *      positionType: 'outside',\\n   *      compactType: 'scrollable',\\n   *      toggleVisibilityButton: false,\\n   *      customAnchorSelector: '#custom-toolbar-here',\\n   *\\n   *      fullscreenMode: {\\n   *          // All of {@link EaselToolbar.defaultSetOfOptions}\\n   *          hidden: false,\\n   *          position: 'top',\\n   *          positionType: 'outside',\\n   *          compactType: 'scrollable',\\n   *          toggleVisibilityButton: false,\\n   *          customAnchorSelector: '#custom-toolbar-here',\\n   *      }\\n   *   }\\n   * </pre></code>\\n   *\\n   * @param {Boolean} options.toolbars.popupButtonAlwaysVisible=true - Always display popup button(If any toolbar uses it)\\n   *\\n   * @param {EaselToolbar.defaultToolbarOptions} options.toolbars.drawingTools - Configuration of \\\"Drawing tools\\\" toolbar\\n   *\\n   * @param {EaselToolbar.defaultToolbarOptions} options.toolbars.toolOptions - Configuration of \\\"Tool options\\\" toolbar\\n   *\\n   * @param {EaselToolbar.defaultToolbarOptions} options.toolbars.settings - Configuration of \\\"Easel settings\\\" toolbar\\n   *\\n   * @param {Object} options.tooltipCss\\n   * Allows css customizations of buttons tooltips. Could be any valid css\\n   * object that will be passed directly to jQuery.css method.\\n   * <br><br>\\n   * Example:\\n   * <code><pre>\\n   *   {\\n   *    background: 'green',\\n   *    color: 'red'\\n   *   }\\n   * </pre></code>\\n   *\\n   * @param {String} options.activeColor=#19A6FD\\n   * Specifies default active color for drawer(the one that will be selected on\\n   * initialization).\\n   *\\n   * @param {String} options.align  left|right|center|inline|floating\\n   * Specifies drawer align.\\n   * Easel can be moved via MovableFloatingMode only if align is 'floating'\\n   * <br><br>\\n   *\\n   * @param {Boolean} options.transparentBackground\\n   * Specifies if drawer canvas has transparent background.\\n   * <br><br>\\n   *\\n   * @param {String} options.texts\\n   * Object containing strings with translations/texts to use.\\n   * <br>\\n   * String keys could be found in Localization_en.js file.\\n   * <br><br>\\n   * Example:\\n   * <code><pre>\\n   *   {\\n   *    'Free drawing mode': 'Pencil',\\n   *   }\\n   * </pre></code>\\n   *\\n   * @param {Array} options.plugins\\n   * List of plugin names that drawer will use. Please see a full list here:\\n   * {@link Easel.plugins}\\n   *\\n   * Example:\\n   * <code><pre>\\n     * plugins: [\\n   *  // Drawing tools\\n   *  'Pencil',\\n   *  'Eraser',\\n   *  'Text',\\n   *  'Line',\\n   *  'ArrowOneSide',\\n   *  'ArrowTwoSide',\\n  *  'Diamond',\\n   *  'Rectangle',\\n   *  'Circle',\\n   *\\n   *  // Drawing options\\n   *  'ColorpickerRedactor',\\n   *  'BrushSize',\\n   *  'Resize'\\n   * ],\\n   * </pre></code>\\n   *\\n   * @param {Object} options.pluginsConfig\\n   * Each Easel plugin could have its own configuration and could be\\n   * configured by this section.\\n   * <br><br>\\n   *\\n   * This is the object which keys are plugin names and values are objects\\n   * with plugin configuration fields.\\n   * <br><br>\\n   *\\n   * Plugins names and documentation about each plugin could be found here:\\n   * {@link Easel.plugins}.\\n   * Look at plugin's constructor `<code>options</code>` argument.\\n   * <br><br>\\n   *\\n   * For example we would like to configure\\n   * {@link Easel.plugins.Text} and {@link Easel.plugins.Eraser}\\n   * plugins:\\n   * <code><pre class=\\\"prettyprint\\\">\\n   * pluginsConfig: {\\n   *   \\\"Text\\\": {\\n   *     \\\"fonts\\\": {\\n   *       \\\"Georgia\\\": 'Georgia, serif',\\n   *       \\\"Palatino\\\": \\\"'Palatino Linotype', Palatino, serif\\\"\\n   *     },\\n   *     \\\"defaultFont\\\": 'Georgia'\\n   *   },\\n   *   \\\"Eraser\\\": {\\n   *     \\\"cursorUrl\\\": \\\"url(assets/eraser_cursor.cur), default\\\"\\n   *   }\\n   * }\\n   * </code></pre>\\n   *\\n   * @param {Object} options.defaultActivePlugin\\n   * Activates default tool, if options.defaultActivePlugin is set;\\n   * MUST contain keys:\\n   * name - name of plugin\\n   * mode - one of : ['always', 'onNew', 'lastUsed']\\n   * Depending on options.defaultActivePlugin.mode :\\n   * 'always'   - same plugin will be always actived\\n   * 'onNew'    - default plugin is actiavted, only if canvas is empty\\n   * 'lastUsed' - on first drawer run plugin options.defaultActivePlugin.name, on consecutive - last used tool\\n   *\\n   * @param {Object} options.canvasProperties\\n   * Specifies fabricjs options that will be passed directly to fabricjs\\n   * canvas instance on creation.\\n   *\\n   * @param {String} options.canvasProperties.selectionColor\\n   * Specifies color of selection rectangle.\\n   *\\n   *\\n   * @param {number[]} options.canvasProperties.selectionDashArray\\n   * What it allows us to do is make selection lines dashed.\\n   * <br><br>\\n   *\\n   * The way to define dash pattern is by specifying intervals via an array.\\n   * <br><br>\\n   * So to create a pattern where there's one long dash followed by one short\\n   * dash, we could use something like <code>[10, 5]</code>\\n   * as \\\"selectionDashArray\\\".\\n   * <br>\\n   *\\n   * This will draw a line that's 10px long, then skip 5px, draw 10px line\\n   * again, and so on.<br>\\n   * If we were to use <code>[2, 4, 6]</code> array, the pattern would be\\n   * created by drawing 2px line, then skipping 4px, then drawing 6px line,\\n   * then skipping 2px, then drawing 4px line, then skipping 6px, and so on.\\n   * You get the point.\\n   *\\n   *\\n   * @param {number} options.canvasProperties.selectionLineWidth\\n   * Specifies selection line width in pixels.\\n   *\\n   *\\n   * @param {String} options.canvasProperties.selectionBorderColor\\n   * Specifies selection line color.\\n   *\\n   *\\n   * @param {Object} options.objectControls\\n   * Specifies the appearance of selected object controls.\\n   *\\n   *\\n   * @param {String} options.objectControls.borderColor\\n   * Specifies selected object border color.\\n   *\\n   *\\n   * @param {float} options.objectControls.borderOpacityWhenMoving\\n   * Specifies border opacity when object is selected and in moving process.\\n   *\\n   *\\n   * @param {String} options.objectControls.cornerColor\\n   * Specified color of control corners for resizing/rotating.\\n   *\\n   *\\n   * @param {number} options.objectControls.cornerSize\\n   * Specifies size of corners for resizing/rotating.\\n   *\\n   *\\n   * @param {boolean} options.objectControls.hasBorders\\n   * Toggles visibility of selected object border.\\n   *\\n   * @param {Object} options.objectControlsTouch\\n   * The same as <code>objectControls</code> but will be used\\n   * when touch device is detected.\\n   *\\n   * @param {Function} options.detectTouch\\n   * A custom function that will be used by drawer to determine whether it is\\n   * running on touch device or not.\\n   * <br><br>\\n   *\\n   * This function must return <code>true</code> or <code>false</code>.\\n   * <br><br>\\n   *\\n   * <code>true</code> means that touch device is detected and drawer should\\n   * adjust its toolbar sized, add touch events etc.\\n   * <br><br>\\n   *\\n   * Note that if this function is not specified, drawer will use its own\\n   * detection mechanism.\\n   * <br><br>\\n   *\\n   * To disable any detection simply set this parameter to such function:\\n   * <code><pre>function() { return false; }</pre></code>\\n   *\\n   *\\n   * @param {Object} options.contentConfig\\n   * Specifies data-management configuration and controls where canvas element\\n   * will store its information.\\n   *\\n   *\\n   * @param {number} options.contentConfig.saveAfterInactiveSec\\n   * Specifies number of seconds to wait after user interaction.\\n   * If nothing happens in that time - canvas will be saved.\\n   * Any interaction resets the timer.\\n   *\\n   * @param {boolean} options.contentConfig.saveInHtml\\n   * Controls whether a drawer will save its content to underlying\\n   * image element.\\n   * <br><br>\\n   *\\n   * If <code>true</code>, canvas objects data will be serialized to JSON and\\n   * appended to image's <code>data-canvas-serialized</code> attribute.\\n   * <br><br>\\n   *\\n   * Note that JSON could be huge on canvases with a lot of objects and\\n   * freedrawings.\\n   *\\n   *\\n   * @param {String|jQuery} options.contentConfig.imagesContainer\\n   * Specifies external data container for canvas images data.\\n   * <br><br>\\n   *\\n   * Canvas will serialize itself into base64 encoded png image and\\n   * store it as json-encoded text to that container.\\n   * <br><br>\\n   *\\n   * This could be used for storing rendered images separately from content.\\n   * <br><br>\\n   *\\n   * JSON example:\\n   * <code><pre>\\n   * {\\n   *    'canvas_id': 'base64/png .....'\\n   * }\\n   * </pre></code>\\n   *\\n   *\\n   * @param {String|jQuery} options.contentConfig.canvasDataContainer\\n   * Specifies external data container for canvas data.\\n   * <br><br>\\n   *\\n   * Canvas will serialize itself into json object containing all the vector\\n   * objects on canvas and its parameters like angle, color etc.\\n   * <br><br>\\n   *\\n   * This could be used for storing canvas vector data separately from content.\\n   * <br><br>\\n   *\\n   * JSON example:\\n   * <code><pre>\\n   * {\\n   *    'canvas_id': {\\n   *        'objects': []\\n   *    }\\n   * }\\n   * </pre></code>\\n   *\\n   * @param {Function} options.contentConfig.loadCanvasData\\n   * Specifies a function that will be called when editable canvas needs to\\n   * load its fabricjs data.\\n   * <br><br>\\n   * <code>function(canvasId)</code>\\n   *\\n   * @param {Function} options.contentConfig.saveCanvasData\\n   * Specifies a function that will be called when editable canvas needs to\\n   * store its fabricjs data.\\n   * <br><br>\\n   * <code>function(canvasId, canvasData)</code>\\n   *\\n   * @param {Function} options.contentConfig.loadImageData\\n   * Specifies a function that will be called when editable canvas needs to\\n   * load base64/png image data data.\\n   * <br><br>\\n   * <code>function(canvasId)</code>\\n   *\\n   * @param {Function} options.contentConfig.saveImageData\\n   * Specifies a function that will be called when editable canvas needs to\\n   * save base64/png image data data.\\n   * <br><br>\\n   * <code>function(canvasId, imageData)</code>\\n   *\\n   * @param {string} options.basePath\\n   * Base web url from which all needed drawer files (assets basically)\\n   * will be loaded. If null, drawer will try to determine it by itself by\\n   * parsing it's script 'src' tag.\\n   *\\n   * @param width {number}   Width in px\\n   * @param height {number}  Height in px\\n   *\\n   * @memberof Easel\\n   * @constructor\\n   */\\n  var Easel = function EaselConstructor(redactorInstance, options,\\n                                          width, height) {\\n    var _this = this;\\n    this.mode = this.MODE_INACTIVE;\\n    this.redactorInstance = redactorInstance;\\n    this.id = Math.random().toString().replace('0.', '');\\n    this.width = width || 0;\\n    this.height = height || 0;\\n\\n    /**\\n     * Use jQuery's event system to dispatch events\\n     * @type {jQuery}\\n     * @private\\n     */\\n\\n    this._eventEmitter = $({});\\n\\n    this.api = new namespace.EaselApi(this);\\n\\n    this.setOptions(options);\\n\\n\\n    /**\\n     * Image element for previewing canvas.\\n     * @type {jQuery}\\n     */\\n    this.$imageElement = null;\\n\\n    /**\\n     * Container for all editing controls.\\n     * @type {jQuery}\\n     */\\n    this.$canvasEditContainer = null;\\n\\n    /**\\n     * Aligment css riles for this canvas.\\n     * Those rules will be applied to image when edit mode is off,\\n     * and to canvas edit box when edit mode is on.\\n     * @type {{}}\\n     */\\n    this.aligmentCss = {};\\n\\n    // toolbars manager\\n    this.toolbars = new EaselToolbarManager(this);\\n    // this.loadPlugins();\\n\\n    if (_this.options.detectTouch) {\\n      if (_this.options.detectTouch.constructor.name !== 'Function') {\\n        throw new Error('detectTouch should be a function which will be ' +\\n        'called when Easel needs to determine whether it is working ' +\\n        'on touch device');\\n      }\\n\\n      _this.touchDevice = _this.options.detectTouch(_this);\\n    } else {\\n      _this.touchDevice = /(iPhone|iPod|iPad|BlackBerry|Android)/\\n        .test(navigator.userAgent);\\n\\n      $('body').on('touchstart.EaselTouchCheck', function () {\\n        _this.touchDevice = true;\\n        $('body').off('touchstart.EaselTouchCheck');\\n        _this.log('touch', 'Found touch screen');\\n      });\\n    }\\n\\n    _this.$canvasDataContainer = null;\\n    if (_this.options.contentConfig.canvasDataContainer) {\\n      _this.$canvasDataContainer =\\n        $(_this.options.contentConfig.canvasDataContainer);\\n\\n      if (_this.$canvasDataContainer.length < 1) {\\n        _this.$canvasDataContainer = null;\\n        throw new Error('contentConfig.canvasDataContainer provided but ' +\\n        'not found in DOM: ' +\\n        _this.options.contentConfig.canvasDataContainer);\\n      }\\n    }\\n\\n    _this.$imagesContainer = null;\\n    if (_this.options.contentConfig.imagesContainer) {\\n      _this.$imagesContainer =\\n        $(_this.options.contentConfig.imagesContainer);\\n\\n      if (_this.$imagesContainer.length < 1) {\\n        _this.$imagesContainer = null;\\n        throw new Error('contentConfig.imagesContainer provided but ' +\\n        'not found in DOM: ' +\\n        _this.options.contentConfig.imagesContainer);\\n      }\\n    }\\n\\n    var inlineStyles = '' \\n\\n    util.addStyle(inlineStyles);\\n\\n    return this;\\n  };\\n\\n\\n  Easel.prototype.api = {};\\n\\n  Easel.prototype.MODE_PREPARING = 'mode:preparing';\\n  Easel.prototype.MODE_ACTIVE = 'mode:active';\\n  Easel.prototype.MODE_INACTIVE = 'mode:inactive';\\n\\n\\n\\n  /**\\n   * Sets new  drawer options. Reloads plugins.\\n   * @param {Object} options\\n   */\\n  Easel.prototype.setOptions = function(options) {\\n      this.options = $.extend(true, this.defaultOptions || {}, options || {});\\n\\n      this.onOptionsUpdated(true);\\n  };\\n\\n  /**\\n   * Ensure ImageCrop plugin presence matches enableImageCrop option.\\n   * @returns {Boolean} true when plugin list was modified\\n   * @private\\n   */\\n  Easel.prototype._syncImageCropPlugin = function () {\\n    var pluginName = 'ImageCrop',\\n        shouldEnable = !!this.options.enableImageCrop,\\n        plugins = this.options.plugins,\\n        corePlugins = this.options.corePlugins,\\n        listChanged = false,\\n        pluginIndex,\\n        corePluginIndex;\\n\\n    if (!Array.isArray(plugins)) {\\n      plugins = [];\\n      this.options.plugins = plugins;\\n    }\\n    if (!Array.isArray(corePlugins)) {\\n      corePlugins = [];\\n      this.options.corePlugins = corePlugins;\\n    }\\n\\n    var pluginInPlugins = plugins.indexOf(pluginName) !== -1;\\n    var pluginInCore = corePlugins.indexOf(pluginName) !== -1;\\n    var pluginPresent = pluginInPlugins || pluginInCore;\\n\\n    if (shouldEnable && !pluginPresent) {\\n      plugins.push(pluginName);\\n      listChanged = true;\\n    } else if (!shouldEnable && pluginPresent) {\\n      if (pluginInPlugins) {\\n        pluginIndex = plugins.indexOf(pluginName);\\n        plugins.splice(pluginIndex, 1);\\n      }\\n      if (pluginInCore) {\\n        corePluginIndex = corePlugins.indexOf(pluginName);\\n        corePlugins.splice(corePluginIndex, 1);\\n      }\\n      listChanged = true;\\n    }\\n\\n    return listChanged;\\n  };\\n\\n  /**\\n   * Get config of plugin\\n   * @param {String} name - name of plugin\\n   * @returns {Object} - config of plugin\\n   */\\n  Easel.prototype.getPluginConfig = function(name) {\\n    var result = {},\\n        nameIsValid = name && typeof name === 'string' && name.length,\\n        pluginConfig = nameIsValid && this.options.pluginsConfig[name],\\n        textPluginConfig = nameIsValid && this.options.pluginsConfig.Text && this.options.pluginsConfig.Text[name];\\n\\n    if (pluginConfig) {\\n      result = $.extend(true, result, pluginConfig);\\n    }\\n    if (textPluginConfig) {\\n      result = $.extend(true, result, textPluginConfig);\\n    }\\n\\n    return result;\\n  };\\n\\n  /**\\n   * Update current options.\\n   * If optionsToUpdate has plugins key, plugins will be reloaded\\n   *\\n   * @param  {Object} optionsToUpdate options object\\n   */\\n  Easel.prototype.updateOptions = function(optionsToUpdate) {\\n      optionsToUpdate = optionsToUpdate || {};\\n      var previousEnableImageCrop = this.options.enableImageCrop;\\n      this.options = $.extend(true, this.options, optionsToUpdate);\\n\\n      var doReloadPlugins = false;\\n      if (optionsToUpdate.plugins) {\\n          // replace old plugin list with new, not extend\\n          this.options.plugins = optionsToUpdate.plugins;\\n          doReloadPlugins = true;\\n      }\\n\\n      var enableImageCropChanged = Object.prototype.hasOwnProperty.call(optionsToUpdate, 'enableImageCrop') &&\\n        optionsToUpdate.enableImageCrop !== previousEnableImageCrop;\\n      if (enableImageCropChanged) {\\n      doReloadPlugins = true;\\n      }\\n\\n      this.onOptionsUpdated(doReloadPlugins);\\n  };\\n\\n\\n\\n\\n    Easel.prototype.onOptionsUpdated = function(reloadPlugins) {\\n      var pluginListChangedByCropSync = this._syncImageCropPlugin();\\n      reloadPlugins = reloadPlugins || pluginListChangedByCropSync;\\n      if(this.options.basePath) {\\n          util.setEaselFolderUrl(this.options.basePath);\\n       }\\n\\n      // hotfix for paths containing drawer folder\\n      this.options.canvasProperties.rotationCursor = 'url(' + util.getEaselFolderUrl() + 'assets/cursor-fa-rotate-right.cur), default';\\n\\n      if (!this.activeColor) {\\n          this.activeColor = this.options.activeColor || this.defaultOptions.activeColor;\\n      }\\n    if (this.activeOpacity === undefined) {\\n      this.activeOpacity = this.options.activeOpacity || this.defaultOptions.activeOpacity;\\n    }\\n\\n      if (reloadPlugins) {\\n        this.loadPlugins();\\n        if (this.toolbars) {\\n          this.toolbars.resetAllToolbars();\\n        }\\n      }\\n  };\\n\\n  /**\\n   * Unloads all plugins,\\n   */\\n  Easel.prototype.unloadPlugins = function() {\\n      for (var key in this._pluginsInstances) {\\n        this.unloadPlugin(key);\\n      }\\n  };\\n\\n\\n  /**\\n   * Unload plugin by name.\\n   */\\n  Easel.prototype.unloadPlugin = function(pluginName) {\\n    if (Object.prototype.hasOwnProperty.call(this._pluginsInstances, pluginName)) {\\n        var tool = this._pluginsInstances[pluginName];\\n        if (tool.removeTool) {\\n            tool.removeTool(true);\\n        }\\n      delete this._pluginsInstances[pluginName];\\n    }\\n  };\\n\\n  /**\\n   * Load plugin\\n   * @param {String} pluginName - name of plugin to load\\n   */\\n  Easel.prototype.loadPlugin = function (pluginName) {\\n    if (!pluginName || !pluginsNamespace[pluginName]) {\\n      this.error('Easel: Load plugin error - ' + pluginName + '. No such plugin.');\\n      return;\\n    }\\n\\n    var alreadyInitialized = this._pluginsInstances[pluginName],\\n        isCorePlugin = this.options.corePlugins && this.options.corePlugins.indexOf(pluginName) !== -1;\\n    if (alreadyInitialized) {\\n      if (!isCorePlugin) {\\n        this.error('Easel: Load plugin error - ' + pluginName + '. Plugin should not be specified multiple times.');\\n      }\\n      return;\\n    }\\n\\n    try {\\n      var pluginConfig = {};\\n      if (this.options.pluginsConfig[pluginName]) {\\n        pluginConfig = this.options.pluginsConfig[pluginName];\\n      }\\n      var plugin = new pluginsNamespace[pluginName](this, pluginConfig);\\n      this._pluginsInstances[pluginName] = plugin;\\n    } catch (err) {\\n      this.error('Easel: Load plugin error - ' + pluginName + '.');\\n      this.error(err);\\n    }\\n  };\\n\\n\\n  /**\\n   * Create plugins instances, according to options.plugins list\\n   */\\n  Easel.prototype.loadPlugins = function() {\\n    if (!this._pluginsInstances) {\\n      this._pluginsInstances = {};\\n    } else {\\n      this.unloadPlugins();\\n    }\\n\\n    if (this.options.corePlugins) {\\n      for (var j = 0; j < this.options.corePlugins.length; j++) {\\n        this.loadPlugin(this.options.corePlugins[j]);\\n      }\\n    }\\n    if (this.options.plugins) {\\n      for (var i = 0; i < this.options.plugins.length; i++) {\\n        this.loadPlugin(this.options.plugins[i]);\\n      }\\n    }\\n  };\\n\\n\\n\\n\\n\\n  Easel.prototype.log = function (tag, msg) {\\n    if (this.options.debug && window.console && window.console.debug) {\\n      window.console.debug('[' + tag + ']', msg);\\n    }\\n  };\\n\\n  Easel.prototype.error = function (msg) {\\n    if (this.options.debug) {\\n      console.error(msg);\\n    }\\n  };\\n\\n  Easel.prototype.clickEvent = function (namespace) {\\n    return 'click.' + namespace + ' touchend.' + namespace;\\n  };\\n\\n\\n  /**\\n   * Returns html string that should be appended to DOM and will represent\\n   * editable canvas.\\n   *\\n   * @returns {String}\\n   */\\n  Easel.prototype.getHtml = function () {\\n    var img = $('<img>')\\n      .css({\\n        'display': 'inline-block',\\n        'width': this.width ||  this.options.defaultWidth,\\n        'height': this.height || this.options.defaultHeight,\\n        'background': this.options.backgroundCss\\n      })\\n      .addClass('editable-canvas-image')\\n      .addClass('editable-canvas-not-edited')\\n      .attr('id', 'canvas_image_' + this.id)\\n      .attr('data-redactor-drawer-enabled', true)\\n      .attr('src', '');\\n\\n    if (this.options.borderCss) {\\n      img.css('border', this.options.borderCss);\\n    }\\n\\n    return $(img)[0].outerHTML;\\n  };\\n\\n  /**\\n   * This method should be called every time display properties of canvas\\n   * change to properly restore them after sync/load.\\n   */\\n  Easel.prototype.updateAligmentCss = function () {\\n    this.aligmentCss = this.getAligmentCssFor(this.$imageElement);\\n  };\\n\\n  Easel.prototype.getAligmentCssFor = function (element) {\\n    var styles = window.getComputedStyle(element[0]),\\n        aligmentCss = {\\n      'display': styles.display,\\n      'float': styles.float,\\n      'margin-left': styles.marginLeft,\\n      'margin-right': styles.marginRight,\\n      'position': styles.position,\\n      'left': styles.left,\\n      'top': styles.top\\n    };\\n\\n    if (element.attr('data-margin-left')) {\\n      aligmentCss['margin-left'] = element.attr('data-margin-left');\\n    }\\n\\n    if (element.attr('data-margin-right')) {\\n      aligmentCss['margin-right'] = element.attr('data-margin-right');\\n    }\\n\\n    return aligmentCss;\\n  };\\n\\n  Easel.prototype.setAligmentCssFor = function (element, css) {\\n    if (element.css('display') == 'none') {\\n      delete css.display;\\n    }\\n\\n    element.css(css);\\n\\n    if (css['margin-left'] && css['margin-left'] == 'auto') {\\n      element.css('margin-left', 'auto');\\n      element.attr('data-margin-left', 'auto');\\n    }\\n\\n    if (css['margin-right'] && css['margin-right'] == 'auto') {\\n      element.css('margin-right', 'auto');\\n      element.attr('data-margin-right', 'auto');\\n    }\\n  };\\n\\n  /**\\n   * Should be called after inserting this element to DOM\\n   * to setup necessary event handlers etc.\\n   */\\n  Easel.prototype.onInsert = function () {\\n    var _this = this;\\n\\n    $(document).off(this.clickEvent('EaselStop' + this.id));\\n\\n    // If we have no image element here - this is the first run\\n    var firstRun = !this.$imageElement;\\n\\n    this.$imageElement = $(document.getElementById('canvas_image_' + this.id));\\n    this.$imageElement.parent().css({\\n        'position': 'relative'\\n    });\\n    \\n    if (firstRun) {\\n      if (this.options.align) {\\n         this.aligmentCss = this._generateAlignCss(this.options.align);\\n      } else {\\n        this.aligmentCss = this.getAligmentCssFor(this.$imageElement);\\n      }\\n\\n      this.width = this.$imageElement.outerWidth();\\n      this.height = this.$imageElement.outerHeight();\\n      this.$imageElement.removeClass('edit-mode');\\n    }\\n\\n    if (this.$imageElement.attr('src').length < 1 &&\\n      !this.$imageElement.hasClass('editable-canvas-not-edited')) {\\n      this.$imageElement.attr('src', this.getImageData());\\n      this.$imageElement.removeClass('editable-canvas-not-edited');\\n    }\\n\\n    //this.setSize(this.width, this.height);\\n    this.setAligmentCssFor(this.$imageElement, this.aligmentCss);\\n\\n    // since this function can be called multiple times in a row\\n    // (it's called every time something in redactor changes)\\n    // we should clear previously set handlers.\\n    if (this.options.editOnClick) {\\n      this.$imageElement.off();\\n      util.bindClick(this.$imageElement, 'Easel', function (event) {\\n        _this._startEditing();\\n      });\\n    } else {\\n      this.$imageElement.off(_this.clickEvent('Easel'));\\n      this.$imageElement.on(_this.clickEvent('Easel'), function () {\\n        _this.drawCanvasControls();\\n      });\\n    }\\n\\n    // set global click handler\\n    util.bindClick($(document), 'Easel', this._globalClickHandler.bind(this));\\n\\n    // call onOptionsChange on EVENT_OPTIONS_CHANGED\\n    this.on(this.EVENT_OPTIONS_CHANGED, this.onOptionsChange.bind(this));\\n    // call onOptionsChange on EVENT_CANVAS_READY, for initial setup\\n    this.on(this.EVENT_CANVAS_READY, this.onOptionsChange.bind(this));\\n  };\\n\\n\\n  /**\\n   * Intercept all click events and check their targets.\\n   * if target is inside canvas edit box - do nothing.\\n   * otherwise - trigger 'stopEditing' method.\\n   *\\n   * @param  {Event} event click\\n   */\\n  Easel.prototype._globalClickHandler = function(event) {\\n      var parentEaselBox = $(event.target).parents('#easel-canvas-box');\\n\\n      if (parentEaselBox.length > 0) {\\n        if (parentEaselBox.attr('data-canvas-id') != this.id) {\\n          return false;\\n        }\\n        return true;\\n      }\\n\\n      if (event.target.id == 'canvas_image_' + this.id) {\\n        return false;\\n      }\\n\\n      if (event.target.id == 'redactor-image-editter' &&\\n        $(event.target).attr('data-canvas-id') == this.id) {\\n        return false;\\n      }\\n\\n      if ($(event.target).parents('#redactor-modal').length > 0) {\\n        return false;\\n      }\\n\\n      if (this.$canvasEditContainer) {\\n        // ignore outside mouse-up while resizing\\n        var needToStop = this.options.exitOnOutsideClick &&\\n            !this.resizingNow &&\\n            !this.croppingNow &&\\n            !this.movingNow &&\\n            !this.fullscreenMode &&\\n            !this.drawingInProgress &&\\n            !this.isBrushDrawing;\\n        if (needToStop) {\\n          this._stopEditing();\\n        }\\n      }\\n  };\\n\\n  /**\\n   * Activates on the 'onclick' handler\\n   * to draw controls ('Edit in drawer button') over image.\\n   *\\n   * Redactor automatically places 'onclick' handler on image when it is appended,\\n   * so it will fire first and it will place image edit html\\n   * over image ('Edit' at the center).\\n   * That handler is Redactor.image.loadEditableControls(imageElement);\\n   *\\n   * Our handler will file later with that edit html appended, so all we need is\\n   * to correct button's title and to change 'onclick' handler of edit-box\\n   * to ours.\\n   */\\n  Easel.prototype.drawCanvasControls = function () {\\n    var _this = this;\\n    // use default image module to generate markup\\n    //this.redactorInstance.image.loadEditableControls(this.imageElement);\\n\\n    // enable click handlers\\n    var $editter = $('#redactor-image-editter');\\n    $editter.attr('data-canvas-id', this.id);\\n    $editter.text('Edit in Easel');\\n    // position correction\\n    $editter.css('margin-left', '-' + $editter.innerWidth() / 2 + 'px');\\n    $editter.off('click');\\n\\n    $editter.on('click', function () {\\n      _this._startEditing();\\n    });\\n  };\\n\\n  /**\\n   * Turns on edit mode.\\n   *\\n   * Hides image element, appends fabricjs canvas element after image,\\n   * adds toolbars for drawing etc.\\n   *\\n   * @private\\n   */\\n  Easel.prototype._startEditing = function () {\\n    this.log('canvasEditMode', 'startEditing()');\\n    var _this = this;\\n    if (this.mode != this.MODE_INACTIVE) {\\n      this.log('Easel.startEditing(): already in active mode');\\n      return;\\n    }\\n    this.mode = this.MODE_PREPARING;\\n\\n    // since we are working inside redactor's editing area which has\\n    // contenteditable=true, every our click to canvas/image/canvas edit\\n    // controls etc will be propagated to redactor's editbox and keyboard\\n    // will be shown on touch devices.\\n    // To prevent that we need to set contenteditable=false every time canvas\\n    // goes into editing mode.\\n    if (_this.redactorInstance) {\\n      _this.redactorInstance.$editor.attr('contenteditable', 'false');\\n    }\\n\\n    _this._previousFocusedElement = document.activeElement;\\n    $(document.activeElement).blur();\\n\\n    // user can resize image so we need to update our w/h.\\n    this.width = this.$imageElement.outerWidth();\\n    this.height = this.$imageElement.outerHeight();\\n\\n    this.$imageElement.addClass('edit-mode');\\n    this.$imageElement.removeClass('editable-canvas-not-edited');\\n\\n    var $canvas = $('<canvas width=\\\"' + this.width + '\\\"' +\\n    ' height=\\\"' + this.height + '\\\" />');\\n\\n    this.$canvasEditContainer = $('<span></span>');\\n    this.$canvasEditContainer.attr({\\n      'id':'easel-canvas-box',\\n      'class': 'easel-instance-container',\\n      'data-canvas-id': this.id,\\n      'tabindex': '0'\\n    });\\n\\n    if (this.options.borderCss) {\\n      this.$canvasEditContainer.css('border', this.options.borderCssEditMode);\\n    }\\n\\n    if (this.touchDevice) {\\n      this.$canvasEditContainer.addClass('touch');\\n    }\\n    this.$canvasEditContainer.css({\\n      'position': 'absolute'\\n    });\\n\\n    this.aligmentCss = this.getAligmentCssFor(this.$imageElement);\\n\\n    this.$canvasEditContainer.append($canvas);\\n    \\n    this.$imageElement.parent().append(this.$canvasEditContainer);\\n    this.adjustEditContainer();\\n    $(window).on('resize.drawer' + this.id, function () {\\n      _this.adjustEditContainer(false, true);\\n    });\\n\\n    if (this.redactorInstance) {\\n      this.redactorInstance.image.hideResize();\\n    }\\n\\n    // get serialized canvas\\n    var serializedCanvas = this.getCanvasData();\\n\\n    // create fabricJs canvas\\n    this.fCanvas = new namespace.Canvas($canvas.get(0));\\n    this.fCanvas.selection = false; // [DRW-74] Prevent selecting multiple objects\\n\\n    if (this.options && this.options.canvasProperties) {\\n      $.each(this.options.canvasProperties, function (k, v) {\\n        _this.fCanvas[k] = v;\\n      });\\n    }\\n\\n    this.$canvasEditContainer\\n      .css('background', this.$imageElement.css('background'));\\n\\n    this.loadCanvas(serializedCanvas);\\n  };\\n\\n\\n  /**\\n   * Turns off edit mode.\\n   *\\n   * Serializes all objects painted on canvas to base64 and sets it as\\n   * this.imageElement 'src' attribute.\\n   *\\n   * Serializes all objects painted on canvas to json and sets it as\\n   * this.imageElement 'data-canvas-serialized' attribute, so all canvas objects\\n   * could be restored for editing later.\\n   *\\n   * @private\\n   */\\n  Easel.prototype._stopEditing = function () {\\n    this.log('canvasEditMode', '_stopEditing()');\\n    if (this.mode == this.MODE_INACTIVE) {\\n      this.log('canvasEditMode', '_stopEditing(): already stopped, mode is INACTIVE');\\n      return;\\n    }\\n\\n    // see startEditingMethod for the reason of making redactor uneditable\\n    if (this.redactorInstance) {\\n      this.redactorInstance.$editor.attr('contenteditable', 'true');\\n    }\\n\\n    // deactivate all tools\\n    this.trigger(this.EVENT_DO_DEACTIVATE_ALL_TOOLS);\\n\\n    // torn off any selection on objects\\n    if (this.fCanvas) {\\n      this.fCanvas.deactivateAll();\\n    }\\n\\n    // image should show what has been painted on canvas\\n    this.$imageElement.attr('src', this.getImageData());\\n    this.$imageElement.removeClass('edit-mode');\\n    this.$imageElement.removeClass('editable-canvas-not-edited');\\n\\n    this.syncCanvasData();\\n\\n    this.$imageElement.show();\\n\\n    if (this.$canvasEditContainer) {\\n      this.$canvasEditContainer.remove();\\n      this.$canvasEditContainer = null;\\n    }\\n\\n    $(window).off('resize.drawer' + this.id);\\n\\n    this.trigger(this.EVENT_EDIT_STOP);\\n    this.mode = this.MODE_INACTIVE;\\n  };\\n\\n  /**\\n   *\\n   * @param {String} newColor\\n   */\\n  Easel.prototype.setActiveColor = function (newColor) {\\n    var currActiveObject = this.fCanvas.getActiveObject(),\\n        currActiveTool = this.activeDrawingTool,\\n        colorPluginInstance = this._pluginsInstances.Color,\\n        colorPickerControl = colorPluginInstance && colorPluginInstance.colorControl;\\n\\n\\n    this.activeColor = newColor;\\n    this.options.activeColor = newColor;\\n    if (!currActiveObject && colorPickerControl) {\\n      colorPickerControl.setColor(newColor);\\n    }\\n    if (currActiveTool) {\\n      currActiveTool.brush = null;\\n      currActiveTool._activateTool();\\n    }\\n    this.trigger(this.EVENT_CANVAS_MODIFIED);\\n  };\\n\\n\\n  /**\\n   * Changes active editor color.\\n   * When called without attributes re-sets previously saved color to canvas.\\n   *\\n   * @param {String|null} [newColor]\\n   * @param {Number|null} [newOpacity] - New opacity value\\n   */\\n  Easel.prototype.setColor = function (newColor, newOpacity) {\\n    if (newColor) {\\n      this.activeColor = newColor;\\n    }\\n    if (newOpacity !== undefined) {\\n      this.activeOpacity = newOpacity;\\n    }\\n\\n    if (!this.fCanvas) {\\n      return;\\n    }\\n\\n    var activeObject = this.fCanvas.getActiveObject();\\n    this.setOpacity(this.activeOpacity, true);\\n    if (activeObject) {\\n      var isLineType =  activeObject.type === 'line' || activeObject.type === 'arrow',\\n          havePath = activeObject.path;\\n      if (isLineType) {\\n        activeObject.set('stroke', this.activeColor);\\n      } else {\\n        if (havePath) {\\n          activeObject.set('stroke', this.activeColor);\\n        } else {\\n          activeObject.set('fill', this.activeColor);\\n        }\\n      }\\n      this.fCanvas.renderAll();\\n    }\\n    this.fCanvas.freeDrawingBrush.color = this.activeColor;\\n    this.fCanvas.freeDrawingBrush.fill = this.activeColor;\\n    this.trigger(this.EVENT_CANVAS_MODIFIED);\\n  };\\n\\n  /**\\n   *\\n   * @param value\\n   * @param withoutProcessing\\n   */\\n  Easel.prototype.setOpacity = function (value, withoutProcessing) {\\n    value = value!== undefined ? value : this.activeOpacity;\\n    this.activeOpacity = value;\\n    var activeObject = this.fCanvas.getActiveObject();\\n    if (activeObject) {\\n      activeObject.set('opacity', value);\\n    }\\n    this.fCanvas.freeDrawingBrush.opacity = value;\\n    if (!withoutProcessing) {\\n      this.fCanvas.renderAll();\\n      this.trigger(this.EVENT_CANVAS_MODIFIED);\\n    }\\n  };\\n\\n  /**\\n   * Changes brush size in free drawing mode.\\n   *\\n   * @param {int|null} [newBrushSize]\\n   */\\n  Easel.prototype.setBrushSize = function (newBrushSize) {\\n    if (this.fCanvas) {\\n      this.fCanvas.freeDrawingBrush.width = newBrushSize;\\n    }\\n\\n    this.trigger(this.EVENT_BRUSH_SIZE_CHANGED);\\n  };\\n\\n  /**\\n   * Returns size of currently selected tool brush.\\n   *\\n   * @returns {number}\\n   */\\n  Easel.prototype.getBrushSize = function () {\\n    var size = 0;\\n\\n    if (this.fCanvas) {\\n      size = this.fCanvas.freeDrawingBrush.width;\\n    }\\n\\n    return size;\\n  };\\n\\n  Easel.prototype.setBrush = function (newBrush) {\\n    this.fCanvas.freeDrawingBrush = newBrush;\\n    this.trigger(this.EVENT_BRUSH_CHANGED);\\n  };\\n\\n  Easel.prototype.getBrush = function () {\\n    return this.fCanvas ? this.fCanvas.freeDrawingBrush : null;\\n  };\\n\\n  /**\\n   * Get current sizes of Easel\\n   * @returns {Easel.EaselApi.sizesOfEasel}\\n   */\\n  Easel.prototype.getSize = function () {\\n    var result = {},\\n        $container = this.$canvasEditContainer,\\n        containerSizes = $container && $container.get(0).getBoundingClientRect(),\\n        scrollSizes = $container && util.getScrollOffset($container);\\n\\n    result.top = containerSizes ? containerSizes.top : null;\\n    result.left = containerSizes ? containerSizes.left : null;\\n\\n    result.scrollTop = scrollSizes ? scrollSizes.top : null;\\n    result.scrollLeft = scrollSizes ? scrollSizes.left : null;\\n\\n    result.width = this.width;\\n    result.height = this.height;\\n    return result;\\n  };\\n\\n  /**\\n   * Changes canvas size.\\n   *\\n   * @param {number} width\\n   * @param {number} height\\n   */\\n  Easel.prototype.setSize = function (width, height) {\\n    this.width = width;\\n    this.height = height;\\n\\n    if (this.fCanvas) {\\n      this.fCanvas.setWidth(this.width);\\n      this.fCanvas.setHeight(this.height);\\n    }\\n\\n    this.$imageElement.css('width', this.width);\\n    this.$imageElement.css('height', this.height);\\n\\n    if (this.$canvasEditContainer) {\\n      this.$canvasEditContainer.css('width', this.width);\\n      this.$canvasEditContainer.css('height', this.height);\\n    }\\n\\n    this.adjustEditContainer(false, true);\\n  };\\n\\n\\n  /**\\n   * Generates css for given align.\\n   * @param  {String} alignMode left|right|center|inline|floating\\n   * @return {Object} object with css properties\\n   */\\n  Easel.prototype._generateAlignCss = function (alignMode) {\\n    var aligmentCss = {};\\n\\n    switch (alignMode) {\\n     case 'floating' :\\n      aligmentCss['position'] = 'absolute';\\n      aligmentCss['display'] = 'block';\\n      aligmentCss['float'] = 'none';\\n      aligmentCss['left'] = '0px';\\n      aligmentCss['top'] = '0px';\\n     break;\\n\\n     case 'center' :\\n      aligmentCss['float'] = 'none';\\n      aligmentCss['margin-left'] = 'auto';\\n      aligmentCss['margin-right'] = 'auto';\\n      aligmentCss['display'] = 'block';\\n      aligmentCss['position'] = 'static';\\n     break;\\n\\n     case 'left' :\\n     case 'right' :\\n      aligmentCss['display'] = 'block';\\n      aligmentCss['float'] = alignMode;\\n      aligmentCss['position'] = 'static';\\n     break;\\n\\n     case 'inline' :\\n      aligmentCss['float'] = 'none';\\n      aligmentCss['display'] = 'inline-block';\\n      aligmentCss['position'] = 'static';\\n     break;\\n\\n     default:\\n      aligmentCss['float'] = 'none';\\n      aligmentCss['display'] = 'inline-block';\\n      aligmentCss['position'] = 'static';\\n    }\\n\\n    return aligmentCss;\\n  };\\n\\n  /**\\n   * Changes canvas aligment.\\n   *\\n   * @param {String} align left|right|center|inline|floating\\n   */\\n  Easel.prototype.setAlign = function (align) {\\n    var newAligmentCss = this._generateAlignCss(align);\\n\\n    this.setAligmentCssFor(this.$imageElement, newAligmentCss);\\n    this.aligmentCss = this.getAligmentCssFor(this.$imageElement);\\n\\n    this.adjustEditContainer();\\n\\n    this.trigger(this.EVENT_CANVAS_MODIFIED);\\n  };\\n\\n  /**\\n   * Returns current aligment setting for canvas.\\n   *\\n   * @returns {string} align left|right|center|inline|floating\\n   */\\n  Easel.prototype.getAlign = function () {\\n    var currentAlign = 'inline';\\n\\n    if (this.aligmentCss['position'] == 'absolute') {\\n      currentAlign = 'floating';\\n    }\\n    else if (this.aligmentCss['float'] == 'left') {\\n      currentAlign = 'left';\\n    } else if (this.aligmentCss['float'] == 'right') {\\n      currentAlign = 'right';\\n    } else if (this.aligmentCss['display'] == 'block' &&\\n      this.aligmentCss['margin-left'] == 'auto') {\\n      currentAlign = 'center';\\n    }\\n\\n    return currentAlign;\\n  };\\n\\n  /**\\n   *\\n   * @param {Boolean} [withAnimation]\\n   * @param {Boolean} [doNotUseDelay] - in some conditions need to use delay to prevent animation\\n   * @returns {boolean}\\n   */\\n  Easel.prototype.adjustEditContainer = function (withAnimation, doNotUseDelay) {\\n    var self = this,\\n        drawerHaveAnimatedClass = this.$canvasEditContainer.hasClass('animated');\\n    if (!this.$canvasEditContainer) {\\n      return false;\\n    }\\n\\n    var imageOffset = this.$imageElement.offset();\\n    if (!withAnimation) {\\n      this.$canvasEditContainer.removeClass('animated');\\n    }\\n    this.$canvasEditContainer.css({\\n      top: 0,\\n      left: 0\\n    });\\n    if (!withAnimation) {\\n      if (doNotUseDelay) {\\n        self.$canvasEditContainer.toggleClass('animated', !!drawerHaveAnimatedClass);\\n      } else {\\n        util.setTimeout(function(){\\n          if (self.$canvasEditContainer && self.$canvasEditContainer.length) {\\n            self.$canvasEditContainer.toggleClass('animated', !!drawerHaveAnimatedClass);\\n          }\\n        },0);\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Removes itself from redactor entirely.\\n   */\\n  Easel.prototype.destroy = function () {\\n    this.trigger(this.EVENT_DESTROY);\\n    this._stopEditing();\\n    this.$imageElement.remove();\\n    this.syncCanvasData(true);\\n    this.syncImageData(true);\\n  };\\n\\n\\n /**\\n  * Activates default tool, if options.defaultActivePlugin is set;\\n  * Name of plugin is taken from options.defaultActivePlugin.name;\\n  * Depending on options.defaultActivePlugin.mode :\\n  * 'always'   - same plugin will be always activated\\n  * 'onNew'    - default plugin is activated, only if canvas is empty\\n  * 'lastUsed' - on first drawer run plugin options.defaultActivePlugin.name, on consecutive - last used tool\\n  */\\n Easel.prototype.activateDefaultPlugin = function () {\\n  // see, if we need to activate default tool\\n  if (!this.options.defaultActivePlugin) {\\n    return;\\n  }\\n\\n  var pluginName = this.options.defaultActivePlugin.name;\\n  var pluginMode = this.options.defaultActivePlugin.mode;\\n\\n  // mode 'always' and 'lastUsed' go always; onNew - only if canvas is empty\\n  if ((pluginMode == 'always') || (pluginMode  == 'lastUsed') ||\\n      (pluginMode == 'onNew' && (this.fCanvas.getObjects().length === 0))) {\\n\\n      this.log('defaultActivePlugin', pluginMode+'/'+pluginName);\\n\\n    // if pluginMode is 'lastUsed' and we have already used tool - use it again\\n    if (this.lastUsedPluginName && pluginMode  == 'lastUsed'){\\n      pluginName = this.lastUsedPluginName;\\n    }\\n\\n    // if plugin 'pluginName' exists, activate it\\n    var defaultTool = this._pluginsInstances[pluginName];\\n    if (defaultTool) {\\n      this.trigger(this.EVENT_DO_ACTIVATE_TOOL, [defaultTool]);\\n    } else {\\n      this.log('WARNING', \\\"options['defaultActivePlugin']['name'] is '\\\" + pluginName + \\\"', but no such plugin found.\\\");\\n    }\\n  }\\n\\n };\\n\\n  /**\\n   * This method will be triggered every time something on canvas change\\n   * to perform synchronization work, trigger events etc.\\n   *\\n   * @param {Boolean} ignoreOptions Some options like saveAfterInactiveSec\\n   * could modify this method behavior to postpone modify event for later\\n   * for better performance. This param allows to ignore any options when\\n   * {true} is passed.\\n   */\\n  Easel.prototype.onCanvasModified = function (ignoreOptions) {\\n    var _this = this;\\n\\n    if (ignoreOptions === undefined &&\\n      this.options.contentConfig.saveAfterInactiveSec) {\\n\\n      if (this.__activityTimer !== undefined) {\\n        _this.log('saveAfterInactiveSec', 'Cleaning previous timeout');\\n        clearTimeout(this.__activityTimer);\\n      }\\n\\n      _this.log('saveAfterInactiveSec', 'Setting up a timeout');\\n      this.__activityTimer = util.setTimeout(function () {\\n        _this.log('saveAfterInactiveSec',\\n          'Timeout happened, triggering onCanvasModified');\\n        _this.onCanvasModified(true);\\n      }, this.options.contentConfig.saveAfterInactiveSec * 1000);\\n\\n      return false;\\n    }\\n\\n    if (!this.redactorInstance) {\\n      // when working inside redactor, RedactorPlugin.js will do this for us\\n      // because one redactor instance could contain multiple Easels and\\n      // it's RedactorPlugin's responsibility to synchronize all canvases\\n      // at same time\\n      this.beforeSync();\\n    }\\n\\n    this.syncCanvasData();\\n    this.syncImageData();\\n\\n    this.trigger(this.EVENT_CANVAS_MODIFIED);\\n\\n    if (!this.redactorInstance) {\\n      this.afterSync();\\n    }\\n  };\\n\\n  /**\\n   * Fabric.js allows objects controls configuration to be applied only\\n   * on instances of objects, but drawer provides global configuration\\n   * in 'objectControls' section.\\n   *\\n   * This method applies that config to specified object with respect to\\n   * touch/desktop config sections.\\n   *\\n   * @private\\n   */\\n  Easel.prototype._updateObjectsControls = function (fObject) {\\n    var objProps = this.options.objectControls;\\n\\n    if (this.touchDevice && this.options.objectControlsTouch) {\\n      objProps = this.options.objectControlsTouch;\\n    }\\n\\n    if (objProps) {\\n      for (var propertyName in objProps) {\\n        if (Object.prototype.hasOwnProperty.call(objProps, propertyName)) {\\n          fObject.set(propertyName, objProps[propertyName]);\\n        }\\n      }\\n    }\\n  };\\n\\n  Easel.prototype.getPluginInstance = function (pluginName) {\\n    if (!this._pluginsInstances[pluginName]) {\\n      throw new Error('Plugin not exists: ' + pluginName);\\n    } else {\\n      return this._pluginsInstances[pluginName];\\n    }\\n  };\\n\\n\\n  /**\\n   * Is called on EVENT_OPTIONS_CHANGED.\\n   * - changes background transparency\\n   */\\n  Easel.prototype.onOptionsChange = function () {\\n    if (this.options.transparentBackground) {\\n      this.$imageElement.css('background', 'transparent');\\n      this.$canvasEditContainer.css('background', 'transparent');\\n    } else {\\n      this.$imageElement.css('background', 'white');\\n      this.$canvasEditContainer.css('background', 'white');\\n    }\\n  };\\n\\n\\n  /**\\n   * Returns translated text string from default vocabulary of from\\n   * specified 'texts' config.\\n   *\\n   * If string not found console.warn will be used and provided textString\\n   * will be returned.\\n   *\\n   * @param textString\\n   */\\n  Easel.prototype.t = function (textString) {\\n    if (this.options.texts[textString]) {\\n      return this.options.texts[textString];\\n    } else {\\n      // console.warn('String not found in texts:' + textString);\\n      return textString;\\n    }\\n  };\\n\\n\\n  /**\\n   * Shows error message to user.\\n   *\\n   * @param {String} err\\n   */\\n  Easel.prototype.showError = function(err) {\\n    // @todo: replace alert!\\n    alert(err);\\n  };\\n\\n  /**\\n   * Returns x coord of drawer left-top\\n   *\\n   * @return {Number} left\\n   */\\n  Easel.prototype.left = function() {\\n    return this.$canvasEditContainer.css('left').replace('px', '') | 0;\\n  };\\n\\n  /**\\n   * Returns y coord of drawer left-top\\n   *\\n   * @return {Number} left\\n   */\\n  Easel.prototype.top = function() {\\n    return this.$canvasEditContainer.css('top').replace('px', '') | 0;\\n  };\\n\\n  Easel.prototype.setTemporaryStyles = function(styles) {\\n      styles = styles || false;\\n      var stylesAreValid = !!styles,\\n          temporaryStyles = stylesAreValid ? $.extend(true, {}, this.fCanvas._temporaryStyles || {}, styles || {}) : false;\\n      for (var styleName in styles) {\\n        if (styles[styleName] === undefined) {\\n          delete temporaryStyles[styleName];\\n        }\\n      }\\n      if (temporaryStyles) {\\n        this.fCanvas._temporaryStyles = temporaryStyles;\\n        this.fCanvas.copiedTextStyle = {\\n          0: temporaryStyles\\n        };\\n        fabric.copiedTextStyle = {\\n          0: temporaryStyles\\n        };\\n      } else {\\n        this.fCanvas._temporaryStyles = temporaryStyles;\\n        this.fCanvas.copiedTextStyle = temporaryStyles;\\n        fabric.copiedTextStyle = temporaryStyles;\\n      }\\n  };\\n\\n  /**\\n   * Get position relative to canvas from event\\n   * @param {Event} event\\n   * @param {Boolean} [considerZoom] @todo\\n   * @returns {Object}\\n   */\\n  Easel.prototype.getRelativeEventPosition = function(event, considerZoom) {\\n    var result = {},\\n        absolutePosition = util.getEventPosition(event),\\n        scrollOffset = util.getScrollOffset(this.$canvasEditContainer),\\n        canvasContainer = this.$canvasEditContainer.get(0),\\n        canvasContainerSizes = canvasContainer.getBoundingClientRect();\\n\\n    result.top = absolutePosition.top - canvasContainerSizes.top - scrollOffset.top;\\n    result.left = absolutePosition.left - canvasContainerSizes.left - scrollOffset.left;\\n    result.scaledTop = result.top;\\n    result.scaledLeft = result.left;\\n\\n\\n    // console.info('pos', result.left, result.scaledLeft, result.top, result.scaledTop);\\n    return result;\\n  };\\n\\n  namespace.Easel = Easel;\\n}(jQuery, Easel, Easel.plugins, Easel.util, Easel.texts));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasableLine.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/PDiamond.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Easel.ObjectApi.js\"))","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n    extend = fabric.util.object.extend,\\n    min = fabric.util.array.min,\\n    max = fabric.util.array.max,\\n    toFixed = fabric.util.toFixed;\\n\\n  fabric.SegmentablePolygon = fabric.util.createClass(fabric.ErasableObject, {\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'segmentablePolygon',\\n\\n    /**\\n     * Points array\\n     * @type Array[]\\n     * @default\\n     */\\n    points: null,\\n\\n    /**\\n     * Minimum X from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minX: 0,\\n\\n    /**\\n     * Minimum Y from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minY: 0,\\n\\n    /**\\n     * List of options to show when object is selected\\n     * @type {String[]}\\n     */\\n    objectOptionsList : ['shapeFill', 'border', 'opacity'],\\n\\n    /**\\n     * Constructor\\n     * @param {Array} points Array of points\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Polygon} thisArg\\n     */\\n    initialize: function (points, options) {\\n      var _this = this;\\n\\n      this.points = points;\\n      if (points === undefined) {\\n        console.error('Points should be array.');\\n      }\\n      options = options || {};\\n\\n      // call super[ErasableObject].initialize()\\n      this.callSuper('initialize', options);\\n\\n      this._calcDimensions();\\n      if (!('top' in options)) {\\n        this.top = this.minY;\\n      }\\n      if (!('left' in options)) {\\n        this.left = this.minX;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _calcDimensions: function () {\\n      var minX = null;\\n      var minY = null;\\n      var maxX = null;\\n      var maxY = null;\\n\\n      for (var i = 0; i < this.points.length; i++) {\\n        var _minX = min(this.points[i], 'x');\\n        if (minX === null || _minX < minX) {\\n          minX = _minX;\\n        }\\n\\n        var _minY = min(this.points[i], 'y');\\n        if (minY === null || _minY < minY) {\\n          minY = _minY;\\n        }\\n\\n        var _maxX = max(this.points[i], 'x');\\n        if (maxX === null || _maxX > maxX) {\\n          maxX = _maxX;\\n        }\\n\\n        var _maxY = max(this.points[i], 'y');\\n        if (maxY === null || _maxY > maxY) {\\n          maxY = _maxY;\\n        }\\n      }\\n\\n      this.width = (maxX - minX) || 1;\\n      this.height = (maxY - minY) || 1;\\n\\n      this.minX = minX;\\n      this.minY = minY;\\n    },\\n\\n    _fixPoints: function () {\\n      this._calcDimensions();\\n\\n      if (this.minX != (this.width / 2) * -1 || this.minY != (this.height / 2) * -1) {\\n        this.points.forEach(function (pointSegment) {\\n          pointSegment.forEach(function (p) {\\n            p.x -= (this.minX + this.width / 2);\\n            p.y -= (this.minY + this.height / 2);\\n          }, this);\\n        }, this);\\n      }\\n    },\\n\\n\\n    /**\\n     * @private\\n     */\\n    _applyPointOffset: function () {\\n      // change points to offset polygon into a bounding box\\n      // executed one time\\n      this.points.forEach(function (pointSegment) {\\n        pointSegment.forEach(function (p) {\\n          p.x -= (this.minX + this.width / 2);\\n          p.y -= (this.minY + this.height / 2);\\n        }, this);\\n      }, this);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function (propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        points: this.points.concat(),\\n        type: this.type\\n      });\\n    },\\n\\n    toSVG: function (reviver) {\\n      var markup = this._createBaseSVGMarkup(),\\n          segments = this.points || [],\\n          pathSegments = [],\\n          segment, i, j;\\n\\n      for (i = 0; i < segments.length; i++) {\\n        segment = segments[i];\\n        if (!segment || !segment.length) {\\n          continue;\\n        }\\n\\n        pathSegments.push('M ', toFixed(segment[0].x, 2), ' ', toFixed(segment[0].y, 2), ' ');\\n        for (j = 1; j < segment.length; j++) {\\n          pathSegments.push('L ', toFixed(segment[j].x, 2), ' ', toFixed(segment[j].y, 2), ' ');\\n        }\\n        pathSegments.push('z ');\\n      }\\n\\n      if (!pathSegments.length) {\\n        return reviver ? reviver('') : '';\\n      }\\n\\n      markup.push(\\n        '<path ', this.getSvgId(),\\n        'd=\\\"', pathSegments.join(''),\\n        '\\\" style=\\\"', this.getSvgStyles(),\\n        '\\\" transform=\\\"', this.getSvgTransform(), ' ', this.getSvgTransformMatrix(),\\n        '\\\" />\\\\n'\\n      );\\n\\n      var svgMarkup = markup.join('');\\n      return reviver ? reviver(svgMarkup) : svgMarkup;\\n    },\\n\\n    render: function (ctx, noTransform) {\\n      // fix some stroke issue, save old stroke\\n      if (this.points[0].length == 2) {\\n        this.oldStroke = this.stroke;\\n        this.oldStrokeDashArray = this.strokeDashArray;\\n        this.oldStrokeWidth = this.strokeWidth;\\n\\n        this.stroke = this.fill;\\n        this.strokeWidth = 3;\\n        this.strokeDashArray = [];\\n      }\\n\\n      // call super[ErasableObject].render\\n      this.callSuper('render', ctx, noTransform);\\n\\n      // fix some stroke issue again, restore old stroke\\n      if (this.points[0].length == 2) {\\n        this.stroke = this.oldStroke;\\n        this.strokeDashArray = this.oldStrokeDashArray;\\n        this.strokeWidth = this.oldStrokeWidth;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _render: function (ctx) {\\n      this.commonRender(ctx);\\n      this._renderFill(ctx);\\n      if (this.stroke || this.strokeDashArray) {\\n        ctx.closePath();\\n        this._renderStroke(ctx);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    commonRender: function (ctx) {\\n      var point;\\n      ctx.beginPath();\\n\\n      if (this._applyPointOffset) {\\n        if (!(this.group && this.group.type === 'path-group')) {\\n          this._applyPointOffset();\\n        }\\n        this._applyPointOffset = null;\\n      }\\n\\n      var firstSegment = this.points[0];\\n\\n      // when we have only one point we should draw a small cirlce\\n      // so user could see it\\n      if(firstSegment.length == 1){\\n        var radius = 2;\\n        ctx.arc(firstSegment[0].x, firstSegment[0].y,\\n          radius, 0, 2 * Math.PI, false\\n        );\\n      }\\n\\n      ctx.moveTo(firstSegment[0].x, firstSegment[0].y);\\n      for (var i = 0, len = firstSegment.length; i < len; i++) {\\n        point = firstSegment[i];\\n        ctx.lineTo(point.x, point.y);\\n      }\\n\\n      ctx.closePath();\\n\\n      if (this.points.length > 1) {\\n        for (var s = 1; s < this.points.length; s++) {\\n          var segmentPoints = this.points[s];\\n          ctx.moveTo(segmentPoints[0].x, segmentPoints[0].y);\\n\\n          for (var sp = 0; sp < segmentPoints.length; sp++) {\\n            ctx.lineTo(segmentPoints[sp].x, segmentPoints[sp].y);\\n          }\\n\\n        }\\n      }\\n    },\\n\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function () {\\n      var sum = 0;\\n      for (var i = 0; i < this.points.length; i++) {\\n        sum += this.points[i].length;\\n      }\\n      return sum;\\n    }\\n\\n  });\\n\\n  /**\\n   * Returns fabric.Polygon instance from an object representation\\n   * @static\\n   * @memberOf fabric.Polygon\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Polygon} Instance of fabric.Polygon\\n   */\\n  fabric.SegmentablePolygon.fromObject = function (object) {\\n    return new fabric.SegmentablePolygon(object.points, object, true);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","module.exports = \"(function(EaselApi) {\\n    /**\\n     * Checks if obj is set and is fabric.Object\\n     *\\n     * @param  {} obj [description]\\n     * @throw {Error}  if obj is falsie or object is not fabric.Object\\n     */\\n    EaselApi.prototype._checkObject = function(obj) {\\n        if (!obj) {\\n            throw new Error('[Easel API]  no object provided!');\\n        }\\n        if (!(obj instanceof fabric.Object)) {\\n            throw new Error(\\\"[Easel API]  object type is not 'fabric.Object!'\\\");\\n        }\\n    };\\n\\n\\n    /**\\n     * Returns currently active object.\\n     * @return {fabric.Object}   currently active object\\n     */\\n    EaselApi.prototype.getSelectedObject = function() {\\n        return this.drawer.fCanvas.getActiveObject();\\n    };\\n\\n\\n    /**\\n     * Bring object closer to front in objects stack.\\n     *\\n     * @param  {fabric.Object} fabricItem   object to reposition\\n     * @return {fabric.Object} returns   same object\\n     */\\n    EaselApi.prototype.bringObjectForward = function(fabricItem) {\\n        this._checkObject(fabricItem);\\n\\n        this.drawer.fCanvas.bringForward(fabricItem, true);\\n        this.drawer.syncCanvasData();\\n        return fabricItem;\\n    };\\n\\n\\n    /**\\n     * Bring object closer to bottom in objects stack.\\n     *\\n     * @param  {fabric.Object} fabricItem   object to reposition\\n     * @return {fabric.Object} returns   same object\\n     */\\n    EaselApi.prototype.sendObjectBackwards = function(fabricItem) {\\n        this._checkObject(fabricItem);\\n        this.drawer.fCanvas.sendBackwards(fabricItem, true);\\n        this.drawer.syncCanvasData();\\n        return fabricItem;\\n    };\\n\\n\\n    /**\\n     * Move object the top object in stack.\\n     *\\n     * @param  {fabric.Object} fabricItem   object to reposition\\n     * @return {fabric.Object}   returns same object\\n     */\\n    EaselApi.prototype.bringObjectToFront = function(fabricItem) {\\n        this._checkObject(fabricItem);\\n\\n        this.drawer.fCanvas.bringToFront(fabricItem, true);\\n        this.drawer.syncCanvasData();\\n        return fabricItem;\\n    };\\n\\n\\n    /**\\n     * Move object the bottom object in stack.\\n     *\\n     * @param  {fabric.Object} fabricItem   object to reposition\\n     * @return {fabric.Object}   returns same object\\n     */\\n    EaselApi.prototype.sendObjectToBack = function(fabricItem) {\\n        this._checkObject(fabricItem);\\n\\n        this.drawer.fCanvas.sendToBack(fabricItem);\\n        this.drawer.syncCanvasData();\\n        return fabricItem;\\n    };\\n\\n    /**\\n     * Remove object from canvas.\\n     *\\n     * @param  {fabric.Object} fabricItem  object to reposition\\n     */\\n    EaselApi.prototype.removeObject = function(fabricItem) {\\n        this._checkObject(fabricItem);\\n\\n        fabricItem.remove();\\n        this.drawer.fCanvas.renderAll();\\n    };\\n\\n\\n  /**\\n   * Duplicate given object.\\n   * If object is not 'async' - it will be returned.\\n   * If 'callback' is provided - it will be called after cloning,\\n   *  with cloned object as argument\\n   *\\n   * @param  {fabric.Object}  fabricItem  object to be cloned\\n   * @param  {Function}       callback    will be called after cloning with cloned object as argument\\n   * @return {fabric.Object}              cloned object, if objject is not 'async'\\n   */\\n    EaselApi.prototype.duplicateObject = function(fabricItem, callback) {\\n        this._checkObject(fabricItem);\\n\\n        var _this = this;\\n        var onCloned = function (clonedObj) {\\n            if (!clonedObj) {\\n                throw new Error(\\\"[Easel API] duplicateObject() : Clone failed! Clone source: \\\" + fabricItem.toString());\\n            }\\n\\n            clonedObj.set('left', fabricItem.get('left') + 20);\\n            clonedObj.set('top', fabricItem.get('top') + 20);\\n            _this.drawer.fCanvas.add(clonedObj);\\n            _this.drawer.fCanvas.renderAll();\\n\\n            // call callback with new object\\n            if (callback) {\\n                callback(clonedObj);\\n            }\\n            return clonedObj;\\n        };\\n\\n        // sync and async objects cloning is different\\n        if(fabricItem.async) {\\n            // call clone with callback\\n            fabricItem.clone(onCloned);\\n        } else {\\n            // direct call function\\n            return onCloned(fabricItem.clone());\\n        }\\n    };\\n\\n})(Easel.EaselApi);\\n\"","module.exports = \"/**\\n * List of all available options for each mode of each toolbar\\n * @typedef {Object} defaultSetOfOptions\\n * @memberOf EaselToolbar\\n * @property {Boolean} [hidden=false] - Toolbar is hidden (via CSS)\\n * @property {String} [position=\\\"top\\\"] - Position of the toolbar relative to the Easel - top/right/left/bottom/custom\\n * @property {Boolean} [toggleVisibilityButton=false] - Use \\\"Toggle visibility\\\" button. Will be ignored if compact type = 'popup'\\n * @property {String} [positionType=\\\"outside\\\"] - Position type - inside/outside canvas\\n * @property {String} [compactType=\\\"multiple\\\"] - Compact type - scrollable/multiple/popup\\n * @property {String} [customAnchorSelector] - Anchor selector for custom position\\n */\\n\\nvar emptyFunc = function() {};\\n\\n/**\\n * Default configuration object of toolbar\\n * @typedef {EaselToolbar.defaultSetOfOptions} defaultToolbarOptions\\n * @memberOf EaselToolbar\\n * @property {EaselToolbar.defaultSetOfOptions} fullscreenMode - Options for fullscreen mode. Able to use same\\n * options as for normal mode. Undefined options will be inherited from normal mode\\n */\\n\\n/**\\n * Configuration object of button.\\n * @typedef {Object} EaselToolbar.buttonConfig\\n * @property {String} [additionalClass] add specified class to button's <li> element.\\n * @property {String} [iconClass] add specified class to button's <i> element.\\n * @property {String} [tooltipText] Tooltip text that will be shown on mouse over.\\n * @property {Number} [buttonOrder=10] Order priority of button. Button with min order value will be first.\\n * @property {Boolean} [isSubMenu=false] Button is submenu of other button\\n * @property {Function} [clickHandler] function that will be invoked when user clicks on this button.\\n * @property {Object} [group]  Group object with group class name and tooltip text\\n * @property {String} [group.name]  Group unique id\\n * @property {String} [group.tooltip]  A tooltip text that will be shown on mouse over\\n */\\n\\n/**\\n * Toolbar with tools like brush/rectangle/text etc.\\n * @param {Easel.Easel} drawerInstance - Easel instance\\n * @param {EaselToolbar.defaultSetOfOptions} [options] Configuration object\\n * @constructor EaselToolbar\\n */\\nvar EaselToolbar = function (drawerInstance, options) {\\n  if (!drawerInstance) {\\n    throw new Error(\\\"EaselToolbar c-tor : drawerInstance is not set!\\\");\\n  }\\n  this.drawerInstance = drawerInstance;\\n  this.buttonsGroups = {};\\n\\n  this._setupOptions(options);\\n  this._setupElement();\\n  this._attachEventHandlers();\\n  this._attachEaselEventHandlers();\\n  this._initCompactType();\\n};\\n\\nEaselToolbar.BASE_CLASS = 'easel-toolbar';\\nEaselToolbar.MULTILINE_CLASS = 'easel-toolbar--multiline';\\nEaselToolbar.HORIZONTAL_CLASS = 'easel-toolbar--horizontal';\\nEaselToolbar.VERTICAL_CLASS = 'easel-toolbar--vertical';\\nEaselToolbar.FLOATING_CLASS = 'easel-toolbar--floating';\\nEaselToolbar.BUTTON_EVENT_NAMESPACE = 'easel-toolbar-button';\\n\\nEaselToolbar.prototype.MULTILINE = 'multiline';\\nEaselToolbar.prototype.SCROLLABLE = 'scrollable';\\nEaselToolbar.prototype.POPUP = 'popup';\\n\\nEaselToolbar.prototype.POSITION_TYPE_OUTSIDE = 'outside';\\nEaselToolbar.prototype.POSITION_TYPE_INSIDE = 'inside';\\n\\n/**\\n * Toolbar position - one of [left, top, right, bottom, custom]\\n * @type {string}\\n */\\nEaselToolbar.prototype.position = 'top';\\n// button groups\\nEaselToolbar.prototype.buttonsGroups = {};\\nEaselToolbar.prototype.buttons = [];\\n\\nEaselToolbar.prototype._defaultOptions = {\\n    compactType : EaselToolbar.prototype.MULTILINE,\\n    positionType: EaselToolbar.prototype.POSITION_TYPE_OUTSIDE,\\n    buttonWidth : 32,\\n    buttonHeight : 35\\n};\\n\\n/**\\n * Default values of button config\\n * @type {EaselToolbar.buttonConfig}\\n * @private\\n */\\nEaselToolbar.prototype._defaultButtonConfig = {\\n  additionalClass: '',\\n  iconClass: '',\\n  tooltipText: '',\\n  buttonOrder: 10,\\n  isSubMenu: false,\\n  group: {\\n    name: '',\\n    tooltip: ''\\n  },\\n  clickHandler: emptyFunc\\n};\\n\\n/**\\n * Setup options\\n * @param {Object} [options] - Configuration object\\n * @private\\n */\\nEaselToolbar.prototype._setupOptions = function (options) {\\n  this.options = $.extend(true, {}, this._defaultOptions || {}, options || {});\\n};\\n\\n/**\\n * Create/setup toolbar element\\n * @private\\n */\\nEaselToolbar.prototype._setupElement = function () {\\n  var toolbarHtml = this._generateTemplate(),\\n      $toolbar = $(toolbarHtml);\\n  this.$toolbar = $toolbar;\\n  this.$toolbarContentHolder = this.$toolbar.find('.toolbar-content-wrapper');\\n};\\n\\n/**\\n * Get html of toolbar element\\n * @returns {String}\\n * @private\\n */\\nEaselToolbar.prototype._generateTemplate = function () {\\n  var html,\\n      wrapperClasses = EaselToolbar.BASE_CLASS + ' ' +\\n          (this.options.toolbarClass || '') +\\n          (this.options.hidden ? ' hidden ' : '');\\n\\n  html = '' +\\n      '<ul class=\\\"' + wrapperClasses + '\\\" ' +\\n        'contenteditable=\\\"false\\\"' +\\n        // 'tabindex=\\\"-1\\\"' +\\n      '>' +\\n          '<ul class=\\\"toolbar-content-wrapper\\\"></ul>' +\\n      '</ul>';\\n  return html;\\n};\\n\\n/**\\n * Setup events\\n * @private\\n */\\nEaselToolbar.prototype._attachEventHandlers = function () {\\n\\n};\\n\\n/**\\n * Setup drawer events\\n * @private\\n */\\nEaselToolbar.prototype._attachEaselEventHandlers = function () {\\n  var self = this;\\n  // always hide group dropdown when any tool activates\\n  this.drawerInstance.on(this.drawerInstance.EVENT_DO_ACTIVATE_TOOL, function () {\\n    // self.$toolbar.find('ul.group-items-container').addClass('hidden');\\n    // @todo: hide all open sub-menus\\n    self.hideActiveSubmenu();\\n  });\\n};\\n\\n/**\\n * Process \\\"compactType\\\" option\\n * @private\\n */\\nEaselToolbar.prototype._initCompactType = function () {\\n  switch (true) {\\n    case (this.options.compactType === EaselToolbar.prototype.SCROLLABLE):\\n      this._initCompactType_scrollable();\\n      break;\\n    case (this.options.compactType === EaselToolbar.prototype.MULTILINE):\\n      this._initCompactType_multiline();\\n      break;\\n    case (this.options.compactType === EaselToolbar.prototype.POPUP):\\n      this._initCompactType_popup();\\n      break;\\n    default:\\n      this._initCompactType_multiline();\\n      break;\\n  }\\n};\\n\\n/**\\n * Init 'scrollable' compact type\\n * @private\\n */\\nEaselToolbar.prototype._initCompactType_scrollable = function () {\\n  this.isScrollable = true;\\n  this.scrollModeActive = false;\\n  this.currentScrollOffset = 0;\\n\\n  this.$toolbar.addClass('toolbar-scrollable');\\n\\n  // look, if show scroll UI on drawer resize and edit start\\n\\n  this.drawerInstance.on(this.drawerInstance.EVENT_CANVAS_START_RESIZE, this._onCanvasResizeStart.bind(this));\\n  this.drawerInstance.on(this.drawerInstance.EVENT_CANVAS_RESIZING, this._onCanvasResizing.bind(this));\\n  this.drawerInstance.on(this.drawerInstance.EVENT_CANVAS_STOP_RESIZE, this._onCanvasResizeFinish.bind(this));\\n  this.drawerInstance.on(this.drawerInstance.EVENT_EDIT_START, this.checkScroll.bind(this));\\n\\n  // handle scrolling by swipe\\n  this.$toolbar.on('mousedown.toolbar touchstart.toolbar', this.onTouchStart.bind(this));\\n};\\n\\n/**\\n * Init 'multiline' compact type\\n * @private\\n */\\nEaselToolbar.prototype._initCompactType_multiline = function () {\\n  this.$toolbar.addClass(EaselToolbar.MULTILINE_CLASS);\\n};\\n\\n/**\\n * Init 'popup' compact type\\n * @private\\n */\\nEaselToolbar.prototype._initCompactType_popup = function () {\\n  this._initCompactType_multiline();\\n};\\n\\n\\n/**\\n * Removes toolbar element.\\n * @fires Easel.Easel.EVENT_TOOLBAR_DESTROYED\\n */\\nEaselToolbar.prototype.remove = function () {\\n    this.$toolbar.remove();\\n    this.buttonsGroups = {};\\n    this.drawerInstance.trigger(this.drawerInstance.EVENT_TOOLBAR_DESTROYED, [this]);\\n};\\n\\n\\n/**\\n * Adds control to toolbar.\\n * @param {jQuery|HTMLElement} control\\n * @param buttonOrder\\n */\\nEaselToolbar.prototype.addControl = function (control, buttonOrder) {\\n  buttonOrder = buttonOrder !== undefined ? buttonOrder : this._defaultButtonConfig.buttonOrder;\\n  var orderString = this._getOrderString(buttonOrder),\\n      currStyleAttr = control.attr('style');\\n  control.attr('style', (currStyleAttr || '') + ';' + orderString);\\n  this.$toolbarContentHolder.append(control);\\n};\\n\\n\\n/**\\n * Add a button to this toolbar.\\n * @param {EaselToolbar.buttonConfig} options Button configuration object\\n */\\nEaselToolbar.prototype.addButton = function (options) {\\n  options = this._validateButtonConfig(options);\\n  var $button = this.createButton(options);\\n\\n  this.buttons.push($button);\\n\\n  // add button and create tooltip\\n  this.$toolbarContentHolder.append($button);\\n\\n  // toolbar grew bigger, so call check for scroll\\n  this.checkScroll();\\n\\n  return $button;\\n};\\n\\n/**\\n * Add a button to this toolbar. Button will be appended to group.\\n * Group is a one button which will show dropdown with its buttons on click.\\n *\\n * @param {EaselToolbar.buttonConfig} options Button configuration object\\n */\\nEaselToolbar.prototype.addButtonToGroup = function (options) {\\n  options = this._validateButtonConfig(options);\\n  var $groupContainer = this.buttonsGroups[options.group.name],\\n      groupElementIsExist = $groupContainer && $groupContainer.length,\\n      needToCreateGroup = !groupElementIsExist;\\n\\n  // create group. if no group exists\\n  if (needToCreateGroup) {\\n    this._createAndAppendGroup(options.group, options.iconClass,options.buttonOrder);\\n    $groupContainer = this.buttonsGroups[options.group.name];\\n  }\\n\\n  // create button\\n  options.isSubMenu = true;\\n  var $button = this.createButton(options);\\n\\n  // and append to toolbar\\n  $groupContainer.$submenuWrapper.buttons.push($button);\\n  $groupContainer.find('.group-items-container').append($button);\\n\\n  return $button;\\n};\\n\\n/**\\n * Check values of button config object\\n * @param {EaselToolbar.buttonConfig} options - button configuration\\n * @returns {EaselToolbar.buttonConfig}\\n */\\nEaselToolbar.prototype._validateButtonConfig = function (options) {\\n  options = options || {};\\n  var defaultConf = $.extend(true, {}, this._defaultButtonConfig),\\n      result = $.extend(true, {}, defaultConf, options);\\n\\n  result.buttonOrder = typeof result.buttonOrder === 'number' ? result.buttonOrder : defaultConf.buttonOrder;\\n  result.isSubMenu = result.isSubMenu !== undefined ? result.isSubMenu : defaultConf.isSubMenu;\\n  result.clickHandler = typeof result.clickHandler === 'function' ? result.clickHandler : defaultConf.clickHandler;\\n  return result;\\n};\\n\\nEaselToolbar.prototype._getOrderString = function (orderValue) {\\n  var orderString = '' +\\n      '-webkit-order:' + orderValue + ';' +\\n      '-ms-flex-order:' + orderValue + ';' +\\n      'order:' + orderValue + ';';\\n  return orderString;\\n};\\n\\n/**\\n * Creates jQuery object with button element markup.\\n *\\n * @param {EaselToolbar.buttonConfig} options - button configuration\\n * @returns {jQuery}\\n */\\nEaselToolbar.prototype.createButton = function (options) {\\n  var orderString = this._getOrderString(options.buttonOrder),\\n      styleString = 'style=\\\"' + orderString + '\\\"';\\n  // button html\\n  var $button,\\n      submenuClass = options.isSubMenu ? ' submenu-child ' : ' ',\\n      classString = 'toolbar-button ' + options.additionalClass + submenuClass,\\n      buttonHtml = '' +\\n    '<li ' +\\n          'class=\\\"' + classString + '\\\"' +\\n          'data-tooltip-class=\\\"'+options.additionalClass+'\\\"' +\\n        styleString +\\n    '>' +\\n      '<a href=\\\"#\\\" ' +\\n          'class=\\\"toolbar-button-icon ' + submenuClass + '\\\"' +\\n        'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n        'data-editable-canvas-cssrules=\\\"line-height,font-size:($v / 2.5)\\\" tabindex=\\\"-1\\\"' +\\n      '>' +\\n          '<i class=\\\"fa ' + options.iconClass + ' ' + submenuClass + '\\\"></i>' +\\n      '</a>' +\\n    '</li>';\\n  $button = $(buttonHtml);\\n\\n  var tooltipOptions = {\\n    additionalClass: options.additionalClass,\\n    text: options.tooltipText,\\n    position: 'bottom'\\n  };\\n  \\n  // Only create tooltip if not disabled\\n  if (!this.drawerInstance.options.toolbars.disableTooltips) {\\n    $button.tooltip = this.drawerInstance.trigger(this.drawerInstance.EVENT_CREATE_TOOLTIP, [$button.find('a'), tooltipOptions]);\\n  }\\n\\n  // prevent default behavior on link click\\n  var $link = $button.find('a');\\n  $link.on('click', function (e) {\\n    e.preventDefault();\\n    e.stopPropagation();\\n  });\\n\\n  // set click handler\\n  Easel.util.bindClick($link, EaselToolbar.BUTTON_EVENT_NAMESPACE, options.clickHandler);\\n  return $button;\\n};\\n\\n\\n/**\\n * Remove button and attached handlers\\n * @param {jQuery} $button - Button element\\n */\\nEaselToolbar.prototype.removeButton = function ($button) {\\n  if (!$button) {\\n    console.warn(\\\"EaselToolbar.removeButton() : no $button is provided!\\\");\\n    return;\\n  }\\n  // unbind click handler\\n  Easel.util.unbindClick($button.find('a'), EaselToolbar.BUTTON_EVENT_NAMESPACE);\\n  // remove element\\n  $button.remove();\\n\\n};\\n\\n/**\\n * Creates group button with empty list of tools, and appends it to toolbar\\n *\\n * @param {Object} group - group data object\\n * @param {string} group.name - name of group\\n * @param {string} iconClass  - css icon class of group button\\n * @param {Number} buttonOrder  - button order value\\n * @private\\n */\\nEaselToolbar.prototype._createAndAppendGroup = function(group, iconClass, buttonOrder) {\\n  // group container html\\n  var orderString = this._getOrderString(buttonOrder),\\n      styleString = 'style=\\\"' + orderString + '\\\"';\\n  var $groupContainer = $(\\n      '<li class=\\\"toolbar-button btn-group group-' + group.name + '\\\"' +\\n          'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n          'data-editable-canvas-cssrules=\\\"width,height\\\"' +\\n          styleString +\\n      '>' +\\n          '<a href=\\\"#\\\" ' +\\n              'class=\\\"toolbar-button-icon\\\"'+\\n              'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n              'data-editable-canvas-cssrules=\\\"line-height,font-size:($v / 2.5)\\\" ' +\\n              'tabindex=\\\"-1\\\"' +\\n          '>' +\\n              '<i class=\\\"fa ' + iconClass + '\\\"></i>' +\\n        '</a>' +\\n        '<div class=\\\"submenu-wrapper\\\">' +\\n            '<ul class=\\\"group-items-container submenu-child toolbar-dropdown-block\\\">' +\\n            '</ul>' +\\n        '</div>' +\\n      '</li>');\\n\\n  $groupContainer.$submenuWrapper = $groupContainer.find('.submenu-wrapper');\\n  $groupContainer.$submenuWrapper.buttons = [];\\n\\n  // add group container to toolbar\\n  this.$toolbarContentHolder.append($groupContainer);\\n  this.buttonsGroups[group.name] = $groupContainer;\\n\\n  // prevent default action on link click - moving to anchor\\n  $groupContainer.find('a').on('click',  function(e) {\\n      e.preventDefault();\\n  });\\n  // react on click\\n  $groupContainer.on('click', this.onGroupButtonClick.bind(this, $groupContainer));\\n\\n  // create tooltip to group\\n\\n  var tooltipOptions = {\\n    additionalClass: group.name,\\n    text: group.tooltip,\\n    position: 'bottom'\\n  };\\n  this.drawerInstance.trigger(this.drawerInstance.EVENT_CREATE_TOOLTIP, [$groupContainer.children('a'), tooltipOptions]);\\n};\\n\\n/**\\n * Set active button\\n * @param {String} buttonClassName\\n */\\nEaselToolbar.prototype.setActiveButton = function (buttonClassName) {\\n  var $button = this.$toolbar.find('.toolbar-button.' + buttonClassName),\\n      $buttonIcon = $button.find('.toolbar-button-icon');\\n  $buttonIcon.addClass('active');\\n};\\n\\n/**\\n * Remove active state for all buttons\\n */\\nEaselToolbar.prototype.clearActiveButton = function () {\\n  var $activeButton = this.$toolbar.find('.toolbar-button .toolbar-button-icon.active');\\n  $activeButton.removeClass('active');\\n};\\n\\n\\n/**\\n * React on group button click\\n * @param {jQuery} $groupButtton - Group container\\n * @param {Event} evt\\n * @private\\n */\\nEaselToolbar.prototype.onGroupButtonClick = function($groupButtton, evt) {\\n  // copy submenu, including handlers\\n  this.activeSubmenu = $groupButtton.$submenuWrapper.clone(true);\\n  // var $submenu = $submenuSrc.clone(true);\\n\\n  var $btn = $(evt.currentTarget);\\n  var $placeholder = this.$toolbar.parent();\\n\\n  // append to toolbar before positioning, so this.activeSubmenu has width and height for further calculations\\n  $placeholder.append(this.activeSubmenu);\\n\\n  var placeholderRect = $placeholder.get(0).getBoundingClientRect();\\n  var buttonRect = $btn.get(0).getBoundingClientRect();\\n  var submenuRect = this.activeSubmenu.get(0).getBoundingClientRect();\\n  var GAP = 6;\\n  var left = buttonRect.left - placeholderRect.left;\\n  var top = buttonRect.top - placeholderRect.top;\\n\\n  if (this.isHorizontal()) {\\n    left += (buttonRect.width - submenuRect.width) / 2;\\n    if (this.position === 'bottom') {\\n      top -= submenuRect.height + GAP;\\n    } else {\\n      top += buttonRect.height + GAP;\\n    }\\n  } else {\\n    top += (buttonRect.height - submenuRect.height) / 2;\\n    if (this.position === 'right') {\\n      left -= submenuRect.width + GAP;\\n    } else {\\n      left += buttonRect.width + GAP;\\n    }\\n  }\\n\\n  var maxLeft = $placeholder.width() - submenuRect.width;\\n  var maxTop = $placeholder.height() - submenuRect.height;\\n  if (!isFinite(maxLeft) || maxLeft < 0) {\\n    maxLeft = 0;\\n  }\\n  if (!isFinite(maxTop) || maxTop < 0) {\\n    maxTop = 0;\\n  }\\n\\n  left = Math.min(Math.max(left, 0), maxLeft);\\n  top = Math.min(Math.max(top, 0), maxTop);\\n\\n  this.activeSubmenu.css({\\n    left: Math.round(left) + 'px',\\n    top: Math.round(top) + 'px'\\n  });\\n\\n  $('body').on('mousedown.submenu', this.onSubmenuMouseDown.bind(this));\\n\\n};\\n\\n/**\\n * React on submenu click\\n * @param {Event} evt\\n * @private\\n */\\nEaselToolbar.prototype.onSubmenuMouseDown = function(evt) {\\n    if (!this.activeSubmenu)\\n        return;\\n    if (evt.target == this.activeSubmenu || $(evt.target).hasClass('submenu-child') )\\n        return;\\n\\n    this.hideActiveSubmenu();\\n};\\n\\n/**\\n * Hide active submenu\\n */\\nEaselToolbar.prototype.hideActiveSubmenu = function() {\\n    if (this.activeSubmenu) {\\n        // hide all tooltips\\n        this.drawerInstance.trigger(this.drawerInstance.EVENT_HIDE_TOOLTIPS);\\n\\n        this.activeSubmenu.remove();\\n        this.activeSubmenu = null;\\n        $('body').off('mousedown.submenu');\\n\\n    }\\n};\\n\\n// EaselToolbar.prototype.onGroupButtonClick = function(evt, button) {\\n\\n// };\\n\\n/**\\n * Makes tool button with css class buttonClass as active.\\n * This is achieved by making group button copy of the tool button.\\n *\\n * @param groupName\\n * @param buttonClass\\n * @private\\n */\\nEaselToolbar.prototype._setGroupButtonActive = function (groupName, buttonClass) {\\n  // find group and button\\n  var $groupContainer = this.buttonsGroups[groupName];\\n  var $button = this.$toolbar.find('.' + buttonClass);\\n\\n  // set $groupContainer css class same as $button class\\n  $groupContainer.attr('class', $button.attr('class'));\\n  $groupContainer.addClass('btn-group');\\n\\n  var groupButton = $groupContainer.children('a');\\n  // make $button.a active\\n  groupButton.addClass('active');\\n  // copy $button.a html to $groupContainer.a\\n  groupButton.html($button.children('a').html());\\n};\\n\\n\\n/**\\n * React on touch start\\n * @param {Event} evt\\n * @private\\n */\\nEaselToolbar.prototype.onTouchStart = function(evt) {\\n    if (!this.scrollModeActive)\\n        return;\\n\\n    this.mouseDown = true;\\n\\n    // handling touch events\\n    var e = (evt.type == 'touchstart') ?  evt.originalEvent.touches[0] : evt;\\n    // get coord we are interested in\\n    var curCoord = this.isHorizontal() ? e.pageX : e.pageY;\\n\\n    // touch start coord plus existing offset\\n    this.touchStartCoord = curCoord + this.currentScrollOffset;\\n\\n    $('body').on('mouseup.toolbar touchend.toolbar', this.onTouchEnd.bind(this));\\n\\n    this.$toolbar.on('mousemove.toolbar touchmove.toolbar', this.onTouchMove.bind(this));\\n};\\n\\n/**\\n * React on touch end\\n * @param {Event} evt\\n * @private\\n */\\nEaselToolbar.prototype.onTouchEnd = function(evt) {\\n    this.mouseDown = false;\\n    $('body').off('mousemove.toolbar touchmove.toolbar');\\n    $('body').off('mouseup.toolbar touchend.toolbar');\\n};\\n\\n/**\\n * React on touch move\\n * @param {Event} evt\\n * @private\\n */\\nEaselToolbar.prototype.onTouchMove = function(evt) {\\n  if (this.mouseDown) {\\n    var eventTarget = evt.target,\\n        $eventTarget = $(eventTarget),\\n        isInput = $eventTarget.is('input'),\\n        isColorIndicator = $eventTarget.is('.color-indicator'),\\n        processEvent = !isInput && !isColorIndicator;\\n\\n    if (processEvent) {\\n      // prevent default action - copying of toolbar content\\n      evt.preventDefault();\\n\\n      // handling touch events\\n      var e = (evt.type === 'touchmove') ?  evt.originalEvent.touches[0] : evt;\\n\\n      // get coord we are interested in\\n      var curCoord = this.isHorizontal() ? e.pageX : e.pageY;\\n\\n      var delta = this.touchStartCoord - curCoord;\\n\\n      this.scrollTo(delta);\\n    }\\n  }\\n};\\n\\n/**\\n * React on canvas resize start\\n * @private\\n */\\nEaselToolbar.prototype._onCanvasResizeStart = function() {\\n  this.checkScroll();\\n};\\n\\n/**\\n * React on canvas resizing\\n * @private\\n */\\nEaselToolbar.prototype._onCanvasResizing = function() {\\n  this.checkScroll();\\n};\\n\\n/**\\n * React on canvas resize finish\\n * @private\\n */\\nEaselToolbar.prototype._onCanvasResizeFinish = function() {\\n  this.checkScroll();\\n};\\n\\n/**\\n *  Compares sizes of toolbar and its placeholder,\\n *  if toolbar is bigger - shows scroll\\n */\\nEaselToolbar.prototype.checkScroll = function() {\\n    // Scrolling disabled\\n    this.scrollModeActive = false;\\n};\\n\\n\\n/**\\n * Toggle toolbar visibility\\n * @param {Boolean} [saveCurrentState]\\n * @param {Boolean} [useSaved]\\n */\\nEaselToolbar.prototype.toggleToolbarVisibility = function (saveCurrentState, useSaved) {\\n  var currentState = !this.$toolbar.hasClass('hidden'),\\n      showToolbar = useSaved ? this.visibilityState : currentState;\\n\\n  if (showToolbar) {\\n    this.showToolbar(saveCurrentState);\\n  } else {\\n    this.hideToolbar(saveCurrentState);\\n  }\\n};\\n\\n/**\\n * Hide toolbar\\n * @param {Boolean} [saveCurrentState]\\n */\\nEaselToolbar.prototype.hideToolbar = function (saveCurrentState) {\\n  if (saveCurrentState) {\\n    this.visibilityState = !this.$toolbar.hasClass('hidden');\\n  }\\n  this.invisible = true;\\n  this.$toolbar.addClass('hidden');\\n};\\n\\n/**\\n * Show toolbar\\n * @param {Boolean} [saveCurrentState]\\n */\\nEaselToolbar.prototype.showToolbar = function (saveCurrentState) {\\n  if (saveCurrentState) {\\n    this.visibilityState = !this.$toolbar.hasClass('hidden');\\n  }\\n  this.invisible = false;\\n  this.$toolbar.removeClass('hidden');\\n};\\n\\n\\n/**\\n * Scroll toolbar to the offset.\\n * @param  {Number} newOffset\\n */\\nEaselToolbar.prototype.scrollTo = function (newOffset) {\\n    // Scrolling disabled\\n};\\n\\n\\n/**\\n * Returns one of [horizontal, vertical]\\n * @return {String} toolbar orientation\\n */\\nEaselToolbar.prototype.getToolbarOrientation = function () {\\n  return this.$toolbar.hasClass(EaselToolbar.VERTICAL_CLASS) ? 'vertical' : 'horizontal';\\n};\\n\\n\\n/**\\n * @return {Boolean}\\n */\\nEaselToolbar.prototype.isHorizontal = function () {\\n  return (this.getToolbarOrientation() ===  'horizontal');\\n};\\n\\n\\n/**\\n * height of toolbar\\n * @return {Number}\\n */\\nEaselToolbar.prototype.height = function () {\\n  return this.$toolbar.height();\\n};\\n\\n\\n/**\\n * Width of toolbar\\n * @return {Number}\\n */\\nEaselToolbar.prototype.width = function () {\\n  return this.$toolbar.width();\\n};\\n\\nEasel.EaselToolbar = EaselToolbar;\\n\\n\\n\"","module.exports = \"(function ($, pluginsNamespace, util) {\\n  'use strict';\\n\\n  var optimalSizeOfDropdown = 375;\\n\\n  /**\\n   * Creates color input for changing color; colorChangeHandler is called on color change.\\n   *\\n   * @param {Easel.Easel} drawer\\n   *\\n   * @param {Object} [options]\\n   * Configuration object.\\n   *\\n   * @param {String[]} [options.colors]\\n   * Array of colors to be used.\\n   *\\n   * @param {number} [options.colorsInRow]\\n   * Number of colors for one row.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ColorpickerControl = function ColorpickerControlConstructor(drawer, options) {\\n      this.drawer = drawer;\\n\\n      // init options\\n      options = options || {};\\n      this.options = $.extend(true, {}, this._defaultOptions || {}, options || {});\\n\\n      this.hideOnEditMode = true;\\n      // more stuff\\n      this.assetsUrl = util.getEaselFolderUrl() + 'assets/';\\n      this.shouldDisplayTransparent = false;\\n\\n      this.colors = this.options.colors;\\n      this.colorsInRow = this.options.colorsInRow;\\n    };\\n\\n\\n  ColorpickerControl.prototype._defaultOptions = {\\n      colors: [\\n          '#ffffff', '#000000', '#eeece1', '#1f497d', '#4f81bd', '#c0504d','#9bbb59', '#8064a2', '#4bacc6', '#f79646', '#ffff00',\\n          '#f2f2f2', '#7f7f7f', '#ddd9c3', '#c6d9f0', '#dbe5f1', '#f2dcdb','#ebf1dd', '#e5e0ec', '#dbeef3', '#fdeada', '#fff2ca',\\n          '#d8d8d8', '#595959', '#c4bd97', '#8db3e2', '#b8cce4', '#e5b9b7','#d7e3bc', '#ccc1d9', '#b7dde8', '#fbd5b5', '#ffe694',\\n          '#bfbfbf', '#3f3f3f', '#938953', '#548dd4', '#95b3d7', '#d99694','#c3d69b', '#b2a2c7', '#b7dde8', '#fac08f', '#f2c314',\\n          '#a5a5a5', '#262626', '#494429', '#17365d', '#366092', '#953734','#76923c', '#5f497a', '#92cddc', '#e36c09', '#c09100',\\n          '#7f7f7f', '#0c0c0c', '#1d1b10', '#0f243e', '#244061', '#632423','#4f6128', '#3f3151', '#31859b', '#974806', '#7f6000'\\n        ],\\n        colorsInRow: 11,\\n        minSwatchSize : 10,\\n        buttonOrder: 6\\n  };\\n\\n  ColorpickerControl.prototype.TRANSPARENT = 'rgba(0, 0, 0, 0)';\\n  ColorpickerControl.prototype.defaultPosition = 'bottom';\\n  ColorpickerControl.prototype.positions = ['bottom', 'top', 'left', 'right'];\\n\\n  /**\\n   * Removes tool\\n   */\\n  ColorpickerControl.prototype.remove = function () {\\n    if (this.$colorButton) {\\n      this.$colorButton.remove();\\n    }\\n  };\\n\\n\\n  /**\\n   * Hides controls\\n   */\\n  ColorpickerControl.prototype.hideControls = function () {\\n    if (this.$colorButton) {\\n      this.$colorButton.addClass('hidden');\\n    }\\n    this.hideColorDropdown();\\n  };\\n\\n  /**\\n   * Shows controls.\\n   * Before showing - updates controls size and position.\\n   */\\n  ColorpickerControl.prototype.showControls = function () {\\n    if (this.$colorButton) {\\n      this.$colorButton.removeClass('hidden');\\n    }\\n  };\\n\\n\\n  /**\\n   * Returns current selected color\\n   * @return {String} currently selected css color\\n   */\\n  ColorpickerControl.prototype.getColor = function() {\\n      return this.currentColor;\\n  };\\n\\n\\n  /**\\n   * Sets current color.\\n   * @param {String|fabric.Color} color valid css color or 'transparent'\\n   */\\n  ColorpickerControl.prototype.setColor = function (color) {\\n      if (color instanceof fabric.Color) {\\n        this.currentColor = color;\\n      } else {\\n        this.currentColor = new fabric.Color(color);\\n      }\\n\\n      var background = color instanceof fabric.Color ? color.toRgba() : color,\\n          isTransparent = color === '' || color == this.TRANSPARENT || color == 'transparent';\\n\\n      if (!isTransparent && this.currentColor && this.currentColor._source) {\\n        isTransparent = this.currentColor._source[3] === 0;\\n      }\\n\\n      if (isTransparent) {\\n        background = 'url(' + this.assetsUrl + 'transparent.png)';\\n        this.currentColor = this.TRANSPARENT;\\n      }\\n\\n      if (this.$colorButton && this.$colorButton.$colorIndicator) {\\n        this.$colorButton.$colorIndicator.css('background', background);\\n      }\\n\\n      // Update HTML5 color input if color is not transparent and input exists\\n      if (this.$colorInput && !isTransparent) {\\n        var hexColor = this._normalizeColorForInput(this.currentColor);\\n        this.$colorInput.val(hexColor);\\n      }\\n    };\\n\\n  ColorpickerControl.prototype._normalizeColorForInput = function (color) {\\n      try {\\n        if (!color || color === this.TRANSPARENT || color === 'transparent') {\\n          return '#000000';\\n        }\\n\\n        var fabricColor = color instanceof fabric.Color ? color : new fabric.Color(color);\\n        return '#' + fabricColor.toHex();\\n      } catch (e) {\\n        return '#000000';\\n      }\\n    };\\n\\n\\n  /**\\n   * Removes transparent color from list\\n   */\\n  ColorpickerControl.prototype.disableTransparent = function () {\\n    this.shouldDisplayTransparent = false;\\n    // HTML5 color input doesn't support transparent, so this is handled in setColor\\n  };\\n\\n  /**\\n   * Adds transparent color to the list\\n   */\\n  ColorpickerControl.prototype.enableTransparent = function () {\\n    this.shouldDisplayTransparent = true;\\n    // HTML5 color input doesn't support transparent, so this is handled in setColor\\n  };\\n\\n\\n  /**\\n   * This function is called every time user clicks on color from color-dropdown\\n   * menu.\\n   *\\n   * @param {String} selectedColor Hash value of user selected color.\\n   */\\n  ColorpickerControl.prototype.onColorSelected = function (selectedColor) {\\n    this.hideColorDropdown();\\n    this.setColor(selectedColor);\\n\\n    if (this.colorChangeHandler) {\\n      this.colorChangeHandler(selectedColor);\\n    }\\n  };\\n\\n\\n  /**\\n   * Create and attach global click handlers\\n   * @private\\n   */\\n  ColorpickerControl.prototype._setGlobalClickHandler = function() {\\n    var self = this;\\n    $('html').click(function (e) {\\n        if (self.colorDropdownVisible && (e.target != self.$colorButton.$colorIndicator.get(0))) {\\n          self.hideColorDropdown();\\n        }\\n        return true;\\n    });\\n  };\\n\\n\\n    /**\\n   * Creates control\\n   * @param  {EaselToolbar} toolbar\\n   * @param  {Function} [colorChangeCallback]  function that will be called on color change\\n   * @returns {jQuery}\\n   */\\n  ColorpickerControl.prototype.createControl = function (toolbar, colorChangeCallback) {\\n    this.toolbar = toolbar;\\n    this.colorChangeCallback = colorChangeCallback;\\n    this._collectDataFromToolbar(toolbar);\\n    this._setGlobalClickHandler();\\n\\n    var colorText = this.options.colorText || this.drawer.t('Fill:');\\n\\n    // Create HTML5 color input control\\n    this.$colorButton = $(\\n      '<li class=\\\"toolbar-item-wrapper toolbar-button-item editable-canvas-color-button\\\">' +\\n        '<span class=\\\"toolbar-item-label\\\">' + colorText + '</span>' +\\n        '<div class=\\\"toolbar-item-icon color-input-wrapper\\\">' +\\n          '<input type=\\\"color\\\" class=\\\"html5-color-input\\\" value=\\\"#000000\\\" />' +\\n          '<div class=\\\"color-indicator\\\"></div>' +\\n        '</div>' +\\n      '</li>'\\n    );\\n\\n    this.$colorInput = this.$colorButton.find('.html5-color-input');\\n    this.$colorButton.$colorIndicator = this.$colorButton.find('.color-indicator');\\n    this.$toolbar = toolbar.$toolbar;\\n\\n    // Set initial color from drawer\\n    var initialColor = this.drawer.activeColor || '#000000';\\n    this.setColor(initialColor);\\n\\n    // Add color change event\\n    this.$colorInput.on('input change', this._onColorInputChange.bind(this));\\n\\n    toolbar.addControl(this.$colorButton, this.options.buttonOrder);\\n    return this.$colorButton;\\n  };\\n\\n  /**\\n   * Handle color input change\\n   * @private\\n   */\\n  ColorpickerControl.prototype._onColorInputChange = function() {\\n    var selectedColor = this.$colorInput.val();\\n    this.setColor(selectedColor);\\n\\n    // Call the callback if provided\\n    if (this.colorChangeCallback) {\\n      this.colorChangeCallback(selectedColor);\\n    }\\n  };\\n\\n  /**\\n   * React on button click\\n   * @param {Event} event - mouse click event\\n   * @private\\n   */\\n  ColorpickerControl.prototype._onButtonClick = function (event) {\\n    var $trigger = $(event.currentTarget);\\n    this.$lastTrigger = $trigger;\\n    this.toggleColorDropdown($trigger);\\n  };\\n\\n  ColorpickerControl.prototype._collectDataFromToolbar = function (toolbar) {\\n    if (toolbar) {\\n      var toolbarPosition = toolbar.options.position;\\n      this.isVertical = toolbarPosition === 'left' || toolbarPosition === 'right';\\n      this.$toolbar = toolbar.$toolbar;\\n      this.toolbar = toolbar;\\n    }\\n  };\\n\\n  /**\\n   * Build some magic picker.\\n   * @param  {jQuery} $container - jQuery wrapper of container\\n   * @private\\n   */\\n  ColorpickerControl.prototype._buildPicker = function ($container) {\\n    // create swatch for each color\\n    for (var i = 0; i < this.colors.length; i++) {\\n      var color = this.colors[i];\\n\\n      var $swatch = this._createSwatch(color);\\n      $container.append($swatch);\\n    }\\n\\n    // create transparentSwatch\\n    var $transparentSwatch = this._createTransparentSwatch();\\n    $container.append($transparentSwatch);\\n  };\\n\\n\\n  /**\\n   * Calcs swatch size and updated Controls width if needed.\\n   * @private\\n   */\\n  ColorpickerControl.prototype._updateControlsSize = function () {\\n      // calc swatch size\\n      var swatchSize = this._calcSwatchSize();\\n      // swatch size in css is 1em, so set $container fontSize\\n      this.$colorButton.$colorDropdown.css('fontSize', swatchSize + 'px');\\n      // set control width\\n      var controlWidth = swatchSize * this.colorsInRow;\\n      this.$colorButton.$colorDropdown.css('width', controlWidth + 'px');\\n  };\\n\\n\\n  /**\\n   * Calc swatch size to fit current drawer width, respecting this.colorsInRow\\n   * @return {Number} size of swatch in px\\n   * @private\\n   */\\n  ColorpickerControl.prototype._calcSwatchSize = function () {\\n    var swatchSize = this.drawer.touchDevice ? this.drawer.options.toolbarSize\\n                                             : this.drawer.options.toolbarSizeTouch;\\n    swatchSize = swatchSize || this.options.minSwatchSize;\\n\\n    // calc swatch width to fit in drawer canvas\\n    var widthToFit = Math.floor(this.drawer.width * 0.95 / this.colorsInRow);\\n    // calc swatch height to fit in drawer canvas, including toolOptionsToolbar height\\n    var heightWithToolbars = this.drawer.height + this.drawer.toolbars.toolOptionsToolbar.height();\\n    var heightToFit = Math.floor(heightWithToolbars  / (this.colors.length / this.colorsInRow));\\n\\n    var minSize = Math.min(widthToFit, heightToFit);\\n    // look if colors total area is bigger then available space\\n    if (swatchSize > minSize) {\\n        swatchSize = Math.max(minSize, this.options.minSwatchSize);\\n    }\\n\\n    return swatchSize;\\n  };\\n\\n  /**\\n   * Collect sizes of needed elements\\n   * @param {jQuery} $trigger - trigger element\\n   * @returns {Object}\\n   * @private\\n   */\\n  ColorpickerControl.prototype._getAvailableSpace = function ($trigger) {\\n    var result;\\n    if ($trigger && $trigger.length) {\\n      var $canvas = this.drawer.$canvasEditContainer,\\n          $contentWrapper = this.$colorButton.$colorDropdown.closest('.popup-content-wrapper'),\\n          $toolbarWrapper = this.$colorButton.$colorDropdown.closest('.toolbar-content-wrapper'),\\n          canvasSizes = $canvas.get(0).getBoundingClientRect(),\\n          triggerSizes = $trigger.get(0).getBoundingClientRect(),\\n          toolbarSizes = $toolbarWrapper.get(0).getBoundingClientRect(),\\n          popupSizes = $contentWrapper.get(0).getBoundingClientRect(),\\n          paletteSizes = this.$colorButton.$colorDropdown.get(0).getBoundingClientRect(),\\n\\n          // arrowSize = 10,\\n          arrowSize = 0,\\n          triggerOffsetX = triggerSizes.left - canvasSizes.left,\\n          triggerOffsetY = triggerSizes.top - canvasSizes.top;\\n      result = {};\\n\\n      result.top = triggerOffsetY;\\n      result.left = triggerOffsetX;\\n      result.right = canvasSizes.width - triggerOffsetX - triggerSizes.width;\\n      result.bottom = canvasSizes.height - triggerOffsetY - triggerSizes.height;\\n\\n      result.centerX = triggerOffsetX + triggerSizes.width/2;\\n      result.centerY = triggerOffsetY + triggerSizes.height/2;\\n\\n      result.palette = {\\n        arrowSize: arrowSize,\\n        top: paletteSizes.height,\\n        bottom: paletteSizes.height,\\n        left: paletteSizes.width,\\n        right: paletteSizes.width\\n      };\\n\\n      result.popupSizes = popupSizes;\\n      result.toolbarSizes = toolbarSizes;\\n      result.paletteSizes = paletteSizes;\\n      result.canvasSizes = canvasSizes;\\n      result.triggerSizes = triggerSizes;\\n    }\\n    this.sizes = result;\\n    return result;\\n  };\\n\\n  /**\\n   * Reset palette\\n   * @private\\n   */\\n  ColorpickerControl.prototype._resetPalette = function () {\\n    this.$colorButton.$colorDropdown.removeClass('palette-with-scroll');\\n    this.$colorButton.$colorDropdown.removeAttr('style');\\n    this.$colorButton.$colorDropdown.removeAttr('data-position');\\n  };\\n\\n  /**\\n   * Set size for palette as for canvas\\n   * @private\\n   */\\n  ColorpickerControl.prototype._setFullSize = function () {\\n    var sizes = this.sizes,\\n        popupOffsetLeft = sizes.toolbarSizes.left - sizes.canvasSizes.left,\\n        popupOffsetTop = sizes.toolbarSizes.top - sizes.canvasSizes.top,\\n        styles = {};\\n\\n    styles.top = -popupOffsetTop;\\n    styles.left = -popupOffsetLeft;\\n    styles.width = sizes.canvasSizes.width;\\n    styles.height = sizes.canvasSizes.height;\\n\\n    this.$colorButton.$colorDropdown.css(styles);\\n  };\\n\\n  /**\\n   * Adjust position for popup\\n   * @param {jQuery} $element - trigger element\\n   * @private\\n   */\\n  ColorpickerControl.prototype._adjustPosition = function ($element) {\\n    this._resetPalette();\\n    var sizes = this._getAvailableSpace($element),\\n        positionFound;\\n    this.positions.forEach(function (position, i) {\\n      var positionExists = sizes[position] && sizes.palette[position];\\n      if (!positionFound && positionExists) {\\n        var neededSpace = sizes.palette[position] + sizes.palette.arrowSize,\\n            spaceIsEnough = (sizes[position] - neededSpace) > 0;\\n        positionFound = spaceIsEnough && position;\\n      }\\n    });\\n    if (positionFound) {\\n      this._movePalette(positionFound);\\n    } else {\\n      this._setFullSize();\\n    }\\n  };\\n\\n  /**\\n   * Crop unnecessary width/height\\n   * @private\\n   */\\n  ColorpickerControl.prototype._cropSizeOfPalette = function () {\\n    var paletteSizes = this.$colorButton.$colorDropdown.get(0).getBoundingClientRect(),\\n        canvasSizes = this.sizes.canvasSizes,\\n        styles = {},\\n        negativeDiffY_bottom = canvasSizes.height - (paletteSizes.height + paletteSizes.top - canvasSizes.top),\\n        negativeDiffY_top = paletteSizes.top - canvasSizes.top,\\n        negativeDiffX_right = canvasSizes.width - (paletteSizes.width + paletteSizes.left - canvasSizes.left),\\n        negativeDiffX_left = paletteSizes.left - canvasSizes.left,\\n        negativeDiffY = Math.min(negativeDiffY_bottom,negativeDiffY_top),\\n        negativeDiffX = Math.min(negativeDiffX_right,negativeDiffX_left),\\n        notEnoughSpace;\\n\\n    if (negativeDiffY < 0) {\\n      notEnoughSpace = true;\\n      styles.height = paletteSizes.height + negativeDiffY;\\n    }\\n    if (negativeDiffX < 0) {\\n      notEnoughSpace = true;\\n      styles.width = paletteSizes.width + negativeDiffX;\\n    }\\n    if (notEnoughSpace) {\\n      this.$colorButton.$colorDropdown.addClass('palette-with-scroll');\\n    }\\n\\n    this.$colorButton.$colorDropdown.css(styles);\\n  };\\n\\n  /**\\n   * Move palette to chosen direction\\n   * @param {String} position\\n   * @private\\n   */\\n  ColorpickerControl.prototype._movePalette = function (position) {\\n    var sizes = this.sizes,\\n        popupOffsetLeft = this.sizes.toolbarSizes.left - this.sizes.canvasSizes.left,\\n        popupOffsetTop = this.sizes.toolbarSizes.top - this.sizes.canvasSizes.top,\\n        isVerticalAlign,\\n        styles = {},\\n        offsetLeft,\\n        offsetTop,\\n        arrowOffsetLeft = sizes.paletteSizes.width/2,\\n        arrowOffsetTop = sizes.paletteSizes.height/2,\\n        negativeDiff,\\n        smallerThanCanvas,\\n        notEnoughSpace;\\n\\n    switch (position) {\\n      case 'left':\\n        offsetLeft = sizes.left - sizes.paletteSizes.width - sizes.palette.arrowSize;\\n        offsetTop = sizes.centerY - sizes.paletteSizes.height/2;\\n        styles.right = sizes.toolbarSizes.width - (sizes.left - popupOffsetLeft);\\n        break;\\n      case 'right':\\n        offsetLeft = sizes.canvasSizes.width - sizes.right + sizes.palette.arrowSize;\\n        offsetTop = sizes.centerY - sizes.paletteSizes.height/2;\\n        styles.left =  sizes.left - popupOffsetLeft + sizes.triggerSizes.width;\\n        break;\\n      case 'top':\\n        isVerticalAlign = true;\\n        offsetLeft = sizes.centerX - sizes.paletteSizes.width/2;\\n        offsetTop = sizes.top - sizes.paletteSizes.height - sizes.palette.arrowSize;\\n        styles.bottom = sizes.toolbarSizes.height - (sizes.top - popupOffsetTop);\\n        break;\\n      case 'bottom':\\n        isVerticalAlign = true;\\n        offsetLeft = sizes.centerX - sizes.paletteSizes.width/2;\\n        offsetTop = sizes.canvasSizes.height - sizes.bottom + sizes.palette.arrowSize;\\n        styles.top = sizes.top - popupOffsetTop + sizes.triggerSizes.height;\\n        break;\\n    }\\n\\n    if (isVerticalAlign) {\\n      negativeDiff = (offsetLeft + sizes.paletteSizes.width ) - sizes.canvasSizes.width;\\n      smallerThanCanvas = (sizes.canvasSizes.width - sizes.paletteSizes.width) > 0;\\n      if (negativeDiff > 0 && offsetLeft > 0 && !smallerThanCanvas) {\\n        arrowOffsetLeft += negativeDiff;\\n        styles.right = 0 - popupOffsetLeft;\\n      } else {\\n        if (offsetLeft < 0) {\\n          arrowOffsetLeft += offsetLeft;\\n          offsetLeft = 0;\\n        }\\n        notEnoughSpace = true;\\n        styles.width = sizes.canvasSizes.width;\\n        styles.left = offsetLeft - popupOffsetLeft;\\n      }\\n    } else {\\n      negativeDiff = (offsetTop + sizes.paletteSizes.height) - sizes.canvasSizes.height;\\n      smallerThanCanvas = (sizes.canvasSizes.height - sizes.paletteSizes.height) > 0;\\n      if (negativeDiff > 0 && offsetTop > 0 && !smallerThanCanvas) {\\n        arrowOffsetTop += negativeDiff;\\n        styles.bottom = 0 - popupOffsetTop;\\n      } else {\\n        notEnoughSpace = true;\\n        if (offsetTop < 0) {\\n          arrowOffsetTop += offsetTop;\\n          offsetTop = 0;\\n        }\\n        styles.height = sizes.canvasSizes.width;\\n        styles.top = offsetTop - popupOffsetTop;\\n      }\\n    }\\n\\n    if (notEnoughSpace) {\\n      this.$colorButton.$colorDropdown.addClass('palette-with-scroll');\\n    }\\n    this.$colorButton.$colorDropdown.attr('data-position',position);\\n    this.$colorButton.$colorDropdown.css(styles);\\n    this._cropSizeOfPalette();\\n    // this._moveArrow(arrowOffsetLeft, arrowOffsetTop);\\n  };\\n\\n\\n  /**\\n   * Adjusts color dropdown position to be inside drawer\\n   * @private\\n   */\\n  ColorpickerControl.prototype._adjustControlsPosition = function () {\\n    var notEnoughWidth = this.drawer.width < optimalSizeOfDropdown,\\n        notEnoughHeight = this.drawer.height < optimalSizeOfDropdown,\\n        smallerThanNormalSize = this.isVertical ? notEnoughHeight : notEnoughWidth,\\n        canvasContainerSizes = this.drawer.$canvasEditContainer.get(0).getBoundingClientRect(),\\n        colorButtonSizes = this.$colorButton.get(0).getBoundingClientRect(),\\n        minimumSizeDelta = 10,\\n        currDropdownSizes;\\n\\n\\n    this.$colorButton.$colorDropdown.removeAttr('style');\\n    currDropdownSizes = this.$colorButton.$colorDropdown.get(0).getBoundingClientRect();\\n\\n    if (this.isVertical) {\\n      if (smallerThanNormalSize) {\\n        this.$colorButton.$colorDropdown.css('top', 0);\\n      } else {\\n        var topOffsetOfButton = colorButtonSizes.top - canvasContainerSizes.top,\\n            newTopValue = topOffsetOfButton + colorButtonSizes.height / 2 - currDropdownSizes.height / 2;\\n        this.$colorButton.$colorDropdown.css('top', newTopValue);\\n      }\\n    } else {\\n      if (smallerThanNormalSize) {\\n        this.$colorButton.$colorDropdown.css('left', 0);\\n      } else {\\n        var leftOffsetOfButton = colorButtonSizes.left - canvasContainerSizes.left,\\n            newLeftValue = leftOffsetOfButton + colorButtonSizes.width / 2 - currDropdownSizes.width / 2;\\n        this.$colorButton.$colorDropdown.css('left', newLeftValue);\\n      }\\n    }\\n\\n    if (!smallerThanNormalSize) {\\n      currDropdownSizes = this.$colorButton.$colorDropdown.get(0).getBoundingClientRect();\\n      if (this.isVertical) {\\n        smallerThanNormalSize = (optimalSizeOfDropdown - currDropdownSizes.height) > minimumSizeDelta;\\n\\n        var topOffsetIsValid = currDropdownSizes.top > canvasContainerSizes.top,\\n            bottomOffsetIsValid = (currDropdownSizes.top + currDropdownSizes.height) < (canvasContainerSizes.top + canvasContainerSizes.height),\\n            topIsCorrect = topOffsetIsValid,\\n            bottomIsCorrect = bottomOffsetIsValid && !smallerThanNormalSize;\\n\\n        if (!topIsCorrect) {\\n          this.$colorButton.$colorDropdown.removeAttr('style');\\n          this.$colorButton.$colorDropdown.css('top', 0);\\n        }\\n        if (!bottomIsCorrect) {\\n          this.$colorButton.$colorDropdown.removeAttr('style');\\n          this.$colorButton.$colorDropdown.css({\\n            'bottom' : 0,\\n            'top': 'auto'\\n          });\\n        }\\n      } else {\\n        smallerThanNormalSize = (optimalSizeOfDropdown - currDropdownSizes.width) > minimumSizeDelta;\\n\\n        var leftOffsetIsValid = currDropdownSizes.left > canvasContainerSizes.left,\\n            rightOffsetIsValid = (currDropdownSizes.left + currDropdownSizes.width) < (canvasContainerSizes.left + canvasContainerSizes.width),\\n            leftIsCorrect = leftOffsetIsValid,\\n            rightIsCorrect = rightOffsetIsValid && !smallerThanNormalSize;\\n\\n        if (!leftIsCorrect) {\\n          this.$colorButton.$colorDropdown.removeAttr('style');\\n          this.$colorButton.$colorDropdown.css('left', 0);\\n        }\\n        if (!rightIsCorrect) {\\n          this.$colorButton.$colorDropdown.removeAttr('style');\\n          this.$colorButton.$colorDropdown.css({\\n            'right' : 0,\\n            'left': 'auto'\\n          });\\n        }\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Get html of color control\\n   * @returns {String}\\n   * @private\\n   */\\n  ColorpickerControl.prototype._getControlHtml = function () {\\n    var colorLabelText = this.options.colorText || \\\"\\\";\\n    return '<li class=\\\"colorpicker-control\\\" ' +\\n              'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n              '>' +\\n            '<span class=\\\"toolbar-label\\\" ' +\\n                  'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n                  'data-editable-canvas-cssrules=\\\"line-height\\\">' +\\n                  this.drawer.t(colorLabelText) + ' ' + '</span>' +\\n            '<span class=\\\"color-indicator\\\" ' +\\n                  'data-editable-canvas-sizeable=\\\"toolbar-button\\\" ' +\\n                  'data-editable-canvas-cssrules=\\\"width\\\"></span>' +\\n            '<span class=\\\"color-dropdown control-hidden hidden\\\" ' +\\n                  'data-editable-canvas-sizeable=\\\"toolbar-button\\\"></span>' +\\n          '</li>';\\n\\n  };\\n\\n    /**\\n     * Creates swatch - square control with given color\\n     *\\n     * @param  {String} color\\n     * @param  {String} _class css class\\n     * @return {jQuery}\\n     * @private\\n     */\\n  ColorpickerControl.prototype._createSwatch = function (color, _class) {\\n      var $swatch = $('<a href=\\\"#\\\"></a>');\\n      $swatch.attr('rel', color)\\n             .addClass('color-swatch')\\n             .css({'background-color': color});\\n\\n      if (_class) {\\n        $swatch.addClass(_class);\\n      }\\n\\n    // bind click\\n      util.bindClick($swatch, 'colorpicker', this._swatchClickHandler.bind(this));\\n\\n      return $swatch;\\n    };\\n\\n\\n    /**\\n     * Swatch click handler.\\n     * Calls onColorSelected()\\n     * Prevents default click on <a> behavior.\\n     *\\n     * @param  {jQuery.Event} e\\n     * @private\\n     */\\n    ColorpickerControl.prototype._swatchClickHandler = function(e) {\\n      e.preventDefault();\\n      e.stopPropagation();\\n\\n      var clickedColorValue = $(e.target).attr('rel');\\n      this.onColorSelected(clickedColorValue);\\n      return false;\\n    };\\n\\n    /**\\n     * Creates swatch for transparent  color\\n     * @return {jQuery}\\n     * @private\\n     */\\n    ColorpickerControl.prototype._createTransparentSwatch = function() {\\n        var $swatch = this._createSwatch(this.TRANSPARENT, 'transparent');\\n        $swatch.text(this.drawer.t('Transparent'));\\n\\n        if (!this.shouldDisplayTransparent) {\\n          $swatch.hide();\\n        }\\n\\n        return $swatch;\\n    };\\n\\n  /**\\n   * Show color dropdown\\n   * @param {jQuery} [$trigger] - trigger element\\n   */\\n  ColorpickerControl.prototype.showColorDropdown = function ($trigger) {\\n    // Not used with HTML5 color input\\n    return;\\n  };\\n\\n  /**\\n   * Hide color dropdown\\n   */\\n  ColorpickerControl.prototype.hideColorDropdown = function () {\\n    this.colorDropdownVisible = false;\\n    if (this.$colorButton && this.$colorButton.$colorDropdown) {\\n      this.$colorButton.$colorDropdown.addClass('hidden');\\n      this.$colorButton.$colorDropdown.addClass('control-hidden');\\n    }\\n    if (this.$cloneControl) {\\n      this.$cloneControl.remove();\\n    }\\n  };\\n\\n  /**\\n   * Toggle state of color dropdown\\n   * @param {jQuery} [$trigger]\\n   */\\n  ColorpickerControl.prototype.toggleColorDropdown = function ($trigger) {\\n    // Not used with HTML5 color input\\n    return;\\n  };\\n\\n\\n  pluginsNamespace.ColorpickerControl = ColorpickerControl;\\n\\n}(jQuery, Easel.plugins, Easel.util));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-overcanvas-popup/OvercanvasPopup.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/PRect.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/BaseBrush.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/ErasableArrow.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/fabricjs_extensions/Line.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-fullscreen/Fullscreen.js\"))","module.exports = \"  /**\\n   * Toolbar with floating buttons\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * @param {Object} [options]\\n   * @extends EaselToolbar\\n   * @constructor\\n   */\\n  var MinimizedToolbar = function (drawerInstance, options) {\\n    options = options || {};\\n    // css class for toolbar\\n    options.toolbarClass = 'tool-minimized-toolbar';\\n    // call EaselToolbar c-tor\\n    EaselToolbar.call(this, drawerInstance, options);\\n    // cry loud of birth\\n    drawerInstance.trigger(drawerInstance.EVENT_MINIMIZED_TOOLBAR_CREATED, [this]);\\n  };\\n\\n  MinimizedToolbar.prototype = Object.create(EaselToolbar.prototype);\\n  MinimizedToolbar.prototype.constructor = EaselToolbar;\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextAlign.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-circle/Circle.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/EaselToolbarManager.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/brush-eraser/EraserBrush.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-diamond/Diamond.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-line/Line.js\"))","module.exports = \"(function ($, pluginsNamespace, util, BaseTextOptionTool) {\\n  'use strict';\\n\\n  /**\\n   * Creates controls for changing font family;\\n   *\\n   * @param drawer\\n   * Instance of drawer\\n   * @param {Object} options\\n   * Configuration object.\\n   * @param {Object} options.fonts\\n   * Specifies the list of fonts available to select.\\n   * The format is:\\n   *\\n   * <code>\\n   * <pre class=\\\"prettyprint javascript\\\">\\n   *   {\\n   *    'Font display name': 'Font-family CSS value'\\n   *   }\\n   * </pre>\\n   * </code>\\n   *\\n   * Example:\\n   *\\n   * <code>\\n   * <pre class=\\\"prettyprint javascript\\\">\\n   * fonts: {\\n   *     'Georgia': 'Georgia, serif',\\n   *     'Palatino': \\\"'Palatino Linotype', 'Book Antiqua', Palatino, serif\\\",\\n   *     'Times New Roman': \\\"'Times New Roman', Times, serif\\\"\\n   * }\\n   * </pre>\\n   * </code>\\n   *\\n   *\\n   * @param {String} options.defaultFont\\n   * Default font display name from <code>fonts</code> config\\n   * that will be selected when edit mode activates.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTextOptionTool\\n   */\\n\\n  var TextFontFamily = function TextFontFamilyConstructor(drawer, options) {\\n    BaseTextOptionTool.call(this, drawer);\\n\\n    this._setupOptions(options);\\n\\n    this.activeFont = this.options.fonts[this.options.defaultFont];\\n    this.drawer.on(this.drawer.EVENT_TEXT_GET_STYLES, this._onGetStyles.bind(this));\\n  };\\n\\n  TextFontFamily.prototype = Object.create(BaseTextOptionTool.prototype);\\n  TextFontFamily.prototype.constructor = BaseTextOptionTool;\\n\\n  TextFontFamily.prototype.name = 'TextFontFamily';\\n  TextFontFamily.prototype.optionName = 'TextFontFamily';\\n  TextFontFamily.prototype.buttonIconClass = 'fa-font';\\n  TextFontFamily.prototype.focusTextOnChange = true;\\n  TextFontFamily.prototype.onlyPredefined = true;\\n  TextFontFamily.prototype.valueType = {\\n    fontFamily: 'string'\\n  };\\n\\n  TextFontFamily.prototype._defaultOptions = {\\n    defaultValues: {\\n      fontFamily: 'Georgia'\\n    },\\n    fonts: {\\n      'Georgia': 'Georgia, serif',\\n      'Palatino': \\\"'Palatino Linotype', 'Book Antiqua', Palatino, serif\\\",\\n      'Times New Roman': \\\"'Times New Roman', Times, serif\\\",\\n\\n      'Arial': 'Arial, Helvetica, sans-serif',\\n      'Arial Black': \\\"'Arial Black', Gadget, sans-serif\\\",\\n      'Comic Sans MS': \\\"'Comic Sans MS', cursive, sans-serif\\\",\\n      'Impact': 'Impact, Charcoal, sans-serif',\\n      'Lucida Grande': \\\"'Lucida Sans Unicode', 'Lucida Grande', sans-serif\\\",\\n      'Tahoma': 'Tahoma, Geneva, sans-serif',\\n      'Trebuchet MS': \\\"'Trebuchet MS', Helvetica, sans-serif\\\",\\n      'Verdana': 'Verdana, Geneva, sans-serif',\\n\\n      'Courier New': \\\"'Courier New', Courier, monospace\\\",\\n      'Lucida Console': \\\"'Lucida Console', Monaco, monospace\\\"\\n    },\\n    defaultFont: 'Georgia'\\n  };\\n\\n  TextFontFamily.prototype.changeFont = function (fontFamilyName, withoutSetStyles) {\\n    var _this = this;\\n\\n    _this.activeFont = _this.options.fonts[fontFamilyName];\\n\\n    if (!withoutSetStyles) {\\n      _this.setStyles({\\n        fontFamily: _this.activeFont\\n      });\\n    }\\n\\n    _this.$toolControl.find('.editable-canvas-fontfamily').css('font-family', _this.activeFont);\\n    _this.$toolControl.find('.editable-canvas-fontfamily').text(fontFamilyName || '');\\n    _this.$toolControl.find('.fonts-dropdown').addClass('hidden');\\n  };\\n\\n  TextFontFamily.prototype.updateSingleControl = function (valueName, value) {\\n    if (valueName === 'fontFamily') {\\n        var font = this.getFontByCss(value);\\n        this.changeFont(font, true);\\n    }\\n  };\\n\\n  TextFontFamily.prototype._collectDefaultOptions = function (pluginName) {\\n    var textConfig = this.drawer.getPluginConfig('Text'),\\n        result = {\\n          fonts: $.extend(true, {}, textConfig.fonts || {}),\\n          defaultFont: textConfig.defaultFont\\n        };\\n    return result;\\n  };\\n\\n  TextFontFamily.prototype._onGetStyles = function (fEvent, tool, result) {\\n    result = result || {};\\n    result.defaultValues =  result.defaultValues || {};\\n    result.defaultValues.fontFamily = this.options.fonts[this.options.defaultFont];\\n  };\\n\\n  /**\\n   * Get font family from css string\\n   * @param {string} fontCssString\\n   * @returns {*}\\n   */\\n  TextFontFamily.prototype.getFontByCss = function (fontCssString) {\\n    var fName = null;\\n    $.each(this.options.fonts, function (fontName, fontCss) {\\n      if (fontCss == fontCssString) {\\n        fName = fontName;\\n      }\\n    });\\n    return fName;\\n  };\\n\\n  TextFontFamily.prototype.setupControl = function (toolbar, $toolControl, changeCallback) {\\n    var _this = this;\\n    util.bindClick(\\n        $toolControl.find('.toolbar-label'), 'fontFamily',\\n        function () {\\n          $toolControl.find('.fonts-dropdown').toggleClass('hidden');\\n        });\\n\\n    //\\n    $toolControl.find('li a').each(function (i, fontItem) {\\n      var $fontItem = $(fontItem);\\n      util.bindClick($fontItem, 'fontFamily',\\n          function () {\\n            var fname = $(this).data('fontName');\\n            _this.changeFont(fname);\\n          });\\n    });\\n  };\\n\\n  TextFontFamily.prototype.controlTemplate = function () {\\n    var result,\\n        $predefined = '',\\n        selectHtml;\\n\\n    $.each(this.options.fonts, function (fontName, fontCss) {\\n      var fontItem = '' +\\n      '<option ' +\\n        'style=\\\"font-family: ' + fontCss + ';\\\"' +\\n        'value=\\\"' + fontName + '\\\"' +\\n        'data-font-name=\\\"' + fontName + '\\\">' +\\n          fontName +\\n      '</option>';\\n\\n      $predefined += fontItem;\\n    });\\n\\n    selectHtml = '' +\\n        '<select ' +\\n          'class=\\\"editable-canvas-text-fontfamily-input controls-value-item\\\" ' +\\n          'name=\\\"drawer-size\\\"' +\\n          'data-name=\\\"fontFamily\\\"' +\\n          'value=\\\"' + this.options.defaultValues.fontFamily + '\\\">' +\\n            $predefined +\\n        '</select>';\\n\\n    var optionItemDefaultClasses = 'toolbar-item-wrapper editable-canvas-text-option editable-canvas-text-fontfamily hidden',\\n        optionItemAdditionalClasses = this.buttonMode ? ' toolbar-button-item ': '',\\n        optionItemClasses = optionItemDefaultClasses + optionItemAdditionalClasses;\\n\\n    result = '' +\\n        '<li class=\\\"' + optionItemClasses + '\\\">' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n        '<span class=\\\"toolbar-item-label\\\">' +\\n        this.drawer.t('Font family:') + ' ' +\\n        '</span>' +\\n        '<span class=\\\"toolbar-item-valueholder\\\"></span>' +\\n        '<span class=\\\"toolbar-item-icon fa ' + this.buttonIconClass + '\\\"></span>' +\\n        '</div>' +\\n        '<div class=\\\"toolbar-dropdown-block collapsed\\\">' +\\n        selectHtml +\\n        '</div>' +\\n        '</li>';\\n\\n    return result;\\n  };\\n\\n  pluginsNamespace.TextFontFamily = TextFontFamily;\\n}(jQuery, Easel.plugins, Easel.util, Easel.plugins.BaseTextOptionTool));\"","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions, util) {\\n  'use strict';\\n\\n  /**\\n   * Provides opacity input for changing shapes/brush opacity.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options - Configuration object\\n   * @param {Number} options.defaultValue - Default opacity value\\n   *\\n   *\\n   * @constructor\\n   * @memberof Easel.options\\n   * @extends {Easel.plugins.BaseToolOptions}\\n   */\\n  var OpacityOption = function OpacityOptionConstructor(drawer, options) {\\n    // call super c-tor\\n    BaseToolOptions.call(this, drawer);\\n    this._setupOptions(options);\\n  };\\n\\n  OpacityOption.prototype = Object.create(BaseToolOptions.prototype);\\n  OpacityOption.prototype.constructor = BaseToolOptions;\\n\\n  OpacityOption.prototype.optionName = 'opacity';\\n\\n\\n  OpacityOption.prototype._defaultOptions = {\\n    defaultValue: 1,\\n    alwaysVisible: true\\n  };\\n\\n  OpacityOption.prototype.createControls = function (toolbar) {\\n    this.createControl(toolbar, this.setOpacity.bind(this));\\n  };\\n\\n  /**\\n   * Create controls.\\n   * @param {EaselToolbar} toolbar\\n   * @param {Function} [opacityChangeCallback]\\n   * @returns {jQuery}\\n   */\\n  OpacityOption.prototype.createControl = function (toolbar, opacityChangeCallback) {\\n    this.toolbar = toolbar;\\n    this.opacityChangeCallback = opacityChangeCallback;\\n\\n    this.$opacityControl = $(\\n        '<li class=\\\"editable-canvas-opacity-option toolbar-item-range list-item-range\\\">' +\\n          '<div class=\\\"toolbar-item-description\\\">' +\\n            '<span class=\\\"toolbar-label editable-canvas-opacity-option-label\\\">' +\\n            this.drawer.t('Opacity :') + ' ' +\\n            '</span>' +\\n            '<span class=\\\"toolbar-label toolbar-label-indicator editable-canvas-opacity-option-indicator\\\">' +\\n              '100%' +\\n            '</span>' +\\n          '</div>' +\\n        '<input class=\\\"editable-canvas-opacity-option-input\\\" ' +\\n        'type=\\\"range\\\" name=\\\"drawer-size\\\" min=\\\"0\\\" max=\\\"100\\\"' +\\n        'value=\\\"100\\\" />' +\\n        '</li>');\\n\\n    this.$opacityIndicator = this.$opacityControl.find('.editable-canvas-opacity-option-indicator');\\n    toolbar.addControl(this.$opacityControl, this.options.buttonOrder);\\n    this.$opacityControl.on('input change', this._onOpacityChange.bind(this));\\n    return this.$opacityControl;\\n  };\\n\\n\\n  /**\\n   * Set opacity value\\n   * @private\\n   */\\n  OpacityOption.prototype.setOpacity = function (value) {\\n    var fCanvas = this.drawer.fCanvas,\\n        activeFabricObject = fCanvas.getActiveObject();\\n\\n    this.drawer.setOpacity(value);\\n    if (activeFabricObject) {\\n      activeFabricObject.setOpacity(value);\\n      fCanvas.renderAll();\\n    }\\n  };\\n\\n  /**\\n   * This function is called every time user changes opacity via control\\n   * @private\\n   */\\n  OpacityOption.prototype._onOpacityChange = function () {\\n    var $opacityInput = $(this.$opacityControl).find('input'),\\n        rawValue = parseInt($opacityInput.val(), 10),\\n        rawValueIsValid = typeof rawValue === 'number' && isFinite(rawValue),\\n        validatedValue = rawValueIsValid ? rawValue : this.options.defaultOpacity,\\n        formattedValue = parseInt(validatedValue, 10) + '%';\\n    this._opacity = validatedValue / 100;\\n\\n    this.$opacityIndicator.text(formattedValue);\\n\\n    if (this.opacityChangeCallback) {\\n      this.opacityChangeCallback(this._opacity);\\n    }\\n  };\\n\\n  OpacityOption.prototype.collectDataFromObject = function (target) {\\n    var result = {};\\n    result.opacity = target.get('opacity');\\n    this.data = result;\\n    return result;\\n  };\\n\\n  OpacityOption.prototype.updateControls = function (dataToFill) {\\n    dataToFill = dataToFill || this.data;\\n\\n    var rawValue = dataToFill.opacity,\\n        rawValueIsValid = typeof rawValue === 'number' && isFinite(rawValue),\\n        validatedValue = rawValueIsValid ? rawValue : this.options.defaultOpacity,\\n        formattedValue = parseInt(validatedValue*100, 10) + '%';\\n    this.drawer.activeOpacity = validatedValue;\\n    this.$opacityControl.find('input').val(validatedValue*100);\\n    this.$opacityControl.find('.editable-canvas-opacity-option-indicator').text(formattedValue);\\n  };\\n\\n  OpacityOption.prototype.showControls = function () {\\n    this.$opacityControl.removeClass('hidden');\\n  };\\n\\n  OpacityOption.prototype.hideControls = function (force) {\\n    var alwaysVisible = this.drawer.options.toolbars.popupButtonAlwaysVisible || this.options.alwaysVisible;\\n    if (force || !alwaysVisible) {\\n      this.$opacityControl.addClass('hidden');\\n    }\\n  };\\n\\n  pluginsNamespace.OpacityOption = OpacityOption;\\n\\n}(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions, Easel.util));\\n\"","module.exports = \"(function (global, $, pluginsNamespace) {\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {});\\n\\n  /**\\n   * @param {Easel.Easel} drawer\\n   * @param {Object} [options]\\n   * @memberof Easel.plugins\\n   * @constructor\\n   */\\n  var ZoomViewport = function ZoomViewportConstr(drawer, options) {\\n    this.drawer = drawer;\\n    this.i = 0;\\n    this.position = new fabric.Point(0, 0);\\n\\n    this.zoom = 1;\\n    return this;\\n  };\\n\\n  /**\\n   * Set zoom depending on last settings\\n   * @param {Number} newZoom - zoom value\\n   * @param {Number} x - x coordinate of zoom center point\\n   * @param {Number} y - y coordinate of zoom center point\\n   * @param {Boolean} [strict] - do not change given coords\\n   * @returns {Object}\\n   */\\n  ZoomViewport.prototype.setViewport = function (newZoom, x, y, strict) {\\n    this._adjustPosition(newZoom, x, y, strict);\\n    this._render();\\n    return this.getData();\\n  };\\n\\n  /**\\n   * Get current viewport data\\n   * @returns {Object}\\n   */\\n  ZoomViewport.prototype.getData = function () {\\n    var data = {},\\n        zoomCenter = this.getZoomCenter();\\n    data.zoom = this.zoom;\\n    data.position = {\\n      x: this.position.x,\\n      y: this.position.y\\n    };\\n    data.zoomCenterX = zoomCenter.x;\\n    data.zoomCenterY = zoomCenter.y;\\n    return data;\\n  };\\n\\n  /**\\n   * Get zoom center coords\\n   * @returns {Object}\\n   */\\n  ZoomViewport.prototype.getZoomCenter = function () {\\n    var result = {},\\n        width = this.drawer.width,\\n        height = this.drawer.height,\\n        availableX = width / this.zoom,\\n        availableY = height / this.zoom,\\n        zoomCenterX = availableX / 2 - this.position.x,\\n        zoomCenterY = availableY / 2 - this.position.y;\\n\\n    result.x = zoomCenterX;\\n    result.y = zoomCenterY;\\n    return result;\\n  };\\n\\n  /**\\n   *\\n   * @param {Number} zoom - zoom value\\n   * @param {Number} x - x offset of canvas\\n   * @param {Number} y - y offset of canvas\\n   * @returns {{x: (number), y: (number)}}\\n   * @private\\n   */\\n  ZoomViewport.prototype._validatePosition = function (zoom, x, y) {\\n    x = x || 0;\\n    y = y || 0;\\n    var width = this.drawer.width,\\n        height = this.drawer.height,\\n        availableX = width / zoom,\\n        availableY = height / zoom,\\n        maxPositionX = width - availableX,\\n        maxPositionY = height - availableY;\\n    if (x < -maxPositionX) {\\n      x = -maxPositionX;\\n    }\\n    if (y < -maxPositionY) {\\n      y = -maxPositionY;\\n    }\\n    if (x > 0) {\\n      x = 0;\\n    }\\n    if (y > 0) {\\n      y = 0;\\n    }\\n    return {\\n      x: x,\\n      y: y\\n    };\\n  };\\n\\n  /**\\n   * @param {Number} [zoom]\\n   */\\n  ZoomViewport.prototype.setToCenterOfCanvas = function (zoom) {\\n    zoom = zoom || this.zoom;\\n    var halfWidth = this.drawer.width / 2,\\n        halfHeight = this.drawer.height / 2;\\n\\n    this._adjustPosition(zoom, halfWidth, halfHeight, true);\\n    this._render();\\n  };\\n\\n  /**\\n   * Render canvas\\n   * @private\\n   */\\n  ZoomViewport.prototype._render = function () {\\n    this.drawer.fCanvas.renderAll();\\n  };\\n\\n  /**\\n   * Update position values\\n   * @param {Number} zoom - zoom value\\n   * @param {Number} x - x offset of canvas\\n   * @param {Number} y - y offset of canvas\\n   */\\n  ZoomViewport.prototype.setPosition = function (zoom, x, y) {\\n    zoom = zoom || this.zoom;\\n    var validatedPoint = this._validatePosition(zoom, x, y);\\n    this.position.x = validatedPoint.x;\\n    this.position.y = validatedPoint.y;\\n    this.zoom = zoom;\\n  };\\n\\n  /**\\n   * Process coordinates of center point\\n   * @param {Number} newZoom - zoom value\\n   * @param {Number} x - x coordinate of zoom center point\\n   * @param {Number} y - y coordinate of zoom center point\\n   * @param {Boolean} [strict] - do not change given coords\\n   * @private\\n   */\\n  ZoomViewport.prototype._adjustPosition = function (newZoom, x, y, strict) {\\n    this.position.x = this.position.x || 0;\\n    this.position.y = this.position.y || 0;\\n    var width = this.drawer.width,\\n        height = this.drawer.height,\\n        k = newZoom / this.zoom,\\n        oldAvailableX = width / this.zoom,\\n        oldAvailableY = height / this.zoom,\\n        newAvailableX = width / newZoom,\\n        newAvailableY = height / newZoom,\\n        newX,\\n        newY;\\n\\n    if (strict) {\\n      newX = newAvailableX/2 - x;\\n      newY = newAvailableY/2 - y;\\n    } else {\\n      if (x !== undefined && y !== undefined) {\\n        var deltaX = (x - width / 2) / this.zoom,\\n            deltaY = (y - width / 2) / this.zoom;\\n        newX = this.position.x - deltaX - ((oldAvailableX - newAvailableX ) / 2);\\n        newY = this.position.y - deltaY - ((oldAvailableY - newAvailableY ) / 2);\\n      } else {\\n        newX = width / 2 - k * (width / 2 - this.position.x);\\n        newY = height / 2 - k * (height / 2 - this.position.y);\\n      }\\n    }\\n    this.setPosition(newZoom, newX, newY);\\n    return this.position;\\n  };\\n\\n  pluginsNamespace.ZoomViewport = ZoomViewport;\\n}(this, jQuery, Easel.plugins));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Canvas.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-arrow/ArrowShape.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-polygon/Polygon.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/feature-image-crop/ImageCropPlugin.js\"))","module.exports = \"/**\\n * Toolbar where will be close, move, fullscreen, open settigs buttons.\\n *\\n * @param {Easel.Easel} drawerInstance\\n * @param {Object} [options]\\n * @extends EaselToolbar\\n * @constructor\\n */\\nvar SettingsToolbar = function (drawerInstance, options) {\\n  options = options || {};\\n  options.toolbarClass = 'tool-settings-toolbar';\\n  // call super c-tor\\n  EaselToolbar.call(this, drawerInstance, options);\\n\\n  // create default buttons for tghi toolbart\\n  this._createDefaultButtons();\\n\\n  // Trigger event\\n  drawerInstance.trigger(drawerInstance.EVENT_CONFIG_TOOLBAR_CREATED, [this]);\\n};\\n\\nSettingsToolbar.prototype = Object.create(EaselToolbar.prototype);\\nSettingsToolbar.prototype.constructor = EaselToolbar;\\n\\n\\n/**\\n * Creates defaults buttons : close.\\n * @private\\n */\\nSettingsToolbar.prototype._createDefaultButtons = function() {\\n};\\n\\n\"","module.exports = \"(function (window, $, util, utilPlugins) {\\n  'use strict';\\n\\n  /**\\n   * @typeDef {Object} returnObj\\n   * @memberOf Easel.utilPlugins.Tooltip\\n   * @property {Easel.utilPlugins.Tooltip} instance - Instance of tooltip plugin\\n   * @property {jQuery} $trigger - Trigger element\\n   * @property {Easel.utilPlugins.Tooltip#destroy} destroy - Destroy instance\\n   * @property {Easel.utilPlugins.Tooltip#adjustPosition} adjustPosition - Refresh/change position\\n   * @property {Easel.utilPlugins.Tooltip#hideTooltip} hideTooltip - Hide tooltip func\\n   * @property {Easel.utilPlugins.Tooltip#showTooltip} showTooltip - Show tooltip func\\n   **/\\n\\n  /**\\n   * Plugin that provide ability to create tooltip for any element. Position/styles of tooltip are configurable.\\n   * Can be used as jQuery plugin - $.fn.EaselTooltip\\n   * @param {HTMLElement} element - trigger element\\n   * @param {Easel.utilPlugins.Tooltip.defaultOptions} [options] - configuration object\\n   * @returns {Easel.utilPlugins.Tooltip.returnObj}\\n   * @memberOf Easel.utilPlugins\\n   * @constructs Tooltip\\n   */\\n  var Tooltip = function(element, options){\\n    this.$element = $(element);\\n\\n    this._setupOptions(options);\\n    this._processOptions();\\n    this._setupTooltip();\\n    this._attachEventHandlers();\\n\\n    return {\\n      instance: this,\\n      $trigger: this.$element,\\n      adjustPosition: this.adjustPosition.bind(this),\\n      destroy: this.destroy.bind(this),\\n      hideTooltip: this.hideTooltip.bind(this),\\n      showTooltip: this.showTooltip.bind(this)\\n    };\\n  };\\n\\n  /**\\n   * @memberOf Easel.utilPlugins.Tooltip\\n   * @typeDef {Object} defaultOptions\\n   * @property {String} defaultClass=\\\"editable-canvas-tooltip\\\" - Tooltip class\\n   * @property {String} defaultPositionX=\\\"center\\\" - Default horizontal position. Can be left/right/center\\n   * @property {String} defaultPositionY=\\\"bottom\\\" - Default vertical position. Can be top/left/center\\n   * @property {String} additionalClass - Tooltip additional class\\n   * @property {String} text - Text of tooltip\\n   * @property {Object} styleObj - Any valid css object\\n   * @property {String} style - inline style of tooltip. Will be overrided if styleObj is defined\\n   * @property {String} position - Position of tooltip. Any combination of left/right/center for horizontal and\\n   * top/bottom/center for vertical. Valid values - \\\"left\\\", \\\"right top\\\", \\\"bottom left\\\", \\\"top center\\\", \\\"top\\\", etc.\\n   * @property {jQuery} $tooltipWrapper - Wrapper element for tooltip\\n   * @property {String} tooltipWrapperSelector - Selector of wrapper element for tooltip.\\n   * Will be overrided if $tooltipWrapper if defined.\\n   *\\n   **/\\n\\n  /**\\n   *\\n   * @type {Easel.utilPlugins.Tooltip.defaultOptions}\\n   * @private\\n   */\\n  Tooltip.prototype._defaultOptions = {\\n    defaultClass: 'editable-canvas-tooltip',\\n    defaultPositionX: 'center',\\n    defaultPositionY: 'bottom',\\n    additionalClass: '',\\n    text: '',\\n    position: '',\\n    style: '',\\n    styleObj: {},\\n    $tooltipWrapper: '',\\n    tooltipWrapperSelector: undefined\\n  };\\n\\n  /**\\n   * Tooltip is enabled\\n   * @type {boolean}\\n   * @private\\n   */\\n  Tooltip.prototype.enabled = true;\\n\\n  /**\\n   * Default tooltip wrapper\\n   * @type {string}\\n   * @private\\n   */\\n  Tooltip.prototype._defaultWrapper = 'body';\\n\\n  /**\\n   * Namespace string for events\\n   * @type {string}\\n   * @private\\n   */\\n  Tooltip.prototype._eventsNamespace = '.drawerTooltip';\\n\\n  /**\\n   * Indicates that tooltip is not displayed yet\\n   * @type {boolean}\\n   * @private\\n   */\\n  Tooltip.prototype._firstShow = true;\\n\\n\\n  /**\\n   * Setup options\\n   * @param {Tooltip.defaultOptions | Object} [options] - Configuration object\\n   * @returns {Tooltip.defaultOptions}\\n   * @private\\n   */\\n  Tooltip.prototype._setupOptions = function(options) {\\n    var optionsFromElement = this._collectOptionsFromElement();\\n    this.options = $.extend(true, {}, this._defaultOptions || {}, optionsFromElement || {}, options || {});\\n    this._initialOptions = $.extend(true, {}, options);\\n    this._initialOptionsFromElement = $.extend(true, {}, optionsFromElement);\\n    return this.options;\\n  };\\n\\n\\n  /**\\n   * Check if jQuery element exists\\n   * @param {jQuery} [element]\\n   * @returns {jQuery|undefined}\\n   * @private\\n   */\\n  Tooltip.prototype._checkElement = function(element) {\\n    var result,\\n        $element;\\n    if (typeof element === 'string') {\\n      $element = $(element);\\n    }\\n    if (element instanceof $) {\\n      $element = element;\\n    }\\n    if ($element && $element.length) {\\n      result = $element.eq(0);\\n    }\\n    return result;\\n  };\\n  \\n  /**\\n   * Process collected options\\n   * @private\\n   */\\n  Tooltip.prototype._processOptions = function() {\\n    var $tooltipWrapper = this._checkElement(this.options.$tooltipWrapper),\\n        $tooltipWrapperFromSelector = this._checkElement(this.options.tooltipWrapperSelector),\\n        $defaultWrapper = this._checkElement(this._defaultWrapper);\\n\\n    this.$tooltipWrapper = $tooltipWrapper || $tooltipWrapperFromSelector || $defaultWrapper;\\n  };\\n\\n\\n  /**\\n   * Setup tooltip element\\n   * @private\\n   */\\n  Tooltip.prototype._setupTooltip = function() {\\n    var tooltipHtml = this._generateTemplate(),\\n        $tooltip = $(tooltipHtml);\\n\\n    if (this.options.styleObj) {\\n      $tooltip.css(this.options.styleObj);\\n    }\\n    this.$element.addClass('tooltip-trigger');\\n    this.$element.data('EaselTooltip', this);\\n    this.$tooltipWrapper.append($tooltip);\\n    this.$tooltip = $tooltip;\\n  };\\n\\n  /**\\n   * Generate html of tooltip\\n   * @returns {string}\\n   * @private\\n   */\\n  Tooltip.prototype._generateTemplate = function () {\\n    var html,\\n        content = this.options.text || '',\\n        classString = this.options.defaultClass + ' ' + this.options.additionalClass,\\n        styleString = this.options.style || '';\\n\\n    html = '' +\\n        '<span ' +\\n          'class=\\\"' + classString + '\\\"' +\\n          'style=\\\"' + styleString + '\\\"' +\\n        '>' +\\n        content +\\n        '</span>';\\n\\n    return html;\\n  };\\n\\n  /**\\n   * Setup/attach event handlers\\n   * @private\\n   */\\n  Tooltip.prototype._attachEventHandlers = function() {\\n    var self = this,\\n        $trigger = this.$element;\\n    this._detachEventHandlers();\\n    $trigger.on('mouseenter' + this._eventsNamespace, function (e) {\\n      var $eventTrigger = $(e.currentTarget),\\n          $body = $('body'),\\n          isMoving = $body.hasClass('easel-moving'),\\n          isResizing = $body.hasClass('easel-resizing'),\\n          tooltipIsDisabled = $trigger.hasClass('disabled'),\\n          ignore = isMoving || isResizing || tooltipIsDisabled;\\n      if (!ignore) {\\n        self.showTooltip($eventTrigger);\\n      }\\n    });\\n    $trigger.on('mouseout' + this._eventsNamespace, function () {\\n      self.hideTooltip();\\n    });\\n  };\\n\\n  /**\\n   * Detach event handlers\\n   * @private\\n   */\\n  Tooltip.prototype._detachEventHandlers = function() {\\n    this.$element.off('mouseenter' + this._eventsNamespace);\\n    this.$element.off('mouseout' + this._eventsNamespace);\\n  };\\n\\n  /**\\n   * Helper function which provides ability to parse string for position values\\n   * @param {String} position\\n   * @returns {Object}\\n   * @private\\n   */\\n  Tooltip.prototype._parsePositionString = function(position) {\\n    position = position || this.options.position || '';\\n    var result = {},\\n        haveAxisX = position.indexOf('right') !== -1 || position.indexOf('left') !== -1,\\n        positionX = haveAxisX && (position.indexOf('right') !== -1 ? 'right' : 'left'),\\n        haveAxisY = position.indexOf('top') !== -1 || position.indexOf('bottom') !== -1,\\n        positionY = haveAxisY && (position.indexOf('top') !== -1 ? 'top' : 'bottom');\\n\\n\\n    positionX = positionX || (haveAxisY ? 'center' : this.options.defaultPositionX);\\n    positionY = positionY || (haveAxisX ? 'center' : this.options.defaultPositionY);\\n\\n    result.positionX = positionX;\\n    result.positionY = positionY;\\n    \\n    return result;\\n  };\\n\\n  /**\\n   * \\n   * @param onlyClasses\\n   * @private\\n   */\\n  Tooltip.prototype._resetTooltip = function(onlyClasses) {\\n    \\n  };\\n  \\n  /**\\n   * Adjust tooltip position\\n   * @param {String|undefined} [positionString] - Position of tooltip. Any combination of left/right/center for horizontal and\\n   * top/bottom/center for vertical. Valid values - \\\"left\\\", \\\"right top\\\", \\\"bottom left\\\", \\\"top center\\\", \\\"top\\\", etc.\\n   * @param {jQuery} [$trigger] - trigger element\\n   */\\n  Tooltip.prototype.adjustPosition = function(positionString, $trigger) {\\n    if (!this.enabled) {\\n      return;\\n    }\\n    $trigger = $trigger || this.$element;\\n    var position = this._parsePositionString(positionString),\\n        $tooltip = this.$tooltip;\\n\\n    var top = 0;\\n    var left = 0;\\n\\n    var arrowSize = 8,\\n        triggerSizes = $trigger.get(0).getBoundingClientRect(),\\n        tooltipSizes = $tooltip.get(0).getBoundingClientRect(),\\n        //use just document scroll because tooltips are relative to document\\n        scroll = {\\n            left: $(document).scrollLeft(),\\n            top: $(document).scrollTop(),\\n        };\\n    \\n    switch (position.positionX) {\\n      case 'right':\\n        left = scroll.left + triggerSizes.left + triggerSizes.width + arrowSize;\\n        break;\\n      case 'left':\\n        left = scroll.left + triggerSizes.left - tooltipSizes.width - arrowSize;\\n        break;\\n      default:\\n        left = scroll.left + triggerSizes.left + (triggerSizes.width - tooltipSizes.width)/2 ;\\n        break;\\n    }\\n    \\n    switch (position.positionY) {\\n      case 'top':\\n        top = scroll.top + triggerSizes.top - tooltipSizes.height - arrowSize;\\n        break;\\n      case 'bottom':\\n        top = scroll.top + triggerSizes.top + triggerSizes.height + arrowSize;\\n        break;\\n      default:\\n        top = scroll.top + triggerSizes.top + (triggerSizes.height - tooltipSizes.height)/2;\\n        break;\\n    }\\n\\n    $tooltip.attr('positionX',position.positionX);\\n    $tooltip.attr('positionY',position.positionY);\\n    $tooltip.css({\\n      top: top + 'px',\\n      left: left + 'px'\\n    });\\n  };\\n\\n  /**\\n   * Collect array of available options from trigger element\\n   * @param {jQuery} [$trigger]\\n   * @returns {Object}\\n   * @private\\n   */\\n  Tooltip.prototype._collectOptionsFromElement = function($trigger) {\\n    $trigger = $trigger || this.$element;\\n    var result = {};\\n\\n    result.items = [];\\n      var triggerText = $trigger.text(),\\n          text = $trigger.attr('tooltip-text'),\\n          style = $trigger.attr('tooltip-style') || '',\\n          position = $trigger.attr('tooltip-position') || '';\\n    result.text = text || triggerText;\\n    result.style = style;\\n    result.position = position;\\n    return result;\\n  };\\n\\n  /**\\n   * Destroy current instance of tooltip. Remove all elements and detach events.\\n   */\\n  Tooltip.prototype.destroy = function() {\\n    this._detachEventHandlers();\\n    this.$tooltip.remove();\\n    this.$element.data('EaselTooltip', undefined);\\n    this.$element.removeClass('tooltip-trigger');\\n    this.enabled = false;\\n  };\\n\\n  /**\\n   * Show tooltip\\n   * @param {jQuery} [$trigger] - trigger element. For correct positioning\\n   */\\n  Tooltip.prototype.showTooltip = function($trigger) {\\n    if (this.enabled) {\\n      this.$element.trigger('showTooltip');\\n      this._firstShow = false;\\n      if (!this.$tooltip.is(':visible')) {\\n        this.$tooltip.addClass('tooltip-transparent');\\n      }\\n      this.adjustPosition(undefined, $trigger);\\n      this.$tooltip.removeClass('tooltip-transparent');\\n      this.$tooltip.addClass('active');\\n      this.isVisible = true;\\n    }\\n  };\\n\\n  /**\\n   * Hide tooltip\\n   */\\n  Tooltip.prototype.hideTooltip = function() {\\n    if (this.enabled && this.isVisible) {\\n      this.$tooltip.removeClass('active');\\n      this.isVisible = false;\\n    }\\n  };\\n\\n  /**\\n   * @Function\\n   * @param {Object} [options]\\n   * @returns {Tooltip[]}\\n   * @memberOf external:\\\"jQuery.fn\\\"\\n   */\\n  $.fn.EaselTooltip = function (options) {\\n    var instances = [];\\n    $(this).each(function (i, element) {\\n      var newInstance = new Tooltip(element, options);\\n      $(element).data('EaselTooltip', newInstance);\\n      instances.push(newInstance);\\n    });\\n    return instances;\\n  };\\n\\n  /**\\n   * @Function\\n   * @memberOf external:\\\"jQuery.fn\\\"\\n   * @returns {Tooltip|Tooltip[]}\\n   */\\n  $.fn.getEaselTooltip = function () {\\n    var instances = [];\\n    $(this).each(function (i, element) {\\n      var currInstance = $(element).data('EaselTooltip');\\n      if (currInstance) {\\n        instances.push(currInstance);\\n      }\\n    });\\n    return instances.length > 1 ? instances : instances[0];\\n  };\\n\\n  utilPlugins.Tooltip = Tooltip;\\n})(window, jQuery, Easel.util, Easel.utilPlugins);\"","module.exports = \"(function ($, BaseShape, pluginsNamespace, util) {\\n  \\\"use strict\\\";\\n\\n  /**\\n   * Provides an editable text shape.\\n   *\\n   * @param drawerInstance\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {number} options.editIconSize\\n   * Sets the 'edit icon' size, in pixels.\\n   * Default is 32px. More then 64px is not recommended.\\n   *\\n   * @param {boolean} options.editIconMode\\n   * Sets if 'edit icon' mode is on.\\n   *\\n   * @param {object.<string, array>} options.predefined\\n   * List of available values from control dropdown\\n   *\\n   * @param {object.<string, array>} options.defaultValues\\n   * List of default values of styles\\n   *\\n   * @memberof Easel.plugins\\n   *\\n   * @constructor\\n   * @augments Easel.plugins.BaseShape\\n   */\\n  var Text = function TextConstructor(drawerInstance, options) {\\n    // call super c-tor\\n    BaseShape.call(this, drawerInstance);\\n\\n\\n    this._setupOptions(options);\\n\\n    this.tooltip = this.drawerInstance.t('Draw a text');\\n    this.helpTooltipText = this.drawerInstance.t('Click to place a text');\\n\\n    this.drawerInstance.on(this.drawerInstance.EVENT_OPTIONS_TOOLBAR_CREATED + this.eventNs, this._onOptionsToolbarCreated.bind(this));\\n  };\\n\\n  Text.prototype = Object.create(BaseShape.prototype);\\n  Text.prototype.constructor = Text;\\n\\n\\n  Text.prototype.name = 'Text';\\n  /**\\n   * List of tool options to show when tool is activated.\\n   * Deviating from BaseShape tool, Line has no 'color', only 'border'.\\n   * @type {String[]}\\n   */\\n  Text.prototype.toolOptionsList = ['border', 'opacity'];\\n\\n\\n  // tool event namespace\\n  Text.prototype.eventNs = '.textTool';\\n\\n  Text.prototype.name = 'Text';\\n  Text.prototype.btnClass = 'btn-text';\\n  Text.prototype.faClass = 'fa-font';\\n/////////////////////////////////////////////////////////\\n\\n    /**\\n     * On tool options toolbar created - create controls and set handlers\\n     * To proper react on objects selection and\\n     *\\n     * @param  {Event} ev\\n     * @param  {Easel} toolbar toolbar which was created\\n     * @private\\n     */\\n    Text.prototype._onOptionsToolbarCreated = function (ev, toolbar) {\\n\\n      // react on text selection change\\n      this.drawerInstance.on(this.drawerInstance.EVENT_TEXT_SELECTION_CHANGED, this._onTextSelectionChanged.bind(this));\\n      // react on edit mode entering\\n      this.drawerInstance.on(this.drawerInstance.EVENT_TEXT_EDITING_ENTERED, this._onTextEditingEntered.bind(this));\\n      // react on edit mode exiting\\n      this.drawerInstance.on(this.drawerInstance.EVENT_TEXT_EDITING_EXITED, this._onTextEditingExited.bind(this));\\n    };\\n\\n    Text.prototype._deactivateTool = function () {\\n        if (!this.active) {\\n          return;\\n        }\\n\\n        // call _deactivateTool() of parent\\n        BaseShape.prototype._deactivateTool.call(this);\\n    };\\n\\n\\n    /**\\n     * Removes tool controls.\\n     * If  doDeleteToolbarCreationListeners is true - removes listeners on toolbar creation event.\\n     * So, tool will not appear on toolbar next time, when toolbar is created.\\n     *\\n     * @param {boolean} doDeleteToolbarCreationListeners\\n     */\\n    Text.prototype.removeTool = function(doDeleteToolbarCreationListeners) {\\n        // sign off option toolbar creation\\n        if (doDeleteToolbarCreationListeners) {\\n            this.drawerInstance.off(this.drawerInstance.EVENT_OPTIONS_TOOLBAR_CREATED + this.eventNs);\\n        }\\n\\n        // call parent removeTool()\\n        BaseShape.prototype.removeTool.call(this, doDeleteToolbarCreationListeners);\\n    };\\n\\n  /**\\n   * React on edit mode entering\\n   * @param  {fabric.Event} fEvent\\n   * @param  {fabric.Object} tool - Object of active tool\\n   * @private\\n   */\\n  Text.prototype._onTextEditingEntered = function (fEvent, tool) {\\n    console.info('EVENT_TEXT_EDITING_ENTERED');\\n    this._onTextSelectionChanged(fEvent, tool);\\n  };\\n\\n  /**\\n   * React on edit mode exiting\\n   * @param  {fabric.Event} fEvent\\n   * @param  {fabric.Object} tool - Object of active tool\\n   * @private\\n   */\\n  Text.prototype._onTextEditingExited = function (fEvent, tool) {\\n    if (tool && tool.target) {\\n      tool.target._lastSelection = undefined;\\n      tool.target._lastStyles = undefined;\\n    }\\n  };\\n\\n  /**\\n   * React on styles changes of current text object\\n   * @param  {fabric.Event} ev\\n   * @param  {fabric.Object} tool - Object of active tool\\n   * @private\\n   */\\n  Text.prototype._onTextSelectionChanged = function (ev, tool) {\\n    var targetObj = (tool && tool.target) || this.drawerInstance.getActiveObject(); // @todo\\n\\n    var currentPos = {\\n          start: targetObj.selectionStart,\\n          end: targetObj.selectionEnd\\n        },\\n        lastPos = targetObj._lastSelection || {},\\n        emptySelection = currentPos.start === currentPos.end,\\n        firstChar = currentPos.start === 0,\\n        sameStartPosition = currentPos.start === lastPos.start && currentPos.start !== undefined,\\n        sameEndPosition = currentPos.end === lastPos.end && currentPos.end !== undefined,\\n        samePosition = sameStartPosition && sameEndPosition;\\n\\n    if (!samePosition) {\\n      targetObj._lastSelection = currentPos;\\n\\n      var objectStyles = targetObj.getObjStyles(),\\n          prevStyles = targetObj._lastStyles || {},\\n          getPrevCharStyles = (emptySelection && !firstChar),\\n          prevCharStyles = getPrevCharStyles && targetObj.getSelectionStyles(currentPos.start - 1),\\n          styles = prevCharStyles || targetObj.getSelectionStyles(),\\n          stylesAreChanged = targetObj._hasStyleChanged(prevStyles, prevCharStyles || styles),\\n          stylesWithMultipleValues = [];\\n\\n      // For not empty selection\\n      if (!emptySelection) {\\n        styles = $.extend(true, {}, styles);\\n        var stylesArrayForEachChar = targetObj.getSelectionStyles(currentPos.start, currentPos.end),\\n            firstStyleObj = $.extend(true, {}, stylesArrayForEachChar[0]);\\n        stylesArrayForEachChar.forEach(function(stylesObj, i) {\\n          for (var styleName in objectStyles) {\\n            var charsHaveDifferentStyles = stylesObj[styleName] !== firstStyleObj[styleName],\\n                alreadyMultiple = stylesWithMultipleValues.indexOf(styleName) !== -1;\\n            if (charsHaveDifferentStyles && !alreadyMultiple) {\\n              stylesWithMultipleValues.push(styleName);\\n              styles[styleName] = undefined;\\n            }\\n          }\\n        });\\n        stylesAreChanged = stylesWithMultipleValues.length || targetObj._hasStyleChanged(prevStyles, styles);\\n      }\\n      this.drawerInstance.setTemporaryStyles(styles);\\n\\n      if (stylesAreChanged) {\\n        targetObj._lastStyles = styles;\\n\\n        var drawer = this.drawerInstance;\\n        drawer.trigger(drawer.EVENT_TEXT_STYLES_CHANGED, [styles, objectStyles, stylesWithMultipleValues]);\\n      }\\n    }\\n  };\\n\\n  Text.prototype.addShape = function (left, top, text, styles) {\\n    styles = styles || {};\\n    left = parseInt(left, 10);\\n    left = left || left === 0 ? left : 0;\\n    top = parseInt(top, 10);\\n    top = top || top === 0 ? top : 0;\\n    var shape = this.createShape(left, top, text, styles);\\n    shape.set('left',left);\\n    shape.set('top',top);\\n    this.shape = shape;\\n    // finish drawing\\n    this.finishItemDraw();\\n\\n    // some tools are supposed to draw one shape and then deactivate\\n    if (this.onlyOneItem) {\\n      this.drawerInstance.trigger(this.drawerInstance.EVENT_DO_DEACTIVATE_TOOL, this);\\n    }\\n  };\\n\\n  Text.prototype.createShape = function (left, top, textString, styles) {\\n    styles = styles || {};\\n    textString = textString || 'Text';\\n    this.startLeft = left;\\n    this.startTop = top;\\n\\n    this.text = new fabric.ErasableText(textString, {editIconMode : this.options.editIconMode, editIconSize: this.options.editIconSize});\\n\\n    var drawer = this.drawerInstance,\\n        defaultValues = this.options.defaultValues || {},\\n        collectedStyles = {};\\n\\n    drawer.trigger(drawer.EVENT_TEXT_GET_STYLES, [this, collectedStyles]);\\n\\n    collectedStyles = collectedStyles || {};\\n    collectedStyles.defaultValues = collectedStyles.defaultValues || {}; //@todo\\n\\n\\n    this.text.set('fontFamily', styles.fontFamily || defaultValues.fontFamily || collectedStyles.defaultValues.fontFamily);\\n    this.text.set('fontSize', styles.fontSize || defaultValues.fontSize || collectedStyles.defaultValues.fontSize);\\n    this.text.set('lineHeight', styles.lineHeight || defaultValues.lineHeight || collectedStyles.defaultValues.lineHeight);\\n    this.text.set('fill', styles.fill || defaultValues.fill || collectedStyles.defaultValues.fill || this.drawerInstance.activeColor);\\n    this.text.set('opacity', styles.opacity || defaultValues.opacity || collectedStyles.defaultValues.opacity || this.drawerInstance.activeOpacity);\\n\\n    this.text.set('left', left - this.text.width / 2);\\n    this.text.set('top', top - this.text.height / 2);\\n\\n    return this.text;\\n  };\\n\\n  Text.prototype.updateShape = function (text, newLeft, newTop) {\\n  };\\n\\n  /**\\n   * Checks if object is instance of fabric.Text\\n   * @param  {fabric.Object} obj - Instance of Fabric.Object\\n   * @return {Boolean}\\n   */\\n  Text.prototype.isObjectText = function (obj) {\\n    return obj instanceof fabric.IText;\\n  };\\n\\n  pluginsNamespace.Text = Text;\\n\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins, Easel.util));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-stroke-width/StrokeWidth.js\"))","module.exports = \"(function (BaseTool, pluginsNamespace) {\\n  'use strict';\\n\\n  /**\\n   * Selection tool that restores default canvas interaction so users can pick and move objects.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * @param {Object} options\\n   * @constructor\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseTool\\n   */\\n  var SelectionTool = function SelectionToolConstructor(drawerInstance, options) {\\n    BaseTool.call(this, drawerInstance, options);\\n\\n    this.name = 'SelectionTool';\\n    this.btnClass = 'btn-selection';\\n    this.faClass = 'fa-mouse-pointer';\\n    this.tooltip = drawerInstance.t('Selection mode');\\n    this.toolOptionsList = [];\\n\\n    this._defaultOptions = {\\n      buttonOrder: 0,\\n      cursor: 'default',\\n      hoverCursor: 'move',\\n      ensureSelectableObjects: true\\n    };\\n\\n    this._setupOptions(options);\\n  };\\n\\n  SelectionTool.prototype = Object.create(BaseTool.prototype);\\n  SelectionTool.prototype.constructor = SelectionTool;\\n\\n  SelectionTool.prototype._activateTool = function () {\\n    BaseTool.prototype._activateTool.call(this);\\n    this._enableSelectionMode();\\n  };\\n\\n  SelectionTool.prototype._deactivateTool = function () {\\n    BaseTool.prototype._deactivateTool.call(this);\\n  };\\n\\n  SelectionTool.prototype._enableSelectionMode = function () {\\n    var fCanvas = this.drawerInstance && this.drawerInstance.fCanvas;\\n    if (!fCanvas) {\\n      return;\\n    }\\n\\n    fCanvas.isDrawingMode = false;\\n    fCanvas.selection = true;\\n    fCanvas.defaultCursor = this.options.cursor;\\n    fCanvas.hoverCursor = this.options.hoverCursor;\\n\\n    if (this.options.ensureSelectableObjects && fCanvas.forEachObject) {\\n      fCanvas.forEachObject(function (obj) {\\n        if (obj) {\\n          obj.selectable = true;\\n          obj.evented = true;\\n        }\\n      });\\n    }\\n\\n    fCanvas.renderAll();\\n  };\\n\\n  pluginsNamespace.SelectionTool = SelectionTool;\\n\\n}(Easel.plugins.BaseTool, Easel.plugins));\\n\"","module.exports = \"(function (Easel) {\\n  /**\\n   *\\n   * @param {Easel.Easel} drawer - instance of drawer\\n   * @memberOf Easel\\n   * @constructor\\n   */\\n    var EaselApi = function(drawer) {\\n        if (!drawer) {\\n            throw new Error('EaselApi(): no drawer is provided!');\\n        }\\n        this.drawer = drawer;\\n    };\\n\\n    EaselApi.prototype.drawer = null;\\n\\n    // Easel core API\\n    ////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * Starts editing mode.\\n     * If already in this mode - do nothing.\\n     */\\n    EaselApi.prototype.checkIsActive = function () {\\n        if (this.drawer.mode != this.drawer.MODE_ACTIVE) {\\n            throw new Error(\\\"Easel is not active!\\\");\\n        }\\n    };\\n\\n\\n    /**\\n     * Starts editing mode.\\n     * If already in this mode - do nothing.\\n     */\\n    EaselApi.prototype.startEditing = function () {\\n        this.drawer._startEditing();\\n    };\\n\\n    /**\\n     * Stops editing.\\n     * If already stopped, ie. in INACTIVE_MODE - do nothing.\\n     */\\n    EaselApi.prototype.stopEditing = function () {\\n        this.drawer._stopEditing();\\n    };\\n\\n\\n\\n    /**\\n     * Get serialized in JSON string canvas data.\\n     * @returns [String]\\n     */\\n    EaselApi.prototype.getCanvasAsJSON = function () {\\n        this.drawer.api.checkIsActive();\\n        return this.drawer.getSerializedCanvas();\\n    };\\n\\n\\n    /**\\n     * Save canvas.\\n     * Syncs drawer canvas data with storages, defined in options\\n     */\\n    EaselApi.prototype.saveCanvas = function () {\\n        this.drawer.api.checkIsActive();\\n        this.drawer.syncCanvasData();\\n    };\\n\\n\\n    /**\\n     * Load canvas.\\n     * Loads canvas\\n     */\\n    EaselApi.prototype.loadCanvasFromData = function (data) {\\n        this.drawer.loadCanvas(data);\\n    };\\n\\n\\n\\n /**\\n   * Returns data-url with image encoded to base64.\\n   *\\n   * @see Easel.Storage.js getImageData() for details\\n   * @returns {String} image data encoded in base64/png.\\n   */\\n   EaselApi.prototype.getCanvasAsImage = function () {\\n        return this.drawer.getImageData();\\n   };\\n\\n\\n    /**\\n     * Save canvas as image in storages, as defined in config\\n     */\\n    EaselApi.prototype.saveCanvasImage = function () {\\n        this.drawer.api.checkIsActive();\\n        this.drawer.syncImageData();\\n    };\\n\\n  /**\\n   * List of all available options for each mode of each toolbar\\n   * @typedef {Object} sizesOfEasel\\n   * @memberOf Easel.EaselApi\\n   * @property {Number} width - width of Easel\\n   * @property {Number} height - height of drawer\\n   * @property {Number} scrollTop - \\\"Top\\\" position including scrollTop value of parent elements\\n   * @property {Number} scrollLeft - \\\"Left\\\" position including scrollLeft value of parent elements\\n   * @property {Number} top - Absolute value of \\\"top\\\" position\\n   * @property {Number} left - Absolute value of \\\"left\\\" position\\n   */\\n\\n\\n  /**\\n     * Get sizes of drawer\\n     * @returns {Easel.EaselApi.sizesOfEasel}\\n     */\\n    EaselApi.prototype.getSize = function () {\\n      var sizes = this.drawer.getSize();\\n      return sizes;\\n    };\\n\\n  /**\\n     * Sets drawer size.\\n     */\\n    EaselApi.prototype.setSize = function (width, height) {\\n        this.drawer.setSize(width, height);\\n    };\\n\\n    /**\\n     * Set active color\\n     * @param {String} color - New color value (HEX)\\n     */\\n    EaselApi.prototype.setActiveColor = function (color) {\\n      this.drawer.setActiveColor(color);\\n    };\\n\\n  /**@\\n   * Create text object\\n   * @param {Number} [positionX=0] - left offset of new text object\\n   * @param {Number} [positionY=0] - top offset of new text object\\n   * @param {String} [text=\\\"Text\\\"] - text of new object\\n   * @param {Object} [styles] - styles for new text object\\n   */\\n  EaselApi.prototype.createText = function (positionX, positionY, text, styles) {\\n    this.drawer._pluginsInstances.Text.addShape(positionX, positionY, text, styles);\\n  };\\n\\n\\n    /**\\n     * Update current options.\\n     * If optionsToUpdate has plugins key, plugins will be reloaded\\n     *\\n     * @param  {Object} optionsToUpdate options object\\n     */\\n    EaselApi.prototype.updateOptions = function (optionsToUpdate) {\\n        this.drawer.updateOptions(optionsToUpdate);\\n    };\\n\\n\\n    /**\\n     * Update current options.\\n     * All plugins will be reloaded\\n     *\\n     * @param  {Object} optionsToUpdate options object\\n     */\\n    EaselApi.prototype.setOptions = function (newOptions) {\\n        this.drawer.setOptions(newOptions);\\n    };\\n\\n\\n    /**\\n     * Load plugin by name.\\n     * Name must exists in Easel namespace.\\n     * If plugin is already loaded, error will be thrown\\n     *\\n     * @param  {String} pluginName plugin name\\n     */\\n    EaselApi.prototype.loadPlugin = function (pluginName) {\\n        this.drawer.loadPlugin(pluginName);\\n    };\\n\\n\\n    /**\\n     * Unload plugin by name.\\n     * If plugin is not loaded, nothing happens.\\n     *\\n     * @param  {String} pluginName plugin name\\n     */\\n    EaselApi.prototype.unloadPlugin = function (pluginName) {\\n        this.drawer.unloadPlugin(pluginName);\\n    };\\n\\n    Easel.EaselApi = EaselApi;\\n})(Easel);\\n\"","module.exports = \"(function ($, utilNamespace) {\\n  'use strict';\\n\\n  /**\\n   * Contains url to a folder of drawer files.\\n   *\\n   * @type {null|string}\\n   * @private\\n   */\\n  var _drawerFolderUrl = null;\\n\\n  utilNamespace.setEaselFolderUrl = function (url) {\\n    _drawerFolderUrl = url.replace(/\\\\/*$/g, '') + '/';\\n  };\\n\\n  /**\\n   * This function finds an url from which drawer file was loaded\\n   *\\n   * @function\\n   * @memberof Easel.util\\n   * @returns {*}\\n   */\\n  utilNamespace.getEaselFolderUrl = function () {\\n    if (_drawerFolderUrl) {\\n      return _drawerFolderUrl;\\n    }\\n\\n    // try to find a folder from which this script is included\\n    var scripts = document.getElementsByTagName(\\\"script\\\");\\n    var easelFilenamePattern = /dist\\\\/(drawer.+\\\\.js)+$/;\\n\\n    for (var i = 0; i < scripts.length; i++) {\\n      var s = scripts.item(i);\\n\\n      if (s.src) {\\n        var match = s.src.match(easelFilenamePattern);\\n        if (match) {\\n          var pathToEaselFolder = s.src.replace(match[1], '');\\n          return pathToEaselFolder;\\n        }\\n      }\\n    }\\n\\n    return '';\\n  };\\n\\n  /**\\n   * Removes all click events with specified namespace bound to element.\\n   *\\n   * @param {jQuery} element\\n   * @param {String} namespace\\n   */\\n  utilNamespace.unbindClick = function (element, namespace) {\\n    var ns = namespace + 'drawerBindClick';\\n\\n    $(element).off('click.' + ns);\\n    $(element).off('touchstart.' + ns);\\n    $(element).off('touchend.' + ns);\\n  };\\n\\n  utilNamespace.bindClick = function (element, namespace, handler) {\\n    var ns = namespace + 'drawerBindClick';\\n\\n    $(element).on('click.' + ns, function (event) {\\n      var elem = this;\\n      var result = null;\\n\\n      if (elem.__lastClickTime) {\\n        var lastClickDiff = Date.now() - elem.__lastClickTime;\\n        if (lastClickDiff > 500) {\\n          try {\\n            result = handler.apply(elem, [event]);\\n            } catch(err){\\n              var errorName = 'Catched error - ' + 'click.' + ns;\\n              console.groupCollapsed(errorName);\\n              console.error(err);\\n              console.groupEnd(errorName);\\n          }\\n\\n          if (result === false) {\\n            event.stopPropagation();\\n            event.preventDefault();\\n            return false;\\n          }\\n        } else {\\n          // seems that we have already triggered this click on touchend event\\n        }\\n      } else {\\n        try {\\n          result = handler.apply(elem, [event]);\\n        } catch (err) {\\n          var errorMsg = 'Catched error - ' + 'click.' + ns;\\n          console.groupCollapsed(errorMsg);\\n          console.error(err);\\n          console.groupEnd(errorMsg);\\n        }\\n\\n        if (result === false) {\\n          event.stopPropagation();\\n          event.preventDefault();\\n          return false;\\n        }\\n      }\\n    });\\n    $(element).on('touchstart.' + ns, function (event) {\\n      var elem = this;\\n\\n      elem.__drawerTouchStartEvent = event;\\n\\n      // disable click entirely since we do everything with touch events\\n      $(element).off('click.' + ns);\\n    });\\n    $(element).on('touchend.' + ns, function (event) {\\n      var elem = this,\\n          result;\\n\\n      if (elem.__drawerTouchStartEvent) {\\n        var tsDiff = Math.abs(\\n          elem.__drawerTouchStartEvent.timeStamp - event.timeStamp\\n        );\\n\\n        if (tsDiff < 300) {\\n          elem.__lastClickTime = Date.now();\\n          try {\\n            result = handler.apply(elem, [event]);\\n          } catch (err) {\\n            var errorName = 'Catched error - ' + 'touchend.' + ns;\\n            console.groupCollapsed(errorName);\\n            console.error(err);\\n            console.groupEnd(errorName);\\n          }\\n          if (result === false) {\\n            event.stopPropagation();\\n            event.preventDefault();\\n            return false;\\n          }\\n        }\\n        delete elem.__drawerTouchStartEvent;\\n      }\\n    });\\n  };\\n\\n  utilNamespace.bindDoubleTap = function (element, namespace,\\n                                          handler) {\\n    var timeWindow = 500;\\n    var positionWindow = 20;\\n\\n    $(element).on('touchend.' + namespace, function (event) {\\n      var eventElem = this,\\n          eventPos;\\n      if (eventElem.__touchEndTime) {\\n        var diff = Date.now() - eventElem.__touchEndTime;\\n        eventPos = utilNamespace.getEventPosition(event);\\n        var xDiff = Math.abs(eventElem.__touchEndX - eventPos.left);\\n        var yDiff = Math.abs(eventElem.__touchEndY - eventPos.top);\\n        var result;\\n\\n        if (diff < timeWindow &&\\n          xDiff < positionWindow &&\\n          yDiff < positionWindow) {\\n\\n          delete eventElem.__touchEndTime;\\n          delete eventElem.__touchEndX;\\n          delete eventElem.__touchEndY;\\n          try {\\n            result = handler.apply(eventElem, [event]);\\n          } catch (err) {\\n            var errorName = 'Catched error - ' + 'touchend(doubleTap).' + namespace;\\n            console.groupCollapsed(errorName);\\n            console.error(err);\\n            console.groupEnd(errorName);\\n          }\\n          if (result === false) {\\n            event.stopPropagation();\\n            event.preventDefault();\\n            return false;\\n          }\\n        } else {\\n          delete eventElem.__touchEndTime;\\n          delete eventElem.__touchEndX;\\n          delete eventElem.__touchEndY;\\n        }\\n      } else {\\n        eventElem.__touchEndTime = Date.now();\\n        eventPos = utilNamespace.getEventPosition(event);\\n        eventElem.__touchEndX = eventPos.left;\\n        eventElem.__touchEndY = eventPos.top;\\n        utilNamespace.setTimeout(function () {\\n          delete eventElem.__touchEndTime;\\n          delete eventElem.__touchEndX;\\n          delete eventElem.__touchEndY;\\n        }, timeWindow);\\n      }\\n    });\\n  };\\n\\n  utilNamespace.bindLongPress = function (element, namespace,\\n                                          handler) {\\n    var logTag = 'drawerBindLongPress';\\n    var ns = namespace + logTag;\\n\\n    $(element).on('touchstart.' + ns, function (event) {\\n      var elem = this;\\n\\n      elem.__touchStartTime = Date.now();\\n      var eventPos = utilNamespace.getEventPosition(event);\\n      elem.__touchStartX = eventPos.left;\\n      elem.__touchStartY = eventPos.top;\\n\\n      if (elem.__longPressCheckTimeout) {\\n        clearTimeout(elem.__longPressCheckTimeout);\\n      }\\n\\n      var cleanHandlers = function () {\\n\\n        delete elem.__touchStartTime;\\n        delete elem.__touchStartX;\\n        delete elem.__touchStartY;\\n\\n        $(elem).off('touchmove.' + ns);\\n        $(elem).off('touchend.' + ns);\\n      };\\n\\n      $(elem).on('touchmove.' + ns, function (moveEvent) {\\n        var eventPos = utilNamespace.getEventPosition(moveEvent);\\n        if (elem.__touchStartTime) {\\n          var xDiff = Math.abs(\\n            elem.__touchStartX - eventPos.left\\n          );\\n          var yDiff = Math.abs(\\n            elem.__touchStartY - eventPos.top\\n          );\\n\\n          if (xDiff > 10 || yDiff > 10) {\\n            cleanHandlers();\\n          }\\n        }\\n      });\\n\\n      $(elem).on('touchend.' + ns, function (endEvent) {\\n        cleanHandlers();\\n      });\\n\\n      elem.__longPressCheckTimeout = setTimeout(function () {\\n        if (elem.__touchStartTime) {\\n          cleanHandlers();\\n          try {\\n            var result = handler.apply(elem, [event]);\\n            } catch (err) {\\n              var errorName = 'Catched error - ' + 'touchstart(bindLongPress).' + ns;\\n              console.groupCollapsed(errorName);\\n              console.error(err);\\n              console.groupEnd(errorName);\\n          }\\n        }\\n      }, 1000);\\n\\n      return true;\\n    });\\n  };\\n\\n  utilNamespace.unbindLongPress = function (element, namespace) {\\n    var logTag = 'drawerBindLongPress';\\n    var ns = namespace + logTag;\\n\\n    $(element).off('touchstart.' + ns);\\n    $(element).off('touchmove.' + ns);\\n    $(element).off('touchend.' + ns);\\n  };\\n\\n  utilNamespace.mouseDown = function (namespace) {\\n    return 'mousedown.' + namespace + this.id +\\n      ' touchstart.' + namespace + this.id;\\n  };\\n\\n  utilNamespace.mouseMove = function (namespace) {\\n    return 'mousemove.' + namespace + this.id +\\n      ' touchmove.' + namespace + this.id;\\n  };\\n\\n  utilNamespace.mouseUp = function (namespace) {\\n    return 'mouseup.' + namespace + this.id +\\n      ' touchend.' + namespace + this.id;\\n  };\\n\\n  utilNamespace.getTransitionDuration = function (el, with_delay) {\\n    var style = window.getComputedStyle(el),\\n      duration = style.webkitTransitionDuration,\\n      delay = style.webkitTransitionDelay;\\n\\n    // fix miliseconds vs seconds\\n    duration = (duration.indexOf(\\\"ms\\\") > -1) ?\\n      parseFloat(duration) : parseFloat(duration) * 1000;\\n    delay = (delay.indexOf(\\\"ms\\\") > -1) ?\\n      parseFloat(delay) : parseFloat(delay) * 1000;\\n\\n    if (with_delay) return (duration + delay);\\n\\n    else return duration;\\n  };\\n\\n  utilNamespace.getEventPosition = function (event, touchIndex) {\\n    var result = {};\\n    var searchTouchEvent = function (innerEvent, fromInner) {\\n      var touchEvent;\\n      if (innerEvent) {\\n        var isTouch = innerEvent.type.indexOf('touch') > -1,\\n            haveTouches = isTouch && innerEvent.touches && innerEvent.touches.length,\\n            eventCoordsAreValid = utilNamespace.eventCoordsAreValid(innerEvent),\\n            getFromTouch = isTouch && haveTouches && !eventCoordsAreValid;\\n\\n        touchEvent = getFromTouch ? innerEvent : (!fromInner && searchTouchEvent(innerEvent.originalEvent, true));\\n      }\\n      return touchEvent;\\n    };\\n    if (event) {\\n      touchIndex = touchIndex || 0;\\n      var touchEvent =  searchTouchEvent(event),\\n          touchCoordsAreValid = touchEvent && utilNamespace.eventCoordsAreValid(touchEvent.touches[touchIndex]),\\n          eventCoordsAreValid = utilNamespace.eventCoordsAreValid(event),\\n          originalEventCoordsAreValid = event && event.originalEvent && utilNamespace.eventCoordsAreValid(event.originalEvent);\\n\\n      var coordsHolder = (touchCoordsAreValid && touchEvent.touches[touchIndex]) || (eventCoordsAreValid && event) || (originalEventCoordsAreValid && event.originalEvent);\\n      if (coordsHolder) {\\n        result = {\\n          left: coordsHolder.pageX,\\n          top: coordsHolder.pageY\\n        };\\n      }\\n    }\\n    return result;\\n  };\\n\\n  utilNamespace.eventCoordsAreValid = function (event) {\\n    var isValid;\\n    if (event) {\\n      var areNotZero = event.pageX !== 0 && event.pageY !== 0,\\n          areNumbers = typeof event.pageX === 'number' && typeof event.pageY === 'number',\\n          areNotNan = areNumbers && isFinite(event.pageX) && isFinite(event.pageY);\\n      isValid = areNotZero && areNumbers && areNotNan;\\n    }\\n    return isValid;\\n  };\\n\\n  utilNamespace.applyStrokePenStyle = function (fabricObject) {\\n    if (!fabricObject || typeof fabricObject.set !== 'function') {\\n      return;\\n    }\\n    fabricObject.set('strokeLineCap', 'round');\\n    fabricObject.set('strokeLineJoin', 'round');\\n    fabricObject.set('strokeMiterLimit', 2);\\n    fabricObject.set('strokeUniform', true);\\n    fabricObject.set('paintFirst', 'stroke');\\n    if (typeof fabricObject.setShadow === 'function') {\\n      fabricObject.setShadow(null);\\n    } else if (fabricObject.shadow) {\\n      fabricObject.shadow = null;\\n    }\\n  };\\n\\n  utilNamespace.isShape = function (fabricObject) {\\n    var isShape = false;\\n\\n    if (fabricObject.type &&\\n      (fabricObject.type == 'line' ||\\n      fabricObject.type == 'arrow')) {\\n      isShape = false;\\n    }\\n    else if (fabricObject.path) { // free drawing shape\\n      isShape = false;\\n    } else {\\n      isShape = true;\\n    }\\n\\n    return isShape;\\n  };\\n\\n\\n  utilNamespace.__temporaryCanvas = null;\\n  utilNamespace.__latestValidCanvasWidth = null;\\n  utilNamespace.__latestValidCanvasHeight = null;\\n  utilNamespace.getTemporaryCanvas = function (originalCanvas) {\\n    if (!utilNamespace.__temporaryCanvas) {\\n      utilNamespace.__temporaryCanvas = document.createElement('canvas');\\n    }\\n\\n    var canvasWidth = originalCanvas.width,\\n        canvasHeight = originalCanvas.height,\\n        resultCanvasWidth = canvasWidth || utilNamespace.__latestValidCanvasWidth || 1,\\n        resultCanvasHeight = canvasHeight || utilNamespace.__latestValidCanvasHeight || 1;\\n\\n    utilNamespace.__temporaryCanvas.setAttribute('width', resultCanvasWidth);\\n    utilNamespace.__temporaryCanvas.setAttribute('height', resultCanvasHeight);\\n\\n    utilNamespace.__latestValidCanvasWidth = resultCanvasWidth;\\n    utilNamespace.__latestValidCanvasHeight = resultCanvasHeight;\\n\\n    return utilNamespace.__temporaryCanvas;\\n  };\\n\\n  utilNamespace.LastCoordsQueue = function () {\\n    this.coordsQueue = [];\\n    this.length = 10;\\n\\n    this.pushCoords = function (x, y) {\\n      if (this.coordsQueue.length > this.length) {\\n        this.coordsQueue =\\n          this.coordsQueue.slice(this.coordsQueue.length - this.length);\\n      }\\n\\n      this.coordsQueue.push({x: x, y: y});\\n    };\\n\\n    this.getInterpolatedValues = function () {\\n      if (this.coordsQueue.length === 0) {\\n        return [];\\n      }\\n\\n      if (this.coordsQueue.length === 1) {\\n        return [{x: this.coordsQueue[0].x, y: this.coordsQueue[0].y}];\\n      }\\n\\n      var interpolatedCoords = [];\\n\\n      var prevX = this.coordsQueue[this.coordsQueue.length - 2].x;\\n      var prevY = this.coordsQueue[this.coordsQueue.length - 2].y;\\n\\n      var currX = this.coordsQueue[this.coordsQueue.length - 1].x;\\n      var currY = this.coordsQueue[this.coordsQueue.length - 1].y;\\n\\n      var xDiff = currX - prevX;\\n      var yDiff = currY - prevY;\\n\\n      var xDiffAbs = Math.abs(xDiff);\\n      var yDiffAbs = Math.abs(yDiff);\\n\\n      var iterations = xDiffAbs > yDiffAbs ? xDiffAbs : yDiffAbs;\\n\\n      for (var ii = 0; ii < iterations; ii++) {\\n        interpolatedCoords.push({\\n          x: prevX + ((xDiff / iterations) * ii),\\n          y: prevY + ((yDiff / iterations) * ii)\\n        });\\n      }\\n\\n      return interpolatedCoords;\\n    };\\n  };\\n\\n  /**\\n   * Add css rule to sheet\\n   * @param {Node} sheet - sheet element\\n   * @param {String} selector - selector for css rule\\n   * @param {String} rules - text of css rules\\n   * @param {Number} [index] - index of rule\\n   */\\n  utilNamespace.addCSSRule = function addCSSRule(sheet, selector, rules, index) {\\n    if (sheet) {\\n      if (\\\"insertRule\\\" in sheet) {\\n        sheet.insertRule(selector + \\\"{\\\" + rules + \\\"}\\\", index);\\n      } else {\\n        if (\\\"addRule\\\" in sheet) {\\n          sheet.addRule(selector, rules, index);\\n        }\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Add css rule to style sheet\\n   * @param {String} styleSelector - selector for css rule\\n   * @param {String} styleRule - text of css rules\\n   * @param {jQuery|String|Node} styleSheet - stylesheet element\\n   * @param {Boolean} [createElement] - create stylesheet element if cant find matched\\n   * @param {Boolean} [force] - need to insert css rules even if there no stylesheet element\\n   */\\n  utilNamespace.addStyleToStyleSheet = function (styleSelector, styleRule, styleSheet, createElement, force) {\\n    var isJqueryEl = styleSheet && styleSheet instanceof jQuery && styleSheet.length,\\n        isSelector = typeof styleSheet === 'string' && $(styleSheet).length && $(styleSheet),\\n        isNode = styleSheet instanceof Node && $(styleSheet).length && $(styleSheet),\\n        $styleSheet = isJqueryEl || isSelector || isNode;\\n    if ($styleSheet) {\\n      utilNamespace.addCSSRule($styleSheet[0].sheet, styleSelector, styleRule);\\n    } else {\\n      if (createElement) {\\n        var head = document.head || document.getElementsByTagName('head')[0],\\n            style = document.createElement('style');\\n\\n        style.type = 'text/css';\\n        style.id = styleSheet;\\n        head.appendChild(style);\\n        utilNamespace.addCSSRule(style.sheet, styleSelector, styleRule);\\n      } else {\\n        if (force) {\\n          var css = styleSelector + '{' + styleRule + '}';\\n          utilNamespace.addStyle(css);\\n        }\\n      }\\n    }\\n  };\\n\\n  utilNamespace.addStyle = function (css) {\\n    var head = document.head || document.getElementsByTagName('head')[0],\\n      style = document.createElement('style');\\n\\n    style.type = 'text/css';\\n    if (style.styleSheet) {\\n      style.styleSheet.cssText = css;\\n    } else {\\n      style.appendChild(document.createTextNode(css));\\n    }\\n\\n    head.appendChild(style);\\n  };\\n\\n\\n  utilNamespace.isString = function (str) {\\n      return typeof(str) == 'string' || str instanceof String;\\n  };\\n\\n  utilNamespace.getScrollTopFromElement = function ($element) {\\n    var $currElement = $element,\\n        result = {\\n          left: 0,\\n          top: 0\\n        },\\n        needToContinue = true;\\n    while (needToContinue) {\\n      needToContinue = $currElement && $currElement.length && !$currElement.is('body');\\n      var currScrollTop = $currElement.scrollTop(), currScrollLeft = $currElement.scrollLeft();\\n      result.top += currScrollTop;\\n      result.left += currScrollLeft;\\n      $currElement = $currElement.parent();\\n    }\\n    result.top += $(document).scrollTop();\\n    result.left += $(document).scrollLeft();\\n    return result;\\n  };\\n\\n\\n  /**\\n   * Debounce function\\n   * @param {Function} func\\n   * @param {Number} [wait]\\n   * @param {Boolean} [immediate]\\n   * @returns {Function}\\n   */\\n  utilNamespace.debounce = function (func, wait, immediate) {\\n    wait = wait || 0;\\n    var timeout;\\n    return function () {\\n      var context = this, args = arguments;\\n      var later = function () {\\n        timeout = null;\\n        if (!immediate) func.apply(context, args);\\n      };\\n      var callNow = immediate && !timeout;\\n      clearTimeout(timeout);\\n      timeout = utilNamespace.setTimeout(later, wait);\\n      if (callNow) func.apply(context, args);\\n    };\\n  };\\n\\n  /**\\n   *\\n   * @param src\\n   * @param {Node} [imageEl]\\n   * @param {Object} [data]\\n   * @returns {Promise}\\n   */\\n  utilNamespace.loadImage = function (src, imageEl, data, ignoreCrossOrigin) {\\n    data = data || {};\\n    var img = imageEl || new Image();\\n    img.style.opacity = 0;\\n\\n    return new Promise(function (resolve) {\\n      if (img.src === src) {\\n        // If image source hasn't changed resolve immediately\\n        resolve(img, data);\\n      } else {\\n        img.removeAttribute('crossOrigin');\\n        if (!ignoreCrossOrigin && src.match(/^https?:\\\\/\\\\/|^\\\\/\\\\//)) {\\n          img.setAttribute('crossOrigin', 'anonymous');\\n        }\\n        img.onload = function () {\\n          utilNamespace.setTimeout(function () {\\n            resolve(img, data);\\n          }, 1);\\n        };\\n        img.src = src;\\n      }\\n    });\\n  };\\n\\n  utilNamespace.checkBrowser = function (browser) {\\n    var ua = navigator.userAgent.toLowerCase();\\n    var match = /(opr)[/]([\\\\w.]+)/.exec( ua ) ||\\n        /(chrome)[ /]([\\\\w.]+)/.exec( ua ) ||\\n        /(webkit)[ /]([\\\\w.]+).*(safari)[ /]([\\\\w.]+)/.exec(ua) ||\\n        /(webkit)[ /]([\\\\w.]+)/.exec( ua ) ||\\n        /(opera)(?:.*version|)[ /]([\\\\w.]+)/.exec( ua ) ||\\n        /(msie) ([\\\\w.]+)/.exec( ua ) ||\\n        ua.indexOf(\\\"trident\\\") >= 0 && /(rv)(?::| )([\\\\w.]+)/.exec( ua ) ||\\n        ua.indexOf(\\\"compatible\\\") < 0 && /(mozilla)(?:.*? rv:([\\\\w.]+)|)/.exec( ua ) ||\\n        [];\\n\\n    if (browser == 'safari') return (typeof match[3] != 'undefined') ? match[3] == 'safari' : false;\\n    if (browser == 'version') return match[2];\\n    if (browser == 'webkit') return (match[1] == 'chrome' || match[1] == 'opr' || match[1] == 'webkit');\\n    if (match[1] == 'rv') return browser == 'msie';\\n    if (match[1] == 'opr') return browser == 'webkit';\\n\\n    return browser == match[1];\\n  };\\n\\n  /**\\n   *\\n   * @param {jQuery} $element\\n   */\\n  utilNamespace.getScrollOffset = function ($element) {\\n    var result = {},\\n        needContinue = true,\\n        currElement = $element,\\n        offsetX = 0,\\n        offsetY = 0;\\n    if ($element && $element.length) {\\n      while (needContinue) {\\n        currElement = currElement.parent();\\n        needContinue = currElement && currElement.length && !currElement.is('body');\\n        offsetX += currElement.scrollLeft();\\n        offsetY += currElement.scrollTop();\\n      }\\n    }\\n    result.left = offsetX;\\n    result.top = offsetY;\\n    return result;\\n  };\\n\\n\\n  /**\\n   * Custom setTimeout function with advanced error handling\\n   @param {String|Function} func\\n   @param {number} [delay]\\n   @param {...*} [arguments]\\n   @return {number}\\n   */\\n  utilNamespace.setTimeout = function (func, delay, args) {\\n    var funcWrapper,\\n        timer,\\n        tempError = new Error('Parent stack'),\\n        stack = tempError.stack;\\n    funcWrapper = function advancedSetTimeout() {\\n      try {\\n        func.apply(window, arguments);\\n      } catch (err) {\\n        var errorName = 'Catched error - ' + 'setTimeout';\\n        console.groupCollapsed(errorName);\\n        console.error('Parent stack:', stack);\\n        console.error('Error stack:', err.stack);\\n        console.error(err);\\n        console.groupEnd(errorName);\\n      }\\n    };\\n    timer = window.setTimeout(funcWrapper, delay, args);\\n    return timer;\\n  };\\n\\n  /**\\n   * Mousewheel handler across browser from developer.mozilla.org\\n   */\\n  (function () {\\n    var prefix = \\\"\\\",\\n        _addEventListener,\\n        support,\\n        addWheelListener;\\n\\n    // detect event model\\n    if (window.addEventListener) {\\n      _addEventListener = \\\"addEventListener\\\";\\n    } else {\\n      _addEventListener = \\\"attachEvent\\\";\\n      prefix = \\\"on\\\";\\n    }\\n\\n    // detect available wheel event\\n    var support_modern = \\\"onwheel\\\" in document.createElement(\\\"div\\\") && \\\"wheel\\\", // Modern browsers support \\\"wheel\\\"\\n        support_WebkitIe = document.onmousewheel !== undefined && \\\"mousewheel\\\",// Webkit and IE support at least \\\"mousewheel\\\"\\n        support_remaining = \\\"DOMMouseScroll\\\"; // let's assume that remaining browsers are older Firefox\\n\\n    support = support_modern || support_WebkitIe || support_remaining;\\n\\n    var eventHandlerForOldBrowsers = function (originalEvent) {\\n          originalEvent = originalEvent || window.event;\\n\\n          // create a normalized event object\\n          var event = {\\n            // keep a ref to the original event object\\n            originalEvent: originalEvent,\\n            target: originalEvent.target || originalEvent.srcElement,\\n            type: \\\"wheel\\\",\\n            deltaMode: originalEvent.type == \\\"MozMousePixelScroll\\\" ? 0 : 1,\\n            deltaX: 0,\\n            deltaY: 0,\\n            deltaZ: 0,\\n            preventDefault: function () {\\n              if (originalEvent.preventDefault) {\\n                originalEvent.preventDefault();\\n              } else {\\n                originalEvent.returnValue = false;\\n              }\\n            }\\n          };\\n\\n          // calculate deltaY (and deltaX) according to the event\\n          if (support == \\\"mousewheel\\\") {\\n            event.deltaY = -1 / 40 * originalEvent.wheelDelta;\\n            // Webkit also support wheelDeltaX\\n            if (originalEvent.wheelDeltaX) {\\n              event.deltaX = -1 / 40 * originalEvent.wheelDeltaX;\\n            }\\n          } else {\\n            event.deltaY = originalEvent.deltaY || originalEvent.detail;\\n          }\\n\\n          // it's time to fire the callback\\n          return callback(event);\\n\\n        },\\n        _addWheelListener = function (elem, eventName, callback, useCapture) {\\n          var eventNameFull = prefix + eventName,\\n              eventHandler;\\n\\n          eventHandler = support == \\\"wheel\\\" ? callback : eventHandlerForOldBrowsers;\\n\\n          elem[_addEventListener](eventNameFull, eventHandler, useCapture || false);\\n        };\\n\\n    /**\\n     *\\n     * @param elem\\n     * @param {Function} callback\\n     * @param {Boolean} useCapture\\n     */\\n    utilNamespace.addWheelListener = function (elem, callback, useCapture) {\\n      _addWheelListener(elem, support, callback, useCapture);\\n\\n      // handle MozMousePixelScroll in older Firefox\\n      if (support == \\\"DOMMouseScroll\\\") {\\n        _addWheelListener(elem, \\\"MozMousePixelScroll\\\", callback, useCapture);\\n      }\\n    };\\n\\n    utilNamespace.requestAnimationFrame = window.requestAnimationFrame.bind(window) ||\\n        window.mozRequestAnimationFrame.bind(window) ||\\n        window.webkitRequestAnimationFrame.bind(window)  ||\\n        window.msRequestAnimationFrame.bind(window)  ||\\n        function (f) {\\n          f();\\n        };\\n\\n    utilNamespace.cancelAnimationFrame = window.cancelAnimationFrame.bind(window) ||\\n        window.mozCancelAnimationFrame.bind(window) ||\\n        function () {};\\n  }());\\n\\n}(jQuery, Easel.util));\"","module.exports = \"/**\\n * Global Easel namespace.\\n *\\n * @namespace\\n * @type {{plugins: {}}}\\n */\\nEasel = {\\n\\n  /**\\n   * All available tool options\\n   * @memberof Easel\\n   * @namespace options\\n   */\\n\\n\\n  /**\\n   * Global namespace for all Easel plugins.\\n   *\\n   * @memberof Easel\\n   * @namespace Easel.plugins\\n   */\\n  plugins: {},\\n\\n  /**\\n   * Global namespace for all Easel utility functions.\\n   *\\n   * @memberof Easel\\n   * @namespace Easel.util\\n   */\\n  util: {},\\n\\n  /**\\n   * Global namespace for all Easel utility plugins.\\n   *\\n   * @memberof Easel\\n   * @namespace Easel.utilPlugins\\n   */\\n  utilPlugins: {},\\n\\n  /**\\n   * All drawer brush classes.\\n   *\\n   * @memberof Easel\\n   * @namespace Easel.brushes\\n   */\\n  brushes: {}\\n};\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/Easel.Api.js\"))","module.exports = \"/* build: `node build.js modules=ALL exclude=json,gestures minifier=uglifyjs` */\\n /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */\\n\\nvar fabric = fabric || { version: \\\"1.7.1\\\" };\\nif (typeof exports !== 'undefined') {\\n  exports.fabric = fabric;\\n}\\n\\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\\n  fabric.document = document;\\n  fabric.window = window;\\n  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)\\n  window.fabric = fabric;\\n}\\nelse {\\n  // assume we're running under node.js when document/window are not present\\n  fabric.document = require(\\\"jsdom\\\")\\n    .jsdom(\\\"<!DOCTYPE html><html><head></head><body></body></html>\\\");\\n\\n  if (fabric.document.createWindow) {\\n    fabric.window = fabric.document.createWindow();\\n  } else {\\n    fabric.window = fabric.document.parentWindow;\\n  }\\n}\\n\\n/**\\n * True when in environment that supports touch events\\n * @type boolean\\n */\\nfabric.isTouchSupported = \\\"ontouchstart\\\" in fabric.document.documentElement;\\n\\n/**\\n * True when in environment that's probably Node.js\\n * @type boolean\\n */\\nfabric.isLikelyNode = typeof Buffer !== 'undefined' &&\\n                      typeof window === 'undefined';\\n\\n/* _FROM_SVG_START_ */\\n/**\\n * Attributes parsed from all SVG elements\\n * @type array\\n */\\nfabric.SHARED_ATTRIBUTES = [\\n  \\\"display\\\",\\n  \\\"transform\\\",\\n  \\\"fill\\\", \\\"fill-opacity\\\", \\\"fill-rule\\\",\\n  \\\"opacity\\\",\\n  \\\"stroke\\\", \\\"stroke-dasharray\\\", \\\"stroke-linecap\\\",\\n  \\\"stroke-linejoin\\\", \\\"stroke-miterlimit\\\",\\n  \\\"stroke-opacity\\\", \\\"stroke-width\\\",\\n  \\\"id\\\"\\n];\\n/* _FROM_SVG_END_ */\\n\\n/**\\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\\n */\\nfabric.DPI = 96;\\nfabric.reNum = '(?:[-+]?(?:\\\\\\\\d+|\\\\\\\\d*\\\\\\\\.\\\\\\\\d+)(?:e[-+]?\\\\\\\\d+)?)';\\nfabric.fontPaths = { };\\n\\n/**\\n * Cache Object for widths of chars in text rendering.\\n */\\nfabric.charWidthsCache = { };\\n\\n/**\\n * Device Pixel Ratio\\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\\n */\\nfabric.devicePixelRatio = fabric.window.devicePixelRatio ||\\n                          fabric.window.webkitDevicePixelRatio ||\\n                          fabric.window.mozDevicePixelRatio ||\\n                          1;\\n\\n\\n(function() {\\n\\n  /**\\n   * @private\\n   * @param {String} eventName\\n   * @param {Function} handler\\n   */\\n  function _removeEventListener(eventName, handler) {\\n    if (!this.__eventListeners[eventName]) {\\n      return;\\n    }\\n    var eventListener = this.__eventListeners[eventName];\\n    if (handler) {\\n      eventListener[eventListener.indexOf(handler)] = false;\\n    }\\n    else {\\n      fabric.util.array.fill(eventListener, false);\\n    }\\n  }\\n\\n  /**\\n   * Observes specified event\\n   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)\\n   * @memberOf fabric.Observable\\n   * @alias on\\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\\n   * @return {Self} thisArg\\n   * @chainable\\n   */\\n  function observe(eventName, handler) {\\n    if (!this.__eventListeners) {\\n      this.__eventListeners = { };\\n    }\\n    // one object with key/value pairs was passed\\n    if (arguments.length === 1) {\\n      for (var prop in eventName) {\\n        this.on(prop, eventName[prop]);\\n      }\\n    }\\n    else {\\n      if (!this.__eventListeners[eventName]) {\\n        this.__eventListeners[eventName] = [];\\n      }\\n      this.__eventListeners[eventName].push(handler);\\n    }\\n    return this;\\n  }\\n\\n  /**\\n   * Stops event observing for a particular event handler. Calling this method\\n   * without arguments removes all handlers for all events\\n   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)\\n   * @memberOf fabric.Observable\\n   * @alias off\\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\\n   * @param {Function} handler Function to be deleted from EventListeners\\n   * @return {Self} thisArg\\n   * @chainable\\n   */\\n  function stopObserving(eventName, handler) {\\n    if (!this.__eventListeners) {\\n      return;\\n    }\\n\\n    // remove all key/value pairs (event name -> event handler)\\n    if (arguments.length === 0) {\\n      for (eventName in this.__eventListeners) {\\n        _removeEventListener.call(this, eventName);\\n      }\\n    }\\n    // one object with key/value pairs was passed\\n    else if (arguments.length === 1 && typeof arguments[0] === 'object') {\\n      for (var prop in eventName) {\\n        _removeEventListener.call(this, prop, eventName[prop]);\\n      }\\n    }\\n    else {\\n      _removeEventListener.call(this, eventName, handler);\\n    }\\n    return this;\\n  }\\n\\n  /**\\n   * Fires event with an optional options object\\n   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)\\n   * @memberOf fabric.Observable\\n   * @alias trigger\\n   * @param {String} eventName Event name to fire\\n   * @param {Object} [options] Options object\\n   * @return {Self} thisArg\\n   * @chainable\\n   */\\n  function fire(eventName, options) {\\n    if (!this.__eventListeners) {\\n      return;\\n    }\\n\\n    var listenersForEvent = this.__eventListeners[eventName];\\n    if (!listenersForEvent) {\\n      return;\\n    }\\n\\n    for (var i = 0, len = listenersForEvent.length; i < len; i++) {\\n      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });\\n    }\\n    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {\\n      return value !== false;\\n    });\\n    return this;\\n  }\\n\\n  /**\\n   * @namespace fabric.Observable\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\\n   * @see {@link http://fabricjs.com/events|Events demo}\\n   */\\n  fabric.Observable = {\\n    observe: observe,\\n    stopObserving: stopObserving,\\n    fire: fire,\\n\\n    on: observe,\\n    off: stopObserving,\\n    trigger: fire\\n  };\\n})();\\n\\n\\n/**\\n * @namespace fabric.Collection\\n */\\nfabric.Collection = {\\n\\n  _objects: [],\\n\\n  /**\\n   * Adds objects to collection, Canvas or Group, then renders canvas\\n   * (if `renderOnAddRemove` is not `false`).\\n   * in case of Group no changes to bounding box are made.\\n   * Objects should be instances of (or inherit from) fabric.Object\\n   * @param {...fabric.Object} object Zero or more fabric instances\\n   * @return {Self} thisArg\\n   * @chainable\\n   */\\n  add: function () {\\n    this._objects.push.apply(this._objects, arguments);\\n    if (this._onObjectAdded) {\\n      for (var i = 0, length = arguments.length; i < length; i++) {\\n        this._onObjectAdded(arguments[i]);\\n      }\\n    }\\n    this.renderOnAddRemove && this.renderAll();\\n    return this;\\n  },\\n\\n  /**\\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\\n   * An object should be an instance of (or inherit from) fabric.Object\\n   * @param {Object} object Object to insert\\n   * @param {Number} index Index to insert object at\\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\\n   * @return {Self} thisArg\\n   * @chainable\\n   */\\n  insertAt: function (object, index, nonSplicing) {\\n    var objects = this.getObjects();\\n    if (nonSplicing) {\\n      objects[index] = object;\\n    }\\n    else {\\n      objects.splice(index, 0, object);\\n    }\\n    this._onObjectAdded && this._onObjectAdded(object);\\n    this.renderOnAddRemove && this.renderAll();\\n    return this;\\n  },\\n\\n  /**\\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\\n   * @param {...fabric.Object} object Zero or more fabric instances\\n   * @return {Self} thisArg\\n   * @chainable\\n   */\\n  remove: function() {\\n    var objects = this.getObjects(),\\n        index, somethingRemoved = false;\\n\\n    for (var i = 0, length = arguments.length; i < length; i++) {\\n      index = objects.indexOf(arguments[i]);\\n\\n      // only call onObjectRemoved if an object was actually removed\\n      if (index !== -1) {\\n        somethingRemoved = true;\\n        objects.splice(index, 1);\\n        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);\\n      }\\n    }\\n\\n    this.renderOnAddRemove && somethingRemoved && this.renderAll();\\n    return this;\\n  },\\n\\n  /**\\n   * Executes given function for each object in this group\\n   * @param {Function} callback\\n   *                   Callback invoked with current object as first argument,\\n   *                   index - as second and an array of all objects - as third.\\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\\n   *                   when no `context` argument is given\\n   *\\n   * @param {Object} context Context (aka thisObject)\\n   * @return {Self} thisArg\\n   * @chainable\\n   */\\n  forEachObject: function(callback, context) {\\n    var objects = this.getObjects();\\n    for (var i = 0, len = objects.length; i < len; i++) {\\n      callback.call(context, objects[i], i, objects);\\n    }\\n    return this;\\n  },\\n\\n  /**\\n   * Returns an array of children objects of this instance\\n   * Type parameter introduced in 1.3.10\\n   * @param {String} [type] When specified, only objects of this type are returned\\n   * @return {Array}\\n   */\\n  getObjects: function(type) {\\n    if (typeof type === 'undefined') {\\n      return this._objects;\\n    }\\n    return this._objects.filter(function(o) {\\n      return o.type === type;\\n    });\\n  },\\n\\n  /**\\n   * Returns object at specified index\\n   * @param {Number} index\\n   * @return {Self} thisArg\\n   */\\n  item: function (index) {\\n    return this.getObjects()[index];\\n  },\\n\\n  /**\\n   * Returns true if collection contains no objects\\n   * @return {Boolean} true if collection is empty\\n   */\\n  isEmpty: function () {\\n    return this.getObjects().length === 0;\\n  },\\n\\n  /**\\n   * Returns a size of a collection (i.e: length of an array containing its objects)\\n   * @return {Number} Collection size\\n   */\\n  size: function() {\\n    return this.getObjects().length;\\n  },\\n\\n  /**\\n   * Returns true if collection contains an object\\n   * @param {Object} object Object to check against\\n   * @return {Boolean} `true` if collection contains an object\\n   */\\n  contains: function(object) {\\n    return this.getObjects().indexOf(object) > -1;\\n  },\\n\\n  /**\\n   * Returns number representation of a collection complexity\\n   * @return {Number} complexity\\n   */\\n  complexity: function () {\\n    return this.getObjects().reduce(function (memo, current) {\\n      memo += current.complexity ? current.complexity() : 0;\\n      return memo;\\n    }, 0);\\n  }\\n};\\n\\n\\n(function(global) {\\n\\n  var sqrt = Math.sqrt,\\n      atan2 = Math.atan2,\\n      pow = Math.pow,\\n      abs = Math.abs,\\n      PiBy180 = Math.PI / 180;\\n\\n  /**\\n   * @namespace fabric.util\\n   */\\n  fabric.util = {\\n\\n    /**\\n     * Removes value from an array.\\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Array} array\\n     * @param {*} value\\n     * @return {Array} original array\\n     */\\n    removeFromArray: function(array, value) {\\n      var idx = array.indexOf(value);\\n      if (idx !== -1) {\\n        array.splice(idx, 1);\\n      }\\n      return array;\\n    },\\n\\n    /**\\n     * Returns random number between 2 specified ones.\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Number} min lower limit\\n     * @param {Number} max upper limit\\n     * @return {Number} random value (between min and max)\\n     */\\n    getRandomInt: function(min, max) {\\n      return Math.floor(Math.random() * (max - min + 1)) + min;\\n    },\\n\\n    /**\\n     * Transforms degrees to radians.\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Number} degrees value in degrees\\n     * @return {Number} value in radians\\n     */\\n    degreesToRadians: function(degrees) {\\n      return degrees * PiBy180;\\n    },\\n\\n    /**\\n     * Transforms radians to degrees.\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Number} radians value in radians\\n     * @return {Number} value in degrees\\n     */\\n    radiansToDegrees: function(radians) {\\n      return radians / PiBy180;\\n    },\\n\\n    /**\\n     * Rotates `point` around `origin` with `radians`\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {fabric.Point} point The point to rotate\\n     * @param {fabric.Point} origin The origin of the rotation\\n     * @param {Number} radians The radians of the angle for the rotation\\n     * @return {fabric.Point} The new rotated point\\n     */\\n    rotatePoint: function(point, origin, radians) {\\n      point.subtractEquals(origin);\\n      var v = fabric.util.rotateVector(point, radians);\\n      return new fabric.Point(v.x, v.y).addEquals(origin);\\n    },\\n\\n    /**\\n     * Rotates `vector` with `radians`\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Object} vector The vector to rotate (x and y)\\n     * @param {Number} radians The radians of the angle for the rotation\\n     * @return {Object} The new rotated point\\n     */\\n    rotateVector: function(vector, radians) {\\n      var sin = Math.sin(radians),\\n          cos = Math.cos(radians),\\n          rx = vector.x * cos - vector.y * sin,\\n          ry = vector.x * sin + vector.y * cos;\\n      return {\\n        x: rx,\\n        y: ry\\n      };\\n    },\\n\\n    /**\\n     * Apply transform t to point p\\n     * @static\\n     * @memberOf fabric.util\\n     * @param  {fabric.Point} p The point to transform\\n     * @param  {Array} t The transform\\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\\n     * @return {fabric.Point} The transformed point\\n     */\\n    transformPoint: function(p, t, ignoreOffset) {\\n      if (ignoreOffset) {\\n        return new fabric.Point(\\n          t[0] * p.x + t[2] * p.y,\\n          t[1] * p.x + t[3] * p.y\\n        );\\n      }\\n      return new fabric.Point(\\n        t[0] * p.x + t[2] * p.y + t[4],\\n        t[1] * p.x + t[3] * p.y + t[5]\\n      );\\n    },\\n\\n    /**\\n     * Returns coordinates of points's bounding rectangle (left, top, width, height)\\n     * @param {Array} points 4 points array\\n     * @return {Object} Object with left, top, width, height properties\\n     */\\n    makeBoundingBoxFromPoints: function(points) {\\n      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],\\n          minX = fabric.util.array.min(xPoints),\\n          maxX = fabric.util.array.max(xPoints),\\n          width = Math.abs(minX - maxX),\\n          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],\\n          minY = fabric.util.array.min(yPoints),\\n          maxY = fabric.util.array.max(yPoints),\\n          height = Math.abs(minY - maxY);\\n\\n      return {\\n        left: minX,\\n        top: minY,\\n        width: width,\\n        height: height\\n      };\\n    },\\n\\n    /**\\n     * Invert transformation t\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Array} t The transform\\n     * @return {Array} The inverted transform\\n     */\\n    invertTransform: function(t) {\\n      var a = 1 / (t[0] * t[3] - t[1] * t[2]),\\n          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],\\n          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);\\n      r[4] = -o.x;\\n      r[5] = -o.y;\\n      return r;\\n    },\\n\\n    /**\\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Number|String} number number to operate on\\n     * @param {Number} fractionDigits number of fraction digits to \\\"leave\\\"\\n     * @return {Number}\\n     */\\n    toFixed: function(number, fractionDigits) {\\n      return parseFloat(Number(number).toFixed(fractionDigits));\\n    },\\n\\n    /**\\n     * Converts from attribute value to pixel value if applicable.\\n     * Returns converted pixels or original value not converted.\\n     * @param {Number|String} value number to operate on\\n     * @param {Number} fontSize\\n     * @return {Number|String}\\n     */\\n    parseUnit: function(value, fontSize) {\\n      var unit = /\\\\D{0,2}$/.exec(value),\\n          number = parseFloat(value);\\n      if (!fontSize) {\\n        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\\n      }\\n      switch (unit[0]) {\\n        case 'mm':\\n          return number * fabric.DPI / 25.4;\\n\\n        case 'cm':\\n          return number * fabric.DPI / 2.54;\\n\\n        case 'in':\\n          return number * fabric.DPI;\\n\\n        case 'pt':\\n          return number * fabric.DPI / 72; // or * 4 / 3\\n\\n        case 'pc':\\n          return number * fabric.DPI / 72 * 12; // or * 16\\n\\n        case 'em':\\n          return number * fontSize;\\n\\n        default:\\n          return number;\\n      }\\n    },\\n\\n    /**\\n     * Function which always returns `false`.\\n     * @static\\n     * @memberOf fabric.util\\n     * @return {Boolean}\\n     */\\n    falseFunction: function() {\\n      return false;\\n    },\\n\\n    /**\\n     * Returns klass \\\"Class\\\" object of given namespace\\n     * @memberOf fabric.util\\n     * @param {String} type Type of object (eg. 'circle')\\n     * @param {String} namespace Namespace to get klass \\\"Class\\\" object from\\n     * @return {Object} klass \\\"Class\\\"\\n     */\\n    getKlass: function(type, namespace) {\\n      // capitalize first letter only\\n      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\\n      return fabric.util.resolveNamespace(namespace)[type];\\n    },\\n\\n    /**\\n     * Returns object of given namespace\\n     * @memberOf fabric.util\\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\\n     * @return {Object} Object for given namespace (default fabric)\\n     */\\n    resolveNamespace: function(namespace) {\\n      if (!namespace) {\\n        return fabric;\\n      }\\n\\n      var parts = namespace.split('.'),\\n          len = parts.length, i,\\n          obj = global || fabric.window;\\n\\n      for (i = 0; i < len; ++i) {\\n        obj = obj[parts[i]];\\n      }\\n\\n      return obj;\\n    },\\n\\n    /**\\n     * Loads image element from given url and passes it to a callback\\n     * @memberOf fabric.util\\n     * @param {String} url URL representing an image\\n     * @param {Function} callback Callback; invoked with loaded image\\n     * @param {*} [context] Context to invoke callback in\\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\\n     */\\n    loadImage: function(url, callback, context, crossOrigin) {\\n      if (!url) {\\n        callback && callback.call(context, url);\\n        return;\\n      }\\n\\n      var img = fabric.util.createImage();\\n\\n      /** @ignore */\\n      img.onload = function () {\\n        callback && callback.call(context, img);\\n        img = img.onload = img.onerror = null;\\n      };\\n\\n      /** @ignore */\\n      img.onerror = function() {\\n        fabric.log('Error loading ' + img.src);\\n        callback && callback.call(context, null, true);\\n        img = img.onload = img.onerror = null;\\n      };\\n\\n      // data-urls appear to be buggy with crossOrigin\\n      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\\n      // see https://code.google.com/p/chromium/issues/detail?id=315152\\n      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\\n      if (url.indexOf('data') !== 0 && crossOrigin) {\\n        img.crossOrigin = crossOrigin;\\n      }\\n\\n      img.src = url;\\n    },\\n\\n    /**\\n     * Creates corresponding fabric instances from their object representations\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Array} objects Objects to enliven\\n     * @param {Function} callback Callback to invoke when all objects are created\\n     * @param {String} namespace Namespace to get klass \\\"Class\\\" object from\\n     * @param {Function} reviver Method for further parsing of object elements,\\n     * called after each fabric object created.\\n     */\\n    enlivenObjects: function(objects, callback, namespace, reviver) {\\n      objects = objects || [];\\n\\n      function onLoaded() {\\n        if (++numLoadedObjects === numTotalObjects) {\\n          callback && callback(enlivenedObjects);\\n        }\\n      }\\n\\n      var enlivenedObjects = [],\\n          numLoadedObjects = 0,\\n          numTotalObjects = objects.length;\\n\\n      if (!numTotalObjects) {\\n        callback && callback(enlivenedObjects);\\n        return;\\n      }\\n\\n      objects.forEach(function (o, index) {\\n        // if sparse array\\n        if (!o || !o.type) {\\n          onLoaded();\\n          return;\\n        }\\n        var klass = fabric.util.getKlass(o.type, namespace);\\n        if (klass.async) {\\n          klass.fromObject(o, function (obj, error) {\\n            if (!error) {\\n              enlivenedObjects[index] = obj;\\n              reviver && reviver(o, enlivenedObjects[index]);\\n            }\\n            onLoaded();\\n          });\\n        }\\n        else {\\n          enlivenedObjects[index] = klass.fromObject(o);\\n          reviver && reviver(o, enlivenedObjects[index]);\\n          onLoaded();\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Groups SVG elements (usually those retrieved from SVG document)\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Array} elements SVG elements to group\\n     * @param {Object} [options] Options object\\n     * @param {String} path Value to set sourcePath to\\n     * @return {fabric.Object|fabric.PathGroup}\\n     */\\n    groupSVGElements: function(elements, options, path) {\\n      var object;\\n\\n      object = new fabric.PathGroup(elements, options);\\n\\n      if (typeof path !== 'undefined') {\\n        object.setSourcePath(path);\\n      }\\n      return object;\\n    },\\n\\n    /**\\n     * Populates an object with properties of another object\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Object} source Source object\\n     * @param {Object} destination Destination object\\n     * @return {Array} properties Propertie names to include\\n     */\\n    populateWithProperties: function(source, destination, properties) {\\n      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {\\n        for (var i = 0, len = properties.length; i < len; i++) {\\n          if (properties[i] in source) {\\n            destination[properties[i]] = source[properties[i]];\\n          }\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Draws a dashed line between two points\\n     *\\n     * This method is used to draw dashed line around selection area.\\n     * See <a href=\\\"http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\\\">dotted stroke in canvas</a>\\n     *\\n     * @param {CanvasRenderingContext2D} ctx context\\n     * @param {Number} x  start x coordinate\\n     * @param {Number} y start y coordinate\\n     * @param {Number} x2 end x coordinate\\n     * @param {Number} y2 end y coordinate\\n     * @param {Array} da dash array pattern\\n     */\\n    drawDashedLine: function(ctx, x, y, x2, y2, da) {\\n      var dx = x2 - x,\\n          dy = y2 - y,\\n          len = sqrt(dx * dx + dy * dy),\\n          rot = atan2(dy, dx),\\n          dc = da.length,\\n          di = 0,\\n          draw = true;\\n\\n      ctx.save();\\n      ctx.translate(x, y);\\n      ctx.moveTo(0, 0);\\n      ctx.rotate(rot);\\n\\n      x = 0;\\n      while (len > x) {\\n        x += da[di++ % dc];\\n        if (x > len) {\\n          x = len;\\n        }\\n        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);\\n        draw = !draw;\\n      }\\n\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * Creates canvas element and initializes it via excanvas if necessary\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {CanvasElement} [canvasEl] optional canvas element to initialize;\\n     * when not given, element is created implicitly\\n     * @return {CanvasElement} initialized canvas element\\n     */\\n    createCanvasElement: function(canvasEl) {\\n      canvasEl || (canvasEl = fabric.document.createElement('canvas'));\\n      /* eslint-disable camelcase */\\n      if (!canvasEl.getContext && typeof G_vmlCanvasManager !== 'undefined') {\\n        G_vmlCanvasManager.initElement(canvasEl);\\n      }\\n      /* eslint-enable camelcase */\\n      return canvasEl;\\n    },\\n\\n    /**\\n     * Creates image element (works on client and node)\\n     * @static\\n     * @memberOf fabric.util\\n     * @return {HTMLImageElement} HTML image element\\n     */\\n    createImage: function() {\\n      return fabric.isLikelyNode\\n        ? new (require('canvas').Image)()\\n        : fabric.document.createElement('img');\\n    },\\n\\n    /**\\n     * Creates accessors (getXXX, setXXX) for a \\\"class\\\", based on \\\"stateProperties\\\" array\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {Object} klass \\\"Class\\\" to create accessors for\\n     */\\n    createAccessors: function(klass) {\\n      var proto = klass.prototype, i, propName,\\n          capitalizedPropName, setterName, getterName;\\n\\n      for (i = proto.stateProperties.length; i--; ) {\\n\\n        propName = proto.stateProperties[i];\\n        capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1);\\n        setterName = 'set' + capitalizedPropName;\\n        getterName = 'get' + capitalizedPropName;\\n\\n        // using `new Function` for better introspection\\n        if (!proto[getterName]) {\\n          proto[getterName] = (function(property) {\\n            return new Function('return this.get(\\\"' + property + '\\\")');\\n          })(propName);\\n        }\\n        if (!proto[setterName]) {\\n          proto[setterName] = (function(property) {\\n            return new Function('value', 'return this.set(\\\"' + property + '\\\", value)');\\n          })(propName);\\n        }\\n      }\\n    },\\n\\n    /**\\n     * @static\\n     * @memberOf fabric.util\\n     * @param {fabric.Object} receiver Object implementing `clipTo` method\\n     * @param {CanvasRenderingContext2D} ctx Context to clip\\n     */\\n    clipContext: function(receiver, ctx) {\\n      ctx.save();\\n      ctx.beginPath();\\n      receiver.clipTo(ctx);\\n      ctx.clip();\\n    },\\n\\n    /**\\n     * Multiply matrix A by matrix B to nest transformations\\n     * @static\\n     * @memberOf fabric.util\\n     * @param  {Array} a First transformMatrix\\n     * @param  {Array} b Second transformMatrix\\n     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\\n     * @return {Array} The product of the two transform matrices\\n     */\\n    multiplyTransformMatrices: function(a, b, is2x2) {\\n      // Matrix multiply a * b\\n      return [\\n        a[0] * b[0] + a[2] * b[1],\\n        a[1] * b[0] + a[3] * b[1],\\n        a[0] * b[2] + a[2] * b[3],\\n        a[1] * b[2] + a[3] * b[3],\\n        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],\\n        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]\\n      ];\\n    },\\n\\n    /**\\n     * Decomposes standard 2x2 matrix into transform componentes\\n     * @static\\n     * @memberOf fabric.util\\n     * @param  {Array} a transformMatrix\\n     * @return {Object} Components of transform\\n     */\\n    qrDecompose: function(a) {\\n      var angle = atan2(a[1], a[0]),\\n          denom = pow(a[0], 2) + pow(a[1], 2),\\n          scaleX = sqrt(denom),\\n          scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,\\n          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);\\n      return {\\n        angle: angle  / PiBy180,\\n        scaleX: scaleX,\\n        scaleY: scaleY,\\n        skewX: skewX / PiBy180,\\n        skewY: 0,\\n        translateX: a[4],\\n        translateY: a[5]\\n      };\\n    },\\n\\n    customTransformMatrix: function(scaleX, scaleY, skewX) {\\n      var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],\\n          scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];\\n      return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);\\n    },\\n\\n    resetObjectTransform: function (target) {\\n      target.scaleX = 1;\\n      target.scaleY = 1;\\n      target.skewX = 0;\\n      target.skewY = 0;\\n      target.flipX = false;\\n      target.flipY = false;\\n      target.setAngle(0);\\n    },\\n\\n    /**\\n     * Returns string representation of function body\\n     * @param {Function} fn Function to get body of\\n     * @return {String} Function body\\n     */\\n    getFunctionBody: function(fn) {\\n      return (String(fn).match(/function[^{]*\\\\{([\\\\s\\\\S]*)\\\\}/) || {})[1];\\n    },\\n\\n    /**\\n     * Returns true if context has transparent pixel\\n     * at specified location (taking tolerance into account)\\n     * @param {CanvasRenderingContext2D} ctx context\\n     * @param {Number} x x coordinate\\n     * @param {Number} y y coordinate\\n     * @param {Number} tolerance Tolerance\\n     */\\n    isTransparent: function(ctx, x, y, tolerance) {\\n\\n      // If tolerance is > 0 adjust start coords to take into account.\\n      // If moves off Canvas fix to 0\\n      if (tolerance > 0) {\\n        if (x > tolerance) {\\n          x -= tolerance;\\n        }\\n        else {\\n          x = 0;\\n        }\\n        if (y > tolerance) {\\n          y -= tolerance;\\n        }\\n        else {\\n          y = 0;\\n        }\\n      }\\n\\n      var _isTransparent = true, i, temp,\\n          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),\\n          l = imageData.data.length;\\n\\n      // Split image data - for tolerance > 1, pixelDataSize = 4;\\n      for (i = 3; i < l; i += 4) {\\n        temp = imageData.data[i];\\n        _isTransparent = temp <= 0;\\n        if (_isTransparent === false) {\\n          break; // Stop if colour found\\n        }\\n      }\\n\\n      imageData = null;\\n\\n      return _isTransparent;\\n    },\\n\\n    /**\\n     * Parse preserveAspectRatio attribute from element\\n     * @param {string} attribute to be parsed\\n     * @return {Object} an object containing align and meetOrSlice attribute\\n     */\\n    parsePreserveAspectRatioAttribute: function(attribute) {\\n      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',\\n          aspectRatioAttrs = attribute.split(' '), align;\\n\\n      if (aspectRatioAttrs && aspectRatioAttrs.length) {\\n        meetOrSlice = aspectRatioAttrs.pop();\\n        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {\\n          align = meetOrSlice;\\n          meetOrSlice = 'meet';\\n        }\\n        else if (aspectRatioAttrs.length) {\\n          align = aspectRatioAttrs.pop();\\n        }\\n      }\\n      //divide align in alignX and alignY\\n      alignX = align !== 'none' ? align.slice(1, 4) : 'none';\\n      alignY = align !== 'none' ? align.slice(5, 8) : 'none';\\n      return {\\n        meetOrSlice: meetOrSlice,\\n        alignX: alignX,\\n        alignY: alignY\\n      };\\n    },\\n\\n    /**\\n     * Clear char widths cache for a font family.\\n     * @memberOf fabric.util\\n     * @param {String} [fontFamily] font family to clear\\n     */\\n    clearFabricFontCache: function(fontFamily) {\\n      if (!fontFamily) {\\n        fabric.charWidthsCache = { };\\n      }\\n      else if (fabric.charWidthsCache[fontFamily]) {\\n        delete fabric.charWidthsCache[fontFamily];\\n      }\\n    }\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function() {\\n\\n  var arcToSegmentsCache = { },\\n      segmentToBezierCache = { },\\n      boundsOfCurveCache = { },\\n      _join = Array.prototype.join;\\n\\n  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\\n   * http://mozilla.org/MPL/2.0/\\n   */\\n  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\\n    var argsString = _join.call(arguments);\\n    if (arcToSegmentsCache[argsString]) {\\n      return arcToSegmentsCache[argsString];\\n    }\\n\\n    var PI = Math.PI, th = rotateX * PI / 180,\\n        sinTh = Math.sin(th),\\n        cosTh = Math.cos(th),\\n        fromX = 0, fromY = 0;\\n\\n    rx = Math.abs(rx);\\n    ry = Math.abs(ry);\\n\\n    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,\\n        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,\\n        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,\\n        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,\\n        root = 0;\\n\\n    if (pl < 0) {\\n      var s = Math.sqrt(1 - pl / (rx2 * ry2));\\n      rx *= s;\\n      ry *= s;\\n    }\\n    else {\\n      root = (large === sweep ? -1.0 : 1.0) *\\n              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));\\n    }\\n\\n    var cx = root * rx * py / ry,\\n        cy = -root * ry * px / rx,\\n        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,\\n        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,\\n        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),\\n        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\\n\\n    if (sweep === 0 && dtheta > 0) {\\n      dtheta -= 2 * PI;\\n    }\\n    else if (sweep === 1 && dtheta < 0) {\\n      dtheta += 2 * PI;\\n    }\\n\\n    // Convert into cubic bezier segments <= 90deg\\n    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),\\n        result = [], mDelta = dtheta / segments,\\n        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),\\n        th3 = mTheta + mDelta;\\n\\n    for (var i = 0; i < segments; i++) {\\n      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\\n      fromX = result[i][4];\\n      fromY = result[i][5];\\n      mTheta = th3;\\n      th3 += mDelta;\\n    }\\n    arcToSegmentsCache[argsString] = result;\\n    return result;\\n  }\\n\\n  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\\n    var argsString2 = _join.call(arguments);\\n    if (segmentToBezierCache[argsString2]) {\\n      return segmentToBezierCache[argsString2];\\n    }\\n\\n    var costh2 = Math.cos(th2),\\n        sinth2 = Math.sin(th2),\\n        costh3 = Math.cos(th3),\\n        sinth3 = Math.sin(th3),\\n        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,\\n        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,\\n        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),\\n        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),\\n        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),\\n        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);\\n\\n    segmentToBezierCache[argsString2] = [\\n      cp1X, cp1Y,\\n      cp2X, cp2Y,\\n      toX, toY\\n    ];\\n    return segmentToBezierCache[argsString2];\\n  }\\n\\n  /*\\n   * Private\\n   */\\n  function calcVectorAngle(ux, uy, vx, vy) {\\n    var ta = Math.atan2(uy, ux),\\n        tb = Math.atan2(vy, vx);\\n    if (tb >= ta) {\\n      return tb - ta;\\n    }\\n    else {\\n      return 2 * Math.PI - (ta - tb);\\n    }\\n  }\\n\\n  /**\\n   * Draws arc\\n   * @param {CanvasRenderingContext2D} ctx\\n   * @param {Number} fx\\n   * @param {Number} fy\\n   * @param {Array} coords\\n   */\\n  fabric.util.drawArc = function(ctx, fx, fy, coords) {\\n    var rx = coords[0],\\n        ry = coords[1],\\n        rot = coords[2],\\n        large = coords[3],\\n        sweep = coords[4],\\n        tx = coords[5],\\n        ty = coords[6],\\n        segs = [[], [], [], []],\\n        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\\n\\n    for (var i = 0, len = segsNorm.length; i < len; i++) {\\n      segs[i][0] = segsNorm[i][0] + fx;\\n      segs[i][1] = segsNorm[i][1] + fy;\\n      segs[i][2] = segsNorm[i][2] + fx;\\n      segs[i][3] = segsNorm[i][3] + fy;\\n      segs[i][4] = segsNorm[i][4] + fx;\\n      segs[i][5] = segsNorm[i][5] + fy;\\n      ctx.bezierCurveTo.apply(ctx, segs[i]);\\n    }\\n  };\\n\\n  /**\\n   * Calculate bounding box of a elliptic-arc\\n   * @param {Number} fx start point of arc\\n   * @param {Number} fy\\n   * @param {Number} rx horizontal radius\\n   * @param {Number} ry vertical radius\\n   * @param {Number} rot angle of horizontal axe\\n   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points\\n   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction\\n   * @param {Number} tx end point of arc\\n   * @param {Number} ty\\n   */\\n  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {\\n\\n    var fromX = 0, fromY = 0, bound, bounds = [],\\n        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\\n\\n    for (var i = 0, len = segs.length; i < len; i++) {\\n      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);\\n      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });\\n      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });\\n      fromX = segs[i][4];\\n      fromY = segs[i][5];\\n    }\\n    return bounds;\\n  };\\n\\n  /**\\n   * Calculate bounding box of a beziercurve\\n   * @param {Number} x0 starting point\\n   * @param {Number} y0\\n   * @param {Number} x1 first control point\\n   * @param {Number} y1\\n   * @param {Number} x2 secondo control point\\n   * @param {Number} y2\\n   * @param {Number} x3 end of beizer\\n   * @param {Number} y3\\n   */\\n  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\\n  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\\n    var argsString = _join.call(arguments);\\n    if (boundsOfCurveCache[argsString]) {\\n      return boundsOfCurveCache[argsString];\\n    }\\n\\n    var sqrt = Math.sqrt,\\n        min = Math.min, max = Math.max,\\n        abs = Math.abs, tvalues = [],\\n        bounds = [[], []],\\n        a, b, c, t, t1, t2, b2ac, sqrtb2ac;\\n\\n    b = 6 * x0 - 12 * x1 + 6 * x2;\\n    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\\n    c = 3 * x1 - 3 * x0;\\n\\n    for (var i = 0; i < 2; ++i) {\\n      if (i > 0) {\\n        b = 6 * y0 - 12 * y1 + 6 * y2;\\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\\n        c = 3 * y1 - 3 * y0;\\n      }\\n\\n      if (abs(a) < 1e-12) {\\n        if (abs(b) < 1e-12) {\\n          continue;\\n        }\\n        t = -c / b;\\n        if (0 < t && t < 1) {\\n          tvalues.push(t);\\n        }\\n        continue;\\n      }\\n      b2ac = b * b - 4 * c * a;\\n      if (b2ac < 0) {\\n        continue;\\n      }\\n      sqrtb2ac = sqrt(b2ac);\\n      t1 = (-b + sqrtb2ac) / (2 * a);\\n      if (0 < t1 && t1 < 1) {\\n        tvalues.push(t1);\\n      }\\n      t2 = (-b - sqrtb2ac) / (2 * a);\\n      if (0 < t2 && t2 < 1) {\\n        tvalues.push(t2);\\n      }\\n    }\\n\\n    var x, y, j = tvalues.length, jlen = j, mt;\\n    while (j--) {\\n      t = tvalues[j];\\n      mt = 1 - t;\\n      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\\n      bounds[0][j] = x;\\n\\n      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\\n      bounds[1][j] = y;\\n    }\\n\\n    bounds[0][jlen] = x0;\\n    bounds[1][jlen] = y0;\\n    bounds[0][jlen + 1] = x3;\\n    bounds[1][jlen + 1] = y3;\\n    var result = [\\n      {\\n        x: min.apply(null, bounds[0]),\\n        y: min.apply(null, bounds[1])\\n      },\\n      {\\n        x: max.apply(null, bounds[0]),\\n        y: max.apply(null, bounds[1])\\n      }\\n    ];\\n    boundsOfCurveCache[argsString] = result;\\n    return result;\\n  }\\n\\n  fabric.util.getBoundsOfCurve = getBoundsOfCurve;\\n\\n})();\\n\\n\\n(function() {\\n\\n  var slice = Array.prototype.slice;\\n\\n  /* _ES5_COMPAT_START_ */\\n\\n  if (!Array.prototype.indexOf) {\\n    /**\\n     * Finds index of an element in an array\\n     * @param {*} searchElement\\n     * @return {Number}\\n     */\\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\\n      if (this === void 0 || this === null) {\\n        throw new TypeError();\\n      }\\n      var t = Object(this), len = t.length >>> 0;\\n      if (len === 0) {\\n        return -1;\\n      }\\n      var n = 0;\\n      if (arguments.length > 0) {\\n        n = Number(arguments[1]);\\n        if (n !== n) { // shortcut for verifying if it's NaN\\n          n = 0;\\n        }\\n        else if (n !== 0 && n !== Number.POSITIVE_INFINITY && n !== Number.NEGATIVE_INFINITY) {\\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\\n        }\\n      }\\n      if (n >= len) {\\n        return -1;\\n      }\\n      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\\n      for (; k < len; k++) {\\n        if (k in t && t[k] === searchElement) {\\n          return k;\\n        }\\n      }\\n      return -1;\\n    };\\n  }\\n\\n  if (!Array.prototype.forEach) {\\n    /**\\n     * Iterates an array, invoking callback for each element\\n     * @param {Function} fn Callback to invoke for each element\\n     * @param {Object} [context] Context to invoke callback in\\n     * @return {Array}\\n     */\\n    Array.prototype.forEach = function(fn, context) {\\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\\n        if (i in this) {\\n          fn.call(context, this[i], i, this);\\n        }\\n      }\\n    };\\n  }\\n\\n  if (!Array.prototype.map) {\\n    /**\\n     * Returns a result of iterating over an array, invoking callback for each element\\n     * @param {Function} fn Callback to invoke for each element\\n     * @param {Object} [context] Context to invoke callback in\\n     * @return {Array}\\n     */\\n    Array.prototype.map = function(fn, context) {\\n      var result = [];\\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\\n        if (i in this) {\\n          result[i] = fn.call(context, this[i], i, this);\\n        }\\n      }\\n      return result;\\n    };\\n  }\\n\\n  if (!Array.prototype.every) {\\n    /**\\n     * Returns true if a callback returns truthy value for all elements in an array\\n     * @param {Function} fn Callback to invoke for each element\\n     * @param {Object} [context] Context to invoke callback in\\n     * @return {Boolean}\\n     */\\n    Array.prototype.every = function(fn, context) {\\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\\n        if (i in this && !fn.call(context, this[i], i, this)) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    };\\n  }\\n\\n  if (!Array.prototype.some) {\\n    /**\\n     * Returns true if a callback returns truthy value for at least one element in an array\\n     * @param {Function} fn Callback to invoke for each element\\n     * @param {Object} [context] Context to invoke callback in\\n     * @return {Boolean}\\n     */\\n    Array.prototype.some = function(fn, context) {\\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\\n        if (i in this && fn.call(context, this[i], i, this)) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    };\\n  }\\n\\n  if (!Array.prototype.filter) {\\n    /**\\n     * Returns the result of iterating over elements in an array\\n     * @param {Function} fn Callback to invoke for each element\\n     * @param {Object} [context] Context to invoke callback in\\n     * @return {Array}\\n     */\\n    Array.prototype.filter = function(fn, context) {\\n      var result = [], val;\\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\\n        if (i in this) {\\n          val = this[i]; // in case fn mutates this\\n          if (fn.call(context, val, i, this)) {\\n            result.push(val);\\n          }\\n        }\\n      }\\n      return result;\\n    };\\n  }\\n\\n  if (!Array.prototype.reduce) {\\n    /**\\n     * Returns \\\"folded\\\" (reduced) result of iterating over elements in an array\\n     * @param {Function} fn Callback to invoke for each element\\n     * @return {*}\\n     */\\n    Array.prototype.reduce = function(fn /*, initial*/) {\\n      var len = this.length >>> 0,\\n          i = 0,\\n          rv;\\n\\n      if (arguments.length > 1) {\\n        rv = arguments[1];\\n      }\\n      else {\\n        do {\\n          if (i in this) {\\n            rv = this[i++];\\n            break;\\n          }\\n          // if array contains no values, no initial value to return\\n          if (++i >= len) {\\n            throw new TypeError();\\n          }\\n        }\\n        while (true);\\n      }\\n      for (; i < len; i++) {\\n        if (i in this) {\\n          rv = fn.call(null, rv, this[i], i, this);\\n        }\\n      }\\n      return rv;\\n    };\\n  }\\n\\n  /* _ES5_COMPAT_END_ */\\n\\n  /**\\n   * Invokes method on all items in a given array\\n   * @memberOf fabric.util.array\\n   * @param {Array} array Array to iterate over\\n   * @param {String} method Name of a method to invoke\\n   * @return {Array}\\n   */\\n  function invoke(array, method) {\\n    var args = slice.call(arguments, 2), result = [];\\n    for (var i = 0, len = array.length; i < len; i++) {\\n      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * Finds maximum value in array (not necessarily \\\"first\\\" one)\\n   * @memberOf fabric.util.array\\n   * @param {Array} array Array to iterate over\\n   * @param {String} byProperty\\n   * @return {*}\\n   */\\n  function max(array, byProperty) {\\n    return find(array, byProperty, function(value1, value2) {\\n      return value1 >= value2;\\n    });\\n  }\\n\\n  /**\\n   * Finds minimum value in array (not necessarily \\\"first\\\" one)\\n   * @memberOf fabric.util.array\\n   * @param {Array} array Array to iterate over\\n   * @param {String} byProperty\\n   * @return {*}\\n   */\\n  function min(array, byProperty) {\\n    return find(array, byProperty, function(value1, value2) {\\n      return value1 < value2;\\n    });\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function fill(array, value) {\\n    var k = array.length;\\n    while (k--) {\\n      array[k] = value;\\n    }\\n    return array;\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function find(array, byProperty, condition) {\\n    if (!array || array.length === 0) {\\n      return;\\n    }\\n\\n    var i = array.length - 1,\\n        result = byProperty ? array[i][byProperty] : array[i];\\n    if (byProperty) {\\n      while (i--) {\\n        if (condition(array[i][byProperty], result)) {\\n          result = array[i][byProperty];\\n        }\\n      }\\n    }\\n    else {\\n      while (i--) {\\n        if (condition(array[i], result)) {\\n          result = array[i];\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @namespace fabric.util.array\\n   */\\n  fabric.util.array = {\\n    fill: fill,\\n    invoke: invoke,\\n    min: min,\\n    max: max\\n  };\\n\\n})();\\n\\n\\n(function() {\\n  /**\\n   * Copies all enumerable properties of one js object to another\\n   * Does not clone or extend fabric.Object subclasses.\\n   * @memberOf fabric.util.object\\n   * @param {Object} destination Where to copy to\\n   * @param {Object} source Where to copy from\\n   * @return {Object}\\n   */\\n\\n  function extend(destination, source, deep) {\\n    // JScript DontEnum bug is not taken care of\\n    // the deep clone is for internal use, is not meant to avoid\\n    // javascript traps or cloning html element or self referenced objects.\\n    if (deep) {\\n      if (!fabric.isLikelyNode && source instanceof Element) {\\n        // avoid cloning deep images, canvases,\\n        destination = source;\\n      }\\n      else if (source instanceof Array) {\\n        destination = [];\\n        for (var i = 0, len = source.length; i < len; i++) {\\n          destination[i] = extend({ }, source[i], deep);\\n        }\\n      }\\n      else if (source && typeof source === 'object') {\\n        for (var property in source) {\\n          if (source.hasOwnProperty(property)) {\\n            destination[property] = extend({ }, source[property], deep);\\n          }\\n        }\\n      }\\n      else {\\n        // this sounds odd for an extend but is ok for recursive use\\n        destination = source;\\n      }\\n    }\\n    else {\\n      for (var property in source) {\\n        destination[property] = source[property];\\n      }\\n    }\\n    return destination;\\n  }\\n\\n  /**\\n   * Creates an empty object and copies all enumerable properties of another object to it\\n   * @memberOf fabric.util.object\\n   * @param {Object} object Object to clone\\n   * @return {Object}\\n   */\\n  function clone(object, deep) {\\n    return extend({ }, object, deep);\\n  }\\n\\n  /** @namespace fabric.util.object */\\n  fabric.util.object = {\\n    extend: extend,\\n    clone: clone\\n  };\\n\\n})();\\n\\n\\n(function() {\\n\\n  /* _ES5_COMPAT_START_ */\\n  if (!String.prototype.trim) {\\n    /**\\n     * Trims a string (removing whitespace from the beginning and the end)\\n     * @function external:String#trim\\n     * @see <a href=\\\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/Trim\\\">String#trim on MDN</a>\\n     */\\n    String.prototype.trim = function () {\\n      // this trim is not fully ES3 or ES5 compliant, but it should cover most cases for now\\n      return this.replace(/^[\\\\s\\\\xA0]+/, '').replace(/[\\\\s\\\\xA0]+$/, '');\\n    };\\n  }\\n  /* _ES5_COMPAT_END_ */\\n\\n  /**\\n   * Camelizes a string\\n   * @memberOf fabric.util.string\\n   * @param {String} string String to camelize\\n   * @return {String} Camelized version of a string\\n   */\\n  function camelize(string) {\\n    return string.replace(/-+(.)?/g, function(match, character) {\\n      return character ? character.toUpperCase() : '';\\n    });\\n  }\\n\\n  /**\\n   * Capitalizes a string\\n   * @memberOf fabric.util.string\\n   * @param {String} string String to capitalize\\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\\n   * and other letters stay untouched, if false first letter is capitalized\\n   * and other letters are converted to lowercase.\\n   * @return {String} Capitalized version of a string\\n   */\\n  function capitalize(string, firstLetterOnly) {\\n    return string.charAt(0).toUpperCase() +\\n      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\\n  }\\n\\n  /**\\n   * Escapes XML in a string\\n   * @memberOf fabric.util.string\\n   * @param {String} string String to escape\\n   * @return {String} Escaped version of a string\\n   */\\n  function escapeXml(string) {\\n    return string.replace(/&/g, '&amp;')\\n       .replace(/\\\"/g, '&quot;')\\n       .replace(/'/g, '&apos;')\\n       .replace(/</g, '&lt;')\\n       .replace(/>/g, '&gt;');\\n  }\\n\\n  /**\\n   * String utilities\\n   * @namespace fabric.util.string\\n   */\\n  fabric.util.string = {\\n    camelize: camelize,\\n    capitalize: capitalize,\\n    escapeXml: escapeXml\\n  };\\n})();\\n\\n\\n/* _ES5_COMPAT_START_ */\\n(function() {\\n\\n  var slice = Array.prototype.slice,\\n      apply = Function.prototype.apply,\\n      Dummy = function() { };\\n\\n  if (!Function.prototype.bind) {\\n    /**\\n     * Cross-browser approximation of ES5 Function.prototype.bind (not fully spec conforming)\\n     * @see <a href=\\\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\\\">Function#bind on MDN</a>\\n     * @param {Object} thisArg Object to bind function to\\n     * @param {Any[]} Values to pass to a bound function\\n     * @return {Function}\\n     */\\n    Function.prototype.bind = function(thisArg) {\\n      var _this = this, args = slice.call(arguments, 1), bound;\\n      if (args.length) {\\n        bound = function() {\\n          return apply.call(_this, this instanceof Dummy ? this : thisArg, args.concat(slice.call(arguments)));\\n        };\\n      }\\n      else {\\n        /** @ignore */\\n        bound = function() {\\n          return apply.call(_this, this instanceof Dummy ? this : thisArg, arguments);\\n        };\\n      }\\n      Dummy.prototype = this.prototype;\\n      bound.prototype = new Dummy();\\n\\n      return bound;\\n    };\\n  }\\n\\n})();\\n/* _ES5_COMPAT_END_ */\\n\\n\\n(function() {\\n\\n  var slice = Array.prototype.slice, emptyFunction = function() { },\\n\\n      IS_DONTENUM_BUGGY = (function() {\\n        for (var p in { toString: 1 }) {\\n          if (p === 'toString') {\\n            return false;\\n          }\\n        }\\n        return true;\\n      })(),\\n\\n      /** @ignore */\\n      addMethods = function(klass, source, parent) {\\n        for (var property in source) {\\n\\n          if (property in klass.prototype &&\\n              typeof klass.prototype[property] === 'function' &&\\n              (source[property] + '').indexOf('callSuper') > -1) {\\n\\n            klass.prototype[property] = (function(property) {\\n              return function() {\\n\\n                var superclass = this.constructor.superclass;\\n                this.constructor.superclass = parent;\\n                var returnValue = source[property].apply(this, arguments);\\n                this.constructor.superclass = superclass;\\n\\n                if (property !== 'initialize') {\\n                  return returnValue;\\n                }\\n              };\\n            })(property);\\n          }\\n          else {\\n            klass.prototype[property] = source[property];\\n          }\\n\\n          if (IS_DONTENUM_BUGGY) {\\n            if (source.toString !== Object.prototype.toString) {\\n              klass.prototype.toString = source.toString;\\n            }\\n            if (source.valueOf !== Object.prototype.valueOf) {\\n              klass.prototype.valueOf = source.valueOf;\\n            }\\n          }\\n        }\\n      };\\n\\n  function Subclass() { }\\n\\n  function callSuper(methodName) {\\n    var fn = this.constructor.superclass.prototype[methodName];\\n    return (arguments.length > 1)\\n      ? fn.apply(this, slice.call(arguments, 1))\\n      : fn.call(this);\\n  }\\n\\n  /**\\n   * Helper for creation of \\\"classes\\\".\\n   * @memberOf fabric.util\\n   * @param {Function} [parent] optional \\\"Class\\\" to inherit from\\n   * @param {Object} [properties] Properties shared by all instances of this class\\n   *                  (be careful modifying objects defined here as this would affect all instances)\\n   */\\n  function createClass() {\\n    var parent = null,\\n        properties = slice.call(arguments, 0);\\n\\n    if (typeof properties[0] === 'function') {\\n      parent = properties.shift();\\n    }\\n    function klass() {\\n      this.initialize.apply(this, arguments);\\n    }\\n\\n    klass.superclass = parent;\\n    klass.subclasses = [];\\n\\n    if (parent) {\\n      Subclass.prototype = parent.prototype;\\n      klass.prototype = new Subclass();\\n      parent.subclasses.push(klass);\\n    }\\n    for (var i = 0, length = properties.length; i < length; i++) {\\n      addMethods(klass, properties[i], parent);\\n    }\\n    if (!klass.prototype.initialize) {\\n      klass.prototype.initialize = emptyFunction;\\n    }\\n    klass.prototype.constructor = klass;\\n    klass.prototype.callSuper = callSuper;\\n    return klass;\\n  }\\n\\n  fabric.util.createClass = createClass;\\n})();\\n\\n\\n(function () {\\n\\n  var unknown = 'unknown';\\n\\n  /* EVENT HANDLING */\\n\\n  function areHostMethods(object) {\\n    var methodNames = Array.prototype.slice.call(arguments, 1),\\n        t, i, len = methodNames.length;\\n    for (i = 0; i < len; i++) {\\n      t = typeof object[methodNames[i]];\\n      if (!(/^(?:function|object|unknown)$/).test(t)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  /** @ignore */\\n  var getElement,\\n      setElement,\\n      getUniqueId = (function () {\\n        var uid = 0;\\n        return function (element) {\\n          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);\\n        };\\n      })();\\n\\n  (function () {\\n    var elements = { };\\n    /** @ignore */\\n    getElement = function (uid) {\\n      return elements[uid];\\n    };\\n    /** @ignore */\\n    setElement = function (uid, element) {\\n      elements[uid] = element;\\n    };\\n  })();\\n\\n  function createListener(uid, handler) {\\n    return {\\n      handler: handler,\\n      wrappedHandler: createWrappedHandler(uid, handler)\\n    };\\n  }\\n\\n  function createWrappedHandler(uid, handler) {\\n    return function (e) {\\n      handler.call(getElement(uid), e || fabric.window.event);\\n    };\\n  }\\n\\n  function createDispatcher(uid, eventName) {\\n    return function (e) {\\n      if (handlers[uid] && handlers[uid][eventName]) {\\n        var handlersForEvent = handlers[uid][eventName];\\n        for (var i = 0, len = handlersForEvent.length; i < len; i++) {\\n          handlersForEvent[i].call(this, e || fabric.window.event);\\n        }\\n      }\\n    };\\n  }\\n\\n  var shouldUseAddListenerRemoveListener = (\\n        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&\\n        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),\\n\\n      shouldUseAttachEventDetachEvent = (\\n        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&\\n        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),\\n\\n      // IE branch\\n      listeners = { },\\n\\n      // DOM L0 branch\\n      handlers = { },\\n\\n      addListener, removeListener;\\n\\n  if (shouldUseAddListenerRemoveListener) {\\n    /** @ignore */\\n    addListener = function (element, eventName, handler) {\\n      element.addEventListener(eventName, handler, false);\\n    };\\n    /** @ignore */\\n    removeListener = function (element, eventName, handler) {\\n      element.removeEventListener(eventName, handler, false);\\n    };\\n  }\\n\\n  else if (shouldUseAttachEventDetachEvent) {\\n    /** @ignore */\\n    addListener = function (element, eventName, handler) {\\n      var uid = getUniqueId(element);\\n      setElement(uid, element);\\n      if (!listeners[uid]) {\\n        listeners[uid] = { };\\n      }\\n      if (!listeners[uid][eventName]) {\\n        listeners[uid][eventName] = [];\\n\\n      }\\n      var listener = createListener(uid, handler);\\n      listeners[uid][eventName].push(listener);\\n      element.attachEvent('on' + eventName, listener.wrappedHandler);\\n    };\\n    /** @ignore */\\n    removeListener = function (element, eventName, handler) {\\n      var uid = getUniqueId(element), listener;\\n      if (listeners[uid] && listeners[uid][eventName]) {\\n        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {\\n          listener = listeners[uid][eventName][i];\\n          if (listener && listener.handler === handler) {\\n            element.detachEvent('on' + eventName, listener.wrappedHandler);\\n            listeners[uid][eventName][i] = null;\\n          }\\n        }\\n      }\\n    };\\n  }\\n  else {\\n    /** @ignore */\\n    addListener = function (element, eventName, handler) {\\n      var uid = getUniqueId(element);\\n      if (!handlers[uid]) {\\n        handlers[uid] = { };\\n      }\\n      if (!handlers[uid][eventName]) {\\n        handlers[uid][eventName] = [];\\n        var existingHandler = element['on' + eventName];\\n        if (existingHandler) {\\n          handlers[uid][eventName].push(existingHandler);\\n        }\\n        element['on' + eventName] = createDispatcher(uid, eventName);\\n      }\\n      handlers[uid][eventName].push(handler);\\n    };\\n    /** @ignore */\\n    removeListener = function (element, eventName, handler) {\\n      var uid = getUniqueId(element);\\n      if (handlers[uid] && handlers[uid][eventName]) {\\n        var handlersForEvent = handlers[uid][eventName];\\n        for (var i = 0, len = handlersForEvent.length; i < len; i++) {\\n          if (handlersForEvent[i] === handler) {\\n            handlersForEvent.splice(i, 1);\\n          }\\n        }\\n      }\\n    };\\n  }\\n\\n  /**\\n   * Adds an event listener to an element\\n   * @function\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element\\n   * @param {String} eventName\\n   * @param {Function} handler\\n   */\\n  fabric.util.addListener = addListener;\\n\\n  /**\\n   * Removes an event listener from an element\\n   * @function\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element\\n   * @param {String} eventName\\n   * @param {Function} handler\\n   */\\n  fabric.util.removeListener = removeListener;\\n\\n  /**\\n   * Cross-browser wrapper for getting event's coordinates\\n   * @memberOf fabric.util\\n   * @param {Event} event Event object\\n   */\\n  function getPointer(event) {\\n    event || (event = fabric.window.event);\\n\\n    var element = event.target ||\\n                  (typeof event.srcElement !== unknown ? event.srcElement : null),\\n\\n        scroll = fabric.util.getScrollLeftTop(element);\\n\\n    return {\\n      x: pointerX(event) + scroll.left,\\n      y: pointerY(event) + scroll.top\\n    };\\n  }\\n\\n  var pointerX = function(event) {\\n    // looks like in IE (<9) clientX at certain point (apparently when mouseup fires on VML element)\\n    // is represented as COM object, with all the consequences, like \\\"unknown\\\" type and error on [[Get]]\\n    // need to investigate later\\n        return (typeof event.clientX !== unknown ? event.clientX : 0);\\n      },\\n\\n      pointerY = function(event) {\\n        return (typeof event.clientY !== unknown ? event.clientY : 0);\\n      };\\n\\n  function _getPointer(event, pageProp, clientProp) {\\n    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';\\n\\n    return (event[touchProp] && event[touchProp][0]\\n      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))\\n        || event[clientProp]\\n      : event[clientProp]);\\n  }\\n\\n  if (fabric.isTouchSupported) {\\n    pointerX = function(event) {\\n      return _getPointer(event, 'pageX', 'clientX');\\n    };\\n    pointerY = function(event) {\\n      return _getPointer(event, 'pageY', 'clientY');\\n    };\\n  }\\n\\n  fabric.util.getPointer = getPointer;\\n\\n  fabric.util.object.extend(fabric.util, fabric.Observable);\\n\\n})();\\n\\n\\n(function () {\\n\\n  /**\\n   * Cross-browser wrapper for setting element's style\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element\\n   * @param {Object} styles\\n   * @return {HTMLElement} Element that was passed as a first argument\\n   */\\n  function setStyle(element, styles) {\\n    var elementStyle = element.style;\\n    if (!elementStyle) {\\n      return element;\\n    }\\n    if (typeof styles === 'string') {\\n      element.style.cssText += ';' + styles;\\n      return styles.indexOf('opacity') > -1\\n        ? setOpacity(element, styles.match(/opacity:\\\\s*(\\\\d?\\\\.?\\\\d*)/)[1])\\n        : element;\\n    }\\n    for (var property in styles) {\\n      if (property === 'opacity') {\\n        setOpacity(element, styles[property]);\\n      }\\n      else {\\n        var normalizedProperty = (property === 'float' || property === 'cssFloat')\\n          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')\\n          : property;\\n        elementStyle[normalizedProperty] = styles[property];\\n      }\\n    }\\n    return element;\\n  }\\n\\n  var parseEl = fabric.document.createElement('div'),\\n      supportsOpacity = typeof parseEl.style.opacity === 'string',\\n      supportsFilters = typeof parseEl.style.filter === 'string',\\n      reOpacity = /alpha\\\\s*\\\\(\\\\s*opacity\\\\s*=\\\\s*([^\\\\)]+)\\\\)/,\\n\\n      /** @ignore */\\n      setOpacity = function (element) { return element; };\\n\\n  if (supportsOpacity) {\\n    /** @ignore */\\n    setOpacity = function(element, value) {\\n      element.style.opacity = value;\\n      return element;\\n    };\\n  }\\n  else if (supportsFilters) {\\n    /** @ignore */\\n    setOpacity = function(element, value) {\\n      var es = element.style;\\n      if (element.currentStyle && !element.currentStyle.hasLayout) {\\n        es.zoom = 1;\\n      }\\n      if (reOpacity.test(es.filter)) {\\n        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');\\n        es.filter = es.filter.replace(reOpacity, value);\\n      }\\n      else {\\n        es.filter += ' alpha(opacity=' + (value * 100) + ')';\\n      }\\n      return element;\\n    };\\n  }\\n\\n  fabric.util.setStyle = setStyle;\\n\\n})();\\n\\n\\n(function() {\\n\\n  var _slice = Array.prototype.slice;\\n\\n  /**\\n   * Takes id and returns an element with that id (if one exists in a document)\\n   * @memberOf fabric.util\\n   * @param {String|HTMLElement} id\\n   * @return {HTMLElement|null}\\n   */\\n  function getById(id) {\\n    return typeof id === 'string' ? fabric.document.getElementById(id) : id;\\n  }\\n\\n  var sliceCanConvertNodelists,\\n      /**\\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\\n       * @memberOf fabric.util\\n       * @param {Object} arrayLike\\n       * @return {Array}\\n       */\\n      toArray = function(arrayLike) {\\n        return _slice.call(arrayLike, 0);\\n      };\\n\\n  try {\\n    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\\n  }\\n  catch (err) { }\\n\\n  if (!sliceCanConvertNodelists) {\\n    toArray = function(arrayLike) {\\n      var arr = new Array(arrayLike.length), i = arrayLike.length;\\n      while (i--) {\\n        arr[i] = arrayLike[i];\\n      }\\n      return arr;\\n    };\\n  }\\n\\n  /**\\n   * Creates specified element with specified attributes\\n   * @memberOf fabric.util\\n   * @param {String} tagName Type of an element to create\\n   * @param {Object} [attributes] Attributes to set on an element\\n   * @return {HTMLElement} Newly created element\\n   */\\n  function makeElement(tagName, attributes) {\\n    var el = fabric.document.createElement(tagName);\\n    for (var prop in attributes) {\\n      if (prop === 'class') {\\n        el.className = attributes[prop];\\n      }\\n      else if (prop === 'for') {\\n        el.htmlFor = attributes[prop];\\n      }\\n      else {\\n        el.setAttribute(prop, attributes[prop]);\\n      }\\n    }\\n    return el;\\n  }\\n\\n  /**\\n   * Adds class to an element\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element Element to add class to\\n   * @param {String} className Class to add to an element\\n   */\\n  function addClass(element, className) {\\n    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {\\n      element.className += (element.className ? ' ' : '') + className;\\n    }\\n  }\\n\\n  /**\\n   * Wraps element with another element\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element Element to wrap\\n   * @param {HTMLElement|String} wrapper Element to wrap with\\n   * @param {Object} [attributes] Attributes to set on a wrapper\\n   * @return {HTMLElement} wrapper\\n   */\\n  function wrapElement(element, wrapper, attributes) {\\n    if (typeof wrapper === 'string') {\\n      wrapper = makeElement(wrapper, attributes);\\n    }\\n    if (element.parentNode) {\\n      element.parentNode.replaceChild(wrapper, element);\\n    }\\n    wrapper.appendChild(element);\\n    return wrapper;\\n  }\\n\\n  /**\\n   * Returns element scroll offsets\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element Element to operate on\\n   * @return {Object} Object with left/top values\\n   */\\n  function getScrollLeftTop(element) {\\n\\n    var left = 0,\\n        top = 0,\\n        docElement = fabric.document.documentElement,\\n        body = fabric.document.body || {\\n          scrollLeft: 0, scrollTop: 0\\n        };\\n\\n    // While loop checks (and then sets element to) .parentNode OR .host\\n    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,\\n    //  but the .parentNode of a root ShadowDOM node will always be null, instead\\n    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938\\n    while (element && (element.parentNode || element.host)) {\\n\\n      // Set element to element parent, or 'host' in case of ShadowDOM\\n      element = element.parentNode || element.host;\\n\\n      if (element === fabric.document) {\\n        left = body.scrollLeft || docElement.scrollLeft || 0;\\n        top = body.scrollTop ||  docElement.scrollTop || 0;\\n      }\\n      else {\\n        left += element.scrollLeft || 0;\\n        top += element.scrollTop || 0;\\n      }\\n\\n      if (element.nodeType === 1 &&\\n          fabric.util.getElementStyle(element, 'position') === 'fixed') {\\n        break;\\n      }\\n    }\\n\\n    return { left: left, top: top };\\n  }\\n\\n  /**\\n   * Returns offset for a given element\\n   * @function\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element Element to get offset for\\n   * @return {Object} Object with \\\"left\\\" and \\\"top\\\" properties\\n   */\\n  function getElementOffset(element) {\\n    var docElem,\\n        doc = element && element.ownerDocument,\\n        box = { left: 0, top: 0 },\\n        offset = { left: 0, top: 0 },\\n        scrollLeftTop,\\n        offsetAttributes = {\\n          borderLeftWidth: 'left',\\n          borderTopWidth:  'top',\\n          paddingLeft:     'left',\\n          paddingTop:      'top'\\n        };\\n\\n    if (!doc) {\\n      return offset;\\n    }\\n\\n    for (var attr in offsetAttributes) {\\n      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\\n    }\\n\\n    docElem = doc.documentElement;\\n    if ( typeof element.getBoundingClientRect !== 'undefined' ) {\\n      box = element.getBoundingClientRect();\\n    }\\n\\n    scrollLeftTop = getScrollLeftTop(element);\\n\\n    return {\\n      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\\n      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top\\n    };\\n  }\\n\\n  /**\\n   * Returns style attribute value of a given element\\n   * @memberOf fabric.util\\n   * @param {HTMLElement} element Element to get style attribute for\\n   * @param {String} attr Style attribute to get for element\\n   * @return {String} Style attribute value of the given element.\\n   */\\n  var getElementStyle;\\n  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\\n    getElementStyle = function(element, attr) {\\n      var style = fabric.document.defaultView.getComputedStyle(element, null);\\n      return style ? style[attr] : undefined;\\n    };\\n  }\\n  else {\\n    getElementStyle = function(element, attr) {\\n      var value = element.style[attr];\\n      if (!value && element.currentStyle) {\\n        value = element.currentStyle[attr];\\n      }\\n      return value;\\n    };\\n  }\\n\\n  (function () {\\n    var style = fabric.document.documentElement.style,\\n        selectProp = 'userSelect' in style\\n          ? 'userSelect'\\n          : 'MozUserSelect' in style\\n            ? 'MozUserSelect'\\n            : 'WebkitUserSelect' in style\\n              ? 'WebkitUserSelect'\\n              : 'KhtmlUserSelect' in style\\n                ? 'KhtmlUserSelect'\\n                : '';\\n\\n    /**\\n     * Makes element unselectable\\n     * @memberOf fabric.util\\n     * @param {HTMLElement} element Element to make unselectable\\n     * @return {HTMLElement} Element that was passed in\\n     */\\n    function makeElementUnselectable(element) {\\n      if (typeof element.onselectstart !== 'undefined') {\\n        element.onselectstart = fabric.util.falseFunction;\\n      }\\n      if (selectProp) {\\n        element.style[selectProp] = 'none';\\n      }\\n      else if (typeof element.unselectable === 'string') {\\n        element.unselectable = 'on';\\n      }\\n      return element;\\n    }\\n\\n    /**\\n     * Makes element selectable\\n     * @memberOf fabric.util\\n     * @param {HTMLElement} element Element to make selectable\\n     * @return {HTMLElement} Element that was passed in\\n     */\\n    function makeElementSelectable(element) {\\n      if (typeof element.onselectstart !== 'undefined') {\\n        element.onselectstart = null;\\n      }\\n      if (selectProp) {\\n        element.style[selectProp] = '';\\n      }\\n      else if (typeof element.unselectable === 'string') {\\n        element.unselectable = '';\\n      }\\n      return element;\\n    }\\n\\n    fabric.util.makeElementUnselectable = makeElementUnselectable;\\n    fabric.util.makeElementSelectable = makeElementSelectable;\\n  })();\\n\\n  (function() {\\n\\n    /**\\n     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading\\n     * @memberOf fabric.util\\n     * @param {String} url URL of a script to load\\n     * @param {Function} callback Callback to execute when script is finished loading\\n     */\\n    function getScript(url, callback) {\\n      var headEl = fabric.document.getElementsByTagName('head')[0],\\n          scriptEl = fabric.document.createElement('script'),\\n          loading = true;\\n\\n      /** @ignore */\\n      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {\\n        if (loading) {\\n          if (typeof this.readyState === 'string' &&\\n              this.readyState !== 'loaded' &&\\n              this.readyState !== 'complete') {\\n            return;\\n          }\\n          loading = false;\\n          callback(e || fabric.window.event);\\n          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;\\n        }\\n      };\\n      scriptEl.src = url;\\n      headEl.appendChild(scriptEl);\\n      // causes issue in Opera\\n      // headEl.removeChild(scriptEl);\\n    }\\n\\n    fabric.util.getScript = getScript;\\n  })();\\n\\n  fabric.util.getById = getById;\\n  fabric.util.toArray = toArray;\\n  fabric.util.makeElement = makeElement;\\n  fabric.util.addClass = addClass;\\n  fabric.util.wrapElement = wrapElement;\\n  fabric.util.getScrollLeftTop = getScrollLeftTop;\\n  fabric.util.getElementOffset = getElementOffset;\\n  fabric.util.getElementStyle = getElementStyle;\\n\\n})();\\n\\n\\n(function() {\\n\\n  function addParamToUrl(url, param) {\\n    return url + (/\\\\?/.test(url) ? '&' : '?') + param;\\n  }\\n\\n  var makeXHR = (function() {\\n    var factories = [\\n      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },\\n      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },\\n      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },\\n      function() { return new XMLHttpRequest(); }\\n    ];\\n    for (var i = factories.length; i--; ) {\\n      try {\\n        var req = factories[i]();\\n        if (req) {\\n          return factories[i];\\n        }\\n      }\\n      catch (err) { }\\n    }\\n  })();\\n\\n  function emptyFn() { }\\n\\n  /**\\n   * Cross-browser abstraction for sending XMLHttpRequest\\n   * @memberOf fabric.util\\n   * @param {String} url URL to send XMLHttpRequest to\\n   * @param {Object} [options] Options object\\n   * @param {String} [options.method=\\\"GET\\\"]\\n   * @param {String} [options.parameters] parameters to append to url in GET or in body\\n   * @param {String} [options.body] body to send with POST or PUT request\\n   * @param {Function} options.onComplete Callback to invoke when request is completed\\n   * @return {XMLHttpRequest} request\\n   */\\n  function request(url, options) {\\n\\n    options || (options = { });\\n\\n    var method = options.method ? options.method.toUpperCase() : 'GET',\\n        onComplete = options.onComplete || function() { },\\n        xhr = makeXHR(),\\n        body = options.body || options.parameters;\\n\\n    /** @ignore */\\n    xhr.onreadystatechange = function() {\\n      if (xhr.readyState === 4) {\\n        onComplete(xhr);\\n        xhr.onreadystatechange = emptyFn;\\n      }\\n    };\\n\\n    if (method === 'GET') {\\n      body = null;\\n      if (typeof options.parameters === 'string') {\\n        url = addParamToUrl(url, options.parameters);\\n      }\\n    }\\n\\n    xhr.open(method, url, true);\\n\\n    if (method === 'POST' || method === 'PUT') {\\n      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\\n    }\\n\\n    xhr.send(body);\\n    return xhr;\\n  }\\n\\n  fabric.util.request = request;\\n})();\\n\\n\\n/**\\n * Wrapper around `console.log` (when available)\\n * @param {*} [values] Values to log\\n */\\nfabric.log = function() { };\\n\\n/**\\n * Wrapper around `console.warn` (when available)\\n * @param {*} [values] Values to log as a warning\\n */\\nfabric.warn = function() { };\\n\\n/* eslint-disable */\\nif (typeof console !== 'undefined') {\\n\\n  ['log', 'warn'].forEach(function(methodName) {\\n\\n    if (typeof console[methodName] !== 'undefined' &&\\n        typeof console[methodName].apply === 'function') {\\n\\n      fabric[methodName] = function() {\\n        return console[methodName].apply(console, arguments);\\n      };\\n    }\\n  });\\n}\\n/* eslint-enable */\\n\\n\\n(function() {\\n\\n  /**\\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\\n   * @memberOf fabric.util\\n   * @param {Object} [options] Animation options\\n   * @param {Function} [options.onChange] Callback; invoked on every value change\\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\\n   * @param {Number} [options.startValue=0] Starting value\\n   * @param {Number} [options.endValue=100] Ending value\\n   * @param {Number} [options.byValue=100] Value to modify the property by\\n   * @param {Function} [options.easing] Easing function\\n   * @param {Number} [options.duration=500] Duration of change (in ms)\\n   */\\n  function animate(options) {\\n\\n    requestAnimFrame(function(timestamp) {\\n      options || (options = { });\\n\\n      var start = timestamp || +new Date(),\\n          duration = options.duration || 500,\\n          finish = start + duration, time,\\n          onChange = options.onChange || function() { },\\n          abort = options.abort || function() { return false; },\\n          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},\\n          startValue = 'startValue' in options ? options.startValue : 0,\\n          endValue = 'endValue' in options ? options.endValue : 100,\\n          byValue = options.byValue || endValue - startValue;\\n\\n      options.onStart && options.onStart();\\n\\n      (function tick(ticktime) {\\n        time = ticktime || +new Date();\\n        var currentTime = time > finish ? duration : (time - start);\\n        if (abort()) {\\n          options.onComplete && options.onComplete();\\n          return;\\n        }\\n        onChange(easing(currentTime, startValue, byValue, duration));\\n        if (time > finish) {\\n          options.onComplete && options.onComplete();\\n          return;\\n        }\\n        requestAnimFrame(tick);\\n      })(start);\\n    });\\n\\n  }\\n\\n  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||\\n                          fabric.window.webkitRequestAnimationFrame ||\\n                          fabric.window.mozRequestAnimationFrame    ||\\n                          fabric.window.oRequestAnimationFrame      ||\\n                          fabric.window.msRequestAnimationFrame     ||\\n                          function(callback) {\\n                            fabric.window.setTimeout(callback, 1000 / 60);\\n                          };\\n\\n  /**\\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\\n   * @memberOf fabric.util\\n   * @param {Function} callback Callback to invoke\\n   * @param {DOMElement} element optional Element to associate with animation\\n   */\\n  function requestAnimFrame() {\\n    return _requestAnimFrame.apply(fabric.window, arguments);\\n  }\\n\\n  fabric.util.animate = animate;\\n  fabric.util.requestAnimFrame = requestAnimFrame;\\n\\n})();\\n\\n\\n(function() {\\n\\n  function normalize(a, c, p, s) {\\n    if (a < Math.abs(c)) {\\n      a = c;\\n      s = p / 4;\\n    }\\n    else {\\n      //handle the 0/0 case:\\n      if (c === 0 && a === 0) {\\n        s = p / (2 * Math.PI) * Math.asin(1);\\n      }\\n      else {\\n        s = p / (2 * Math.PI) * Math.asin(c / a);\\n      }\\n    }\\n    return { a: a, c: c, p: p, s: s };\\n  }\\n\\n  function elastic(opts, t, d) {\\n    return opts.a *\\n      Math.pow(2, 10 * (t -= 1)) *\\n      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );\\n  }\\n\\n  /**\\n   * Cubic easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutCubic(t, b, c, d) {\\n    return c * ((t = t / d - 1) * t * t + 1) + b;\\n  }\\n\\n  /**\\n   * Cubic easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutCubic(t, b, c, d) {\\n    t /= d / 2;\\n    if (t < 1) {\\n      return c / 2 * t * t * t + b;\\n    }\\n    return c / 2 * ((t -= 2) * t * t + 2) + b;\\n  }\\n\\n  /**\\n   * Quartic easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInQuart(t, b, c, d) {\\n    return c * (t /= d) * t * t * t + b;\\n  }\\n\\n  /**\\n   * Quartic easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutQuart(t, b, c, d) {\\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\\n  }\\n\\n  /**\\n   * Quartic easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutQuart(t, b, c, d) {\\n    t /= d / 2;\\n    if (t < 1) {\\n      return c / 2 * t * t * t * t + b;\\n    }\\n    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\\n  }\\n\\n  /**\\n   * Quintic easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInQuint(t, b, c, d) {\\n    return c * (t /= d) * t * t * t * t + b;\\n  }\\n\\n  /**\\n   * Quintic easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutQuint(t, b, c, d) {\\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\\n  }\\n\\n  /**\\n   * Quintic easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutQuint(t, b, c, d) {\\n    t /= d / 2;\\n    if (t < 1) {\\n      return c / 2 * t * t * t * t * t + b;\\n    }\\n    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\\n  }\\n\\n  /**\\n   * Sinusoidal easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInSine(t, b, c, d) {\\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\\n  }\\n\\n  /**\\n   * Sinusoidal easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutSine(t, b, c, d) {\\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\\n  }\\n\\n  /**\\n   * Sinusoidal easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutSine(t, b, c, d) {\\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\\n  }\\n\\n  /**\\n   * Exponential easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInExpo(t, b, c, d) {\\n    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\\n  }\\n\\n  /**\\n   * Exponential easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutExpo(t, b, c, d) {\\n    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\\n  }\\n\\n  /**\\n   * Exponential easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutExpo(t, b, c, d) {\\n    if (t === 0) {\\n      return b;\\n    }\\n    if (t === d) {\\n      return b + c;\\n    }\\n    t /= d / 2;\\n    if (t < 1) {\\n      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\\n    }\\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\\n  }\\n\\n  /**\\n   * Circular easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInCirc(t, b, c, d) {\\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\\n  }\\n\\n  /**\\n   * Circular easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutCirc(t, b, c, d) {\\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\\n  }\\n\\n  /**\\n   * Circular easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutCirc(t, b, c, d) {\\n    t /= d / 2;\\n    if (t < 1) {\\n      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\\n    }\\n    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\\n  }\\n\\n  /**\\n   * Elastic easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInElastic(t, b, c, d) {\\n    var s = 1.70158, p = 0, a = c;\\n    if (t === 0) {\\n      return b;\\n    }\\n    t /= d;\\n    if (t === 1) {\\n      return b + c;\\n    }\\n    if (!p) {\\n      p = d * 0.3;\\n    }\\n    var opts = normalize(a, c, p, s);\\n    return -elastic(opts, t, d) + b;\\n  }\\n\\n  /**\\n   * Elastic easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutElastic(t, b, c, d) {\\n    var s = 1.70158, p = 0, a = c;\\n    if (t === 0) {\\n      return b;\\n    }\\n    t /= d;\\n    if (t === 1) {\\n      return b + c;\\n    }\\n    if (!p) {\\n      p = d * 0.3;\\n    }\\n    var opts = normalize(a, c, p, s);\\n    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;\\n  }\\n\\n  /**\\n   * Elastic easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutElastic(t, b, c, d) {\\n    var s = 1.70158, p = 0, a = c;\\n    if (t === 0) {\\n      return b;\\n    }\\n    t /= d / 2;\\n    if (t === 2) {\\n      return b + c;\\n    }\\n    if (!p) {\\n      p = d * (0.3 * 1.5);\\n    }\\n    var opts = normalize(a, c, p, s);\\n    if (t < 1) {\\n      return -0.5 * elastic(opts, t, d) + b;\\n    }\\n    return opts.a * Math.pow(2, -10 * (t -= 1)) *\\n      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;\\n  }\\n\\n  /**\\n   * Backwards easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInBack(t, b, c, d, s) {\\n    if (s === undefined) {\\n      s = 1.70158;\\n    }\\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\\n  }\\n\\n  /**\\n   * Backwards easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutBack(t, b, c, d, s) {\\n    if (s === undefined) {\\n      s = 1.70158;\\n    }\\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\\n  }\\n\\n  /**\\n   * Backwards easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutBack(t, b, c, d, s) {\\n    if (s === undefined) {\\n      s = 1.70158;\\n    }\\n    t /= d / 2;\\n    if (t < 1) {\\n      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\\n    }\\n    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\\n  }\\n\\n  /**\\n   * Bouncing easing in\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInBounce(t, b, c, d) {\\n    return c - easeOutBounce (d - t, 0, c, d) + b;\\n  }\\n\\n  /**\\n   * Bouncing easing out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeOutBounce(t, b, c, d) {\\n    if ((t /= d) < (1 / 2.75)) {\\n      return c * (7.5625 * t * t) + b;\\n    }\\n    else if (t < (2 / 2.75)) {\\n      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;\\n    }\\n    else if (t < (2.5 / 2.75)) {\\n      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;\\n    }\\n    else {\\n      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;\\n    }\\n  }\\n\\n  /**\\n   * Bouncing easing in and out\\n   * @memberOf fabric.util.ease\\n   */\\n  function easeInOutBounce(t, b, c, d) {\\n    if (t < d / 2) {\\n      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;\\n    }\\n    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\\n  }\\n\\n  /**\\n   * Easing functions\\n   * See <a href=\\\"http://gizma.com/easing/\\\">Easing Equations by Robert Penner</a>\\n   * @namespace fabric.util.ease\\n   */\\n  fabric.util.ease = {\\n\\n    /**\\n     * Quadratic easing in\\n     * @memberOf fabric.util.ease\\n     */\\n    easeInQuad: function(t, b, c, d) {\\n      return c * (t /= d) * t + b;\\n    },\\n\\n    /**\\n     * Quadratic easing out\\n     * @memberOf fabric.util.ease\\n     */\\n    easeOutQuad: function(t, b, c, d) {\\n      return -c * (t /= d) * (t - 2) + b;\\n    },\\n\\n    /**\\n     * Quadratic easing in and out\\n     * @memberOf fabric.util.ease\\n     */\\n    easeInOutQuad: function(t, b, c, d) {\\n      t /= (d / 2);\\n      if (t < 1) {\\n        return c / 2 * t * t + b;\\n      }\\n      return -c / 2 * ((--t) * (t - 2) - 1) + b;\\n    },\\n\\n    /**\\n     * Cubic easing in\\n     * @memberOf fabric.util.ease\\n     */\\n    easeInCubic: function(t, b, c, d) {\\n      return c * (t /= d) * t * t + b;\\n    },\\n\\n    easeOutCubic: easeOutCubic,\\n    easeInOutCubic: easeInOutCubic,\\n    easeInQuart: easeInQuart,\\n    easeOutQuart: easeOutQuart,\\n    easeInOutQuart: easeInOutQuart,\\n    easeInQuint: easeInQuint,\\n    easeOutQuint: easeOutQuint,\\n    easeInOutQuint: easeInOutQuint,\\n    easeInSine: easeInSine,\\n    easeOutSine: easeOutSine,\\n    easeInOutSine: easeInOutSine,\\n    easeInExpo: easeInExpo,\\n    easeOutExpo: easeOutExpo,\\n    easeInOutExpo: easeInOutExpo,\\n    easeInCirc: easeInCirc,\\n    easeOutCirc: easeOutCirc,\\n    easeInOutCirc: easeInOutCirc,\\n    easeInElastic: easeInElastic,\\n    easeOutElastic: easeOutElastic,\\n    easeInOutElastic: easeInOutElastic,\\n    easeInBack: easeInBack,\\n    easeOutBack: easeOutBack,\\n    easeInOutBack: easeInOutBack,\\n    easeInBounce: easeInBounce,\\n    easeOutBounce: easeOutBounce,\\n    easeInOutBounce: easeInOutBounce\\n  };\\n\\n})();\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  /**\\n   * @name fabric\\n   * @namespace\\n   */\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      capitalize = fabric.util.string.capitalize,\\n      clone = fabric.util.object.clone,\\n      toFixed = fabric.util.toFixed,\\n      parseUnit = fabric.util.parseUnit,\\n      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,\\n\\n      reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,\\n      reViewBoxTagNames = /^(symbol|image|marker|pattern|view|svg)$/i,\\n      reNotAllowedAncestors = /^(?:pattern|defs|symbol|metadata)$/i,\\n      reAllowedParents = /^(symbol|g|a|svg)$/i,\\n\\n      attributesMap = {\\n        cx:                   'left',\\n        x:                    'left',\\n        r:                    'radius',\\n        cy:                   'top',\\n        y:                    'top',\\n        display:              'visible',\\n        visibility:           'visible',\\n        transform:            'transformMatrix',\\n        'fill-opacity':       'fillOpacity',\\n        'fill-rule':          'fillRule',\\n        'font-family':        'fontFamily',\\n        'font-size':          'fontSize',\\n        'font-style':         'fontStyle',\\n        'font-weight':        'fontWeight',\\n        'stroke-dasharray':   'strokeDashArray',\\n        'stroke-linecap':     'strokeLineCap',\\n        'stroke-linejoin':    'strokeLineJoin',\\n        'stroke-miterlimit':  'strokeMiterLimit',\\n        'stroke-opacity':     'strokeOpacity',\\n        'stroke-width':       'strokeWidth',\\n        'text-decoration':    'textDecoration',\\n        'text-anchor':        'originX'\\n      },\\n\\n      colorAttributes = {\\n        stroke: 'strokeOpacity',\\n        fill:   'fillOpacity'\\n      };\\n\\n  fabric.cssRules = { };\\n  fabric.gradientDefs = { };\\n\\n  function normalizeAttr(attr) {\\n    // transform attribute names\\n    if (attr in attributesMap) {\\n      return attributesMap[attr];\\n    }\\n    return attr;\\n  }\\n\\n  function normalizeValue(attr, value, parentAttributes, fontSize) {\\n    var isArray = Object.prototype.toString.call(value) === '[object Array]',\\n        parsed;\\n\\n    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {\\n      value = '';\\n    }\\n    else if (attr === 'strokeDashArray') {\\n      if (value === 'none') {\\n        value = null;\\n      }\\n      else {\\n        value = value.replace(/,/g, ' ').split(/\\\\s+/).map(function(n) {\\n          return parseFloat(n);\\n        });\\n      }\\n    }\\n    else if (attr === 'transformMatrix') {\\n      if (parentAttributes && parentAttributes.transformMatrix) {\\n        value = multiplyTransformMatrices(\\n          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\\n      }\\n      else {\\n        value = fabric.parseTransformAttribute(value);\\n      }\\n    }\\n    else if (attr === 'visible') {\\n      value = (value === 'none' || value === 'hidden') ? false : true;\\n      // display=none on parent element always takes precedence over child element\\n      if (parentAttributes && parentAttributes.visible === false) {\\n        value = false;\\n      }\\n    }\\n    else if (attr === 'originX' /* text-anchor */) {\\n      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';\\n    }\\n    else {\\n      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\\n    }\\n\\n    return (!isArray && isNaN(parsed) ? value : parsed);\\n  }\\n\\n  /**\\n   * @private\\n   * @param {Object} attributes Array of attributes to parse\\n   */\\n  function _setStrokeFillOpacity(attributes) {\\n    for (var attr in colorAttributes) {\\n\\n      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {\\n        continue;\\n      }\\n\\n      if (typeof attributes[attr] === 'undefined') {\\n        if (!fabric.Object.prototype[attr]) {\\n          continue;\\n        }\\n        attributes[attr] = fabric.Object.prototype[attr];\\n      }\\n\\n      if (attributes[attr].indexOf('url(') === 0) {\\n        continue;\\n      }\\n\\n      var color = new fabric.Color(attributes[attr]);\\n      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\\n    }\\n    return attributes;\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function _getMultipleNodes(doc, nodeNames) {\\n    var nodeName, nodeArray = [], nodeList;\\n    for (var i = 0; i < nodeNames.length; i++) {\\n      nodeName = nodeNames[i];\\n      nodeList = doc.getElementsByTagName(nodeName);\\n      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));\\n    }\\n    return nodeArray;\\n  }\\n\\n  /**\\n   * Parses \\\"transform\\\" attribute, returning an array of values\\n   * @static\\n   * @function\\n   * @memberOf fabric\\n   * @param {String} attributeValue String containing attribute value\\n   * @return {Array} Array of 6 elements representing transformation matrix\\n   */\\n  fabric.parseTransformAttribute = (function() {\\n    function rotateMatrix(matrix, args) {\\n      var angle = args[0],\\n          x = (args.length === 3) ? args[1] : 0,\\n          y = (args.length === 3) ? args[2] : 0;\\n\\n      matrix[0] = Math.cos(angle);\\n      matrix[1] = Math.sin(angle);\\n      matrix[2] = -Math.sin(angle);\\n      matrix[3] = Math.cos(angle);\\n      matrix[4] = x - (matrix[0] * x + matrix[2] * y);\\n      matrix[5] = y - (matrix[1] * x + matrix[3] * y);\\n    }\\n\\n    function scaleMatrix(matrix, args) {\\n      var multiplierX = args[0],\\n          multiplierY = (args.length === 2) ? args[1] : args[0];\\n\\n      matrix[0] = multiplierX;\\n      matrix[3] = multiplierY;\\n    }\\n\\n    function skewXMatrix(matrix, args) {\\n      matrix[2] = Math.tan(fabric.util.degreesToRadians(args[0]));\\n    }\\n\\n    function skewYMatrix(matrix, args) {\\n      matrix[1] = Math.tan(fabric.util.degreesToRadians(args[0]));\\n    }\\n\\n    function translateMatrix(matrix, args) {\\n      matrix[4] = args[0];\\n      if (args.length === 2) {\\n        matrix[5] = args[1];\\n      }\\n    }\\n\\n    // identity matrix\\n    var iMatrix = [\\n          1, // a\\n          0, // b\\n          0, // c\\n          1, // d\\n          0, // e\\n          0  // f\\n        ],\\n\\n        // == begin transform regexp\\n        number = fabric.reNum,\\n\\n        commaWsp = '(?:\\\\\\\\s+,?\\\\\\\\s*|,\\\\\\\\s*)',\\n\\n        skewX = '(?:(skewX)\\\\\\\\s*\\\\\\\\(\\\\\\\\s*(' + number + ')\\\\\\\\s*\\\\\\\\))',\\n\\n        skewY = '(?:(skewY)\\\\\\\\s*\\\\\\\\(\\\\\\\\s*(' + number + ')\\\\\\\\s*\\\\\\\\))',\\n\\n        rotate = '(?:(rotate)\\\\\\\\s*\\\\\\\\(\\\\\\\\s*(' + number + ')(?:' +\\n                    commaWsp + '(' + number + ')' +\\n                    commaWsp + '(' + number + '))?\\\\\\\\s*\\\\\\\\))',\\n\\n        scale = '(?:(scale)\\\\\\\\s*\\\\\\\\(\\\\\\\\s*(' + number + ')(?:' +\\n                    commaWsp + '(' + number + '))?\\\\\\\\s*\\\\\\\\))',\\n\\n        translate = '(?:(translate)\\\\\\\\s*\\\\\\\\(\\\\\\\\s*(' + number + ')(?:' +\\n                    commaWsp + '(' + number + '))?\\\\\\\\s*\\\\\\\\))',\\n\\n        matrix = '(?:(matrix)\\\\\\\\s*\\\\\\\\(\\\\\\\\s*' +\\n                  '(' + number + ')' + commaWsp +\\n                  '(' + number + ')' + commaWsp +\\n                  '(' + number + ')' + commaWsp +\\n                  '(' + number + ')' + commaWsp +\\n                  '(' + number + ')' + commaWsp +\\n                  '(' + number + ')' +\\n                  '\\\\\\\\s*\\\\\\\\))',\\n\\n        transform = '(?:' +\\n                    matrix + '|' +\\n                    translate + '|' +\\n                    scale + '|' +\\n                    rotate + '|' +\\n                    skewX + '|' +\\n                    skewY +\\n                    ')',\\n\\n        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',\\n\\n        transformList = '^\\\\\\\\s*(?:' + transforms + '?)\\\\\\\\s*$',\\n\\n        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\\n        reTransformList = new RegExp(transformList),\\n        // == end transform regexp\\n\\n        reTransform = new RegExp(transform, 'g');\\n\\n    return function(attributeValue) {\\n\\n      // start with identity matrix\\n      var matrix = iMatrix.concat(),\\n          matrices = [];\\n\\n      // return if no argument was given or\\n      // an argument does not match transform attribute regexp\\n      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {\\n        return matrix;\\n      }\\n\\n      attributeValue.replace(reTransform, function(match) {\\n\\n        var m = new RegExp(transform).exec(match).filter(function (match) {\\n              // match !== '' && match != null\\n              return (!!match);\\n            }),\\n            operation = m[1],\\n            args = m.slice(2).map(parseFloat);\\n\\n        switch (operation) {\\n          case 'translate':\\n            translateMatrix(matrix, args);\\n            break;\\n          case 'rotate':\\n            args[0] = fabric.util.degreesToRadians(args[0]);\\n            rotateMatrix(matrix, args);\\n            break;\\n          case 'scale':\\n            scaleMatrix(matrix, args);\\n            break;\\n          case 'skewX':\\n            skewXMatrix(matrix, args);\\n            break;\\n          case 'skewY':\\n            skewYMatrix(matrix, args);\\n            break;\\n          case 'matrix':\\n            matrix = args;\\n            break;\\n        }\\n\\n        // snapshot current matrix into matrices array\\n        matrices.push(matrix.concat());\\n        // reset\\n        matrix = iMatrix.concat();\\n      });\\n\\n      var combinedMatrix = matrices[0];\\n      while (matrices.length > 1) {\\n        matrices.shift();\\n        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\\n      }\\n      return combinedMatrix;\\n    };\\n  })();\\n\\n  /**\\n   * @private\\n   */\\n  function parseStyleString(style, oStyle) {\\n    var attr, value;\\n    style.replace(/;\\\\s*$/, '').split(';').forEach(function (chunk) {\\n      var pair = chunk.split(':');\\n\\n      attr = normalizeAttr(pair[0].trim().toLowerCase());\\n      value = normalizeValue(attr, pair[1].trim());\\n\\n      oStyle[attr] = value;\\n    });\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function parseStyleObject(style, oStyle) {\\n    var attr, value;\\n    for (var prop in style) {\\n      if (typeof style[prop] === 'undefined') {\\n        continue;\\n      }\\n\\n      attr = normalizeAttr(prop.toLowerCase());\\n      value = normalizeValue(attr, style[prop]);\\n\\n      oStyle[attr] = value;\\n    }\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function getGlobalStylesForElement(element, svgUid) {\\n    var styles = { };\\n    for (var rule in fabric.cssRules[svgUid]) {\\n      if (elementMatchesRule(element, rule.split(' '))) {\\n        for (var property in fabric.cssRules[svgUid][rule]) {\\n          styles[property] = fabric.cssRules[svgUid][rule][property];\\n        }\\n      }\\n    }\\n    return styles;\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function elementMatchesRule(element, selectors) {\\n    var firstMatching, parentMatching = true;\\n    //start from rightmost selector.\\n    firstMatching = selectorMatches(element, selectors.pop());\\n    if (firstMatching && selectors.length) {\\n      parentMatching = doesSomeParentMatch(element, selectors);\\n    }\\n    return firstMatching && parentMatching && (selectors.length === 0);\\n  }\\n\\n  function doesSomeParentMatch(element, selectors) {\\n    var selector, parentMatching = true;\\n    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {\\n      if (parentMatching) {\\n        selector = selectors.pop();\\n      }\\n      element = element.parentNode;\\n      parentMatching = selectorMatches(element, selector);\\n    }\\n    return selectors.length === 0;\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function selectorMatches(element, selector) {\\n    var nodeName = element.nodeName,\\n        classNames = element.getAttribute('class'),\\n        id = element.getAttribute('id'), matcher;\\n    // i check if a selector matches slicing away part from it.\\n    // if i get empty string i should match\\n    matcher = new RegExp('^' + nodeName, 'i');\\n    selector = selector.replace(matcher, '');\\n    if (id && selector.length) {\\n      matcher = new RegExp('#' + id + '(?![a-zA-Z\\\\\\\\-]+)', 'i');\\n      selector = selector.replace(matcher, '');\\n    }\\n    if (classNames && selector.length) {\\n      classNames = classNames.split(' ');\\n      for (var i = classNames.length; i--;) {\\n        matcher = new RegExp('\\\\\\\\.' + classNames[i] + '(?![a-zA-Z\\\\\\\\-]+)', 'i');\\n        selector = selector.replace(matcher, '');\\n      }\\n    }\\n    return selector.length === 0;\\n  }\\n\\n  /**\\n   * @private\\n   * to support IE8 missing getElementById on SVGdocument\\n   */\\n  function elementById(doc, id) {\\n    var el;\\n    doc.getElementById && (el = doc.getElementById(id));\\n    if (el) {\\n      return el;\\n    }\\n    var node, i, nodelist = doc.getElementsByTagName('*');\\n    for (i = 0; i < nodelist.length; i++) {\\n      node = nodelist[i];\\n      if (id === node.getAttribute('id')) {\\n        return node;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function parseUseDirectives(doc) {\\n    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;\\n\\n    while (nodelist.length && i < nodelist.length) {\\n      var el = nodelist[i],\\n          xlink = el.getAttribute('xlink:href').substr(1),\\n          x = el.getAttribute('x') || 0,\\n          y = el.getAttribute('y') || 0,\\n          el2 = elementById(doc, xlink).cloneNode(true),\\n          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',\\n          parentNode, oldLength = nodelist.length, attr, j, attrs, l;\\n\\n      applyViewboxTransform(el2);\\n      if (/^svg$/i.test(el2.nodeName)) {\\n        var el3 = el2.ownerDocument.createElement('g');\\n        for (j = 0, attrs = el2.attributes, l = attrs.length; j < l; j++) {\\n          attr = attrs.item(j);\\n          el3.setAttribute(attr.nodeName, attr.nodeValue);\\n        }\\n        // el2.firstChild != null\\n        while (el2.firstChild) {\\n          el3.appendChild(el2.firstChild);\\n        }\\n        el2 = el3;\\n      }\\n\\n      for (j = 0, attrs = el.attributes, l = attrs.length; j < l; j++) {\\n        attr = attrs.item(j);\\n        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {\\n          continue;\\n        }\\n\\n        if (attr.nodeName === 'transform') {\\n          currentTrans = attr.nodeValue + ' ' + currentTrans;\\n        }\\n        else {\\n          el2.setAttribute(attr.nodeName, attr.nodeValue);\\n        }\\n      }\\n\\n      el2.setAttribute('transform', currentTrans);\\n      el2.setAttribute('instantiated_by_use', '1');\\n      el2.removeAttribute('id');\\n      parentNode = el.parentNode;\\n      parentNode.replaceChild(el2, el);\\n      // some browsers do not shorten nodelist after replaceChild (IE8)\\n      if (nodelist.length === oldLength) {\\n        i++;\\n      }\\n    }\\n  }\\n\\n  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\\n  // matches, e.g.: +14.56e-12, etc.\\n  var reViewBoxAttrValue = new RegExp(\\n    '^' +\\n    '\\\\\\\\s*(' + fabric.reNum + '+)\\\\\\\\s*,?' +\\n    '\\\\\\\\s*(' + fabric.reNum + '+)\\\\\\\\s*,?' +\\n    '\\\\\\\\s*(' + fabric.reNum + '+)\\\\\\\\s*,?' +\\n    '\\\\\\\\s*(' + fabric.reNum + '+)\\\\\\\\s*' +\\n    '$'\\n  );\\n\\n  /**\\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\\n   */\\n  function applyViewboxTransform(element) {\\n\\n    var viewBoxAttr = element.getAttribute('viewBox'),\\n        scaleX = 1,\\n        scaleY = 1,\\n        minX = 0,\\n        minY = 0,\\n        viewBoxWidth, viewBoxHeight, matrix, el,\\n        widthAttr = element.getAttribute('width'),\\n        heightAttr = element.getAttribute('height'),\\n        x = element.getAttribute('x') || 0,\\n        y = element.getAttribute('y') || 0,\\n        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',\\n        missingViewBox = (!viewBoxAttr || !reViewBoxTagNames.test(element.nodeName)\\n                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),\\n        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),\\n        toBeParsed = missingViewBox && missingDimAttr,\\n        parsedDim = { }, translateMatrix = '';\\n\\n    parsedDim.width = 0;\\n    parsedDim.height = 0;\\n    parsedDim.toBeParsed = toBeParsed;\\n\\n    if (toBeParsed) {\\n      return parsedDim;\\n    }\\n\\n    if (missingViewBox) {\\n      parsedDim.width = parseUnit(widthAttr);\\n      parsedDim.height = parseUnit(heightAttr);\\n      return parsedDim;\\n    }\\n\\n    minX = -parseFloat(viewBoxAttr[1]);\\n    minY = -parseFloat(viewBoxAttr[2]);\\n    viewBoxWidth = parseFloat(viewBoxAttr[3]);\\n    viewBoxHeight = parseFloat(viewBoxAttr[4]);\\n\\n    if (!missingDimAttr) {\\n      parsedDim.width = parseUnit(widthAttr);\\n      parsedDim.height = parseUnit(heightAttr);\\n      scaleX = parsedDim.width / viewBoxWidth;\\n      scaleY = parsedDim.height / viewBoxHeight;\\n    }\\n    else {\\n      parsedDim.width = viewBoxWidth;\\n      parsedDim.height = viewBoxHeight;\\n    }\\n\\n    // default is to preserve aspect ratio\\n    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\\n    if (preserveAspectRatio.alignX !== 'none') {\\n      //translate all container for the effect of Mid, Min, Max\\n      scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);\\n    }\\n\\n    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\\n      return parsedDim;\\n    }\\n\\n    if (x || y) {\\n      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';\\n    }\\n\\n    matrix = translateMatrix + ' matrix(' + scaleX +\\n                  ' 0' +\\n                  ' 0 ' +\\n                  scaleY + ' ' +\\n                  (minX * scaleX) + ' ' +\\n                  (minY * scaleY) + ') ';\\n\\n    if (element.nodeName === 'svg') {\\n      el = element.ownerDocument.createElement('g');\\n      // element.firstChild != null\\n      while (element.firstChild) {\\n        el.appendChild(element.firstChild);\\n      }\\n      element.appendChild(el);\\n    }\\n    else {\\n      el = element;\\n      matrix = el.getAttribute('transform') + matrix;\\n    }\\n\\n    el.setAttribute('transform', matrix);\\n    return parsedDim;\\n  }\\n\\n  /**\\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\\n   * @static\\n   * @function\\n   * @memberOf fabric\\n   * @param {SVGDocument} doc SVG document to parse\\n   * @param {Function} callback Callback to call when parsing is finished;\\n   * It's being passed an array of elements (parsed from a document).\\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\\n   */\\n  fabric.parseSVGDocument = (function() {\\n\\n    function hasAncestorWithNodeName(element, nodeName) {\\n      while (element && (element = element.parentNode)) {\\n        if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))\\n          && !element.getAttribute('instantiated_by_use')) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n\\n    return function(doc, callback, reviver) {\\n      if (!doc) {\\n        return;\\n      }\\n\\n      parseUseDirectives(doc);\\n\\n      var startTime = new Date(),\\n          svgUid =  fabric.Object.__uid++,\\n          options = applyViewboxTransform(doc),\\n          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));\\n\\n      options.svgUid = svgUid;\\n\\n      if (descendants.length === 0 && fabric.isLikelyNode) {\\n        // we're likely in node, where \\\"o3-xml\\\" library fails to gEBTN(\\\"*\\\")\\n        // https://github.com/ajaxorg/node-o3-xml/issues/21\\n        descendants = doc.selectNodes('//*[name(.)!=\\\"svg\\\"]');\\n        var arr = [];\\n        for (var i = 0, len = descendants.length; i < len; i++) {\\n          arr[i] = descendants[i];\\n        }\\n        descendants = arr;\\n      }\\n\\n      var elements = descendants.filter(function(el) {\\n        applyViewboxTransform(el);\\n        return reAllowedSVGTagNames.test(el.nodeName.replace('svg:', '')) &&\\n              !hasAncestorWithNodeName(el, reNotAllowedAncestors); // http://www.w3.org/TR/SVG/struct.html#DefsElement\\n      });\\n\\n      if (!elements || (elements && !elements.length)) {\\n        callback && callback([], {});\\n        return;\\n      }\\n\\n      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\\n      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\\n      // Precedence of rules:   style > class > attribute\\n      fabric.parseElements(elements, function(instances) {\\n        fabric.documentParsingTime = new Date() - startTime;\\n        if (callback) {\\n          callback(instances, options);\\n        }\\n      }, clone(options), reviver);\\n    };\\n  })();\\n\\n  /**\\n   * Used for caching SVG documents (loaded via `fabric.Canvas#loadSVGFromURL`)\\n   * @namespace\\n   */\\n  var svgCache = {\\n\\n    /**\\n     * @param {String} name\\n     * @param {Function} callback\\n     */\\n    has: function (name, callback) {\\n      callback(false);\\n    },\\n\\n    get: function () {\\n      /* NOOP */\\n    },\\n\\n    set: function () {\\n      /* NOOP */\\n    }\\n  };\\n\\n  /**\\n   * @private\\n   */\\n  function _enlivenCachedObject(cachedObject) {\\n\\n    var objects = cachedObject.objects,\\n        options = cachedObject.options;\\n\\n    objects = objects.map(function (o) {\\n      return fabric[capitalize(o.type)].fromObject(o);\\n    });\\n\\n    return ({ objects: objects, options: options });\\n  }\\n\\n  /**\\n   * @private\\n   */\\n  function _createSVGPattern(markup, canvas, property) {\\n    if (canvas[property] && canvas[property].toSVG) {\\n      markup.push(\\n        '\\\\t<pattern x=\\\"0\\\" y=\\\"0\\\" id=\\\"', property, 'Pattern\\\" ',\\n          'width=\\\"', canvas[property].source.width,\\n          '\\\" height=\\\"', canvas[property].source.height,\\n          '\\\" patternUnits=\\\"userSpaceOnUse\\\">\\\\n',\\n        '\\\\t\\\\t<image x=\\\"0\\\" y=\\\"0\\\" ',\\n        'width=\\\"', canvas[property].source.width,\\n        '\\\" height=\\\"', canvas[property].source.height,\\n        '\\\" xlink:href=\\\"', canvas[property].source.src,\\n        '\\\"></image>\\\\n\\\\t</pattern>\\\\n'\\n      );\\n    }\\n  }\\n\\n  var reFontDeclaration = new RegExp(\\n    '(normal|italic)?\\\\\\\\s*(normal|small-caps)?\\\\\\\\s*' +\\n    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\\\\\s*(' +\\n      fabric.reNum +\\n    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\\\\\/(normal|' + fabric.reNum + '))?\\\\\\\\s+(.*)');\\n\\n  extend(fabric, {\\n    /**\\n     * Parses a short font declaration, building adding its properties to a style object\\n     * @static\\n     * @function\\n     * @memberOf fabric\\n     * @param {String} value font declaration\\n     * @param {Object} oStyle definition\\n     */\\n    parseFontDeclaration: function(value, oStyle) {\\n      var match = value.match(reFontDeclaration);\\n\\n      if (!match) {\\n        return;\\n      }\\n      var fontStyle = match[1],\\n          // font variant is not used\\n          // fontVariant = match[2],\\n          fontWeight = match[3],\\n          fontSize = match[4],\\n          lineHeight = match[5],\\n          fontFamily = match[6];\\n\\n      if (fontStyle) {\\n        oStyle.fontStyle = fontStyle;\\n      }\\n      if (fontWeight) {\\n        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\\n      }\\n      if (fontSize) {\\n        oStyle.fontSize = parseUnit(fontSize);\\n      }\\n      if (fontFamily) {\\n        oStyle.fontFamily = fontFamily;\\n      }\\n      if (lineHeight) {\\n        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;\\n      }\\n    },\\n\\n    /**\\n     * Parses an SVG document, returning all of the gradient declarations found in it\\n     * @static\\n     * @function\\n     * @memberOf fabric\\n     * @param {SVGDocument} doc SVG document to parse\\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\\n     */\\n    getGradientDefs: function(doc) {\\n      var tagArray = [\\n            'linearGradient',\\n            'radialGradient',\\n            'svg:linearGradient',\\n            'svg:radialGradient'],\\n          elList = _getMultipleNodes(doc, tagArray),\\n          el, j = 0, id, xlink,\\n          gradientDefs = { }, idsToXlinkMap = { };\\n\\n      j = elList.length;\\n\\n      while (j--) {\\n        el = elList[j];\\n        xlink = el.getAttribute('xlink:href');\\n        id = el.getAttribute('id');\\n        if (xlink) {\\n          idsToXlinkMap[id] = xlink.substr(1);\\n        }\\n        gradientDefs[id] = el;\\n      }\\n\\n      for (id in idsToXlinkMap) {\\n        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);\\n        el = gradientDefs[id];\\n        while (el2.firstChild) {\\n          el.appendChild(el2.firstChild);\\n        }\\n      }\\n      return gradientDefs;\\n    },\\n\\n    /**\\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\\n     * Parses parent \\\"g\\\" nodes recursively upwards.\\n     * @static\\n     * @memberOf fabric\\n     * @param {DOMElement} element Element to parse\\n     * @param {Array} attributes Array of attributes to parse\\n     * @return {Object} object containing parsed attributes' names/values\\n     */\\n    parseAttributes: function(element, attributes, svgUid) {\\n\\n      if (!element) {\\n        return;\\n      }\\n\\n      var value,\\n          parentAttributes = { },\\n          fontSize;\\n\\n      if (typeof svgUid === 'undefined') {\\n        svgUid = element.getAttribute('svgUid');\\n      }\\n      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\\n      if (element.parentNode && reAllowedParents.test(element.parentNode.nodeName)) {\\n        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\\n      }\\n      fontSize = (parentAttributes && parentAttributes.fontSize ) ||\\n                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;\\n\\n      var ownAttributes = attributes.reduce(function(memo, attr) {\\n        value = element.getAttribute(attr);\\n        if (value) {\\n          attr = normalizeAttr(attr);\\n          value = normalizeValue(attr, value, parentAttributes, fontSize);\\n\\n          memo[attr] = value;\\n        }\\n        return memo;\\n      }, { });\\n\\n      // add values parsed from style, which take precedence over attributes\\n      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\\n      ownAttributes = extend(ownAttributes,\\n        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));\\n      if (ownAttributes.font) {\\n        fabric.parseFontDeclaration(ownAttributes.font, ownAttributes);\\n      }\\n      return _setStrokeFillOpacity(extend(parentAttributes, ownAttributes));\\n    },\\n\\n    /**\\n     * Transforms an array of svg elements to corresponding fabric.* instances\\n     * @static\\n     * @memberOf fabric\\n     * @param {Array} elements Array of elements to parse\\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\\n     * @param {Object} [options] Options object\\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\\n     */\\n    parseElements: function(elements, callback, options, reviver) {\\n      new fabric.ElementsParser(elements, callback, options, reviver).parse();\\n    },\\n\\n    /**\\n     * Parses \\\"style\\\" attribute, retuning an object with values\\n     * @static\\n     * @memberOf fabric\\n     * @param {SVGElement} element Element to parse\\n     * @return {Object} Objects with values parsed from style attribute of an element\\n     */\\n    parseStyleAttribute: function(element) {\\n      var oStyle = { },\\n          style = element.getAttribute('style');\\n\\n      if (!style) {\\n        return oStyle;\\n      }\\n\\n      if (typeof style === 'string') {\\n        parseStyleString(style, oStyle);\\n      }\\n      else {\\n        parseStyleObject(style, oStyle);\\n      }\\n\\n      return oStyle;\\n    },\\n\\n    /**\\n     * Parses \\\"points\\\" attribute, returning an array of values\\n     * @static\\n     * @memberOf fabric\\n     * @param {String} points points attribute string\\n     * @return {Array} array of points\\n     */\\n    parsePointsAttribute: function(points) {\\n\\n      // points attribute is required and must not be empty\\n      if (!points) {\\n        return null;\\n      }\\n\\n      // replace commas with whitespace and remove bookending whitespace\\n      points = points.replace(/,/g, ' ').trim();\\n\\n      points = points.split(/\\\\s+/);\\n      var parsedPoints = [], i, len;\\n\\n      i = 0;\\n      len = points.length;\\n      for (; i < len; i += 2) {\\n        parsedPoints.push({\\n          x: parseFloat(points[i]),\\n          y: parseFloat(points[i + 1])\\n        });\\n      }\\n\\n      // odd number of points is an error\\n      // if (parsedPoints.length % 2 !== 0) {\\n      //   return null;\\n      // }\\n\\n      return parsedPoints;\\n    },\\n\\n    /**\\n     * Returns CSS rules for a given SVG document\\n     * @static\\n     * @function\\n     * @memberOf fabric\\n     * @param {SVGDocument} doc SVG document to parse\\n     * @return {Object} CSS rules of this document\\n     */\\n    getCSSRules: function(doc) {\\n      var styles = doc.getElementsByTagName('style'),\\n          allRules = { }, rules;\\n\\n      // very crude parsing of style contents\\n      for (var i = 0, len = styles.length; i < len; i++) {\\n        // IE9 doesn't support textContent, but provides text instead.\\n        var styleContents = styles[i].textContent || styles[i].text;\\n\\n        // remove comments\\n        styleContents = styleContents.replace(/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\//g, '');\\n        if (styleContents.trim() === '') {\\n          continue;\\n        }\\n        rules = styleContents.match(/[^{]*\\\\{[\\\\s\\\\S]*?\\\\}/g);\\n        rules = rules.map(function(rule) { return rule.trim(); });\\n        rules.forEach(function(rule) {\\n\\n          var match = rule.match(/([\\\\s\\\\S]*?)\\\\s*\\\\{([^}]*)\\\\}/),\\n              ruleObj = { }, declaration = match[2].trim(),\\n              propertyValuePairs = declaration.replace(/;$/, '').split(/\\\\s*;\\\\s*/);\\n\\n          for (var i = 0, len = propertyValuePairs.length; i < len; i++) {\\n            var pair = propertyValuePairs[i].split(/\\\\s*:\\\\s*/),\\n                property = normalizeAttr(pair[0]),\\n                value = normalizeValue(property, pair[1], pair[0]);\\n            ruleObj[property] = value;\\n          }\\n          rule = match[1];\\n          rule.split(',').forEach(function(_rule) {\\n            _rule = _rule.replace(/^svg/i, '').trim();\\n            if (_rule === '') {\\n              return;\\n            }\\n            if (allRules[_rule]) {\\n              fabric.util.object.extend(allRules[_rule], ruleObj);\\n            }\\n            else {\\n              allRules[_rule] = fabric.util.object.clone(ruleObj);\\n            }\\n          });\\n        });\\n      }\\n      return allRules;\\n    },\\n\\n    /**\\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\\n     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\\n     * @memberOf fabric\\n     * @param {String} url\\n     * @param {Function} callback\\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\\n     */\\n    loadSVGFromURL: function(url, callback, reviver) {\\n\\n      url = url.replace(/^\\\\n\\\\s*/, '').trim();\\n      svgCache.has(url, function (hasUrl) {\\n        if (hasUrl) {\\n          svgCache.get(url, function (value) {\\n            var enlivedRecord = _enlivenCachedObject(value);\\n            callback(enlivedRecord.objects, enlivedRecord.options);\\n          });\\n        }\\n        else {\\n          new fabric.util.request(url, {\\n            method: 'get',\\n            onComplete: onComplete\\n          });\\n        }\\n      });\\n\\n      function onComplete(r) {\\n\\n        var xml = r.responseXML;\\n        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {\\n          xml = new ActiveXObject('Microsoft.XMLDOM');\\n          xml.async = 'false';\\n          //IE chokes on DOCTYPE\\n          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\\\\s\\\\S]*?(\\\\[[\\\\s\\\\S]*\\\\])*?>/i, ''));\\n        }\\n        if (!xml || !xml.documentElement) {\\n          callback && callback(null);\\n        }\\n\\n        fabric.parseSVGDocument(xml.documentElement, function (results, options) {\\n          svgCache.set(url, {\\n            objects: fabric.util.array.invoke(results, 'toObject'),\\n            options: options\\n          });\\n          callback && callback(results, options);\\n        }, reviver);\\n      }\\n    },\\n\\n    /**\\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\\n     * @memberOf fabric\\n     * @param {String} string\\n     * @param {Function} callback\\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\\n     */\\n    loadSVGFromString: function(string, callback, reviver) {\\n      string = string.trim();\\n      var doc;\\n      if (typeof DOMParser !== 'undefined') {\\n        var parser = new DOMParser();\\n        if (parser && parser.parseFromString) {\\n          doc = parser.parseFromString(string, 'text/xml');\\n        }\\n      }\\n      else if (fabric.window.ActiveXObject) {\\n        doc = new ActiveXObject('Microsoft.XMLDOM');\\n        doc.async = 'false';\\n        // IE chokes on DOCTYPE\\n        doc.loadXML(string.replace(/<!DOCTYPE[\\\\s\\\\S]*?(\\\\[[\\\\s\\\\S]*\\\\])*?>/i, ''));\\n      }\\n\\n      fabric.parseSVGDocument(doc.documentElement, function (results, options) {\\n        callback(results, options);\\n      }, reviver);\\n    },\\n\\n    /**\\n     * Creates markup containing SVG font faces,\\n     * font URLs for font faces must be collected by developers\\n     * and are not extracted from the DOM by fabricjs\\n     * @param {Array} objects Array of fabric objects\\n     * @return {String}\\n     */\\n    createSVGFontFacesMarkup: function(objects) {\\n      var markup = '', fontList = { }, obj, fontFamily,\\n          style, row, rowIndex, _char, charIndex,\\n          fontPaths = fabric.fontPaths;\\n\\n      for (var i = 0, len = objects.length; i < len; i++) {\\n        obj = objects[i];\\n        fontFamily = obj.fontFamily;\\n        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {\\n          continue;\\n        }\\n        fontList[fontFamily] = true;\\n        if (!obj.styles) {\\n          continue;\\n        }\\n        style = obj.styles;\\n        for (rowIndex in style) {\\n          row = style[rowIndex];\\n          for (charIndex in row) {\\n            _char = row[charIndex];\\n            fontFamily = _char.fontFamily;\\n            if (!fontList[fontFamily] && fontPaths[fontFamily]) {\\n              fontList[fontFamily] = true;\\n            }\\n          }\\n        }\\n      }\\n\\n      for (var j in fontList) {\\n        markup += [\\n          '\\\\t\\\\t@font-face {\\\\n',\\n          '\\\\t\\\\t\\\\tfont-family: \\\\'', j, '\\\\';\\\\n',\\n          '\\\\t\\\\t\\\\tsrc: url(\\\\'', fontPaths[j], '\\\\');\\\\n',\\n          '\\\\t\\\\t}\\\\n'\\n        ].join('');\\n      }\\n\\n      if (markup) {\\n        markup = [\\n          '\\\\t<style type=\\\"text/css\\\">',\\n          '<![CDATA[\\\\n',\\n          markup,\\n          ']]>',\\n          '</style>\\\\n'\\n        ].join('');\\n      }\\n\\n      return markup;\\n    },\\n\\n    /**\\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\\n     * @param {fabric.Canvas} canvas instance of fabric.Canvas\\n     * @return {String}\\n     */\\n    createSVGRefElementsMarkup: function(canvas) {\\n      var markup = [];\\n\\n      _createSVGPattern(markup, canvas, 'backgroundColor');\\n      _createSVGPattern(markup, canvas, 'overlayColor');\\n\\n      return markup.join('');\\n    }\\n  });\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\nfabric.ElementsParser = function(elements, callback, options, reviver) {\\n  this.elements = elements;\\n  this.callback = callback;\\n  this.options = options;\\n  this.reviver = reviver;\\n  this.svgUid = (options && options.svgUid) || 0;\\n};\\n\\nfabric.ElementsParser.prototype.parse = function() {\\n  this.instances = new Array(this.elements.length);\\n  this.numElements = this.elements.length;\\n\\n  this.createObjects();\\n};\\n\\nfabric.ElementsParser.prototype.createObjects = function() {\\n  for (var i = 0, len = this.elements.length; i < len; i++) {\\n    this.elements[i].setAttribute('svgUid', this.svgUid);\\n    (function(_obj, i) {\\n      setTimeout(function() {\\n        _obj.createObject(_obj.elements[i], i);\\n      }, 0);\\n    })(this, i);\\n  }\\n};\\n\\nfabric.ElementsParser.prototype.createObject = function(el, index) {\\n  var klass = fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];\\n  if (klass && klass.fromElement) {\\n    try {\\n      this._createObject(klass, el, index);\\n    }\\n    catch (err) {\\n      fabric.log(err);\\n    }\\n  }\\n  else {\\n    this.checkIfDone();\\n  }\\n};\\n\\nfabric.ElementsParser.prototype._createObject = function(klass, el, index) {\\n  if (klass.async) {\\n    klass.fromElement(el, this.createCallback(index, el), this.options);\\n  }\\n  else {\\n    var obj = klass.fromElement(el, this.options);\\n    this.resolveGradient(obj, 'fill');\\n    this.resolveGradient(obj, 'stroke');\\n    this.reviver && this.reviver(el, obj);\\n    this.instances[index] = obj;\\n    this.checkIfDone();\\n  }\\n};\\n\\nfabric.ElementsParser.prototype.createCallback = function(index, el) {\\n  var _this = this;\\n  return function(obj) {\\n    _this.resolveGradient(obj, 'fill');\\n    _this.resolveGradient(obj, 'stroke');\\n    _this.reviver && _this.reviver(el, obj);\\n    _this.instances[index] = obj;\\n    _this.checkIfDone();\\n  };\\n};\\n\\nfabric.ElementsParser.prototype.resolveGradient = function(obj, property) {\\n\\n  var instanceFillValue = obj.get(property);\\n  if (!(/^url\\\\(/).test(instanceFillValue)) {\\n    return;\\n  }\\n  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);\\n  if (fabric.gradientDefs[this.svgUid][gradientId]) {\\n    obj.set(property,\\n      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));\\n  }\\n};\\n\\nfabric.ElementsParser.prototype.checkIfDone = function() {\\n  if (--this.numElements === 0) {\\n    this.instances = this.instances.filter(function(el) {\\n      // eslint-disable-next-line no-eq-null, eqeqeq\\n      return el != null;\\n    });\\n    this.callback(this.instances);\\n  }\\n};\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */\\n\\n  var fabric = global.fabric || (global.fabric = { });\\n\\n  if (fabric.Point) {\\n    fabric.warn('fabric.Point is already defined');\\n    return;\\n  }\\n\\n  fabric.Point = Point;\\n\\n  /**\\n   * Point class\\n   * @class fabric.Point\\n   * @memberOf fabric\\n   * @constructor\\n   * @param {Number} x\\n   * @param {Number} y\\n   * @return {fabric.Point} thisArg\\n   */\\n  function Point(x, y) {\\n    this.x = x;\\n    this.y = y;\\n  }\\n\\n  Point.prototype = /** @lends fabric.Point.prototype */ {\\n\\n    type: 'point',\\n\\n    constructor: Point,\\n\\n    /**\\n     * Adds another point to this one and returns another one\\n     * @param {fabric.Point} that\\n     * @return {fabric.Point} new Point instance with added values\\n     */\\n    add: function (that) {\\n      return new Point(this.x + that.x, this.y + that.y);\\n    },\\n\\n    /**\\n     * Adds another point to this one\\n     * @param {fabric.Point} that\\n     * @return {fabric.Point} thisArg\\n     * @chainable\\n     */\\n    addEquals: function (that) {\\n      this.x += that.x;\\n      this.y += that.y;\\n      return this;\\n    },\\n\\n    /**\\n     * Adds value to this point and returns a new one\\n     * @param {Number} scalar\\n     * @return {fabric.Point} new Point with added value\\n     */\\n    scalarAdd: function (scalar) {\\n      return new Point(this.x + scalar, this.y + scalar);\\n    },\\n\\n    /**\\n     * Adds value to this point\\n     * @param {Number} scalar\\n     * @return {fabric.Point} thisArg\\n     * @chainable\\n     */\\n    scalarAddEquals: function (scalar) {\\n      this.x += scalar;\\n      this.y += scalar;\\n      return this;\\n    },\\n\\n    /**\\n     * Subtracts another point from this point and returns a new one\\n     * @param {fabric.Point} that\\n     * @return {fabric.Point} new Point object with subtracted values\\n     */\\n    subtract: function (that) {\\n      return new Point(this.x - that.x, this.y - that.y);\\n    },\\n\\n    /**\\n     * Subtracts another point from this point\\n     * @param {fabric.Point} that\\n     * @return {fabric.Point} thisArg\\n     * @chainable\\n     */\\n    subtractEquals: function (that) {\\n      this.x -= that.x;\\n      this.y -= that.y;\\n      return this;\\n    },\\n\\n    /**\\n     * Subtracts value from this point and returns a new one\\n     * @param {Number} scalar\\n     * @return {fabric.Point}\\n     */\\n    scalarSubtract: function (scalar) {\\n      return new Point(this.x - scalar, this.y - scalar);\\n    },\\n\\n    /**\\n     * Subtracts value from this point\\n     * @param {Number} scalar\\n     * @return {fabric.Point} thisArg\\n     * @chainable\\n     */\\n    scalarSubtractEquals: function (scalar) {\\n      this.x -= scalar;\\n      this.y -= scalar;\\n      return this;\\n    },\\n\\n    /**\\n     * Miltiplies this point by a value and returns a new one\\n     * TODO: rename in scalarMultiply in 2.0\\n     * @param {Number} scalar\\n     * @return {fabric.Point}\\n     */\\n    multiply: function (scalar) {\\n      return new Point(this.x * scalar, this.y * scalar);\\n    },\\n\\n    /**\\n     * Miltiplies this point by a value\\n     * TODO: rename in scalarMultiplyEquals in 2.0\\n     * @param {Number} scalar\\n     * @return {fabric.Point} thisArg\\n     * @chainable\\n     */\\n    multiplyEquals: function (scalar) {\\n      this.x *= scalar;\\n      this.y *= scalar;\\n      return this;\\n    },\\n\\n    /**\\n     * Divides this point by a value and returns a new one\\n     * TODO: rename in scalarDivide in 2.0\\n     * @param {Number} scalar\\n     * @return {fabric.Point}\\n     */\\n    divide: function (scalar) {\\n      return new Point(this.x / scalar, this.y / scalar);\\n    },\\n\\n    /**\\n     * Divides this point by a value\\n     * TODO: rename in scalarDivideEquals in 2.0\\n     * @param {Number} scalar\\n     * @return {fabric.Point} thisArg\\n     * @chainable\\n     */\\n    divideEquals: function (scalar) {\\n      this.x /= scalar;\\n      this.y /= scalar;\\n      return this;\\n    },\\n\\n    /**\\n     * Returns true if this point is equal to another one\\n     * @param {fabric.Point} that\\n     * @return {Boolean}\\n     */\\n    eq: function (that) {\\n      return (this.x === that.x && this.y === that.y);\\n    },\\n\\n    /**\\n     * Returns true if this point is less than another one\\n     * @param {fabric.Point} that\\n     * @return {Boolean}\\n     */\\n    lt: function (that) {\\n      return (this.x < that.x && this.y < that.y);\\n    },\\n\\n    /**\\n     * Returns true if this point is less than or equal to another one\\n     * @param {fabric.Point} that\\n     * @return {Boolean}\\n     */\\n    lte: function (that) {\\n      return (this.x <= that.x && this.y <= that.y);\\n    },\\n\\n    /**\\n\\n     * Returns true if this point is greater another one\\n     * @param {fabric.Point} that\\n     * @return {Boolean}\\n     */\\n    gt: function (that) {\\n      return (this.x > that.x && this.y > that.y);\\n    },\\n\\n    /**\\n     * Returns true if this point is greater than or equal to another one\\n     * @param {fabric.Point} that\\n     * @return {Boolean}\\n     */\\n    gte: function (that) {\\n      return (this.x >= that.x && this.y >= that.y);\\n    },\\n\\n    /**\\n     * Returns new point which is the result of linear interpolation with this one and another one\\n     * @param {fabric.Point} that\\n     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5\\n     * @return {fabric.Point}\\n     */\\n    lerp: function (that, t) {\\n      if (typeof t === 'undefined') {\\n        t = 0.5;\\n      }\\n      t = Math.max(Math.min(1, t), 0);\\n      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\\n    },\\n\\n    /**\\n     * Returns distance from this point and another one\\n     * @param {fabric.Point} that\\n     * @return {Number}\\n     */\\n    distanceFrom: function (that) {\\n      var dx = this.x - that.x,\\n          dy = this.y - that.y;\\n      return Math.sqrt(dx * dx + dy * dy);\\n    },\\n\\n    /**\\n     * Returns the point between this point and another one\\n     * @param {fabric.Point} that\\n     * @return {fabric.Point}\\n     */\\n    midPointFrom: function (that) {\\n      return this.lerp(that);\\n    },\\n\\n    /**\\n     * Returns a new point which is the min of this and another one\\n     * @param {fabric.Point} that\\n     * @return {fabric.Point}\\n     */\\n    min: function (that) {\\n      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\\n    },\\n\\n    /**\\n     * Returns a new point which is the max of this and another one\\n     * @param {fabric.Point} that\\n     * @return {fabric.Point}\\n     */\\n    max: function (that) {\\n      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\\n    },\\n\\n    /**\\n     * Returns string representation of this point\\n     * @return {String}\\n     */\\n    toString: function () {\\n      return this.x + ',' + this.y;\\n    },\\n\\n    /**\\n     * Sets x/y of this point\\n     * @param {Number} x\\n     * @param {Number} y\\n     * @chainable\\n     */\\n    setXY: function (x, y) {\\n      this.x = x;\\n      this.y = y;\\n      return this;\\n    },\\n\\n    /**\\n     * Sets x of this point\\n     * @param {Number} x\\n     * @chainable\\n     */\\n    setX: function (x) {\\n      this.x = x;\\n      return this;\\n    },\\n\\n    /**\\n     * Sets y of this point\\n     * @param {Number} y\\n     * @chainable\\n     */\\n    setY: function (y) {\\n      this.y = y;\\n      return this;\\n    },\\n\\n    /**\\n     * Sets x/y of this point from another point\\n     * @param {fabric.Point} that\\n     * @chainable\\n     */\\n    setFromPoint: function (that) {\\n      this.x = that.x;\\n      this.y = that.y;\\n      return this;\\n    },\\n\\n    /**\\n     * Swaps x/y of this point and another point\\n     * @param {fabric.Point} that\\n     */\\n    swap: function (that) {\\n      var x = this.x,\\n          y = this.y;\\n      this.x = that.x;\\n      this.y = that.y;\\n      that.x = x;\\n      that.y = y;\\n    },\\n\\n    /**\\n     * return a cloned instance of the point\\n     * @return {fabric.Point}\\n     */\\n    clone: function () {\\n      return new Point(this.x, this.y);\\n    }\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */\\n  var fabric = global.fabric || (global.fabric = { });\\n\\n  if (fabric.Intersection) {\\n    fabric.warn('fabric.Intersection is already defined');\\n    return;\\n  }\\n\\n  /**\\n   * Intersection class\\n   * @class fabric.Intersection\\n   * @memberOf fabric\\n   * @constructor\\n   */\\n  function Intersection(status) {\\n    this.status = status;\\n    this.points = [];\\n  }\\n\\n  fabric.Intersection = Intersection;\\n\\n  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\\n\\n    constructor: Intersection,\\n\\n    /**\\n     * Appends a point to intersection\\n     * @param {fabric.Point} point\\n     * @return {fabric.Intersection} thisArg\\n     * @chainable\\n     */\\n    appendPoint: function (point) {\\n      this.points.push(point);\\n      return this;\\n    },\\n\\n    /**\\n     * Appends points to intersection\\n     * @param {Array} points\\n     * @return {fabric.Intersection} thisArg\\n     * @chainable\\n     */\\n    appendPoints: function (points) {\\n      this.points = this.points.concat(points);\\n      return this;\\n    }\\n  };\\n\\n  /**\\n   * Checks if one line intersects another\\n   * TODO: rename in intersectSegmentSegment\\n   * @static\\n   * @param {fabric.Point} a1\\n   * @param {fabric.Point} a2\\n   * @param {fabric.Point} b1\\n   * @param {fabric.Point} b2\\n   * @return {fabric.Intersection}\\n   */\\n  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {\\n    var result,\\n        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\\n        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\\n        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\\n    if (uB !== 0) {\\n      var ua = uaT / uB,\\n          ub = ubT / uB;\\n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\\n        result = new Intersection('Intersection');\\n        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\\n      }\\n      else {\\n        result = new Intersection();\\n      }\\n    }\\n    else {\\n      if (uaT === 0 || ubT === 0) {\\n        result = new Intersection('Coincident');\\n      }\\n      else {\\n        result = new Intersection('Parallel');\\n      }\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Checks if line intersects polygon\\n   * TODO: rename in intersectSegmentPolygon\\n   * fix detection of coincident\\n   * @static\\n   * @param {fabric.Point} a1\\n   * @param {fabric.Point} a2\\n   * @param {Array} points\\n   * @return {fabric.Intersection}\\n   */\\n  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\\n    var result = new Intersection(),\\n        length = points.length,\\n        b1, b2, inter;\\n\\n    for (var i = 0; i < length; i++) {\\n      b1 = points[i];\\n      b2 = points[(i + 1) % length];\\n      inter = Intersection.intersectLineLine(a1, a2, b1, b2);\\n\\n      result.appendPoints(inter.points);\\n    }\\n    if (result.points.length > 0) {\\n      result.status = 'Intersection';\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Checks if polygon intersects another polygon\\n   * @static\\n   * @param {Array} points1\\n   * @param {Array} points2\\n   * @return {fabric.Intersection}\\n   */\\n  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {\\n    var result = new Intersection(),\\n        length = points1.length;\\n\\n    for (var i = 0; i < length; i++) {\\n      var a1 = points1[i],\\n          a2 = points1[(i + 1) % length],\\n          inter = Intersection.intersectLinePolygon(a1, a2, points2);\\n\\n      result.appendPoints(inter.points);\\n    }\\n    if (result.points.length > 0) {\\n      result.status = 'Intersection';\\n    }\\n    return result;\\n  };\\n\\n  /**\\n   * Checks if polygon intersects rectangle\\n   * @static\\n   * @param {Array} points\\n   * @param {fabric.Point} r1\\n   * @param {fabric.Point} r2\\n   * @return {fabric.Intersection}\\n   */\\n  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {\\n    var min = r1.min(r2),\\n        max = r1.max(r2),\\n        topRight = new fabric.Point(max.x, min.y),\\n        bottomLeft = new fabric.Point(min.x, max.y),\\n        inter1 = Intersection.intersectLinePolygon(min, topRight, points),\\n        inter2 = Intersection.intersectLinePolygon(topRight, max, points),\\n        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),\\n        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),\\n        result = new Intersection();\\n\\n    result.appendPoints(inter1.points);\\n    result.appendPoints(inter2.points);\\n    result.appendPoints(inter3.points);\\n    result.appendPoints(inter4.points);\\n\\n    if (result.points.length > 0) {\\n      result.status = 'Intersection';\\n    }\\n    return result;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { });\\n\\n  if (fabric.Color) {\\n    fabric.warn('fabric.Color is already defined.');\\n    return;\\n  }\\n\\n  /**\\n   * Color class\\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\\n   *\\n   * @class fabric.Color\\n   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list\\n   * @return {fabric.Color} thisArg\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\\n   */\\n  function Color(color) {\\n    if (!color) {\\n      this.setSource([0, 0, 0, 1]);\\n    }\\n    else {\\n      this._tryParsingColor(color);\\n    }\\n  }\\n\\n  fabric.Color = Color;\\n\\n  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\\n\\n    /**\\n     * @private\\n     * @param {String|Array} color Color value to parse\\n     */\\n    _tryParsingColor: function(color) {\\n      var source;\\n\\n      if (color in Color.colorNameMap) {\\n        color = Color.colorNameMap[color];\\n      }\\n\\n      if (color === 'transparent') {\\n        source = [255, 255, 255, 0];\\n      }\\n\\n      if (!source) {\\n        source = Color.sourceFromHex(color);\\n      }\\n      if (!source) {\\n        source = Color.sourceFromRgb(color);\\n      }\\n      if (!source) {\\n        source = Color.sourceFromHsl(color);\\n      }\\n      if (!source) {\\n        //if color is not recognize let's make black as canvas does\\n        source = [0, 0, 0, 1];\\n      }\\n      if (source) {\\n        this.setSource(source);\\n      }\\n    },\\n\\n    /**\\n     * Adapted from <a href=\\\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\\\">https://github.com/mjijackson</a>\\n     * @private\\n     * @param {Number} r Red color value\\n     * @param {Number} g Green color value\\n     * @param {Number} b Blue color value\\n     * @return {Array} Hsl color\\n     */\\n    _rgbToHsl: function(r, g, b) {\\n      r /= 255; g /= 255; b /= 255;\\n\\n      var h, s, l,\\n          max = fabric.util.array.max([r, g, b]),\\n          min = fabric.util.array.min([r, g, b]);\\n\\n      l = (max + min) / 2;\\n\\n      if (max === min) {\\n        h = s = 0; // achromatic\\n      }\\n      else {\\n        var d = max - min;\\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\\n        switch (max) {\\n          case r:\\n            h = (g - b) / d + (g < b ? 6 : 0);\\n            break;\\n          case g:\\n            h = (b - r) / d + 2;\\n            break;\\n          case b:\\n            h = (r - g) / d + 4;\\n            break;\\n        }\\n        h /= 6;\\n      }\\n\\n      return [\\n        Math.round(h * 360),\\n        Math.round(s * 100),\\n        Math.round(l * 100)\\n      ];\\n    },\\n\\n    /**\\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\\n     * @return {Array}\\n     */\\n    getSource: function() {\\n      return this._source;\\n    },\\n\\n    /**\\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\\n     * @param {Array} source\\n     */\\n    setSource: function(source) {\\n      this._source = source;\\n    },\\n\\n    /**\\n     * Returns color represenation in RGB format\\n     * @return {String} ex: rgb(0-255,0-255,0-255)\\n     */\\n    toRgb: function() {\\n      var source = this.getSource();\\n      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';\\n    },\\n\\n    /**\\n     * Returns color represenation in RGBA format\\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\\n     */\\n    toRgba: function() {\\n      var source = this.getSource();\\n      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';\\n    },\\n\\n    /**\\n     * Returns color represenation in HSL format\\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\\n     */\\n    toHsl: function() {\\n      var source = this.getSource(),\\n          hsl = this._rgbToHsl(source[0], source[1], source[2]);\\n\\n      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';\\n    },\\n\\n    /**\\n     * Returns color represenation in HSLA format\\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\\n     */\\n    toHsla: function() {\\n      var source = this.getSource(),\\n          hsl = this._rgbToHsl(source[0], source[1], source[2]);\\n\\n      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';\\n    },\\n\\n    /**\\n     * Returns color represenation in HEX format\\n     * @return {String} ex: FF5555\\n     */\\n    toHex: function() {\\n      var source = this.getSource(), r, g, b;\\n\\n      r = source[0].toString(16);\\n      r = (r.length === 1) ? ('0' + r) : r;\\n\\n      g = source[1].toString(16);\\n      g = (g.length === 1) ? ('0' + g) : g;\\n\\n      b = source[2].toString(16);\\n      b = (b.length === 1) ? ('0' + b) : b;\\n\\n      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\\n    },\\n\\n    /**\\n     * Gets value of alpha channel for this color\\n     * @return {Number} 0-1\\n     */\\n    getAlpha: function() {\\n      return this.getSource()[3];\\n    },\\n\\n    /**\\n     * Sets value of alpha channel for this color\\n     * @param {Number} alpha Alpha value 0-1\\n     * @return {fabric.Color} thisArg\\n     */\\n    setAlpha: function(alpha) {\\n      var source = this.getSource();\\n      source[3] = alpha;\\n      this.setSource(source);\\n      return this;\\n    },\\n\\n    /**\\n     * Transforms color to its grayscale representation\\n     * @return {fabric.Color} thisArg\\n     */\\n    toGrayscale: function() {\\n      var source = this.getSource(),\\n          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),\\n          currentAlpha = source[3];\\n      this.setSource([average, average, average, currentAlpha]);\\n      return this;\\n    },\\n\\n    /**\\n     * Transforms color to its black and white representation\\n     * @param {Number} threshold\\n     * @return {fabric.Color} thisArg\\n     */\\n    toBlackWhite: function(threshold) {\\n      var source = this.getSource(),\\n          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),\\n          currentAlpha = source[3];\\n\\n      threshold = threshold || 127;\\n\\n      average = (Number(average) < Number(threshold)) ? 0 : 255;\\n      this.setSource([average, average, average, currentAlpha]);\\n      return this;\\n    },\\n\\n    /**\\n     * Overlays color with another color\\n     * @param {String|fabric.Color} otherColor\\n     * @return {fabric.Color} thisArg\\n     */\\n    overlayWith: function(otherColor) {\\n      if (!(otherColor instanceof Color)) {\\n        otherColor = new Color(otherColor);\\n      }\\n\\n      var result = [],\\n          alpha = this.getAlpha(),\\n          otherAlpha = 0.5,\\n          source = this.getSource(),\\n          otherSource = otherColor.getSource();\\n\\n      for (var i = 0; i < 3; i++) {\\n        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));\\n      }\\n\\n      result[3] = alpha;\\n      this.setSource(result);\\n      return this;\\n    }\\n  };\\n\\n  /**\\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\\n   * @static\\n   * @field\\n   * @memberOf fabric.Color\\n   */\\n   // eslint-disable-next-line max-len\\n  fabric.Color.reRGBa = /^rgba?\\\\(\\\\s*(\\\\d{1,3}(?:\\\\.\\\\d+)?\\\\%?)\\\\s*,\\\\s*(\\\\d{1,3}(?:\\\\.\\\\d+)?\\\\%?)\\\\s*,\\\\s*(\\\\d{1,3}(?:\\\\.\\\\d+)?\\\\%?)\\\\s*(?:\\\\s*,\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*)?\\\\)$/;\\n\\n  /**\\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\\n   * @static\\n   * @field\\n   * @memberOf fabric.Color\\n   */\\n  fabric.Color.reHSLa = /^hsla?\\\\(\\\\s*(\\\\d{1,3})\\\\s*,\\\\s*(\\\\d{1,3}\\\\%)\\\\s*,\\\\s*(\\\\d{1,3}\\\\%)\\\\s*(?:\\\\s*,\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*)?\\\\)$/;\\n\\n  /**\\n   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)\\n   * @static\\n   * @field\\n   * @memberOf fabric.Color\\n   */\\n  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;\\n\\n  /**\\n   * Map of the 17 basic color names with HEX code\\n   * @static\\n   * @field\\n   * @memberOf fabric.Color\\n   * @see: http://www.w3.org/TR/CSS2/syndata.html#color-units\\n   */\\n  fabric.Color.colorNameMap = {\\n    aqua:    '#00FFFF',\\n    black:   '#000000',\\n    blue:    '#0000FF',\\n    fuchsia: '#FF00FF',\\n    gray:    '#808080',\\n    grey:    '#808080',\\n    green:   '#008000',\\n    lime:    '#00FF00',\\n    maroon:  '#800000',\\n    navy:    '#000080',\\n    olive:   '#808000',\\n    orange:  '#FFA500',\\n    purple:  '#800080',\\n    red:     '#FF0000',\\n    silver:  '#C0C0C0',\\n    teal:    '#008080',\\n    white:   '#FFFFFF',\\n    yellow:  '#FFFF00'\\n  };\\n\\n  /**\\n   * @private\\n   * @param {Number} p\\n   * @param {Number} q\\n   * @param {Number} t\\n   * @return {Number}\\n   */\\n  function hue2rgb(p, q, t) {\\n    if (t < 0) {\\n      t += 1;\\n    }\\n    if (t > 1) {\\n      t -= 1;\\n    }\\n    if (t < 1 / 6) {\\n      return p + (q - p) * 6 * t;\\n    }\\n    if (t < 1 / 2) {\\n      return q;\\n    }\\n    if (t < 2 / 3) {\\n      return p + (q - p) * (2 / 3 - t) * 6;\\n    }\\n    return p;\\n  }\\n\\n  /**\\n   * Returns new color object, when given a color in RGB format\\n   * @memberOf fabric.Color\\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\\n   * @return {fabric.Color}\\n   */\\n  fabric.Color.fromRgb = function(color) {\\n    return Color.fromSource(Color.sourceFromRgb(color));\\n  };\\n\\n  /**\\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\\n   * @memberOf fabric.Color\\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\\n   * @return {Array} source\\n   */\\n  fabric.Color.sourceFromRgb = function(color) {\\n    var match = color.match(Color.reRGBa);\\n    if (match) {\\n      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),\\n          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),\\n          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\\n\\n      return [\\n        parseInt(r, 10),\\n        parseInt(g, 10),\\n        parseInt(b, 10),\\n        match[4] ? parseFloat(match[4]) : 1\\n      ];\\n    }\\n  };\\n\\n  /**\\n   * Returns new color object, when given a color in RGBA format\\n   * @static\\n   * @function\\n   * @memberOf fabric.Color\\n   * @param {String} color\\n   * @return {fabric.Color}\\n   */\\n  fabric.Color.fromRgba = Color.fromRgb;\\n\\n  /**\\n   * Returns new color object, when given a color in HSL format\\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\\n   * @memberOf fabric.Color\\n   * @return {fabric.Color}\\n   */\\n  fabric.Color.fromHsl = function(color) {\\n    return Color.fromSource(Color.sourceFromHsl(color));\\n  };\\n\\n  /**\\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\\n   * Adapted from <a href=\\\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\\\">https://github.com/mjijackson</a>\\n   * @memberOf fabric.Color\\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\\n   * @return {Array} source\\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\\n   */\\n  fabric.Color.sourceFromHsl = function(color) {\\n    var match = color.match(Color.reHSLa);\\n    if (!match) {\\n      return;\\n    }\\n\\n    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,\\n        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),\\n        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),\\n        r, g, b;\\n\\n    if (s === 0) {\\n      r = g = b = l;\\n    }\\n    else {\\n      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,\\n          p = l * 2 - q;\\n\\n      r = hue2rgb(p, q, h + 1 / 3);\\n      g = hue2rgb(p, q, h);\\n      b = hue2rgb(p, q, h - 1 / 3);\\n    }\\n\\n    return [\\n      Math.round(r * 255),\\n      Math.round(g * 255),\\n      Math.round(b * 255),\\n      match[4] ? parseFloat(match[4]) : 1\\n    ];\\n  };\\n\\n  /**\\n   * Returns new color object, when given a color in HSLA format\\n   * @static\\n   * @function\\n   * @memberOf fabric.Color\\n   * @param {String} color\\n   * @return {fabric.Color}\\n   */\\n  fabric.Color.fromHsla = Color.fromHsl;\\n\\n  /**\\n   * Returns new color object, when given a color in HEX format\\n   * @static\\n   * @memberOf fabric.Color\\n   * @param {String} color Color value ex: FF5555\\n   * @return {fabric.Color}\\n   */\\n  fabric.Color.fromHex = function(color) {\\n    return Color.fromSource(Color.sourceFromHex(color));\\n  };\\n\\n  /**\\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format\\n   * @static\\n   * @memberOf fabric.Color\\n   * @param {String} color ex: FF5555 or FF5544CC (RGBa)\\n   * @return {Array} source\\n   */\\n  fabric.Color.sourceFromHex = function(color) {\\n    if (color.match(Color.reHex)) {\\n      var value = color.slice(color.indexOf('#') + 1),\\n          isShortNotation = (value.length === 3 || value.length === 4),\\n          isRGBa = (value.length === 8 || value.length === 4),\\n          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),\\n          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),\\n          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),\\n          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';\\n\\n      return [\\n        parseInt(r, 16),\\n        parseInt(g, 16),\\n        parseInt(b, 16),\\n        parseFloat((parseInt(a, 16) / 255).toFixed(2))\\n      ];\\n    }\\n  };\\n\\n  /**\\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\\n   * @static\\n   * @memberOf fabric.Color\\n   * @param {Array} source\\n   * @return {fabric.Color}\\n   */\\n  fabric.Color.fromSource = function(source) {\\n    var oColor = new Color();\\n    oColor.setSource(source);\\n    return oColor;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function() {\\n\\n  /* _FROM_SVG_START_ */\\n  function getColorStop(el) {\\n    var style = el.getAttribute('style'),\\n        offset = el.getAttribute('offset') || 0,\\n        color, colorAlpha, opacity;\\n\\n    // convert percents to absolute values\\n    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\\n    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\\n    if (style) {\\n      var keyValuePairs = style.split(/\\\\s*;\\\\s*/);\\n\\n      if (keyValuePairs[keyValuePairs.length - 1] === '') {\\n        keyValuePairs.pop();\\n      }\\n\\n      for (var i = keyValuePairs.length; i--; ) {\\n\\n        var split = keyValuePairs[i].split(/\\\\s*:\\\\s*/),\\n            key = split[0].trim(),\\n            value = split[1].trim();\\n\\n        if (key === 'stop-color') {\\n          color = value;\\n        }\\n        else if (key === 'stop-opacity') {\\n          opacity = value;\\n        }\\n      }\\n    }\\n\\n    if (!color) {\\n      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';\\n    }\\n    if (!opacity) {\\n      opacity = el.getAttribute('stop-opacity');\\n    }\\n\\n    color = new fabric.Color(color);\\n    colorAlpha = color.getAlpha();\\n    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\\n    opacity *= colorAlpha;\\n\\n    return {\\n      offset: offset,\\n      color: color.toRgb(),\\n      opacity: opacity\\n    };\\n  }\\n\\n  function getLinearCoords(el) {\\n    return {\\n      x1: el.getAttribute('x1') || 0,\\n      y1: el.getAttribute('y1') || 0,\\n      x2: el.getAttribute('x2') || '100%',\\n      y2: el.getAttribute('y2') || 0\\n    };\\n  }\\n\\n  function getRadialCoords(el) {\\n    return {\\n      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',\\n      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',\\n      r1: 0,\\n      x2: el.getAttribute('cx') || '50%',\\n      y2: el.getAttribute('cy') || '50%',\\n      r2: el.getAttribute('r') || '50%'\\n    };\\n  }\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Gradient class\\n   * @class fabric.Gradient\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\\n   * @see {@link fabric.Gradient#initialize} for constructor definition\\n   */\\n  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\\n\\n    /**\\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\\n     * @type Number\\n     * @default 0\\n     */\\n    offsetX: 0,\\n\\n    /**\\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\\n     * @type Number\\n     * @default 0\\n     */\\n    offsetY: 0,\\n\\n    /**\\n     * Constructor\\n     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops\\n     * @return {fabric.Gradient} thisArg\\n     */\\n    initialize: function(options) {\\n      options || (options = { });\\n\\n      var coords = { };\\n\\n      this.id = fabric.Object.__uid++;\\n      this.type = options.type || 'linear';\\n\\n      coords = {\\n        x1: options.coords.x1 || 0,\\n        y1: options.coords.y1 || 0,\\n        x2: options.coords.x2 || 0,\\n        y2: options.coords.y2 || 0\\n      };\\n\\n      if (this.type === 'radial') {\\n        coords.r1 = options.coords.r1 || 0;\\n        coords.r2 = options.coords.r2 || 0;\\n      }\\n      this.coords = coords;\\n      this.colorStops = options.colorStops.slice();\\n      if (options.gradientTransform) {\\n        this.gradientTransform = options.gradientTransform;\\n      }\\n      this.offsetX = options.offsetX || this.offsetX;\\n      this.offsetY = options.offsetY || this.offsetY;\\n    },\\n\\n    /**\\n     * Adds another colorStop\\n     * @param {Object} colorStop Object with offset and color\\n     * @return {fabric.Gradient} thisArg\\n     */\\n    addColorStop: function(colorStop) {\\n      for (var position in colorStop) {\\n        var color = new fabric.Color(colorStop[position]);\\n        this.colorStops.push({\\n          offset: position,\\n          color: color.toRgb(),\\n          opacity: color.getAlpha()\\n        });\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Returns object representation of a gradient\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object}\\n     */\\n    toObject: function(propertiesToInclude) {\\n      var object = {\\n        type: this.type,\\n        coords: this.coords,\\n        colorStops: this.colorStops,\\n        offsetX: this.offsetX,\\n        offsetY: this.offsetY,\\n        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform\\n      };\\n      fabric.util.populateWithProperties(this, object, propertiesToInclude);\\n\\n      return object;\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns SVG representation of an gradient\\n     * @param {Object} object Object to create a gradient for\\n     * @return {String} SVG representation of an gradient (linear/radial)\\n     */\\n    toSVG: function(object) {\\n      var coords = fabric.util.object.clone(this.coords),\\n          markup, commonAttributes;\\n\\n      // colorStops must be sorted ascending\\n      this.colorStops.sort(function(a, b) {\\n        return a.offset - b.offset;\\n      });\\n\\n      if (!(object.group && object.group.type === 'path-group')) {\\n        for (var prop in coords) {\\n          if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\\n            coords[prop] += this.offsetX - object.width / 2;\\n          }\\n          else if (prop === 'y1' || prop === 'y2') {\\n            coords[prop] += this.offsetY - object.height / 2;\\n          }\\n        }\\n      }\\n\\n      commonAttributes = 'id=\\\"SVGID_' + this.id +\\n                     '\\\" gradientUnits=\\\"userSpaceOnUse\\\"';\\n      if (this.gradientTransform) {\\n        commonAttributes += ' gradientTransform=\\\"matrix(' + this.gradientTransform.join(' ') + ')\\\" ';\\n      }\\n      if (this.type === 'linear') {\\n        markup = [\\n          '<linearGradient ',\\n          commonAttributes,\\n          ' x1=\\\"', coords.x1,\\n          '\\\" y1=\\\"', coords.y1,\\n          '\\\" x2=\\\"', coords.x2,\\n          '\\\" y2=\\\"', coords.y2,\\n          '\\\">\\\\n'\\n        ];\\n      }\\n      else if (this.type === 'radial') {\\n        markup = [\\n          '<radialGradient ',\\n          commonAttributes,\\n          ' cx=\\\"', coords.x2,\\n          '\\\" cy=\\\"', coords.y2,\\n          '\\\" r=\\\"', coords.r2,\\n          '\\\" fx=\\\"', coords.x1,\\n          '\\\" fy=\\\"', coords.y1,\\n          '\\\">\\\\n'\\n        ];\\n      }\\n\\n      for (var i = 0; i < this.colorStops.length; i++) {\\n        markup.push(\\n          '<stop ',\\n            'offset=\\\"', (this.colorStops[i].offset * 100) + '%',\\n            '\\\" style=\\\"stop-color:', this.colorStops[i].color,\\n            (this.colorStops[i].opacity !== null ? ';stop-opacity: ' + this.colorStops[i].opacity : ';'),\\n          '\\\"/>\\\\n'\\n        );\\n      }\\n\\n      markup.push((this.type === 'linear' ? '</linearGradient>\\\\n' : '</radialGradient>\\\\n'));\\n\\n      return markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns an instance of CanvasGradient\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Object} object\\n     * @return {CanvasGradient}\\n     */\\n    toLive: function(ctx, object) {\\n      var gradient, prop, coords = fabric.util.object.clone(this.coords);\\n\\n      if (!this.type) {\\n        return;\\n      }\\n\\n      if (object.group && object.group.type === 'path-group') {\\n        for (prop in coords) {\\n          if (prop === 'x1' || prop === 'x2') {\\n            coords[prop] += -this.offsetX + object.width / 2;\\n          }\\n          else if (prop === 'y1' || prop === 'y2') {\\n            coords[prop] += -this.offsetY + object.height / 2;\\n          }\\n        }\\n      }\\n\\n      if (this.type === 'linear') {\\n        gradient = ctx.createLinearGradient(\\n          coords.x1, coords.y1, coords.x2, coords.y2);\\n      }\\n      else if (this.type === 'radial') {\\n        gradient = ctx.createRadialGradient(\\n          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\\n      }\\n\\n      for (var i = 0, len = this.colorStops.length; i < len; i++) {\\n        var color = this.colorStops[i].color,\\n            opacity = this.colorStops[i].opacity,\\n            offset = this.colorStops[i].offset;\\n\\n        if (typeof opacity !== 'undefined') {\\n          color = new fabric.Color(color).setAlpha(opacity).toRgba();\\n        }\\n        gradient.addColorStop(parseFloat(offset), color);\\n      }\\n\\n      return gradient;\\n    }\\n  });\\n\\n  fabric.util.object.extend(fabric.Gradient, {\\n\\n    /* _FROM_SVG_START_ */\\n    /**\\n     * Returns {@link fabric.Gradient} instance from an SVG element\\n     * @static\\n     * @memberOf fabric.Gradient\\n     * @param {SVGGradientElement} el SVG gradient element\\n     * @param {fabric.Object} instance\\n     * @return {fabric.Gradient} Gradient instance\\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\\n     */\\n    fromElement: function(el, instance) {\\n\\n      /**\\n       *  @example:\\n       *\\n       *  <linearGradient id=\\\"linearGrad1\\\">\\n       *    <stop offset=\\\"0%\\\" stop-color=\\\"white\\\"/>\\n       *    <stop offset=\\\"100%\\\" stop-color=\\\"black\\\"/>\\n       *  </linearGradient>\\n       *\\n       *  OR\\n       *\\n       *  <linearGradient id=\\\"linearGrad2\\\">\\n       *    <stop offset=\\\"0\\\" style=\\\"stop-color:rgb(255,255,255)\\\"/>\\n       *    <stop offset=\\\"1\\\" style=\\\"stop-color:rgb(0,0,0)\\\"/>\\n       *  </linearGradient>\\n       *\\n       *  OR\\n       *\\n       *  <radialGradient id=\\\"radialGrad1\\\">\\n       *    <stop offset=\\\"0%\\\" stop-color=\\\"white\\\" stop-opacity=\\\"1\\\" />\\n       *    <stop offset=\\\"50%\\\" stop-color=\\\"black\\\" stop-opacity=\\\"0.5\\\" />\\n       *    <stop offset=\\\"100%\\\" stop-color=\\\"white\\\" stop-opacity=\\\"1\\\" />\\n       *  </radialGradient>\\n       *\\n       *  OR\\n       *\\n       *  <radialGradient id=\\\"radialGrad2\\\">\\n       *    <stop offset=\\\"0\\\" stop-color=\\\"rgb(255,255,255)\\\" />\\n       *    <stop offset=\\\"0.5\\\" stop-color=\\\"rgb(0,0,0)\\\" />\\n       *    <stop offset=\\\"1\\\" stop-color=\\\"rgb(255,255,255)\\\" />\\n       *  </radialGradient>\\n       *\\n       */\\n\\n      var colorStopEls = el.getElementsByTagName('stop'),\\n          type,\\n          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',\\n          gradientTransform = el.getAttribute('gradientTransform'),\\n          colorStops = [],\\n          coords, ellipseMatrix;\\n\\n      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {\\n        type = 'linear';\\n      }\\n      else {\\n        type = 'radial';\\n      }\\n\\n      if (type === 'linear') {\\n        coords = getLinearCoords(el);\\n      }\\n      else if (type === 'radial') {\\n        coords = getRadialCoords(el);\\n      }\\n\\n      for (var i = colorStopEls.length; i--; ) {\\n        colorStops.push(getColorStop(colorStopEls[i]));\\n      }\\n\\n      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);\\n\\n      var gradient = new fabric.Gradient({\\n        type: type,\\n        coords: coords,\\n        colorStops: colorStops,\\n        offsetX: -instance.left,\\n        offsetY: -instance.top\\n      });\\n\\n      if (gradientTransform || ellipseMatrix !== '') {\\n        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);\\n      }\\n      return gradient;\\n    },\\n    /* _FROM_SVG_END_ */\\n\\n    /**\\n     * Returns {@link fabric.Gradient} instance from its object representation\\n     * @static\\n     * @memberOf fabric.Gradient\\n     * @param {Object} obj\\n     * @param {Object} [options] Options object\\n     */\\n    forObject: function(obj, options) {\\n      options || (options = { });\\n      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');\\n      return new fabric.Gradient(options);\\n    }\\n  });\\n\\n  /**\\n   * @private\\n   */\\n  function _convertPercentUnitsToValues(object, options, gradientUnits) {\\n    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';\\n    for (var prop in options) {\\n      if (options[prop] === 'Infinity') {\\n        options[prop] = 1;\\n      }\\n      else if (options[prop] === '-Infinity') {\\n        options[prop] = 0;\\n      }\\n      propValue = parseFloat(options[prop], 10);\\n      if (typeof options[prop] === 'string' && /^\\\\d+%$/.test(options[prop])) {\\n        multFactor = 0.01;\\n      }\\n      else {\\n        multFactor = 1;\\n      }\\n      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\\n        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;\\n        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;\\n      }\\n      else if (prop === 'y1' || prop === 'y2') {\\n        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;\\n        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;\\n      }\\n      options[prop] = propValue * multFactor + addFactor;\\n    }\\n    if (object.type === 'ellipse' &&\\n        options.r2 !== null &&\\n        gradientUnits === 'objectBoundingBox' &&\\n        object.rx !== object.ry) {\\n\\n      var scaleFactor = object.ry / object.rx;\\n      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';\\n      if (options.y1) {\\n        options.y1 /= scaleFactor;\\n      }\\n      if (options.y2) {\\n        options.y2 /= scaleFactor;\\n      }\\n    }\\n    return ellipseMatrix;\\n  }\\n})();\\n\\n\\n/**\\n * Pattern class\\n * @class fabric.Pattern\\n * @see {@link http://fabricjs.com/patterns|Pattern demo}\\n * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}\\n * @see {@link fabric.Pattern#initialize} for constructor definition\\n */\\nfabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\\n\\n  /**\\n   * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\\n   * @type String\\n   * @default\\n   */\\n  repeat: 'repeat',\\n\\n  /**\\n   * Pattern horizontal offset from object's left/top corner\\n   * @type Number\\n   * @default\\n   */\\n  offsetX: 0,\\n\\n  /**\\n   * Pattern vertical offset from object's left/top corner\\n   * @type Number\\n   * @default\\n   */\\n  offsetY: 0,\\n\\n  /**\\n   * Constructor\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Pattern} thisArg\\n   */\\n  initialize: function(options) {\\n    options || (options = { });\\n\\n    this.id = fabric.Object.__uid++;\\n\\n    if (options.source) {\\n      if (typeof options.source === 'string') {\\n        // function string\\n        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {\\n          this.source = new Function(fabric.util.getFunctionBody(options.source));\\n        }\\n        else {\\n          // img src string\\n          var _this = this;\\n          this.source = fabric.util.createImage();\\n          fabric.util.loadImage(options.source, function(img) {\\n            _this.source = img;\\n          });\\n        }\\n      }\\n      else {\\n        // img element\\n        this.source = options.source;\\n      }\\n    }\\n    if (options.repeat) {\\n      this.repeat = options.repeat;\\n    }\\n    if (options.offsetX) {\\n      this.offsetX = options.offsetX;\\n    }\\n    if (options.offsetY) {\\n      this.offsetY = options.offsetY;\\n    }\\n  },\\n\\n  /**\\n   * Returns object representation of a pattern\\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n   * @return {Object} Object representation of a pattern instance\\n   */\\n  toObject: function(propertiesToInclude) {\\n\\n    var source, object;\\n\\n    // callback\\n    if (typeof this.source === 'function') {\\n      source = String(this.source);\\n    }\\n    // <img> element\\n    else if (typeof this.source.src === 'string') {\\n      source = this.source.src;\\n    }\\n    // <canvas> element\\n    else if (typeof this.source === 'object' && this.source.toDataURL) {\\n      source = this.source.toDataURL();\\n    }\\n\\n    object = {\\n      source: source,\\n      repeat: this.repeat,\\n      offsetX: this.offsetX,\\n      offsetY: this.offsetY\\n    };\\n    fabric.util.populateWithProperties(this, object, propertiesToInclude);\\n\\n    return object;\\n  },\\n\\n  /* _TO_SVG_START_ */\\n  /**\\n   * Returns SVG representation of a pattern\\n   * @param {fabric.Object} object\\n   * @return {String} SVG representation of a pattern\\n   */\\n  toSVG: function(object) {\\n    var patternSource = typeof this.source === 'function' ? this.source() : this.source,\\n        patternWidth = patternSource.width / object.getWidth(),\\n        patternHeight = patternSource.height / object.getHeight(),\\n        patternOffsetX = this.offsetX / object.getWidth(),\\n        patternOffsetY = this.offsetY / object.getHeight(),\\n        patternImgSrc = '';\\n    if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {\\n      patternHeight = 1;\\n    }\\n    if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {\\n      patternWidth = 1;\\n    }\\n    if (patternSource.src) {\\n      patternImgSrc = patternSource.src;\\n    }\\n    else if (patternSource.toDataURL) {\\n      patternImgSrc = patternSource.toDataURL();\\n    }\\n\\n    return '<pattern id=\\\"SVGID_' + this.id +\\n                  '\\\" x=\\\"' + patternOffsetX +\\n                  '\\\" y=\\\"' + patternOffsetY +\\n                  '\\\" width=\\\"' + patternWidth +\\n                  '\\\" height=\\\"' + patternHeight + '\\\">\\\\n' +\\n             '<image x=\\\"0\\\" y=\\\"0\\\"' +\\n                    ' width=\\\"' + patternSource.width +\\n                    '\\\" height=\\\"' + patternSource.height +\\n                    '\\\" xlink:href=\\\"' + patternImgSrc +\\n             '\\\"></image>\\\\n' +\\n           '</pattern>\\\\n';\\n  },\\n  /* _TO_SVG_END_ */\\n\\n  /**\\n   * Returns an instance of CanvasPattern\\n   * @param {CanvasRenderingContext2D} ctx Context to create pattern\\n   * @return {CanvasPattern}\\n   */\\n  toLive: function(ctx) {\\n    var source = typeof this.source === 'function'\\n      ? this.source()\\n      : this.source;\\n\\n    // if the image failed to load, return, and allow rest to continue loading\\n    if (!source) {\\n      return '';\\n    }\\n\\n    // if an image\\n    if (typeof source.src !== 'undefined') {\\n      if (!source.complete) {\\n        return '';\\n      }\\n      if (source.naturalWidth === 0 || source.naturalHeight === 0) {\\n        return '';\\n      }\\n    }\\n    return ctx.createPattern(source, this.repeat);\\n  }\\n});\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      toFixed = fabric.util.toFixed;\\n\\n  if (fabric.Shadow) {\\n    fabric.warn('fabric.Shadow is already defined.');\\n    return;\\n  }\\n\\n  /**\\n   * Shadow class\\n   * @class fabric.Shadow\\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\\n   * @see {@link fabric.Shadow#initialize} for constructor definition\\n   */\\n  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\\n\\n    /**\\n     * Shadow color\\n     * @type String\\n     * @default\\n     */\\n    color: 'rgb(0,0,0)',\\n\\n    /**\\n     * Shadow blur\\n     * @type Number\\n     */\\n    blur: 0,\\n\\n    /**\\n     * Shadow horizontal offset\\n     * @type Number\\n     * @default\\n     */\\n    offsetX: 0,\\n\\n    /**\\n     * Shadow vertical offset\\n     * @type Number\\n     * @default\\n     */\\n    offsetY: 0,\\n\\n    /**\\n     * Whether the shadow should affect stroke operations\\n     * @type Boolean\\n     * @default\\n     */\\n    affectStroke: false,\\n\\n    /**\\n     * Indicates whether toObject should include default values\\n     * @type Boolean\\n     * @default\\n     */\\n    includeDefaultValues: true,\\n\\n    /**\\n     * Constructor\\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetX properties or string (e.g. \\\"rgba(0,0,0,0.2) 2px 2px 10px, \\\"2px 2px 10px rgba(0,0,0,0.2)\\\")\\n     * @return {fabric.Shadow} thisArg\\n     */\\n    initialize: function(options) {\\n\\n      if (typeof options === 'string') {\\n        options = this._parseShadow(options);\\n      }\\n\\n      for (var prop in options) {\\n        this[prop] = options[prop];\\n      }\\n\\n      this.id = fabric.Object.__uid++;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} shadow Shadow value to parse\\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\\n     */\\n    _parseShadow: function(shadow) {\\n      var shadowStr = shadow.trim(),\\n          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],\\n          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';\\n\\n      return {\\n        color: color.trim(),\\n        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,\\n        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,\\n        blur: parseInt(offsetsAndBlur[3], 10) || 0\\n      };\\n    },\\n\\n    /**\\n     * Returns a string representation of an instance\\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\\n     * @return {String} Returns CSS3 text-shadow declaration\\n     */\\n    toString: function() {\\n      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns SVG representation of a shadow\\n     * @param {fabric.Object} object\\n     * @return {String} SVG representation of a shadow\\n     */\\n    toSVG: function(object) {\\n      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\\n          offset = fabric.util.rotateVector(\\n            { x: this.offsetX, y: this.offsetY },\\n            fabric.util.degreesToRadians(-object.angle)),\\n          BLUR_BOX = 20;\\n\\n      if (object.width && object.height) {\\n        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\\n        // we add some extra space to filter box to contain the blur ( 20 )\\n        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\\n        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\\n      }\\n      if (object.flipX) {\\n        offset.x *= -1;\\n      }\\n      if (object.flipY) {\\n        offset.y *= -1;\\n      }\\n      return (\\n        '<filter id=\\\"SVGID_' + this.id + '\\\" y=\\\"-' + fBoxY + '%\\\" height=\\\"' + (100 + 2 * fBoxY) + '%\\\" ' +\\n          'x=\\\"-' + fBoxX + '%\\\" width=\\\"' + (100 + 2 * fBoxX) + '%\\\" ' + '>\\\\n' +\\n          '\\\\t<feGaussianBlur in=\\\"SourceAlpha\\\" stdDeviation=\\\"' +\\n            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '\\\"></feGaussianBlur>\\\\n' +\\n          '\\\\t<feOffset dx=\\\"' + toFixed(offset.x, NUM_FRACTION_DIGITS) +\\n          '\\\" dy=\\\"' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '\\\" result=\\\"oBlur\\\" ></feOffset>\\\\n' +\\n          '\\\\t<feFlood flood-color=\\\"' + this.color + '\\\"/>\\\\n' +\\n          '\\\\t<feComposite in2=\\\"oBlur\\\" operator=\\\"in\\\" />\\\\n' +\\n          '\\\\t<feMerge>\\\\n' +\\n            '\\\\t\\\\t<feMergeNode></feMergeNode>\\\\n' +\\n            '\\\\t\\\\t<feMergeNode in=\\\"SourceGraphic\\\"></feMergeNode>\\\\n' +\\n          '\\\\t</feMerge>\\\\n' +\\n        '</filter>\\\\n');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns object representation of a shadow\\n     * @return {Object} Object representation of a shadow instance\\n     */\\n    toObject: function() {\\n      if (this.includeDefaultValues) {\\n        return {\\n          color: this.color,\\n          blur: this.blur,\\n          offsetX: this.offsetX,\\n          offsetY: this.offsetY,\\n          affectStroke: this.affectStroke\\n        };\\n      }\\n      var obj = { }, proto = fabric.Shadow.prototype;\\n\\n      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {\\n        if (this[prop] !== proto[prop]) {\\n          obj[prop] = this[prop];\\n        }\\n      }, this);\\n\\n      return obj;\\n    }\\n  });\\n\\n  /**\\n   * Regex matching shadow offsetX, offsetY and blur (ex: \\\"2px 2px 10px rgba(0,0,0,0.2)\\\", \\\"rgb(0,255,0) 2px 2px\\\")\\n   * @static\\n   * @field\\n   * @memberOf fabric.Shadow\\n   */\\n  // eslint-disable-next-line max-len\\n  fabric.Shadow.reOffsetsAndBlur = /(?:\\\\s|^)(-?\\\\d+(?:px)?(?:\\\\s?|$))?(-?\\\\d+(?:px)?(?:\\\\s?|$))?(\\\\d+(?:px)?)?(?:\\\\s?|$)(?:$|\\\\s)/;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function () {\\n\\n  'use strict';\\n\\n  if (fabric.StaticCanvas) {\\n    fabric.warn('fabric.StaticCanvas is already defined.');\\n    return;\\n  }\\n\\n  // aliases for faster resolution\\n  var extend = fabric.util.object.extend,\\n      getElementOffset = fabric.util.getElementOffset,\\n      removeFromArray = fabric.util.removeFromArray,\\n      toFixed = fabric.util.toFixed,\\n\\n      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');\\n\\n  /**\\n   * Static canvas class\\n   * @class fabric.StaticCanvas\\n   * @mixes fabric.Collection\\n   * @mixes fabric.Observable\\n   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}\\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\\n   * @fires before:render\\n   * @fires after:render\\n   * @fires canvas:cleared\\n   * @fires object:added\\n   * @fires object:removed\\n   */\\n  fabric.StaticCanvas = fabric.util.createClass(/** @lends fabric.StaticCanvas.prototype */ {\\n\\n    /**\\n     * Constructor\\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\\n     * @param {Object} [options] Options object\\n     * @return {Object} thisArg\\n     */\\n    initialize: function(el, options) {\\n      options || (options = { });\\n\\n      this._initStatic(el, options);\\n    },\\n\\n    /**\\n     * Background color of canvas instance.\\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\\n     * @type {(String|fabric.Pattern)}\\n     * @default\\n     */\\n    backgroundColor: '',\\n\\n    /**\\n     * Background image of canvas instance.\\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.\\n     * <b>Backwards incompatibility note:</b> The \\\"backgroundImageOpacity\\\"\\n     * and \\\"backgroundImageStretch\\\" properties are deprecated since 1.3.9.\\n     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.\\n     * @type fabric.Image\\n     * @default\\n     */\\n    backgroundImage: null,\\n\\n    /**\\n     * Overlay color of canvas instance.\\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\\n     * @since 1.3.9\\n     * @type {(String|fabric.Pattern)}\\n     * @default\\n     */\\n    overlayColor: '',\\n\\n    /**\\n     * Overlay image of canvas instance.\\n     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.\\n     * <b>Backwards incompatibility note:</b> The \\\"overlayImageLeft\\\"\\n     * and \\\"overlayImageTop\\\" properties are deprecated since 1.3.9.\\n     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.\\n     * @type fabric.Image\\n     * @default\\n     */\\n    overlayImage: null,\\n\\n    /**\\n     * Indicates whether toObject/toDatalessObject should include default values\\n     * @type Boolean\\n     * @default\\n     */\\n    includeDefaultValues: true,\\n\\n    /**\\n     * Indicates whether objects' state should be saved\\n     * @type Boolean\\n     * @default\\n     */\\n    stateful: false,\\n\\n    /**\\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove} should also re-render canvas.\\n     * Disabling this option could give a great performance boost when adding/removing a lot of objects to/from canvas at once\\n     * (followed by a manual rendering after addition/deletion)\\n     * @type Boolean\\n     * @default\\n     */\\n    renderOnAddRemove: true,\\n\\n    /**\\n     * Function that determines clipping of entire canvas area\\n     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}\\n     * @type Function\\n     * @default\\n     */\\n    clipTo: null,\\n\\n    /**\\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\\n     * @type Boolean\\n     * @default\\n     */\\n    controlsAboveOverlay: false,\\n\\n    /**\\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\\n     * @type Boolean\\n     * @default\\n     */\\n    allowTouchScrolling: false,\\n\\n    /**\\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\\n     * @type Boolean\\n     * @default\\n     */\\n    imageSmoothingEnabled: true,\\n\\n    /**\\n     * The transformation (in the format of Canvas transform) which focuses the viewport\\n     * @type Array\\n     * @default\\n     */\\n    viewportTransform: [1, 0, 0, 1, 0, 0],\\n\\n    /**\\n     * if set to false background image is not affected by viewport transform\\n     * @since 1.6.3\\n     * @type Boolean\\n     * @default\\n     */\\n    backgroundVpt: true,\\n\\n    /**\\n     * if set to false overlya image is not affected by viewport transform\\n     * @since 1.6.3\\n     * @type Boolean\\n     * @default\\n     */\\n    overlayVpt: true,\\n\\n    /**\\n     * Callback; invoked right before object is about to be scaled/rotated\\n     */\\n    onBeforeScaleRotate: function () {\\n      /* NOOP */\\n    },\\n\\n    /**\\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\\n     */\\n    enableRetinaScaling: true,\\n\\n    /**\\n     * @private\\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\\n     * @param {Object} [options] Options object\\n     */\\n    _initStatic: function(el, options) {\\n      var cb = fabric.StaticCanvas.prototype.renderAll.bind(this);\\n      this._objects = [];\\n      this._createLowerCanvas(el);\\n      this._initOptions(options);\\n      this._setImageSmoothing();\\n      // only initialize retina scaling once\\n      if (!this.interactive) {\\n        this._initRetinaScaling();\\n      }\\n\\n      if (options.overlayImage) {\\n        this.setOverlayImage(options.overlayImage, cb);\\n      }\\n      if (options.backgroundImage) {\\n        this.setBackgroundImage(options.backgroundImage, cb);\\n      }\\n      if (options.backgroundColor) {\\n        this.setBackgroundColor(options.backgroundColor, cb);\\n      }\\n      if (options.overlayColor) {\\n        this.setOverlayColor(options.overlayColor, cb);\\n      }\\n      this.calcOffset();\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _isRetinaScaling: function() {\\n      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Number} retinaScaling if applied, otherwise 1;\\n     */\\n    getRetinaScaling: function() {\\n      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _initRetinaScaling: function() {\\n      if (!this._isRetinaScaling()) {\\n        return;\\n      }\\n      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);\\n      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);\\n\\n      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);\\n    },\\n\\n    /**\\n     * Calculates canvas element offset relative to the document\\n     * This method is also attached as \\\"resize\\\" event handler of window\\n     * @return {fabric.Canvas} instance\\n     * @chainable\\n     */\\n    calcOffset: function () {\\n      this._offset = getElementOffset(this.lowerCanvasEl);\\n      return this;\\n    },\\n\\n    /**\\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\\n     *   // Needed to position overlayImage at 0/0\\n     *   originX: 'left',\\n     *   originY: 'top'\\n     * });\\n     * @example <caption>overlayImage with different properties</caption>\\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\\n     *   opacity: 0.5,\\n     *   angle: 45,\\n     *   left: 400,\\n     *   top: 400,\\n     *   originX: 'left',\\n     *   originY: 'top'\\n     * });\\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {\\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\\n     * });\\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\\n     *   width: canvas.width,\\n     *   height: canvas.height,\\n     *   // Needed to position overlayImage at 0/0\\n     *   originX: 'left',\\n     *   originY: 'top'\\n     * });\\n     * @example <caption>overlayImage loaded from cross-origin</caption>\\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\\n     *   opacity: 0.5,\\n     *   angle: 45,\\n     *   left: 400,\\n     *   top: 400,\\n     *   originX: 'left',\\n     *   originY: 'top',\\n     *   crossOrigin: 'anonymous'\\n     * });\\n     */\\n    setOverlayImage: function (image, callback, options) {\\n      return this.__setBgOverlayImage('overlayImage', image, callback, options);\\n    },\\n\\n    /**\\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}\\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\\n     *   // Needed to position backgroundImage at 0/0\\n     *   originX: 'left',\\n     *   originY: 'top'\\n     * });\\n     * @example <caption>backgroundImage with different properties</caption>\\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\\n     *   opacity: 0.5,\\n     *   angle: 45,\\n     *   left: 400,\\n     *   top: 400,\\n     *   originX: 'left',\\n     *   originY: 'top'\\n     * });\\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {\\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\\n     * });\\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\\n     *   width: canvas.width,\\n     *   height: canvas.height,\\n     *   // Needed to position backgroundImage at 0/0\\n     *   originX: 'left',\\n     *   originY: 'top'\\n     * });\\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\\n     *   opacity: 0.5,\\n     *   angle: 45,\\n     *   left: 400,\\n     *   top: 400,\\n     *   originX: 'left',\\n     *   originY: 'top',\\n     *   crossOrigin: 'anonymous'\\n     * });\\n     */\\n    setBackgroundImage: function (image, callback, options) {\\n      return this.__setBgOverlayImage('backgroundImage', image, callback, options);\\n    },\\n\\n    /**\\n     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas\\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set background color to\\n     * @param {Function} callback Callback to invoke when background color is set\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\\n     * @example <caption>Normal overlayColor - color value</caption>\\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\\n     * canvas.setOverlayColor({\\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\\n     * }, canvas.renderAll.bind(canvas));\\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\\n     * canvas.setOverlayColor({\\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\\n     *   repeat: 'repeat',\\n     *   offsetX: 200,\\n     *   offsetY: 100\\n     * }, canvas.renderAll.bind(canvas));\\n     */\\n    setOverlayColor: function(overlayColor, callback) {\\n      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);\\n    },\\n\\n    /**\\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\\n     * @param {Function} callback Callback to invoke when background color is set\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\\n     * @example <caption>Normal backgroundColor - color value</caption>\\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\\n     * canvas.setBackgroundColor({\\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\\n     * }, canvas.renderAll.bind(canvas));\\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\\n     * canvas.setBackgroundColor({\\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\\n     *   repeat: 'repeat',\\n     *   offsetX: 200,\\n     *   offsetY: 100\\n     * }, canvas.renderAll.bind(canvas));\\n     */\\n    setBackgroundColor: function(backgroundColor, callback) {\\n      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);\\n    },\\n\\n    /**\\n     * @private\\n     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}\\n     */\\n    _setImageSmoothing: function() {\\n      var ctx = this.getContext();\\n\\n      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled\\n        || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;\\n      ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay\\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\\n     */\\n    __setBgOverlayImage: function(property, image, callback, options) {\\n      if (typeof image === 'string') {\\n        fabric.util.loadImage(image, function(img) {\\n          img && (this[property] = new fabric.Image(img, options));\\n          callback && callback(img);\\n        }, this, options && options.crossOrigin);\\n      }\\n      else {\\n        options && image.setOptions(options);\\n        this[property] = image;\\n        callback && callback(image);\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\\n     * @param {Function} [callback] Callback is invoked when color is set\\n     */\\n    __setBgOverlayColor: function(property, color, callback) {\\n      if (color && color.source) {\\n        var _this = this;\\n        fabric.util.loadImage(color.source, function(img) {\\n          _this[property] = new fabric.Pattern({\\n            source: img,\\n            repeat: color.repeat,\\n            offsetX: color.offsetX,\\n            offsetY: color.offsetY\\n          });\\n          callback && callback();\\n        });\\n      }\\n      else {\\n        this[property] = color;\\n        callback && callback();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _createCanvasElement: function(canvasEl) {\\n      var element = fabric.util.createCanvasElement(canvasEl)\\n      if (!element.style) {\\n        element.style = { };\\n      }\\n      if (!element) {\\n        throw CANVAS_INIT_ERROR;\\n      }\\n      if (typeof element.getContext === 'undefined') {\\n        throw CANVAS_INIT_ERROR;\\n      }\\n      return element;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} [options] Options object\\n     */\\n    _initOptions: function (options) {\\n      for (var prop in options) {\\n        this[prop] = options[prop];\\n      }\\n\\n      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;\\n      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;\\n\\n      if (!this.lowerCanvasEl.style) {\\n        return;\\n      }\\n\\n      this.lowerCanvasEl.width = this.width;\\n      this.lowerCanvasEl.height = this.height;\\n\\n      this.lowerCanvasEl.style.width = this.width + 'px';\\n      this.lowerCanvasEl.style.height = this.height + 'px';\\n\\n      this.viewportTransform = this.viewportTransform.slice();\\n    },\\n\\n    /**\\n     * Creates a bottom canvas\\n     * @private\\n     * @param {HTMLElement} [canvasEl]\\n     */\\n    _createLowerCanvas: function (canvasEl) {\\n      this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement(canvasEl);\\n\\n      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');\\n\\n      if (this.interactive) {\\n        this._applyCanvasStyle(this.lowerCanvasEl);\\n      }\\n\\n      this.contextContainer = this.lowerCanvasEl.getContext('2d');\\n    },\\n\\n    /**\\n     * Returns canvas width (in px)\\n     * @return {Number}\\n     */\\n    getWidth: function () {\\n      return this.width;\\n    },\\n\\n    /**\\n     * Returns canvas height (in px)\\n     * @return {Number}\\n     */\\n    getHeight: function () {\\n      return this.height;\\n    },\\n\\n    /**\\n     * Sets width of this canvas instance\\n     * @param {Number|String} value                         Value to set width to\\n     * @param {Object}        [options]                     Options object\\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    setWidth: function (value, options) {\\n      return this.setDimensions({ width: value }, options);\\n    },\\n\\n    /**\\n     * Sets height of this canvas instance\\n     * @param {Number|String} value                         Value to set height to\\n     * @param {Object}        [options]                     Options object\\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    setHeight: function (value, options) {\\n      return this.setDimensions({ height: value }, options);\\n    },\\n\\n    /**\\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\\n     * @param {Object}        dimensions                    Object with width/height properties\\n     * @param {Number|String} [dimensions.width]            Width of canvas element\\n     * @param {Number|String} [dimensions.height]           Height of canvas element\\n     * @param {Object}        [options]                     Options object\\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    setDimensions: function (dimensions, options) {\\n      var cssValue;\\n\\n      options = options || {};\\n\\n      for (var prop in dimensions) {\\n        cssValue = dimensions[prop];\\n\\n        if (!options.cssOnly) {\\n          this._setBackstoreDimension(prop, dimensions[prop]);\\n          cssValue += 'px';\\n        }\\n\\n        if (!options.backstoreOnly) {\\n          this._setCssDimension(prop, cssValue);\\n        }\\n      }\\n      this._initRetinaScaling();\\n      this._setImageSmoothing();\\n      this.calcOffset();\\n\\n      if (!options.cssOnly) {\\n        this.renderAll();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Helper for setting width/height\\n     * @private\\n     * @param {String} prop property (width|height)\\n     * @param {Number} value value to set property to\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    _setBackstoreDimension: function (prop, value) {\\n      this.lowerCanvasEl[prop] = value;\\n\\n      if (this.upperCanvasEl) {\\n        this.upperCanvasEl[prop] = value;\\n      }\\n\\n      if (this.cacheCanvasEl) {\\n        this.cacheCanvasEl[prop] = value;\\n      }\\n\\n      this[prop] = value;\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Helper for setting css width/height\\n     * @private\\n     * @param {String} prop property (width|height)\\n     * @param {String} value value to set property to\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    _setCssDimension: function (prop, value) {\\n      this.lowerCanvasEl.style[prop] = value;\\n\\n      if (this.upperCanvasEl) {\\n        this.upperCanvasEl.style[prop] = value;\\n      }\\n\\n      if (this.wrapperEl) {\\n        this.wrapperEl.style[prop] = value;\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Returns canvas zoom level\\n     * @return {Number}\\n     */\\n    getZoom: function () {\\n      return this.viewportTransform[0];\\n    },\\n\\n    /**\\n     * Sets viewport transform of this canvas instance\\n     * @param {Array} vpt the transform in the form of context.transform\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    setViewportTransform: function (vpt) {\\n      var activeGroup = this._activeGroup, object;\\n      this.viewportTransform = vpt;\\n      for (var i = 0, len = this._objects.length; i < len; i++) {\\n        object = this._objects[i];\\n        object.group || object.setCoords();\\n      }\\n      if (activeGroup) {\\n        activeGroup.setCoords();\\n      }\\n      this.renderAll();\\n      return this;\\n    },\\n\\n    /**\\n     * Sets zoom level of this canvas instance, zoom centered around point\\n     * @param {fabric.Point} point to zoom with respect to\\n     * @param {Number} value to set zoom to, less than 1 zooms out\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    zoomToPoint: function (point, value) {\\n      // TODO: just change the scale, preserve other transformations\\n      var before = point, vpt = this.viewportTransform.slice(0);\\n      point = fabric.util.transformPoint(point, fabric.util.invertTransform(this.viewportTransform));\\n      vpt[0] = value;\\n      vpt[3] = value;\\n      var after = fabric.util.transformPoint(point, vpt);\\n      vpt[4] += before.x - after.x;\\n      vpt[5] += before.y - after.y;\\n      return this.setViewportTransform(vpt);\\n    },\\n\\n    /**\\n     * Sets zoom level of this canvas instance\\n     * @param {Number} value to set zoom to, less than 1 zooms out\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    setZoom: function (value) {\\n      this.zoomToPoint(new fabric.Point(0, 0), value);\\n      return this;\\n    },\\n\\n    /**\\n     * Pan viewport so as to place point at top left corner of canvas\\n     * @param {fabric.Point} point to move to\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    absolutePan: function (point) {\\n      var vpt = this.viewportTransform.slice(0);\\n      vpt[4] = -point.x;\\n      vpt[5] = -point.y;\\n      return this.setViewportTransform(vpt);\\n    },\\n\\n    /**\\n     * Pans viewpoint relatively\\n     * @param {fabric.Point} point (position vector) to move by\\n     * @return {fabric.Canvas} instance\\n     * @chainable true\\n     */\\n    relativePan: function (point) {\\n      return this.absolutePan(new fabric.Point(\\n        -point.x - this.viewportTransform[4],\\n        -point.y - this.viewportTransform[5]\\n      ));\\n    },\\n\\n    /**\\n     * Returns &lt;canvas> element corresponding to this instance\\n     * @return {HTMLCanvasElement}\\n     */\\n    getElement: function () {\\n      return this.lowerCanvasEl;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {fabric.Object} obj Object that was added\\n     */\\n    _onObjectAdded: function(obj) {\\n      this.stateful && obj.setupState();\\n      obj._set('canvas', this);\\n      obj.setCoords();\\n      this.fire('object:added', { target: obj });\\n      obj.fire('added');\\n    },\\n\\n    /**\\n     * @private\\n     * @param {fabric.Object} obj Object that was removed\\n     */\\n    _onObjectRemoved: function(obj) {\\n      this.fire('object:removed', { target: obj });\\n      obj.fire('removed');\\n      delete obj.canvas;\\n    },\\n\\n    /**\\n     * Clears specified context of canvas element\\n     * @param {CanvasRenderingContext2D} ctx Context to clear\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    clearContext: function(ctx) {\\n      ctx.clearRect(0, 0, this.width, this.height);\\n      return this;\\n    },\\n\\n    /**\\n     * Returns context of canvas where objects are drawn\\n     * @return {CanvasRenderingContext2D}\\n     */\\n    getContext: function () {\\n      return this.contextContainer;\\n    },\\n\\n    /**\\n     * Clears all contexts (background, main, top) of an instance\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    clear: function () {\\n      this._objects.length = 0;\\n      this.backgroundImage = null;\\n      this.overlayImage = null;\\n      this.backgroundColor = '';\\n      this.overlayColor = ''\\n      if (this._hasITextHandlers) {\\n        this.off('selection:cleared', this._canvasITextSelectionClearedHanlder);\\n        this.off('object:selected', this._canvasITextSelectionClearedHanlder);\\n        this.off('mouse:up', this._mouseUpITextHandler);\\n        this._iTextInstances = null;\\n        this._hasITextHandlers = false;\\n      }\\n      this.clearContext(this.contextContainer);\\n      this.fire('canvas:cleared');\\n      this.renderAll();\\n      return this;\\n    },\\n\\n    /**\\n     * Renders both the canvas.\\n     * @return {fabric.Canvas} instance\\n     * @chainable\\n     */\\n    renderAll: function () {\\n      var canvasToDrawOn = this.contextContainer;\\n      this.renderCanvas(canvasToDrawOn, this._objects);\\n      return this;\\n    },\\n\\n    /**\\n     * Renders background, objects, overlay and controls.\\n     * @param {CanvasRenderingContext2D} ctx\\n     * @param {Array} objects to render\\n     * @return {fabric.Canvas} instance\\n     * @chainable\\n     */\\n    renderCanvas: function(ctx, objects) {\\n      this.clearContext(ctx);\\n      this.fire('before:render');\\n      if (this.clipTo) {\\n        fabric.util.clipContext(this, ctx);\\n      }\\n      this._renderBackground(ctx);\\n\\n      ctx.save();\\n      //apply viewport transform once for all rendering process\\n      ctx.transform.apply(ctx, this.viewportTransform);\\n      this._renderObjects(ctx, objects);\\n      ctx.restore();\\n      if (!this.controlsAboveOverlay && this.interactive) {\\n        this.drawControls(ctx);\\n      }\\n      if (this.clipTo) {\\n        ctx.restore();\\n      }\\n      this._renderOverlay(ctx);\\n      if (this.controlsAboveOverlay && this.interactive) {\\n        this.drawControls(ctx);\\n      }\\n      this.fire('after:render');\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Array} objects to render\\n     */\\n    _renderObjects: function(ctx, objects) {\\n      for (var i = 0, length = objects.length; i < length; ++i) {\\n        objects[i] && objects[i].render(ctx);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {string} property 'background' or 'overlay'\\n     */\\n    _renderBackgroundOrOverlay: function(ctx, property) {\\n      var object = this[property + 'Color'];\\n      if (object) {\\n        ctx.fillStyle = object.toLive\\n          ? object.toLive(ctx)\\n          : object;\\n\\n        ctx.fillRect(\\n          object.offsetX || 0,\\n          object.offsetY || 0,\\n          this.width,\\n          this.height);\\n      }\\n      object = this[property + 'Image'];\\n      if (object) {\\n        if (this[property + 'Vpt']) {\\n          ctx.save();\\n          ctx.transform.apply(ctx, this.viewportTransform);\\n        }\\n        object.render(ctx);\\n        this[property + 'Vpt'] && ctx.restore();\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderBackground: function(ctx) {\\n      this._renderBackgroundOrOverlay(ctx, 'background');\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderOverlay: function(ctx) {\\n      this._renderBackgroundOrOverlay(ctx, 'overlay');\\n    },\\n\\n    /**\\n     * Returns coordinates of a center of canvas.\\n     * Returned value is an object with top and left properties\\n     * @return {Object} object with \\\"top\\\" and \\\"left\\\" number values\\n     */\\n    getCenter: function () {\\n      return {\\n        top: this.getHeight() / 2,\\n        left: this.getWidth() / 2\\n      };\\n    },\\n\\n    /**\\n     * Centers object horizontally in the canvas\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @param {fabric.Object} object Object to center horizontally\\n     * @return {fabric.Canvas} thisArg\\n     */\\n    centerObjectH: function (object) {\\n      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));\\n    },\\n\\n    /**\\n     * Centers object vertically in the canvas\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @param {fabric.Object} object Object to center vertically\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    centerObjectV: function (object) {\\n      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));\\n    },\\n\\n    /**\\n     * Centers object vertically and horizontally in the canvas\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @param {fabric.Object} object Object to center vertically and horizontally\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    centerObject: function(object) {\\n      var center = this.getCenter();\\n\\n      return this._centerObject(object, new fabric.Point(center.left, center.top));\\n    },\\n\\n    /**\\n     * Centers object vertically and horizontally in the viewport\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @param {fabric.Object} object Object to center vertically and horizontally\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    viewportCenterObject: function(object) {\\n      var vpCenter = this.getVpCenter();\\n\\n      return this._centerObject(object, vpCenter);\\n    },\\n\\n    /**\\n     * Centers object horizontally in the viewport, object.top is unchanged\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @param {fabric.Object} object Object to center vertically and horizontally\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    viewportCenterObjectH: function(object) {\\n      var vpCenter = this.getVpCenter();\\n      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));\\n      return this;\\n    },\\n\\n    /**\\n     * Centers object Vertically in the viewport, object.top is unchanged\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @param {fabric.Object} object Object to center vertically and horizontally\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    viewportCenterObjectV: function(object) {\\n      var vpCenter = this.getVpCenter();\\n\\n      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));\\n    },\\n\\n    /**\\n     * Calculate the point in canvas that correspond to the center of actual viewport.\\n     * @return {fabric.Point} vpCenter, viewport center\\n     * @chainable\\n     */\\n    getVpCenter: function() {\\n      var center = this.getCenter(),\\n          iVpt = fabric.util.invertTransform(this.viewportTransform);\\n      return fabric.util.transformPoint({ x: center.left, y: center.top }, iVpt);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {fabric.Object} object Object to center\\n     * @param {fabric.Point} center Center point\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    _centerObject: function(object, center) {\\n      object.setPositionByOrigin(center, 'center', 'center');\\n      this.renderAll();\\n      return this;\\n    },\\n\\n    /**\\n     * Returs dataless JSON representation of canvas\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {String} json string\\n     */\\n    toDatalessJSON: function (propertiesToInclude) {\\n      return this.toDatalessObject(propertiesToInclude);\\n    },\\n\\n    /**\\n     * Returns object representation of canvas\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function (propertiesToInclude) {\\n      return this._toObjectMethod('toObject', propertiesToInclude);\\n    },\\n\\n    /**\\n     * Returns dataless object representation of canvas\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toDatalessObject: function (propertiesToInclude) {\\n      return this._toObjectMethod('toDatalessObject', propertiesToInclude);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _toObjectMethod: function (methodName, propertiesToInclude) {\\n\\n      var data = {\\n        objects: this._toObjects(methodName, propertiesToInclude)\\n      };\\n\\n      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));\\n\\n      fabric.util.populateWithProperties(this, data, propertiesToInclude);\\n\\n      return data;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _toObjects: function(methodName, propertiesToInclude) {\\n      return this.getObjects().filter(function(object) {\\n        return !object.excludeFromExport;\\n      }).map(function(instance) {\\n        return this._toObject(instance, methodName, propertiesToInclude);\\n      }, this);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _toObject: function(instance, methodName, propertiesToInclude) {\\n      var originalValue;\\n\\n      if (!this.includeDefaultValues) {\\n        originalValue = instance.includeDefaultValues;\\n        instance.includeDefaultValues = false;\\n      }\\n\\n      var object = instance[methodName](propertiesToInclude);\\n      if (!this.includeDefaultValues) {\\n        instance.includeDefaultValues = originalValue;\\n      }\\n      return object;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    __serializeBgOverlay: function(methodName, propertiesToInclude) {\\n      var data = {\\n        background: (this.backgroundColor && this.backgroundColor.toObject)\\n          ? this.backgroundColor.toObject(propertiesToInclude)\\n          : this.backgroundColor\\n      };\\n\\n      if (this.overlayColor) {\\n        data.overlay = this.overlayColor.toObject\\n          ? this.overlayColor.toObject(propertiesToInclude)\\n          : this.overlayColor;\\n      }\\n      if (this.backgroundImage) {\\n        data.backgroundImage = this._toObject(this.backgroundImage, methodName, propertiesToInclude);\\n      }\\n      if (this.overlayImage) {\\n        data.overlayImage = this._toObject(this.overlayImage, methodName, propertiesToInclude);\\n      }\\n\\n      return data;\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\\n     * a zoomed canvas will then produce zoomed SVG output.\\n     * @type Boolean\\n     * @default\\n     */\\n    svgViewportTransformation: true,\\n\\n    /**\\n     * Returns SVG representation of canvas\\n     * @function\\n     * @param {Object} [options] Options object for SVG output\\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\\n     * @param {Object} [options.viewBox] SVG viewbox object\\n     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox\\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\\n     * @param {Number} [options.viewBox.width] Width of viewbox\\n     * @param {Number} [options.viewBox.height] Height of viewbox\\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\\n     * @param {String} [options.width] desired width of svg with or without units\\n     * @param {String} [options.height] desired height of svg with or without units\\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\\n     * @return {String} SVG string\\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\\n     * @example <caption>Normal SVG output</caption>\\n     * var svg = canvas.toSVG();\\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\\n     * var svg = canvas.toSVG({suppressPreamble: true});\\n     * @example <caption>SVG output with viewBox attribute</caption>\\n     * var svg = canvas.toSVG({\\n     *   viewBox: {\\n     *     x: 100,\\n     *     y: 100,\\n     *     width: 200,\\n     *     height: 300\\n     *   }\\n     * });\\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\\n     * @example <caption>Modify SVG output with reviver function</caption>\\n     * var svg = canvas.toSVG(null, function(svg) {\\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\\n     * });\\n     */\\n    toSVG: function(options, reviver) {\\n      options || (options = { });\\n\\n      var markup = [];\\n\\n      this._setSVGPreamble(markup, options);\\n      this._setSVGHeader(markup, options);\\n\\n      this._setSVGBgOverlayColor(markup, 'backgroundColor');\\n      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);\\n\\n      this._setSVGObjects(markup, reviver);\\n\\n      this._setSVGBgOverlayColor(markup, 'overlayColor');\\n      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);\\n\\n      markup.push('</svg>');\\n\\n      return markup.join('');\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGPreamble: function(markup, options) {\\n      if (options.suppressPreamble) {\\n        return;\\n      }\\n      markup.push(\\n        '<?xml version=\\\"1.0\\\" encoding=\\\"', (options.encoding || 'UTF-8'), '\\\" standalone=\\\"no\\\" ?>\\\\n',\\n          '<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" ',\\n            '\\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\\\n'\\n      );\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGHeader: function(markup, options) {\\n      var width = options.width || this.width,\\n          height = options.height || this.height,\\n          vpt, viewBox = 'viewBox=\\\"0 0 ' + this.width + ' ' + this.height + '\\\" ',\\n          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\\n\\n      if (options.viewBox) {\\n        viewBox = 'viewBox=\\\"' +\\n                options.viewBox.x + ' ' +\\n                options.viewBox.y + ' ' +\\n                options.viewBox.width + ' ' +\\n                options.viewBox.height + '\\\" ';\\n      }\\n      else {\\n        if (this.svgViewportTransformation) {\\n          vpt = this.viewportTransform;\\n          viewBox = 'viewBox=\\\"' +\\n                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +\\n                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +\\n                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +\\n                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '\\\" ';\\n        }\\n      }\\n\\n      markup.push(\\n        '<svg ',\\n          'xmlns=\\\"http://www.w3.org/2000/svg\\\" ',\\n          'xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" ',\\n          'version=\\\"1.1\\\" ',\\n          'width=\\\"', width, '\\\" ',\\n          'height=\\\"', height, '\\\" ',\\n          (this.backgroundColor && !this.backgroundColor.toLive\\n            ? 'style=\\\"background-color: ' + this.backgroundColor + '\\\" '\\n            : null),\\n          viewBox,\\n          'xml:space=\\\"preserve\\\">\\\\n',\\n        '<desc>Created with Fabric.js ', fabric.version, '</desc>\\\\n',\\n        '<defs>',\\n          fabric.createSVGFontFacesMarkup(this.getObjects()),\\n          fabric.createSVGRefElementsMarkup(this),\\n        '</defs>\\\\n'\\n      );\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGObjects: function(markup, reviver) {\\n      var instance;\\n      for (var i = 0, objects = this.getObjects(), len = objects.length; i < len; i++) {\\n        instance = objects[i];\\n        if (instance.excludeFromExport) {\\n          continue;\\n        }\\n        this._setSVGObject(markup, instance, reviver);\\n      }\\n    },\\n\\n    /**\\n     * push single object svg representation in the markup\\n     * @private\\n     */\\n    _setSVGObject: function(markup, instance, reviver) {\\n      markup.push(instance.toSVG(reviver));\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGBgOverlayImage: function(markup, property, reviver) {\\n      if (this[property] && this[property].toSVG) {\\n        markup.push(this[property].toSVG(reviver));\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGBgOverlayColor: function(markup, property) {\\n      if (this[property] && this[property].source) {\\n        markup.push(\\n          '<rect x=\\\"', this[property].offsetX, '\\\" y=\\\"', this[property].offsetY, '\\\" ',\\n            'width=\\\"',\\n              (this[property].repeat === 'repeat-y' || this[property].repeat === 'no-repeat'\\n                ? this[property].source.width\\n                : this.width),\\n            '\\\" height=\\\"',\\n              (this[property].repeat === 'repeat-x' || this[property].repeat === 'no-repeat'\\n                ? this[property].source.height\\n                : this.height),\\n            '\\\" fill=\\\"url(#' + property + 'Pattern)\\\"',\\n          '></rect>\\\\n'\\n        );\\n      }\\n      else if (this[property] && property === 'overlayColor') {\\n        markup.push(\\n          '<rect x=\\\"0\\\" y=\\\"0\\\" ',\\n            'width=\\\"', this.width,\\n            '\\\" height=\\\"', this.height,\\n            '\\\" fill=\\\"', this[property], '\\\"',\\n          '></rect>\\\\n'\\n        );\\n      }\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Moves an object or the objects of a multiple selection\\n     * to the bottom of the stack of drawn objects\\n     * @param {fabric.Object} object Object to send to back\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    sendToBack: function (object) {\\n      if (!object) {\\n        return this;\\n      }\\n      var activeGroup = this._activeGroup,\\n          i, obj, objs;\\n      if (object === activeGroup) {\\n        objs = activeGroup._objects;\\n        for (i = objs.length; i--;) {\\n          obj = objs[i];\\n          removeFromArray(this._objects, obj);\\n          this._objects.unshift(obj);\\n        }\\n      }\\n      else {\\n        removeFromArray(this._objects, object);\\n        this._objects.unshift(object);\\n      }\\n      return this.renderAll && this.renderAll();\\n    },\\n\\n    /**\\n     * Moves an object or the objects of a multiple selection\\n     * to the top of the stack of drawn objects\\n     * @param {fabric.Object} object Object to send\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    bringToFront: function (object) {\\n      if (!object) {\\n        return this;\\n      }\\n      var activeGroup = this._activeGroup,\\n          i, obj, objs;\\n      if (object === activeGroup) {\\n        objs = activeGroup._objects;\\n        for (i = 0; i < objs.length; i++) {\\n          obj = objs[i];\\n          removeFromArray(this._objects, obj);\\n          this._objects.push(obj);\\n        }\\n      }\\n      else {\\n        removeFromArray(this._objects, object);\\n        this._objects.push(object);\\n      }\\n      return this.renderAll && this.renderAll();\\n    },\\n\\n    /**\\n     * Moves an object or a selection down in stack of drawn objects\\n     * @param {fabric.Object} object Object to send\\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    sendBackwards: function (object, intersecting) {\\n      if (!object) {\\n        return this;\\n      }\\n      var activeGroup = this._activeGroup,\\n          i, obj, idx, newIdx, objs;\\n\\n      if (object === activeGroup) {\\n        objs = activeGroup._objects;\\n        for (i = 0; i < objs.length; i++) {\\n          obj = objs[i];\\n          idx = this._objects.indexOf(obj);\\n          if (idx !== 0) {\\n            newIdx = idx - 1;\\n            removeFromArray(this._objects, obj);\\n            this._objects.splice(newIdx, 0, obj);\\n          }\\n        }\\n      }\\n      else {\\n        idx = this._objects.indexOf(object);\\n        if (idx !== 0) {\\n          // if object is not on the bottom of stack\\n          newIdx = this._findNewLowerIndex(object, idx, intersecting);\\n          removeFromArray(this._objects, object);\\n          this._objects.splice(newIdx, 0, object);\\n        }\\n      }\\n      this.renderAll && this.renderAll();\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _findNewLowerIndex: function(object, idx, intersecting) {\\n      var newIdx;\\n\\n      if (intersecting) {\\n        newIdx = idx;\\n\\n        // traverse down the stack looking for the nearest intersecting object\\n        for (var i = idx - 1; i >= 0; --i) {\\n\\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\\n                               object.isContainedWithinObject(this._objects[i]) ||\\n                               this._objects[i].isContainedWithinObject(object);\\n\\n          if (isIntersecting) {\\n            newIdx = i;\\n            break;\\n          }\\n        }\\n      }\\n      else {\\n        newIdx = idx - 1;\\n      }\\n\\n      return newIdx;\\n    },\\n\\n    /**\\n     * Moves an object or a selection up in stack of drawn objects\\n     * @param {fabric.Object} object Object to send\\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    bringForward: function (object, intersecting) {\\n      if (!object) {\\n        return this;\\n      }\\n      var activeGroup = this._activeGroup,\\n          i, obj, idx, newIdx, objs;\\n\\n      if (object === activeGroup) {\\n        objs = activeGroup._objects;\\n        for (i = objs.length; i--;) {\\n          obj = objs[i];\\n          idx = this._objects.indexOf(obj);\\n          if (idx !== this._objects.length - 1) {\\n            newIdx = idx + 1;\\n            removeFromArray(this._objects, obj);\\n            this._objects.splice(newIdx, 0, obj);\\n          }\\n        }\\n      }\\n      else {\\n        idx = this._objects.indexOf(object);\\n        if (idx !== this._objects.length - 1) {\\n          // if object is not on top of stack (last item in an array)\\n          newIdx = this._findNewUpperIndex(object, idx, intersecting);\\n          removeFromArray(this._objects, object);\\n          this._objects.splice(newIdx, 0, object);\\n        }\\n      }\\n      this.renderAll && this.renderAll();\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _findNewUpperIndex: function(object, idx, intersecting) {\\n      var newIdx;\\n\\n      if (intersecting) {\\n        newIdx = idx;\\n\\n        // traverse up the stack looking for the nearest intersecting object\\n        for (var i = idx + 1; i < this._objects.length; ++i) {\\n\\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\\n                               object.isContainedWithinObject(this._objects[i]) ||\\n                               this._objects[i].isContainedWithinObject(object);\\n\\n          if (isIntersecting) {\\n            newIdx = i;\\n            break;\\n          }\\n        }\\n      }\\n      else {\\n        newIdx = idx + 1;\\n      }\\n\\n      return newIdx;\\n    },\\n\\n    /**\\n     * Moves an object to specified level in stack of drawn objects\\n     * @param {fabric.Object} object Object to send\\n     * @param {Number} index Position to move to\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    moveTo: function (object, index) {\\n      removeFromArray(this._objects, object);\\n      this._objects.splice(index, 0, object);\\n      return this.renderAll && this.renderAll();\\n    },\\n\\n    /**\\n     * Clears a canvas element and removes all event listeners\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    dispose: function () {\\n      this.clear();\\n      return this;\\n    },\\n\\n    /**\\n     * Returns a string representation of an instance\\n     * @return {String} string representation of an instance\\n     */\\n    toString: function () {\\n      return '#<fabric.Canvas (' + this.complexity() + '): ' +\\n               '{ objects: ' + this.getObjects().length + ' }>';\\n    }\\n  });\\n\\n  extend(fabric.StaticCanvas.prototype, fabric.Observable);\\n  extend(fabric.StaticCanvas.prototype, fabric.Collection);\\n  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\\n\\n  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\\n\\n    /**\\n     * @static\\n     * @type String\\n     * @default\\n     */\\n    EMPTY_JSON: '{\\\"objects\\\": [], \\\"background\\\": \\\"white\\\"}',\\n\\n    /**\\n     * Provides a way to check support of some of the canvas methods\\n     * (either those of HTMLCanvasElement itself, or rendering context)\\n     *\\n     * @param {String} methodName Method to check support for;\\n     *                            Could be one of \\\"getImageData\\\", \\\"toDataURL\\\", \\\"toDataURLWithQuality\\\" or \\\"setLineDash\\\"\\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\\n     *                          `null` if canvas element or context can not be initialized\\n     */\\n    supports: function (methodName) {\\n      var el = fabric.util.createCanvasElement();\\n\\n      if (!el || !el.getContext) {\\n        return null;\\n      }\\n\\n      var ctx = el.getContext('2d');\\n      if (!ctx) {\\n        return null;\\n      }\\n\\n      switch (methodName) {\\n\\n        case 'getImageData':\\n          return typeof ctx.getImageData !== 'undefined';\\n\\n        case 'setLineDash':\\n          return typeof ctx.setLineDash !== 'undefined';\\n\\n        case 'toDataURL':\\n          return typeof el.toDataURL !== 'undefined';\\n\\n        case 'toDataURLWithQuality':\\n          try {\\n            el.toDataURL('image/jpeg', 0);\\n            return true;\\n          }\\n          catch (e) { }\\n          return false;\\n\\n        default:\\n          return null;\\n      }\\n    }\\n  });\\n\\n  /**\\n   * Returns JSON representation of canvas\\n   * @function\\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n   * @return {String} JSON string\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\\n   * @example <caption>JSON without additional properties</caption>\\n   * var json = canvas.toJSON();\\n   * @example <caption>JSON with additional properties included</caption>\\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);\\n   * @example <caption>JSON without default values</caption>\\n   * canvas.includeDefaultValues = false;\\n   * var json = canvas.toJSON();\\n   */\\n  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\\n\\n})();\\n\\n\\n/**\\n * BaseBrush class\\n * @class fabric.BaseBrush\\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\\n */\\nfabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\\n\\n  /**\\n   * Color of a brush\\n   * @type String\\n   * @default\\n   */\\n  color: 'rgb(0, 0, 0)',\\n\\n  /**\\n   * Width of a brush\\n   * @type Number\\n   * @default\\n   */\\n  width: 1,\\n\\n  /**\\n   * Shadow object representing shadow of this shape.\\n   * <b>Backwards incompatibility note:</b> This property replaces \\\"shadowColor\\\" (String), \\\"shadowOffsetX\\\" (Number),\\n   * \\\"shadowOffsetY\\\" (Number) and \\\"shadowBlur\\\" (Number) since v1.2.12\\n   * @type fabric.Shadow\\n   * @default\\n   */\\n  shadow: null,\\n\\n  /**\\n   * Line endings style of a brush (one of \\\"butt\\\", \\\"round\\\", \\\"square\\\")\\n   * @type String\\n   * @default\\n   */\\n  strokeLineCap: 'round',\\n\\n  /**\\n   * Corner style of a brush (one of \\\"bevil\\\", \\\"round\\\", \\\"miter\\\")\\n   * @type String\\n   * @default\\n   */\\n  strokeLineJoin: 'round',\\n\\n  /**\\n   * Stroke Dash Array.\\n   * @type Array\\n   * @default\\n   */\\n  strokeDashArray: null,\\n\\n  /**\\n   * Sets shadow of an object\\n   * @param {Object|String} [options] Options object or string (e.g. \\\"2px 2px 10px rgba(0,0,0,0.2)\\\")\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  setShadow: function(options) {\\n    this.shadow = new fabric.Shadow(options);\\n    return this;\\n  },\\n\\n  /**\\n   * Sets brush styles\\n   * @private\\n   */\\n  _setBrushStyles: function() {\\n    var ctx = this.canvas.contextTop;\\n\\n    ctx.strokeStyle = this.color;\\n    ctx.lineWidth = this.width;\\n    ctx.lineCap = this.strokeLineCap;\\n    ctx.lineJoin = this.strokeLineJoin;\\n    if (this.strokeDashArray && fabric.StaticCanvas.supports('setLineDash')) {\\n      ctx.setLineDash(this.strokeDashArray);\\n    }\\n  },\\n\\n  /**\\n   * Sets brush shadow styles\\n   * @private\\n   */\\n  _setShadow: function() {\\n    if (!this.shadow) {\\n      return;\\n    }\\n\\n    var ctx = this.canvas.contextTop,\\n        zoom = this.canvas.getZoom();\\n\\n    ctx.shadowColor = this.shadow.color;\\n    ctx.shadowBlur = this.shadow.blur * zoom;\\n    ctx.shadowOffsetX = this.shadow.offsetX * zoom;\\n    ctx.shadowOffsetY = this.shadow.offsetY * zoom;\\n  },\\n\\n  /**\\n   * Removes brush shadow styles\\n   * @private\\n   */\\n  _resetShadow: function() {\\n    var ctx = this.canvas.contextTop;\\n\\n    ctx.shadowColor = '';\\n    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\\n  }\\n});\\n\\n\\n(function() {\\n\\n  /**\\n   * PencilBrush class\\n   * @class fabric.PencilBrush\\n   * @extends fabric.BaseBrush\\n   */\\n  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\\n\\n    /**\\n     * Constructor\\n     * @param {fabric.Canvas} canvas\\n     * @return {fabric.PencilBrush} Instance of a pencil brush\\n     */\\n    initialize: function(canvas) {\\n      this.canvas = canvas;\\n      this._points = [];\\n    },\\n\\n    /**\\n     * Inovoked on mouse down\\n     * @param {Object} pointer\\n     */\\n    onMouseDown: function(pointer) {\\n      this._prepareForDrawing(pointer);\\n      // capture coordinates immediately\\n      // this allows to draw dots (when movement never occurs)\\n      this._captureDrawingPath(pointer);\\n      this._render();\\n    },\\n\\n    /**\\n     * Inovoked on mouse move\\n     * @param {Object} pointer\\n     */\\n    onMouseMove: function(pointer) {\\n      this._captureDrawingPath(pointer);\\n      // redraw curve\\n      // clear top canvas\\n      this.canvas.clearContext(this.canvas.contextTop);\\n      this._render();\\n    },\\n\\n    /**\\n     * Invoked on mouse up\\n     */\\n    onMouseUp: function() {\\n      this._finalizeAndAddPath();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} pointer Actual mouse position related to the canvas.\\n     */\\n    _prepareForDrawing: function(pointer) {\\n\\n      var p = new fabric.Point(pointer.x, pointer.y);\\n\\n      this._reset();\\n      this._addPoint(p);\\n\\n      this.canvas.contextTop.moveTo(p.x, p.y);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {fabric.Point} point Point to be added to points array\\n     */\\n    _addPoint: function(point) {\\n      this._points.push(point);\\n    },\\n\\n    /**\\n     * Clear points array and set contextTop canvas style.\\n     * @private\\n     */\\n    _reset: function() {\\n      this._points.length = 0;\\n\\n      this._setBrushStyles();\\n      this._setShadow();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} pointer Actual mouse position related to the canvas.\\n     */\\n    _captureDrawingPath: function(pointer) {\\n      var pointerPoint = new fabric.Point(pointer.x, pointer.y);\\n      this._addPoint(pointerPoint);\\n    },\\n\\n    /**\\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\\n     * @private\\n     */\\n    _render: function() {\\n      var ctx  = this.canvas.contextTop,\\n          v = this.canvas.viewportTransform,\\n          p1 = this._points[0],\\n          p2 = this._points[1];\\n\\n      ctx.save();\\n      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\\n      ctx.beginPath();\\n\\n      //if we only have 2 points in the path and they are the same\\n      //it means that the user only clicked the canvas without moving the mouse\\n      //then we should be drawing a dot. A path isn't drawn between two identical dots\\n      //that's why we set them apart a bit\\n      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\\n        p1.x -= 0.5;\\n        p2.x += 0.5;\\n      }\\n      ctx.moveTo(p1.x, p1.y);\\n\\n      for (var i = 1, len = this._points.length; i < len; i++) {\\n        // we pick the point between pi + 1 & pi + 2 as the\\n        // end point and p1 as our control point.\\n        var midPoint = p1.midPointFrom(p2);\\n        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\\n\\n        p1 = this._points[i];\\n        p2 = this._points[i + 1];\\n      }\\n      // Draw last line as a straight line while\\n      // we wait for the next point to be able to calculate\\n      // the bezier control point\\n      ctx.lineTo(p1.x, p1.y);\\n      ctx.stroke();\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * Converts points to SVG path\\n     * @param {Array} points Array of points\\n     * @return {String} SVG path\\n     */\\n    convertPointsToSVGPath: function(points) {\\n      var path = [],\\n          p1 = new fabric.Point(points[0].x, points[0].y),\\n          p2 = new fabric.Point(points[1].x, points[1].y);\\n\\n      path.push('M ', points[0].x, ' ', points[0].y, ' ');\\n      for (var i = 1, len = points.length; i < len; i++) {\\n        var midPoint = p1.midPointFrom(p2);\\n        // p1 is our bezier control point\\n        // midpoint is our endpoint\\n        // start point is p(i-1) value.\\n        path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');\\n        p1 = new fabric.Point(points[i].x, points[i].y);\\n        if ((i + 1) < points.length) {\\n          p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);\\n        }\\n      }\\n      path.push('L ', p1.x, ' ', p1.y, ' ');\\n      return path;\\n    },\\n\\n    /**\\n     * Creates fabric.Path object to add on canvas\\n     * @param {String} pathData Path data\\n     * @return {fabric.Path} Path to add on canvas\\n     */\\n    createPath: function(pathData) {\\n      var path = new fabric.Path(pathData, {\\n        fill: null,\\n        stroke: this.color,\\n        strokeWidth: this.width,\\n        strokeLineCap: this.strokeLineCap,\\n        strokeLineJoin: this.strokeLineJoin,\\n        strokeDashArray: this.strokeDashArray,\\n        originX: 'center',\\n        originY: 'center'\\n      });\\n\\n      if (this.shadow) {\\n        this.shadow.affectStroke = true;\\n        path.setShadow(this.shadow);\\n      }\\n\\n      return path;\\n    },\\n\\n    /**\\n     * On mouseup after drawing the path on contextTop canvas\\n     * we use the points captured to create an new fabric path object\\n     * and add it to the fabric canvas.\\n     */\\n    _finalizeAndAddPath: function() {\\n      var ctx = this.canvas.contextTop;\\n      ctx.closePath();\\n\\n      var pathData = this.convertPointsToSVGPath(this._points).join('');\\n      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {\\n        // do not create 0 width/height paths, as they are\\n        // rendered inconsistently across browsers\\n        // Firefox 4, for example, renders a dot,\\n        // whereas Chrome 10 renders nothing\\n        this.canvas.renderAll();\\n        return;\\n      }\\n\\n      var path = this.createPath(pathData);\\n\\n      this.canvas.add(path);\\n      path.setCoords();\\n\\n      this.canvas.clearContext(this.canvas.contextTop);\\n      this._resetShadow();\\n      this.canvas.renderAll();\\n\\n      // fire event 'path' created\\n      this.canvas.fire('path:created', { path: path });\\n    }\\n  });\\n})();\\n\\n\\n/**\\n * CircleBrush class\\n * @class fabric.CircleBrush\\n */\\nfabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\\n\\n  /**\\n   * Width of a brush\\n   * @type Number\\n   * @default\\n   */\\n  width: 10,\\n\\n  /**\\n   * Constructor\\n   * @param {fabric.Canvas} canvas\\n   * @return {fabric.CircleBrush} Instance of a circle brush\\n   */\\n  initialize: function(canvas) {\\n    this.canvas = canvas;\\n    this.points = [];\\n  },\\n\\n  /**\\n   * Invoked inside on mouse down and mouse move\\n   * @param {Object} pointer\\n   */\\n  drawDot: function(pointer) {\\n    var point = this.addPoint(pointer),\\n        ctx = this.canvas.contextTop,\\n        v = this.canvas.viewportTransform;\\n    ctx.save();\\n    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\\n\\n    ctx.fillStyle = point.fill;\\n    ctx.beginPath();\\n    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\\n    ctx.closePath();\\n    ctx.fill();\\n\\n    ctx.restore();\\n  },\\n\\n  /**\\n   * Invoked on mouse down\\n   */\\n  onMouseDown: function(pointer) {\\n    this.points.length = 0;\\n    this.canvas.clearContext(this.canvas.contextTop);\\n    this._setShadow();\\n    this.drawDot(pointer);\\n  },\\n\\n  /**\\n   * Invoked on mouse move\\n   * @param {Object} pointer\\n   */\\n  onMouseMove: function(pointer) {\\n    this.drawDot(pointer);\\n  },\\n\\n  /**\\n   * Invoked on mouse up\\n   */\\n  onMouseUp: function() {\\n    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\\n    this.canvas.renderOnAddRemove = false;\\n\\n    var circles = [];\\n\\n    for (var i = 0, len = this.points.length; i < len; i++) {\\n      var point = this.points[i],\\n          circle = new fabric.Circle({\\n            radius: point.radius,\\n            left: point.x,\\n            top: point.y,\\n            originX: 'center',\\n            originY: 'center',\\n            fill: point.fill\\n          });\\n\\n      this.shadow && circle.setShadow(this.shadow);\\n\\n      circles.push(circle);\\n    }\\n    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });\\n    group.canvas = this.canvas;\\n\\n    this.canvas.add(group);\\n    this.canvas.fire('path:created', { path: group });\\n\\n    this.canvas.clearContext(this.canvas.contextTop);\\n    this._resetShadow();\\n    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\\n    this.canvas.renderAll();\\n  },\\n\\n  /**\\n   * @param {Object} pointer\\n   * @return {fabric.Point} Just added pointer point\\n   */\\n  addPoint: function(pointer) {\\n    var pointerPoint = new fabric.Point(pointer.x, pointer.y),\\n\\n        circleRadius = fabric.util.getRandomInt(\\n                        Math.max(0, this.width - 20), this.width + 20) / 2,\\n\\n        circleColor = new fabric.Color(this.color)\\n                        .setAlpha(fabric.util.getRandomInt(0, 100) / 100)\\n                        .toRgba();\\n\\n    pointerPoint.radius = circleRadius;\\n    pointerPoint.fill = circleColor;\\n\\n    this.points.push(pointerPoint);\\n\\n    return pointerPoint;\\n  }\\n});\\n\\n\\n/**\\n * SprayBrush class\\n * @class fabric.SprayBrush\\n */\\nfabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\\n\\n  /**\\n   * Width of a spray\\n   * @type Number\\n   * @default\\n   */\\n  width:              10,\\n\\n  /**\\n   * Density of a spray (number of dots per chunk)\\n   * @type Number\\n   * @default\\n   */\\n  density:            20,\\n\\n  /**\\n   * Width of spray dots\\n   * @type Number\\n   * @default\\n   */\\n  dotWidth:           1,\\n\\n  /**\\n   * Width variance of spray dots\\n   * @type Number\\n   * @default\\n   */\\n  dotWidthVariance:   1,\\n\\n  /**\\n   * Whether opacity of a dot should be random\\n   * @type Boolean\\n   * @default\\n   */\\n  randomOpacity:        false,\\n\\n  /**\\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\\n   * @type Boolean\\n   * @default\\n   */\\n  optimizeOverlapping:  true,\\n\\n  /**\\n   * Constructor\\n   * @param {fabric.Canvas} canvas\\n   * @return {fabric.SprayBrush} Instance of a spray brush\\n   */\\n  initialize: function(canvas) {\\n    this.canvas = canvas;\\n    this.sprayChunks = [];\\n  },\\n\\n  /**\\n   * Invoked on mouse down\\n   * @param {Object} pointer\\n   */\\n  onMouseDown: function(pointer) {\\n    this.sprayChunks.length = 0;\\n    this.canvas.clearContext(this.canvas.contextTop);\\n    this._setShadow();\\n\\n    this.addSprayChunk(pointer);\\n    this.render();\\n  },\\n\\n  /**\\n   * Invoked on mouse move\\n   * @param {Object} pointer\\n   */\\n  onMouseMove: function(pointer) {\\n    this.addSprayChunk(pointer);\\n    this.render();\\n  },\\n\\n  /**\\n   * Invoked on mouse up\\n   */\\n  onMouseUp: function() {\\n    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\\n    this.canvas.renderOnAddRemove = false;\\n\\n    var rects = [];\\n\\n    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {\\n      var sprayChunk = this.sprayChunks[i];\\n\\n      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {\\n\\n        var rect = new fabric.Rect({\\n          width: sprayChunk[j].width,\\n          height: sprayChunk[j].width,\\n          left: sprayChunk[j].x + 1,\\n          top: sprayChunk[j].y + 1,\\n          originX: 'center',\\n          originY: 'center',\\n          fill: this.color\\n        });\\n\\n        this.shadow && rect.setShadow(this.shadow);\\n        rects.push(rect);\\n      }\\n    }\\n\\n    if (this.optimizeOverlapping) {\\n      rects = this._getOptimizedRects(rects);\\n    }\\n\\n    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });\\n    group.canvas = this.canvas;\\n\\n    this.canvas.add(group);\\n    this.canvas.fire('path:created', { path: group });\\n\\n    this.canvas.clearContext(this.canvas.contextTop);\\n    this._resetShadow();\\n    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\\n    this.canvas.renderAll();\\n  },\\n\\n  /**\\n   * @private\\n   * @param {Array} rects\\n   */\\n  _getOptimizedRects: function(rects) {\\n\\n    // avoid creating duplicate rects at the same coordinates\\n    var uniqueRects = { }, key;\\n\\n    for (var i = 0, len = rects.length; i < len; i++) {\\n      key = rects[i].left + '' + rects[i].top;\\n      if (!uniqueRects[key]) {\\n        uniqueRects[key] = rects[i];\\n      }\\n    }\\n    var uniqueRectsArray = [];\\n    for (key in uniqueRects) {\\n      uniqueRectsArray.push(uniqueRects[key]);\\n    }\\n\\n    return uniqueRectsArray;\\n  },\\n\\n  /**\\n   * Renders brush\\n   */\\n  render: function() {\\n    var ctx = this.canvas.contextTop;\\n    ctx.fillStyle = this.color;\\n\\n    var v = this.canvas.viewportTransform;\\n    ctx.save();\\n    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\\n\\n    for (var i = 0, len = this.sprayChunkPoints.length; i < len; i++) {\\n      var point = this.sprayChunkPoints[i];\\n      if (typeof point.opacity !== 'undefined') {\\n        ctx.globalAlpha = point.opacity;\\n      }\\n      ctx.fillRect(point.x, point.y, point.width, point.width);\\n    }\\n    ctx.restore();\\n  },\\n\\n  /**\\n   * @param {Object} pointer\\n   */\\n  addSprayChunk: function(pointer) {\\n    this.sprayChunkPoints = [];\\n\\n    var x, y, width, radius = this.width / 2;\\n\\n    for (var i = 0; i < this.density; i++) {\\n\\n      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\\n      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\\n\\n      if (this.dotWidthVariance) {\\n        width = fabric.util.getRandomInt(\\n          // bottom clamp width to 1\\n          Math.max(1, this.dotWidth - this.dotWidthVariance),\\n          this.dotWidth + this.dotWidthVariance);\\n      }\\n      else {\\n        width = this.dotWidth;\\n      }\\n\\n      var point = new fabric.Point(x, y);\\n      point.width = width;\\n\\n      if (this.randomOpacity) {\\n        point.opacity = fabric.util.getRandomInt(0, 100) / 100;\\n      }\\n\\n      this.sprayChunkPoints.push(point);\\n    }\\n\\n    this.sprayChunks.push(this.sprayChunkPoints);\\n  }\\n});\\n\\n\\n/**\\n * PatternBrush class\\n * @class fabric.PatternBrush\\n * @extends fabric.BaseBrush\\n */\\nfabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\\n\\n  getPatternSrc: function() {\\n\\n    var dotWidth = 20,\\n        dotDistance = 5,\\n        patternCanvas = fabric.document.createElement('canvas'),\\n        patternCtx = patternCanvas.getContext('2d');\\n\\n    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\\n\\n    patternCtx.fillStyle = this.color;\\n    patternCtx.beginPath();\\n    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\\n    patternCtx.closePath();\\n    patternCtx.fill();\\n\\n    return patternCanvas;\\n  },\\n\\n  getPatternSrcFunction: function() {\\n    return String(this.getPatternSrc).replace('this.color', '\\\"' + this.color + '\\\"');\\n  },\\n\\n  /**\\n   * Creates \\\"pattern\\\" instance property\\n   */\\n  getPattern: function() {\\n    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');\\n  },\\n\\n  /**\\n   * Sets brush styles\\n   */\\n  _setBrushStyles: function() {\\n    this.callSuper('_setBrushStyles');\\n    this.canvas.contextTop.strokeStyle = this.getPattern();\\n  },\\n\\n  /**\\n   * Creates path\\n   */\\n  createPath: function(pathData) {\\n    var path = this.callSuper('createPath', pathData),\\n        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);\\n\\n    path.stroke = new fabric.Pattern({\\n      source: this.source || this.getPatternSrcFunction(),\\n      offsetX: -topLeft.x,\\n      offsetY: -topLeft.y\\n    });\\n    return path;\\n  }\\n});\\n\\n\\n(function() {\\n\\n  var getPointer = fabric.util.getPointer,\\n      degreesToRadians = fabric.util.degreesToRadians,\\n      radiansToDegrees = fabric.util.radiansToDegrees,\\n      atan2 = Math.atan2,\\n      abs = Math.abs,\\n      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),\\n\\n      STROKE_OFFSET = 0.5;\\n\\n  /**\\n   * Canvas class\\n   * @class fabric.Canvas\\n   * @extends fabric.StaticCanvas\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}\\n   * @see {@link fabric.Canvas#initialize} for constructor definition\\n   *\\n   * @fires object:added\\n   * @fires object:modified\\n   * @fires object:rotating\\n   * @fires object:scaling\\n   * @fires object:moving\\n   * @fires object:selected\\n   *\\n   * @fires before:selection:cleared\\n   * @fires selection:cleared\\n   * @fires selection:created\\n   *\\n   * @fires path:created\\n   * @fires mouse:down\\n   * @fires mouse:move\\n   * @fires mouse:up\\n   * @fires mouse:over\\n   * @fires mouse:out\\n   *\\n   */\\n  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\\n\\n    /**\\n     * Constructor\\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\\n     * @param {Object} [options] Options object\\n     * @return {Object} thisArg\\n     */\\n    initialize: function(el, options) {\\n      options || (options = { });\\n\\n      this._initStatic(el, options);\\n      this._initInteractive();\\n      this._createCacheCanvas();\\n    },\\n\\n    /**\\n     * When true, objects can be transformed by one side (unproportionally)\\n     * @type Boolean\\n     * @default\\n     */\\n    uniScaleTransform:      false,\\n\\n    /**\\n     * Indicates which key enable unproportional scaling\\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\\n     * If `null` or 'none' or any other string that is not a modifier key\\n     * feature is disabled feature disabled.\\n     * @since 1.6.2\\n     * @type String\\n     * @default\\n     */\\n    uniScaleKey:           'shiftKey',\\n\\n    /**\\n     * When true, objects use center point as the origin of scale transformation.\\n     * <b>Backwards incompatibility note:</b> This property replaces \\\"centerTransform\\\" (Boolean).\\n     * @since 1.3.4\\n     * @type Boolean\\n     * @default\\n     */\\n    centeredScaling:        false,\\n\\n    /**\\n     * When true, objects use center point as the origin of rotate transformation.\\n     * <b>Backwards incompatibility note:</b> This property replaces \\\"centerTransform\\\" (Boolean).\\n     * @since 1.3.4\\n     * @type Boolean\\n     * @default\\n     */\\n    centeredRotation:       false,\\n\\n    /**\\n     * Indicates which key enable centered Transfrom\\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\\n     * If `null` or 'none' or any other string that is not a modifier key\\n     * feature is disabled feature disabled.\\n     * @since 1.6.2\\n     * @type String\\n     * @default\\n     */\\n    centeredKey:           'altKey',\\n\\n    /**\\n     * Indicates which key enable alternate action on corner\\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\\n     * If `null` or 'none' or any other string that is not a modifier key\\n     * feature is disabled feature disabled.\\n     * @since 1.6.2\\n     * @type String\\n     * @default\\n     */\\n    altActionKey:           'shiftKey',\\n\\n    /**\\n     * Indicates that canvas is interactive. This property should not be changed.\\n     * @type Boolean\\n     * @default\\n     */\\n    interactive:            true,\\n\\n    /**\\n     * Indicates whether group selection should be enabled\\n     * @type Boolean\\n     * @default\\n     */\\n    selection:              true,\\n\\n    /**\\n     * Indicates which key enable multiple click selection\\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\\n     * If `null` or 'none' or any other string that is not a modifier key\\n     * feature is disabled feature disabled.\\n     * @since 1.6.2\\n     * @type String\\n     * @default\\n     */\\n    selectionKey:           'shiftKey',\\n\\n    /**\\n     * Indicates which key enable alternative selection\\n     * in case of target overlapping with active object\\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\\n     * If `null` or 'none' or any other string that is not a modifier key\\n     * feature is disabled feature disabled.\\n     * @since 1.6.5\\n     * @type null|String\\n     * @default\\n     */\\n    altSelectionKey:           null,\\n\\n    /**\\n     * Color of selection\\n     * @type String\\n     * @default\\n     */\\n    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue\\n\\n    /**\\n     * Default dash array pattern\\n     * If not empty the selection border is dashed\\n     * @type Array\\n     */\\n    selectionDashArray:     [],\\n\\n    /**\\n     * Color of the border of selection (usually slightly darker than color of selection itself)\\n     * @type String\\n     * @default\\n     */\\n    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',\\n\\n    /**\\n     * Width of a line used in object/group selection\\n     * @type Number\\n     * @default\\n     */\\n    selectionLineWidth:     1,\\n\\n    /**\\n     * Default cursor value used when hovering over an object on canvas\\n     * @type String\\n     * @default\\n     */\\n    hoverCursor:            'move',\\n\\n    /**\\n     * Default cursor value used when moving an object on canvas\\n     * @type String\\n     * @default\\n     */\\n    moveCursor:             'move',\\n\\n    /**\\n     * Default cursor value used for the entire canvas\\n     * @type String\\n     * @default\\n     */\\n    defaultCursor:          'default',\\n\\n    /**\\n     * Cursor value used during free drawing\\n     * @type String\\n     * @default\\n     */\\n    freeDrawingCursor:      'crosshair',\\n\\n    /**\\n     * Cursor value used for rotation point\\n     * @type String\\n     * @default\\n     */\\n    rotationCursor:         'crosshair',\\n\\n    /**\\n     * Default element class that's given to wrapper (div) element of canvas\\n     * @type String\\n     * @default\\n     */\\n    containerClass:         'canvas-container',\\n\\n    /**\\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\\n     * @type Boolean\\n     * @default\\n     */\\n    perPixelTargetFind:     false,\\n\\n    /**\\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\\n     * @type Number\\n     * @default\\n     */\\n    targetFindTolerance:    0,\\n\\n    /**\\n     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.\\n     * @type Boolean\\n     * @default\\n     */\\n    skipTargetFind:         false,\\n\\n    /**\\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\\n     * After mousedown, mousemove creates a shape,\\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}\\n     * @type Boolean\\n     * @default\\n     */\\n    isDrawingMode:          false,\\n\\n    /**\\n     * Indicates whether objects should remain in current stack position when selected.\\n     * When false objects are brought to top and rendered as part of the selection group\\n     * @type Boolean\\n     * @default\\n     */\\n    preserveObjectStacking: false,\\n\\n    /**\\n     * Indicates the angle that an object will lock to while rotating.\\n     * @type Number\\n     * @since 1.6.7\\n     * @default\\n     */\\n    snapAngle: 0,\\n\\n    /**\\n     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.\\n     * When `null`, the snapThreshold will default to the snapAngle.\\n     * @type null|Number\\n     * @since 1.6.7\\n     * @default\\n     */\\n    snapThreshold: null,\\n\\n    /**\\n     * Indicates if the right click on canvas can output the context menu or not\\n     * @type Boolean\\n     * @since 1.6.5\\n     * @default\\n     */\\n    stopContextMenu: false,\\n\\n    /**\\n     * Indicates if the canvas can fire right click events\\n     * @type Boolean\\n     * @since 1.6.5\\n     * @default\\n     */\\n    fireRightClick: false,\\n\\n    /**\\n     * @private\\n     */\\n    _initInteractive: function() {\\n      this._currentTransform = null;\\n      this._groupSelector = null;\\n      this._initWrapperElement();\\n      this._createUpperCanvas();\\n      this._initEventListeners();\\n\\n      this._initRetinaScaling();\\n\\n      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\\n\\n      this.calcOffset();\\n    },\\n\\n    /**\\n     * Divides objects in two groups, one to render immediately\\n     * and one to render as activeGroup.\\n     * @return {Array} objects to render immediately and pushes the other in the activeGroup.\\n     */\\n    _chooseObjectsToRender: function() {\\n      var activeGroup = this.getActiveGroup(),\\n          activeObject = this.getActiveObject(),\\n          object, objsToRender = [], activeGroupObjects = [];\\n\\n      if ((activeGroup || activeObject) && !this.preserveObjectStacking) {\\n        for (var i = 0, length = this._objects.length; i < length; i++) {\\n          object = this._objects[i];\\n          if ((!activeGroup || !activeGroup.contains(object)) && object !== activeObject) {\\n            objsToRender.push(object);\\n          }\\n          else {\\n            activeGroupObjects.push(object);\\n          }\\n        }\\n        if (activeGroup) {\\n          activeGroup._set('_objects', activeGroupObjects);\\n          objsToRender.push(activeGroup);\\n        }\\n        activeObject && objsToRender.push(activeObject);\\n      }\\n      else {\\n        objsToRender = this._objects;\\n      }\\n      return objsToRender;\\n    },\\n\\n    /**\\n     * Renders both the top canvas and the secondary container canvas.\\n     * @return {fabric.Canvas} instance\\n     * @chainable\\n     */\\n    renderAll: function () {\\n      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {\\n        this.clearContext(this.contextTop);\\n        this.contextTopDirty = false;\\n      }\\n      var canvasToDrawOn = this.contextContainer;\\n      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());\\n      return this;\\n    },\\n\\n    /**\\n     * Method to render only the top canvas.\\n     * Also used to render the group selection box.\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    renderTop: function () {\\n      var ctx = this.contextTop;\\n      this.clearContext(ctx);\\n\\n      // we render the top context - last object\\n      if (this.selection && this._groupSelector) {\\n        this._drawSelection(ctx);\\n      }\\n\\n      this.fire('after:render');\\n      this.contextTopDirty = true;\\n      return this;\\n    },\\n\\n    /**\\n     * Resets the current transform to its original values and chooses the type of resizing based on the event\\n     * @private\\n     */\\n    _resetCurrentTransform: function() {\\n      var t = this._currentTransform;\\n\\n      t.target.set({\\n        scaleX: t.original.scaleX,\\n        scaleY: t.original.scaleY,\\n        skewX: t.original.skewX,\\n        skewY: t.original.skewY,\\n        left: t.original.left,\\n        top: t.original.top\\n      });\\n\\n      if (this._shouldCenterTransform(t.target)) {\\n        if (t.action === 'rotate') {\\n          this._setOriginToCenter(t.target);\\n        }\\n        else {\\n          if (t.originX !== 'center') {\\n            if (t.originX === 'right') {\\n              t.mouseXSign = -1;\\n            }\\n            else {\\n              t.mouseXSign = 1;\\n            }\\n          }\\n          if (t.originY !== 'center') {\\n            if (t.originY === 'bottom') {\\n              t.mouseYSign = -1;\\n            }\\n            else {\\n              t.mouseYSign = 1;\\n            }\\n          }\\n\\n          t.originX = 'center';\\n          t.originY = 'center';\\n        }\\n      }\\n      else {\\n        t.originX = t.original.originX;\\n        t.originY = t.original.originY;\\n      }\\n    },\\n\\n    /**\\n     * Checks if point is contained within an area of given object\\n     * @param {Event} e Event object\\n     * @param {fabric.Object} target Object to test against\\n     * @param {Object} [point] x,y object of point coordinates we want to check.\\n     * @return {Boolean} true if point is contained within an area of given object\\n     */\\n    containsPoint: function (e, target, point) {\\n      var ignoreZoom = true,\\n          pointer = point || this.getPointer(e, ignoreZoom),\\n          xy;\\n\\n      if (target.group && target.group === this.getActiveGroup()) {\\n        xy = this._normalizePointer(target.group, pointer);\\n      }\\n      else {\\n        xy = { x: pointer.x, y: pointer.y };\\n      }\\n      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\\n      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\\n      return (target.containsPoint(xy) || target._findTargetCorner(pointer));\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _normalizePointer: function (object, pointer) {\\n      var m = object.calcTransformMatrix(),\\n          invertedM = fabric.util.invertTransform(m),\\n          vptPointer = this.restorePointerVpt(pointer);\\n      return fabric.util.transformPoint(vptPointer, invertedM);\\n    },\\n\\n    /**\\n     * Returns true if object is transparent at a certain location\\n     * @param {fabric.Object} target Object to check\\n     * @param {Number} x Left coordinate\\n     * @param {Number} y Top coordinate\\n     * @return {Boolean}\\n     */\\n    isTargetTransparent: function (target, x, y) {\\n      var hasBorders = target.hasBorders,\\n          transparentCorners = target.transparentCorners,\\n          ctx = this.contextCache,\\n          originalColor = target.selectionBackgroundColor;\\n\\n      target.hasBorders = target.transparentCorners = false;\\n      target.selectionBackgroundColor = '';\\n\\n      ctx.save();\\n      ctx.transform.apply(ctx, this.viewportTransform);\\n      target.render(ctx);\\n      ctx.restore();\\n\\n      target.active && target._renderControls(ctx);\\n\\n      target.hasBorders = hasBorders;\\n      target.transparentCorners = transparentCorners;\\n      target.selectionBackgroundColor = originalColor;\\n\\n      var isTransparent = fabric.util.isTransparent(\\n        ctx, x, y, this.targetFindTolerance);\\n\\n      this.clearContext(ctx);\\n\\n      return isTransparent;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object\\n     * @param {fabric.Object} target\\n     */\\n    _shouldClearSelection: function (e, target) {\\n      var activeGroup = this.getActiveGroup(),\\n          activeObject = this.getActiveObject();\\n\\n      return (\\n        !target\\n        ||\\n        (target &&\\n          activeGroup &&\\n          !activeGroup.contains(target) &&\\n          activeGroup !== target &&\\n          !e[this.selectionKey])\\n        ||\\n        (target && !target.evented)\\n        ||\\n        (target &&\\n          !target.selectable &&\\n          activeObject &&\\n          activeObject !== target)\\n      );\\n    },\\n\\n    /**\\n     * @private\\n     * @param {fabric.Object} target\\n     */\\n    _shouldCenterTransform: function (target) {\\n      if (!target) {\\n        return;\\n      }\\n\\n      var t = this._currentTransform,\\n          centerTransform;\\n\\n      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {\\n        centerTransform = this.centeredScaling || target.centeredScaling;\\n      }\\n      else if (t.action === 'rotate') {\\n        centerTransform = this.centeredRotation || target.centeredRotation;\\n      }\\n\\n      return centerTransform ? !t.altKey : t.altKey;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getOriginFromCorner: function(target, corner) {\\n      var origin = {\\n        x: target.originX,\\n        y: target.originY\\n      };\\n\\n      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {\\n        origin.x = 'right';\\n      }\\n      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {\\n        origin.x = 'left';\\n      }\\n\\n      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {\\n        origin.y = 'bottom';\\n      }\\n      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {\\n        origin.y = 'top';\\n      }\\n\\n      return origin;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getActionFromCorner: function(target, corner, e) {\\n      if (!corner) {\\n        return 'drag';\\n      }\\n\\n      switch (corner) {\\n        case 'mtr':\\n          return 'rotate';\\n        case 'ml':\\n        case 'mr':\\n          return e[this.altActionKey] ? 'skewY' : 'scaleX';\\n        case 'mt':\\n        case 'mb':\\n          return e[this.altActionKey] ? 'skewX' : 'scaleY';\\n        default:\\n          return 'scale';\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object\\n     * @param {fabric.Object} target\\n     */\\n    _setupCurrentTransform: function (e, target) {\\n      if (!target) {\\n        return;\\n      }\\n\\n      var pointer = this.getPointer(e),\\n          corner = target._findTargetCorner(this.getPointer(e, true)),\\n          action = this._getActionFromCorner(target, corner, e),\\n          origin = this._getOriginFromCorner(target, corner);\\n\\n      this._currentTransform = {\\n        target: target,\\n        action: action,\\n        corner: corner,\\n        scaleX: target.scaleX,\\n        scaleY: target.scaleY,\\n        skewX: target.skewX,\\n        skewY: target.skewY,\\n        offsetX: pointer.x - target.left,\\n        offsetY: pointer.y - target.top,\\n        originX: origin.x,\\n        originY: origin.y,\\n        ex: pointer.x,\\n        ey: pointer.y,\\n        lastX: pointer.x,\\n        lastY: pointer.y,\\n        left: target.left,\\n        top: target.top,\\n        theta: degreesToRadians(target.angle),\\n        width: target.width * target.scaleX,\\n        mouseXSign: 1,\\n        mouseYSign: 1,\\n        shiftKey: e.shiftKey,\\n        altKey: e[this.centeredKey]\\n      };\\n\\n      this._currentTransform.original = {\\n        left: target.left,\\n        top: target.top,\\n        scaleX: target.scaleX,\\n        scaleY: target.scaleY,\\n        skewX: target.skewX,\\n        skewY: target.skewY,\\n        originX: origin.x,\\n        originY: origin.y\\n      };\\n\\n      this._resetCurrentTransform();\\n    },\\n\\n    /**\\n     * Translates object by \\\"setting\\\" its left/top\\n     * @private\\n     * @param {Number} x pointer's x coordinate\\n     * @param {Number} y pointer's y coordinate\\n     * @return {Boolean} true if the translation occurred\\n     */\\n    _translateObject: function (x, y) {\\n      var transform = this._currentTransform,\\n          target = transform.target,\\n          newLeft = x - transform.offsetX,\\n          newTop = y - transform.offsetY,\\n          moveX = !target.get('lockMovementX') && target.left !== newLeft,\\n          moveY = !target.get('lockMovementY') && target.top !== newTop;\\n\\n      moveX && target.set('left', newLeft);\\n      moveY && target.set('top', newTop);\\n      return moveX || moveY;\\n    },\\n\\n    /**\\n     * Check if we are increasing a positive skew or lower it,\\n     * checking mouse direction and pressed corner.\\n     * @private\\n     */\\n    _changeSkewTransformOrigin: function(mouseMove, t, by) {\\n      var property = 'originX', origins = { 0: 'center' },\\n          skew = t.target.skewX, originA = 'left', originB = 'right',\\n          corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,\\n          flipSign = 1;\\n\\n      mouseMove = mouseMove > 0 ? 1 : -1;\\n      if (by === 'y') {\\n        skew = t.target.skewY;\\n        originA = 'top';\\n        originB = 'bottom';\\n        property = 'originY';\\n      }\\n      origins[-1] = originA;\\n      origins[1] = originB;\\n\\n      t.target.flipX && (flipSign *= -1);\\n      t.target.flipY && (flipSign *= -1);\\n\\n      if (skew === 0) {\\n        t.skewSign = -corner * mouseMove * flipSign;\\n        t[property] = origins[-mouseMove];\\n      }\\n      else {\\n        skew = skew > 0 ? 1 : -1;\\n        t.skewSign = skew;\\n        t[property] = origins[skew * corner * flipSign];\\n      }\\n    },\\n\\n    /**\\n     * Skew object by mouse events\\n     * @private\\n     * @param {Number} x pointer's x coordinate\\n     * @param {Number} y pointer's y coordinate\\n     * @param {String} by Either 'x' or 'y'\\n     * @return {Boolean} true if the skewing occurred\\n     */\\n    _skewObject: function (x, y, by) {\\n      var t = this._currentTransform,\\n          target = t.target, skewed = false,\\n          lockSkewingX = target.get('lockSkewingX'),\\n          lockSkewingY = target.get('lockSkewingY');\\n\\n      if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {\\n        return false;\\n      }\\n\\n      // Get the constraint point\\n      var center = target.getCenterPoint(),\\n          actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],\\n          lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],\\n          actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();\\n\\n      this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);\\n      actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];\\n      constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);\\n      // Actually skew the object\\n      skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);\\n      t.lastX = x;\\n      t.lastY = y;\\n      // Make sure the constraints apply\\n      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);\\n      return skewed;\\n    },\\n\\n    /**\\n     * Set object skew\\n     * @private\\n     * @return {Boolean} true if the skewing occurred\\n     */\\n    _setObjectSkew: function(localMouse, transform, by, _dim) {\\n      var target = transform.target, newValue, skewed = false,\\n          skewSign = transform.skewSign, newDim, dimNoSkew,\\n          otherBy, _otherBy, _by, newDimMouse, skewX, skewY;\\n\\n      if (by === 'x') {\\n        otherBy = 'y';\\n        _otherBy = 'Y';\\n        _by = 'X';\\n        skewX = 0;\\n        skewY = target.skewY;\\n      }\\n      else {\\n        otherBy = 'x';\\n        _otherBy = 'X';\\n        _by = 'Y';\\n        skewX = target.skewX;\\n        skewY = 0;\\n      }\\n\\n      dimNoSkew = target._getTransformedDimensions(skewX, skewY);\\n      newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];\\n      if (newDimMouse <= 2) {\\n        newValue = 0;\\n      }\\n      else {\\n        newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /\\n                                        (dimNoSkew[otherBy] / target['scale' + _otherBy]));\\n        newValue = fabric.util.radiansToDegrees(newValue);\\n      }\\n      skewed = target['skew' + _by] !== newValue;\\n      target.set('skew' + _by, newValue);\\n      if (target['skew' + _otherBy] !== 0) {\\n        newDim = target._getTransformedDimensions();\\n        newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];\\n        target.set('scale' + _otherBy, newValue);\\n      }\\n      return skewed;\\n    },\\n\\n    /**\\n     * Scales object by invoking its scaleX/scaleY methods\\n     * @private\\n     * @param {Number} x pointer's x coordinate\\n     * @param {Number} y pointer's y coordinate\\n     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.\\n     *                    When not provided, an object is scaled by both dimensions equally\\n     * @return {Boolean} true if the scaling occurred\\n     */\\n    _scaleObject: function (x, y, by) {\\n      var t = this._currentTransform,\\n          target = t.target,\\n          lockScalingX = target.get('lockScalingX'),\\n          lockScalingY = target.get('lockScalingY'),\\n          lockScalingFlip = target.get('lockScalingFlip');\\n\\n      if (lockScalingX && lockScalingY) {\\n        return false;\\n      }\\n\\n      // Get the constraint point\\n      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),\\n          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),\\n          dim = target._getTransformedDimensions(), scaled = false;\\n\\n      this._setLocalMouse(localMouse, t);\\n\\n      // Actually scale the object\\n      scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);\\n\\n      // Make sure the constraints apply\\n      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);\\n      return scaled;\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Boolean} true if the scaling occurred\\n     */\\n    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {\\n      var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,\\n          changeX, changeY, scaleX, scaleY;\\n\\n      scaleX = localMouse.x * target.scaleX / _dim.x;\\n      scaleY = localMouse.y * target.scaleY / _dim.y;\\n      changeX = target.scaleX !== scaleX;\\n      changeY = target.scaleY !== scaleY;\\n\\n      if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {\\n        forbidScalingX = true;\\n      }\\n\\n      if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {\\n        forbidScalingY = true;\\n      }\\n\\n      if (by === 'equally' && !lockScalingX && !lockScalingY) {\\n        forbidScalingX || forbidScalingY || (scaled = this._scaleObjectEqually(localMouse, target, transform, _dim));\\n      }\\n      else if (!by) {\\n        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));\\n        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));\\n      }\\n      else if (by === 'x' && !target.get('lockUniScaling')) {\\n        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));\\n      }\\n      else if (by === 'y' && !target.get('lockUniScaling')) {\\n        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));\\n      }\\n      transform.newScaleX = scaleX;\\n      transform.newScaleY = scaleY;\\n      forbidScalingX || forbidScalingY || this._flipObject(transform, by);\\n      return scaled;\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Boolean} true if the scaling occurred\\n     */\\n    _scaleObjectEqually: function(localMouse, target, transform, _dim) {\\n\\n      var dist = localMouse.y + localMouse.x,\\n          lastDist = _dim.y * transform.original.scaleY / target.scaleY +\\n                     _dim.x * transform.original.scaleX / target.scaleX,\\n          scaled;\\n\\n      // We use transform.scaleX/Y instead of target.scaleX/Y\\n      // because the object may have a min scale and we'll loose the proportions\\n      transform.newScaleX = transform.original.scaleX * dist / lastDist;\\n      transform.newScaleY = transform.original.scaleY * dist / lastDist;\\n      scaled = transform.newScaleX !== target.scaleX || transform.newScaleY !== target.scaleY;\\n      target.set('scaleX', transform.newScaleX);\\n      target.set('scaleY', transform.newScaleY);\\n      return scaled;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _flipObject: function(transform, by) {\\n      if (transform.newScaleX < 0 && by !== 'y') {\\n        if (transform.originX === 'left') {\\n          transform.originX = 'right';\\n        }\\n        else if (transform.originX === 'right') {\\n          transform.originX = 'left';\\n        }\\n      }\\n\\n      if (transform.newScaleY < 0 && by !== 'x') {\\n        if (transform.originY === 'top') {\\n          transform.originY = 'bottom';\\n        }\\n        else if (transform.originY === 'bottom') {\\n          transform.originY = 'top';\\n        }\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setLocalMouse: function(localMouse, t) {\\n      var target = t.target;\\n\\n      if (t.originX === 'right') {\\n        localMouse.x *= -1;\\n      }\\n      else if (t.originX === 'center') {\\n        localMouse.x *= t.mouseXSign * 2;\\n        if (localMouse.x < 0) {\\n          t.mouseXSign = -t.mouseXSign;\\n        }\\n      }\\n\\n      if (t.originY === 'bottom') {\\n        localMouse.y *= -1;\\n      }\\n      else if (t.originY === 'center') {\\n        localMouse.y *= t.mouseYSign * 2;\\n        if (localMouse.y < 0) {\\n          t.mouseYSign = -t.mouseYSign;\\n        }\\n      }\\n\\n      // adjust the mouse coordinates when dealing with padding\\n      if (abs(localMouse.x) > target.padding) {\\n        if (localMouse.x < 0) {\\n          localMouse.x += target.padding;\\n        }\\n        else {\\n          localMouse.x -= target.padding;\\n        }\\n      }\\n      else { // mouse is within the padding, set to 0\\n        localMouse.x = 0;\\n      }\\n\\n      if (abs(localMouse.y) > target.padding) {\\n        if (localMouse.y < 0) {\\n          localMouse.y += target.padding;\\n        }\\n        else {\\n          localMouse.y -= target.padding;\\n        }\\n      }\\n      else {\\n        localMouse.y = 0;\\n      }\\n    },\\n\\n    /**\\n     * Rotates object by invoking its rotate method\\n     * @private\\n     * @param {Number} x pointer's x coordinate\\n     * @param {Number} y pointer's y coordinate\\n     * @return {Boolean} true if the rotation occurred\\n     */\\n    _rotateObject: function (x, y) {\\n\\n      var t = this._currentTransform;\\n\\n      if (t.target.get('lockRotation')) {\\n        return false;\\n      }\\n\\n      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),\\n          curAngle = atan2(y - t.top, x - t.left),\\n          angle = radiansToDegrees(curAngle - lastAngle + t.theta),\\n          hasRoated = true;\\n\\n      // normalize angle to positive value\\n      if (angle < 0) {\\n        angle = 360 + angle;\\n      }\\n\\n      angle %= 360\\n\\n      if (t.target.snapAngle > 0) {\\n        var snapAngle  = t.target.snapAngle,\\n            snapThreshold  = t.target.snapThreshold || snapAngle,\\n            rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,\\n            leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;\\n\\n        if (Math.abs(angle - leftAngleLocked) < snapThreshold) {\\n          angle = leftAngleLocked;\\n        }\\n        else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {\\n          angle = rightAngleLocked;\\n        }\\n\\n        if (t.target.angle === angle) {\\n          hasRoated = false\\n        }\\n      }\\n\\n      t.target.angle = angle;\\n      return hasRoated;\\n    },\\n\\n    /**\\n     * Set the cursor type of the canvas element\\n     * @param {String} value Cursor type of the canvas element.\\n     * @see http://www.w3.org/TR/css3-ui/#cursor\\n     */\\n    setCursor: function (value) {\\n      this.upperCanvasEl.style.cursor = value;\\n    },\\n\\n    /**\\n     * @param {fabric.Object} target to reset transform\\n     * @private\\n     */\\n    _resetObjectTransform: function (target) {\\n      target.scaleX = 1;\\n      target.scaleY = 1;\\n      target.skewX = 0;\\n      target.skewY = 0;\\n      target.setAngle(0);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx to draw the selection on\\n     */\\n    _drawSelection: function (ctx) {\\n      var groupSelector = this._groupSelector,\\n          left = groupSelector.left,\\n          top = groupSelector.top,\\n          aleft = abs(left),\\n          atop = abs(top);\\n\\n      if (this.selectionColor) {\\n        ctx.fillStyle = this.selectionColor;\\n\\n        ctx.fillRect(\\n          groupSelector.ex - ((left > 0) ? 0 : -left),\\n          groupSelector.ey - ((top > 0) ? 0 : -top),\\n          aleft,\\n          atop\\n        );\\n      }\\n\\n      if (!this.selectionLineWidth || !this.selectionBorderColor) {\\n        return;\\n      }\\n      ctx.lineWidth = this.selectionLineWidth;\\n      ctx.strokeStyle = this.selectionBorderColor;\\n\\n      // selection border\\n      if (this.selectionDashArray.length > 1 && !supportLineDash) {\\n\\n        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),\\n            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);\\n\\n        ctx.beginPath();\\n\\n        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);\\n        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);\\n        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);\\n        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);\\n\\n        ctx.closePath();\\n        ctx.stroke();\\n      }\\n      else {\\n        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);\\n        ctx.strokeRect(\\n          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),\\n          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),\\n          aleft,\\n          atop\\n        );\\n      }\\n    },\\n\\n    /**\\n     * Method that determines what object we are clicking on\\n     * @param {Event} e mouse event\\n     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through\\n     */\\n    findTarget: function (e, skipGroup) {\\n      if (this.skipTargetFind) {\\n        return;\\n      }\\n\\n      var ignoreZoom = true,\\n          pointer = this.getPointer(e, ignoreZoom),\\n          activeGroup = this.getActiveGroup(),\\n          activeObject = this.getActiveObject(),\\n          activeTarget;\\n\\n      // first check current group (if one exists)\\n      // active group does not check sub targets like normal groups.\\n      // if active group just exits.\\n      if (activeGroup && !skipGroup && this._checkTarget(pointer, activeGroup)) {\\n        this._fireOverOutEvents(activeGroup, e);\\n        return activeGroup;\\n      }\\n      // if we hit the corner of an activeObject, let's return that.\\n      if (activeObject && activeObject._findTargetCorner(pointer)) {\\n        this._fireOverOutEvents(activeObject, e);\\n        return activeObject;\\n      }\\n      if (activeObject && this._checkTarget(pointer, activeObject)) {\\n        if (!this.preserveObjectStacking) {\\n          this._fireOverOutEvents(activeObject, e);\\n          return activeObject;\\n        }\\n        else {\\n          activeTarget = activeObject;\\n        }\\n      }\\n\\n      this.targets = [];\\n\\n      var target = this._searchPossibleTargets(this._objects, pointer);\\n      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {\\n        target = activeTarget;\\n      }\\n      this._fireOverOutEvents(target, e);\\n      return target;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _fireOverOutEvents: function(target, e) {\\n      if (target) {\\n        if (this._hoveredTarget !== target) {\\n          if (this._hoveredTarget) {\\n            this.fire('mouse:out', { target: this._hoveredTarget, e: e });\\n            this._hoveredTarget.fire('mouseout');\\n          }\\n          this.fire('mouse:over', { target: target, e: e });\\n          target.fire('mouseover');\\n          this._hoveredTarget = target;\\n        }\\n      }\\n      else if (this._hoveredTarget) {\\n        this.fire('mouse:out', { target: this._hoveredTarget, e: e });\\n        this._hoveredTarget.fire('mouseout');\\n        this._hoveredTarget = null;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _checkTarget: function(pointer, obj) {\\n      if (obj &&\\n          obj.visible &&\\n          obj.evented &&\\n          this.containsPoint(null, obj, pointer)){\\n        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\\n          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);\\n          if (!isTransparent) {\\n            return true;\\n          }\\n        }\\n        else {\\n          return true;\\n        }\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _searchPossibleTargets: function(objects, pointer) {\\n\\n      // Cache all targets where their bounding box contains point.\\n      var target, i = objects.length, normalizedPointer, subTarget;\\n      // Do not check for currently grouped objects, since we check the parent group itself.\\n      // untill we call this function specifically to search inside the activeGroup\\n      while (i--) {\\n        if (this._checkTarget(pointer, objects[i])) {\\n          target = objects[i];\\n          if (target.type === 'group' && target.subTargetCheck) {\\n            normalizedPointer = this._normalizePointer(target, pointer);\\n            subTarget = this._searchPossibleTargets(target._objects, normalizedPointer);\\n            subTarget && this.targets.push(subTarget);\\n          }\\n          break;\\n        }\\n      }\\n      return target;\\n    },\\n\\n    /**\\n     * Returns pointer coordinates without the effect of the viewport\\n     * @param {Object} pointer with \\\"x\\\" and \\\"y\\\" number values\\n     * @return {Object} object with \\\"x\\\" and \\\"y\\\" number values\\n     */\\n    restorePointerVpt: function(pointer) {\\n      return fabric.util.transformPoint(\\n        pointer,\\n        fabric.util.invertTransform(this.viewportTransform)\\n      );\\n    },\\n\\n    /**\\n     * Returns pointer coordinates relative to canvas.\\n     * @param {Event} e\\n     * @param {Boolean} ignoreZoom\\n     * @return {Object} object with \\\"x\\\" and \\\"y\\\" number values\\n     */\\n    getPointer: function (e, ignoreZoom, upperCanvasEl) {\\n      if (!upperCanvasEl) {\\n        upperCanvasEl = this.upperCanvasEl;\\n      }\\n      var pointer = getPointer(e),\\n          bounds = upperCanvasEl.getBoundingClientRect(),\\n          boundsWidth = bounds.width || 0,\\n          boundsHeight = bounds.height || 0,\\n          cssScale;\\n\\n      if (!boundsWidth || !boundsHeight ) {\\n        if ('top' in bounds && 'bottom' in bounds) {\\n          boundsHeight = Math.abs( bounds.top - bounds.bottom );\\n        }\\n        if ('right' in bounds && 'left' in bounds) {\\n          boundsWidth = Math.abs( bounds.right - bounds.left );\\n        }\\n      }\\n\\n      this.calcOffset();\\n\\n      pointer.x = pointer.x - this._offset.left;\\n      pointer.y = pointer.y - this._offset.top;\\n      if (!ignoreZoom) {\\n        pointer = this.restorePointerVpt(pointer);\\n      }\\n\\n      if (boundsWidth === 0 || boundsHeight === 0) {\\n        // If bounds are not available (i.e. not visible), do not apply scale.\\n        cssScale = { width: 1, height: 1 };\\n      }\\n      else {\\n        cssScale = {\\n          width: upperCanvasEl.width / boundsWidth,\\n          height: upperCanvasEl.height / boundsHeight\\n        };\\n      }\\n\\n      return {\\n        x: pointer.x * cssScale.width,\\n        y: pointer.y * cssScale.height\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\\n     */\\n    _createUpperCanvas: function () {\\n      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\\\s*lower-canvas\\\\s*/, '');\\n\\n      this.upperCanvasEl = this._createCanvasElement();\\n      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);\\n\\n      this.wrapperEl.appendChild(this.upperCanvasEl);\\n\\n      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);\\n      this._applyCanvasStyle(this.upperCanvasEl);\\n      this.contextTop = this.upperCanvasEl.getContext('2d');\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _createCacheCanvas: function () {\\n      this.cacheCanvasEl = this._createCanvasElement();\\n      this.cacheCanvasEl.setAttribute('width', this.width);\\n      this.cacheCanvasEl.setAttribute('height', this.height);\\n      this.contextCache = this.cacheCanvasEl.getContext('2d');\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _initWrapperElement: function () {\\n      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {\\n        'class': this.containerClass\\n      });\\n      fabric.util.setStyle(this.wrapperEl, {\\n        width: this.getWidth() + 'px',\\n        height: this.getHeight() + 'px',\\n        position: 'relative'\\n      });\\n      fabric.util.makeElementUnselectable(this.wrapperEl);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {HTMLElement} element canvas element to apply styles on\\n     */\\n    _applyCanvasStyle: function (element) {\\n      var width = this.getWidth() || element.width,\\n          height = this.getHeight() || element.height;\\n\\n      fabric.util.setStyle(element, {\\n        position: 'absolute',\\n        width: width + 'px',\\n        height: height + 'px',\\n        left: 0,\\n        top: 0\\n      });\\n      element.width = width;\\n      element.height = height;\\n      fabric.util.makeElementUnselectable(element);\\n    },\\n\\n    /**\\n     * Copys the the entire inline style from one element (fromEl) to another (toEl)\\n     * @private\\n     * @param {Element} fromEl Element style is copied from\\n     * @param {Element} toEl Element copied style is applied to\\n     */\\n    _copyCanvasStyle: function (fromEl, toEl) {\\n      toEl.style.cssText = fromEl.style.cssText;\\n    },\\n\\n    /**\\n     * Returns context of canvas where object selection is drawn\\n     * @return {CanvasRenderingContext2D}\\n     */\\n    getSelectionContext: function() {\\n      return this.contextTop;\\n    },\\n\\n    /**\\n     * Returns &lt;canvas> element on which object selection is drawn\\n     * @return {HTMLCanvasElement}\\n     */\\n    getSelectionElement: function () {\\n      return this.upperCanvasEl;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} object\\n     */\\n    _setActiveObject: function(object) {\\n      if (this._activeObject) {\\n        this._activeObject.set('active', false);\\n      }\\n      this._activeObject = object;\\n      object.set('active', true);\\n    },\\n\\n    /**\\n     * Sets given object as the only active object on canvas\\n     * @param {fabric.Object} object Object to set as an active one\\n     * @param {Event} [e] Event (passed along when firing \\\"object:selected\\\")\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    setActiveObject: function (object, e) {\\n      this._setActiveObject(object);\\n      this.renderAll();\\n      this.fire('object:selected', { target: object, e: e });\\n      object.fire('selected', { e: e });\\n      return this;\\n    },\\n\\n    /**\\n     * Returns currently active object\\n     * @return {fabric.Object} active object\\n     */\\n    getActiveObject: function () {\\n      return this._activeObject;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {fabric.Object} obj Object that was removed\\n     */\\n    _onObjectRemoved: function(obj) {\\n      // removing active object should fire \\\"selection:cleared\\\" events\\n      if (this.getActiveObject() === obj) {\\n        this.fire('before:selection:cleared', { target: obj });\\n        this._discardActiveObject();\\n        this.fire('selection:cleared', { target: obj });\\n        obj.fire('deselected');\\n      }\\n      this.callSuper('_onObjectRemoved', obj);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _discardActiveObject: function() {\\n      if (this._activeObject) {\\n        this._activeObject.set('active', false);\\n      }\\n      this._activeObject = null;\\n    },\\n\\n    /**\\n     * Discards currently active object and fire events\\n     * @param {event} e\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    discardActiveObject: function (e) {\\n      var activeObject = this._activeObject;\\n      this.fire('before:selection:cleared', { target: activeObject, e: e });\\n      this._discardActiveObject();\\n      this.fire('selection:cleared', { e: e });\\n      activeObject && activeObject.fire('deselected', { e: e });\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {fabric.Group} group\\n     */\\n    _setActiveGroup: function(group) {\\n      this._activeGroup = group;\\n      if (group) {\\n        group.set('active', true);\\n      }\\n    },\\n\\n    /**\\n     * Sets active group to a specified one\\n     * @param {fabric.Group} group Group to set as a current one\\n     * @param {Event} e Event object\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    setActiveGroup: function (group, e) {\\n      this._setActiveGroup(group);\\n      if (group) {\\n        this.fire('object:selected', { target: group, e: e });\\n        group.fire('selected', { e: e });\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Returns currently active group\\n     * @return {fabric.Group} Current group\\n     */\\n    getActiveGroup: function () {\\n      return this._activeGroup;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _discardActiveGroup: function() {\\n      var g = this.getActiveGroup();\\n      if (g) {\\n        g.destroy();\\n      }\\n      this.setActiveGroup(null);\\n    },\\n\\n    /**\\n     * Discards currently active group and fire events\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    discardActiveGroup: function (e) {\\n      var g = this.getActiveGroup();\\n      this.fire('before:selection:cleared', { e: e, target: g });\\n      this._discardActiveGroup();\\n      this.fire('selection:cleared', { e: e });\\n      return this;\\n    },\\n\\n    /**\\n     * Deactivates all objects on canvas, removing any active group or object\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    deactivateAll: function () {\\n      var allObjects = this.getObjects(),\\n          i = 0,\\n          len = allObjects.length,\\n          obj;\\n      for ( ; i < len; i++) {\\n        obj = allObjects[i];\\n        obj && obj.set('active', false);\\n      }\\n      this._discardActiveGroup();\\n      this._discardActiveObject();\\n      return this;\\n    },\\n\\n    /**\\n     * Deactivates all objects and dispatches appropriate events\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    deactivateAllWithDispatch: function (e) {\\n      var activeGroup = this.getActiveGroup(),\\n          activeObject = this.getActiveObject();\\n      if (activeObject || activeGroup) {\\n        this.fire('before:selection:cleared', { target: activeObject || activeGroup, e: e });\\n      }\\n      this.deactivateAll();\\n      if (activeObject || activeGroup) {\\n        this.fire('selection:cleared', { e: e, target: activeObject });\\n        activeObject && activeObject.fire('deselected');\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Clears a canvas element and removes all event listeners\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    dispose: function () {\\n      this.callSuper('dispose');\\n      var wrapper = this.wrapperEl;\\n      this.removeListeners();\\n      wrapper.removeChild(this.upperCanvasEl);\\n      wrapper.removeChild(this.lowerCanvasEl);\\n      delete this.upperCanvasEl;\\n      if (wrapper.parentNode) {\\n        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);\\n      }\\n      delete this.wrapperEl;\\n      return this;\\n    },\\n\\n    /**\\n     * Clears all contexts (background, main, top) of an instance\\n     * @return {fabric.Canvas} thisArg\\n     * @chainable\\n     */\\n    clear: function () {\\n      this.discardActiveGroup();\\n      this.discardActiveObject();\\n      this.clearContext(this.contextTop);\\n      return this.callSuper('clear');\\n    },\\n\\n    /**\\n     * Draws objects' controls (borders/controls)\\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\\n     */\\n    drawControls: function(ctx) {\\n      var activeGroup = this.getActiveGroup();\\n\\n      if (activeGroup) {\\n        activeGroup._renderControls(ctx);\\n      }\\n      else {\\n        this._drawObjectsControls(ctx);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _drawObjectsControls: function(ctx) {\\n      for (var i = 0, len = this._objects.length; i < len; ++i) {\\n        if (!this._objects[i] || !this._objects[i].active) {\\n          continue;\\n        }\\n        this._objects[i]._renderControls(ctx);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _toObject: function(instance, methodName, propertiesToInclude) {\\n      //If the object is part of the current selection group, it should\\n      //be transformed appropriately\\n      //i.e. it should be serialised as it would appear if the selection group\\n      //were to be destroyed.\\n      var originalProperties = this._realizeGroupTransformOnObject(instance),\\n          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);\\n      //Undo the damage we did by changing all of its properties\\n      this._unwindGroupTransformOnObject(instance, originalProperties);\\n      return object;\\n    },\\n\\n    /**\\n     * Realises an object's group transformation on it\\n     * @private\\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\\n     * @returns the original values of instance which were changed\\n     */\\n    _realizeGroupTransformOnObject: function(instance) {\\n      var layoutProps = ['angle', 'flipX', 'flipY', 'height', 'left', 'scaleX', 'scaleY', 'top', 'width'];\\n      if (instance.group && instance.group === this.getActiveGroup()) {\\n        //Copy all the positionally relevant properties across now\\n        var originalValues = {};\\n        layoutProps.forEach(function(prop) {\\n          originalValues[prop] = instance[prop];\\n        });\\n        this.getActiveGroup().realizeTransform(instance);\\n        return originalValues;\\n      }\\n      else {\\n        return null;\\n      }\\n    },\\n\\n    /**\\n     * Restores the changed properties of instance\\n     * @private\\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\\n     */\\n    _unwindGroupTransformOnObject: function(instance, originalValues) {\\n      if (originalValues) {\\n        instance.set(originalValues);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGObject: function(markup, instance, reviver) {\\n      var originalProperties;\\n      //If the object is in a selection group, simulate what would happen to that\\n      //object when the group is deselected\\n      originalProperties = this._realizeGroupTransformOnObject(instance);\\n      this.callSuper('_setSVGObject', markup, instance, reviver);\\n      this._unwindGroupTransformOnObject(instance, originalProperties);\\n    },\\n  });\\n\\n  // copying static properties manually to work around Opera's bug,\\n  // where \\\"prototype\\\" property is enumerable and overrides existing prototype\\n  for (var prop in fabric.StaticCanvas) {\\n    if (prop !== 'prototype') {\\n      fabric.Canvas[prop] = fabric.StaticCanvas[prop];\\n    }\\n  }\\n\\n  if (fabric.isTouchSupported) {\\n    /** @ignore */\\n    fabric.Canvas.prototype._setCursorFromEvent = function() { };\\n  }\\n\\n  /**\\n   * @ignore\\n   * @class fabric.Element\\n   * @alias fabric.Canvas\\n   * @deprecated Use {@link fabric.Canvas} instead.\\n   * @constructor\\n   */\\n  fabric.Element = fabric.Canvas;\\n})();\\n\\n\\n(function() {\\n\\n  var cursorOffset = {\\n        mt: 0, // n\\n        tr: 1, // ne\\n        mr: 2, // e\\n        br: 3, // se\\n        mb: 4, // s\\n        bl: 5, // sw\\n        ml: 6, // w\\n        tl: 7 // nw\\n      },\\n      addListener = fabric.util.addListener,\\n      removeListener = fabric.util.removeListener;\\n\\n  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\\n\\n    /**\\n     * Map of cursor style values for each of the object controls\\n     * @private\\n     */\\n    cursorMap: [\\n      'n-resize',\\n      'ne-resize',\\n      'e-resize',\\n      'se-resize',\\n      's-resize',\\n      'sw-resize',\\n      'w-resize',\\n      'nw-resize'\\n    ],\\n\\n    /**\\n     * Adds mouse listeners to canvas\\n     * @private\\n     */\\n    _initEventListeners: function () {\\n\\n      this._bindEvents();\\n\\n      addListener(fabric.window, 'resize', this._onResize);\\n\\n      // mouse events\\n      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\\n      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\\n      addListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);\\n      addListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);\\n      addListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);\\n      addListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);\\n\\n      // touch events\\n      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);\\n      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\\n\\n      if (typeof eventjs !== 'undefined' && 'add' in eventjs) {\\n        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);\\n        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);\\n        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);\\n        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);\\n        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _bindEvents: function() {\\n      this._onMouseDown = this._onMouseDown.bind(this);\\n      this._onMouseMove = this._onMouseMove.bind(this);\\n      this._onMouseUp = this._onMouseUp.bind(this);\\n      this._onResize = this._onResize.bind(this);\\n      this._onGesture = this._onGesture.bind(this);\\n      this._onDrag = this._onDrag.bind(this);\\n      this._onShake = this._onShake.bind(this);\\n      this._onLongPress = this._onLongPress.bind(this);\\n      this._onOrientationChange = this._onOrientationChange.bind(this);\\n      this._onMouseWheel = this._onMouseWheel.bind(this);\\n      this._onMouseOut = this._onMouseOut.bind(this);\\n      this._onMouseEnter = this._onMouseEnter.bind(this);\\n      this._onContextMenu = this._onContextMenu.bind(this);\\n    },\\n\\n    /**\\n     * Removes all event listeners\\n     */\\n    removeListeners: function() {\\n      removeListener(fabric.window, 'resize', this._onResize);\\n\\n      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\\n      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\\n      removeListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);\\n      removeListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);\\n      removeListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);\\n      removeListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);\\n\\n      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);\\n      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\\n\\n      if (typeof eventjs !== 'undefined' && 'remove' in eventjs) {\\n        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);\\n        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);\\n        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);\\n        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);\\n        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} [e] Event object fired on Event.js gesture\\n     * @param {Event} [self] Inner Event object\\n     */\\n    _onGesture: function(e, self) {\\n      this.__onTransformGesture && this.__onTransformGesture(e, self);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} [e] Event object fired on Event.js drag\\n     * @param {Event} [self] Inner Event object\\n     */\\n    _onDrag: function(e, self) {\\n      this.__onDrag && this.__onDrag(e, self);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} [e] Event object fired on wheel event\\n     */\\n    _onMouseWheel: function(e) {\\n      this.__onMouseWheel(e);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mousedown\\n     */\\n    _onMouseOut: function(e) {\\n      var target = this._hoveredTarget;\\n      this.fire('mouse:out', { target: target, e: e });\\n      this._hoveredTarget = null;\\n      target && target.fire('mouseout', { e: e });\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mouseenter\\n     */\\n    _onMouseEnter: function(e) {\\n      if (!this.findTarget(e)) {\\n        this.fire('mouse:over', { target: null, e: e });\\n        this._hoveredTarget = null;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} [e] Event object fired on Event.js orientation change\\n     * @param {Event} [self] Inner Event object\\n     */\\n    _onOrientationChange: function(e, self) {\\n      this.__onOrientationChange && this.__onOrientationChange(e, self);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} [e] Event object fired on Event.js shake\\n     * @param {Event} [self] Inner Event object\\n     */\\n    _onShake: function(e, self) {\\n      this.__onShake && this.__onShake(e, self);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} [e] Event object fired on Event.js shake\\n     * @param {Event} [self] Inner Event object\\n     */\\n    _onLongPress: function(e, self) {\\n      this.__onLongPress && this.__onLongPress(e, self);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mousedown\\n     */\\n    _onContextMenu: function (e) {\\n      if (this.stopContextMenu) {\\n        e.stopPropagation()\\n        e.preventDefault();\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mousedown\\n     */\\n    _onMouseDown: function (e) {\\n      this.__onMouseDown(e);\\n\\n      addListener(fabric.document, 'touchend', this._onMouseUp);\\n      addListener(fabric.document, 'touchmove', this._onMouseMove);\\n\\n      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\\n      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\\n\\n      if (e.type === 'touchstart') {\\n        // Unbind mousedown to prevent double triggers from touch devices\\n        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\\n      }\\n      else {\\n        addListener(fabric.document, 'mouseup', this._onMouseUp);\\n        addListener(fabric.document, 'mousemove', this._onMouseMove);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mouseup\\n     */\\n    _onMouseUp: function (e) {\\n      this.__onMouseUp(e);\\n\\n      removeListener(fabric.document, 'mouseup', this._onMouseUp);\\n      removeListener(fabric.document, 'touchend', this._onMouseUp);\\n\\n      removeListener(fabric.document, 'mousemove', this._onMouseMove);\\n      removeListener(fabric.document, 'touchmove', this._onMouseMove);\\n\\n      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\\n      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\\n\\n      if (e.type === 'touchend') {\\n        // Wait 400ms before rebinding mousedown to prevent double triggers\\n        // from touch devices\\n        var _this = this;\\n        setTimeout(function() {\\n          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);\\n        }, 400);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mousemove\\n     */\\n    _onMouseMove: function (e) {\\n      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\\n      this.__onMouseMove(e);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _onResize: function () {\\n      this.calcOffset();\\n    },\\n\\n    /**\\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\\n     * @private\\n     * @param {Object} target\\n     * @param {Object} pointer\\n     */\\n    _shouldRender: function(target, pointer) {\\n      var activeObject = this.getActiveGroup() || this.getActiveObject();\\n\\n      return !!(\\n        (target && (\\n          target.isMoving ||\\n          target !== activeObject))\\n        ||\\n        (!target && !!activeObject)\\n        ||\\n        (!target && !activeObject && !this._groupSelector)\\n        ||\\n        (pointer &&\\n          this._previousPointer &&\\n          this.selection && (\\n          pointer.x !== this._previousPointer.x ||\\n          pointer.y !== this._previousPointer.y))\\n      );\\n    },\\n\\n    /**\\n     * Method that defines the actions when mouse is released on canvas.\\n     * The method resets the currentTransform parameters, store the image corner\\n     * position in the image object and render the canvas on top.\\n     * @private\\n     * @param {Event} e Event object fired on mouseup\\n     */\\n    __onMouseUp: function (e) {\\n      var target, searchTarget = true, transform = this._currentTransform,\\n          groupSelector = this._groupSelector,\\n          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));\\n\\n      if (this.isDrawingMode && this._isCurrentlyDrawing) {\\n        this._onMouseUpInDrawingMode(e);\\n        return;\\n      }\\n\\n      if (transform) {\\n        this._finalizeCurrentTransform();\\n        searchTarget = !transform.actionPerformed;\\n      }\\n\\n      target = searchTarget ? this.findTarget(e, true) : transform.target;\\n\\n      var shouldRender = this._shouldRender(target, this.getPointer(e));\\n\\n      if (target || !isClick) {\\n        this._maybeGroupObjects(e);\\n      }\\n      else {\\n        // those are done by default on mouse up\\n        // by _maybeGroupObjects, we are skipping it in case of no target find\\n        this._groupSelector = null;\\n        this._currentTransform = null;\\n      }\\n\\n      if (target) {\\n        target.isMoving = false;\\n      }\\n\\n      this._handleCursorAndEvent(e, target, 'up');\\n      target && (target.__corner = 0);\\n      shouldRender && this.renderAll();\\n    },\\n\\n    /**\\n     * set cursor for mouse up and handle mouseUp event\\n     * @param {Event} e event from mouse\\n     * @param {fabric.Object} target receiving event\\n     * @param {String} eventType event to fire (up, down or move)\\n     */\\n    _handleCursorAndEvent: function(e, target, eventType) {\\n      this._setCursorFromEvent(e, target);\\n      this._handleEvent(e, eventType, target ? target : null);\\n    },\\n\\n    /**\\n     * Handle event firing for target and subtargets\\n     * @param {Event} e event from mouse\\n     * @param {String} eventType event to fire (up, down or move)\\n     * @param {fabric.Object} targetObj receiving event\\n     */\\n    _handleEvent: function(e, eventType, targetObj) {\\n      var target = typeof targetObj === undefined ? this.findTarget(e) : targetObj,\\n          targets = this.targets || [],\\n          options = { e: e, target: target, subTargets: targets };\\n\\n      this.fire('mouse:' + eventType, options);\\n      target && target.fire('mouse' + eventType, options);\\n      for (var i = 0; i < targets.length; i++) {\\n        targets[i].fire('mouse' + eventType, options);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _finalizeCurrentTransform: function() {\\n\\n      var transform = this._currentTransform,\\n          target = transform.target;\\n\\n      if (target._scaling) {\\n        target._scaling = false;\\n      }\\n\\n      target.setCoords();\\n      this._restoreOriginXY(target);\\n\\n      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {\\n        this.fire('object:modified', { target: target });\\n        target.fire('modified');\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} target Object to restore\\n     */\\n    _restoreOriginXY: function(target) {\\n      if (this._previousOriginX && this._previousOriginY) {\\n\\n        var originPoint = target.translateToOriginPoint(\\n          target.getCenterPoint(),\\n          this._previousOriginX,\\n          this._previousOriginY);\\n\\n        target.originX = this._previousOriginX;\\n        target.originY = this._previousOriginY;\\n\\n        target.left = originPoint.x;\\n        target.top = originPoint.y;\\n\\n        this._previousOriginX = null;\\n        this._previousOriginY = null;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mousedown\\n     */\\n    _onMouseDownInDrawingMode: function(e) {\\n      this._isCurrentlyDrawing = true;\\n      this.discardActiveObject(e).renderAll();\\n      if (this.clipTo) {\\n        fabric.util.clipContext(this, this.contextTop);\\n      }\\n      var pointer = this.getPointer(e);\\n      this.freeDrawingBrush.onMouseDown(pointer);\\n      this._handleEvent(e, 'down');\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mousemove\\n     */\\n    _onMouseMoveInDrawingMode: function(e) {\\n      if (this._isCurrentlyDrawing) {\\n        var pointer = this.getPointer(e);\\n        this.freeDrawingBrush.onMouseMove(pointer);\\n      }\\n      this.setCursor(this.freeDrawingCursor);\\n      this._handleEvent(e, 'move');\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object fired on mouseup\\n     */\\n    _onMouseUpInDrawingMode: function(e) {\\n      this._isCurrentlyDrawing = false;\\n      if (this.clipTo) {\\n        this.contextTop.restore();\\n      }\\n      this.freeDrawingBrush.onMouseUp();\\n      this._handleEvent(e, 'up');\\n    },\\n\\n    /**\\n     * Method that defines the actions when mouse is clic ked on canvas.\\n     * The method inits the currentTransform parameters and renders all the\\n     * canvas so the current image can be placed on the top canvas and the rest\\n     * in on the container one.\\n     * @private\\n     * @param {Event} e Event object fired on mousedown\\n     */\\n    __onMouseDown: function (e) {\\n\\n      var target = this.findTarget(e),\\n          pointer = this.getPointer(e, true);\\n\\n      // if right click just fire events\\n      var isRightClick  = 'which' in e ? e.which === 3 : e.button === 2;\\n      if (isRightClick) {\\n        if (this.fireRightClick) {\\n          this._handleEvent(e, 'down', target ? target : null);\\n        }\\n        return;\\n      }\\n\\n      if (this.isDrawingMode) {\\n        this._onMouseDownInDrawingMode(e);\\n        return;\\n      }\\n\\n      // ignore if some object is being transformed at this moment\\n      if (this._currentTransform) {\\n        return;\\n      }\\n\\n      // save pointer for check in __onMouseUp event\\n      this._previousPointer = pointer;\\n\\n      var shouldRender = this._shouldRender(target, pointer),\\n          shouldGroup = this._shouldGroup(e, target);\\n\\n      if (this._shouldClearSelection(e, target)) {\\n        this._clearSelection(e, target, pointer);\\n      }\\n      else if (shouldGroup) {\\n        this._handleGrouping(e, target);\\n        target = this.getActiveGroup();\\n      }\\n\\n      if (target) {\\n        if (target.selectable && (target.__corner || !shouldGroup)) {\\n          this._beforeTransform(e, target);\\n          this._setupCurrentTransform(e, target);\\n        }\\n\\n        if (target !== this.getActiveGroup() && target !== this.getActiveObject()) {\\n          this.deactivateAll();\\n          target.selectable && this.setActiveObject(target, e);\\n        }\\n      }\\n      this._handleEvent(e, 'down', target ? target : null);\\n      // we must renderAll so that we update the visuals\\n      shouldRender && this.renderAll();\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _beforeTransform: function(e, target) {\\n      this.stateful && target.saveState();\\n\\n      // determine if it's a drag or rotate case\\n      if (target._findTargetCorner(this.getPointer(e))) {\\n        this.onBeforeScaleRotate(target);\\n      }\\n\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _clearSelection: function(e, target, pointer) {\\n      this.deactivateAllWithDispatch(e);\\n\\n      if (target && target.selectable) {\\n        this.setActiveObject(target, e);\\n      }\\n      else if (this.selection) {\\n        this._groupSelector = {\\n          ex: pointer.x,\\n          ey: pointer.y,\\n          top: 0,\\n          left: 0\\n        };\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} target Object for that origin is set to center\\n     */\\n    _setOriginToCenter: function(target) {\\n      this._previousOriginX = this._currentTransform.target.originX;\\n      this._previousOriginY = this._currentTransform.target.originY;\\n\\n      var center = target.getCenterPoint();\\n\\n      target.originX = 'center';\\n      target.originY = 'center';\\n\\n      target.left = center.x;\\n      target.top = center.y;\\n\\n      this._currentTransform.left = target.left;\\n      this._currentTransform.top = target.top;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} target Object for that center is set to origin\\n     */\\n    _setCenterToOrigin: function(target) {\\n      var originPoint = target.translateToOriginPoint(\\n        target.getCenterPoint(),\\n        this._previousOriginX,\\n        this._previousOriginY);\\n\\n      target.originX = this._previousOriginX;\\n      target.originY = this._previousOriginY;\\n\\n      target.left = originPoint.x;\\n      target.top = originPoint.y;\\n\\n      this._previousOriginX = null;\\n      this._previousOriginY = null;\\n    },\\n\\n    /**\\n     * Method that defines the actions when mouse is hovering the canvas.\\n     * The currentTransform parameter will definde whether the user is rotating/scaling/translating\\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\\n     * all any other type of action.\\n     * In case of an image transformation only the top canvas will be rendered.\\n     * @private\\n     * @param {Event} e Event object fired on mousemove\\n     */\\n    __onMouseMove: function (e) {\\n\\n      var target, pointer;\\n\\n      if (this.isDrawingMode) {\\n        this._onMouseMoveInDrawingMode(e);\\n        return;\\n      }\\n      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {\\n        return;\\n      }\\n\\n      var groupSelector = this._groupSelector;\\n\\n      // We initially clicked in an empty area, so we draw a box for multiple selection\\n      if (groupSelector) {\\n        pointer = this.getPointer(e, true);\\n\\n        groupSelector.left = pointer.x - groupSelector.ex;\\n        groupSelector.top = pointer.y - groupSelector.ey;\\n\\n        this.renderTop();\\n      }\\n      else if (!this._currentTransform) {\\n        target = this.findTarget(e);\\n        this._setCursorFromEvent(e, target);\\n      }\\n      else {\\n        this._transformObject(e);\\n      }\\n      this._handleEvent(e, 'move', target ? target : null);\\n    },\\n\\n    /**\\n     * Method that defines actions when an Event Mouse Wheel\\n     * @param {Event} e Event object fired on mouseup\\n     */\\n    __onMouseWheel: function(e) {\\n      this.fire('mouse:wheel', {\\n        e: e\\n      });\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event fired on mousemove\\n     */\\n    _transformObject: function(e) {\\n      var pointer = this.getPointer(e),\\n          transform = this._currentTransform;\\n\\n      transform.reset = false;\\n      transform.target.isMoving = true;\\n\\n      this._beforeScaleTransform(e, transform);\\n      this._performTransformAction(e, transform, pointer);\\n\\n      transform.actionPerformed && this.renderAll();\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _performTransformAction: function(e, transform, pointer) {\\n      var x = pointer.x,\\n          y = pointer.y,\\n          target = transform.target,\\n          action = transform.action,\\n          actionPerformed = false;\\n\\n      if (action === 'rotate') {\\n        (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', target, e);\\n      }\\n      else if (action === 'scale') {\\n        (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', target, e);\\n      }\\n      else if (action === 'scaleX') {\\n        (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', target, e);\\n      }\\n      else if (action === 'scaleY') {\\n        (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', target, e);\\n      }\\n      else if (action === 'skewX') {\\n        (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', target, e);\\n      }\\n      else if (action === 'skewY') {\\n        (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', target, e);\\n      }\\n      else {\\n        actionPerformed = this._translateObject(x, y);\\n        if (actionPerformed) {\\n          this._fire('moving', target, e);\\n          this.setCursor(target.moveCursor || this.moveCursor);\\n        }\\n      }\\n      transform.actionPerformed = actionPerformed;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _fire: function(eventName, target, e) {\\n      this.fire('object:' + eventName, { target: target, e: e });\\n      target.fire(eventName, { e: e });\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _beforeScaleTransform: function(e, transform) {\\n      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {\\n        var centerTransform = this._shouldCenterTransform(transform.target);\\n\\n        // Switch from a normal resize to center-based\\n        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||\\n           // Switch from center-based resize to normal one\\n           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')\\n        ) {\\n          this._resetCurrentTransform();\\n          transform.reset = true;\\n        }\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object\\n     * @param {Object} transform current tranform\\n     * @param {Number} x mouse position x from origin\\n     * @param {Number} y mouse poistion y from origin\\n     * @return {Boolean} true if the scaling occurred\\n     */\\n    _onScale: function(e, transform, x, y) {\\n      if ((e[this.uniScaleKey] || this.uniScaleTransform) && !transform.target.get('lockUniScaling')) {\\n        transform.currentAction = 'scale';\\n        return this._scaleObject(x, y);\\n      }\\n      else {\\n        // Switch from a normal resize to proportional\\n        if (!transform.reset && transform.currentAction === 'scale') {\\n          this._resetCurrentTransform();\\n        }\\n\\n        transform.currentAction = 'scaleEqually';\\n        return this._scaleObject(x, y, 'equally');\\n      }\\n    },\\n\\n    /**\\n     * Sets the cursor depending on where the canvas is being hovered.\\n     * Note: very buggy in Opera\\n     * @param {Event} e Event object\\n     * @param {Object} target Object that the mouse is hovering, if so.\\n     */\\n    _setCursorFromEvent: function (e, target) {\\n      if (!target) {\\n        this.setCursor(this.defaultCursor);\\n        return false;\\n      }\\n\\n      var hoverCursor = target.hoverCursor || this.hoverCursor;\\n      if (!target.selectable) {\\n        //let's skip _findTargetCorner if object is not selectable\\n        this.setCursor(hoverCursor);\\n      }\\n      else {\\n        var activeGroup = this.getActiveGroup(),\\n            // only show proper corner when group selection is not active\\n            corner = target._findTargetCorner\\n                      && (!activeGroup || !activeGroup.contains(target))\\n                      && target._findTargetCorner(this.getPointer(e, true));\\n\\n        if (!corner) {\\n          this.setCursor(hoverCursor);\\n        }\\n        else {\\n          this._setCornerCursor(corner, target, e);\\n        }\\n      }\\n      //actually unclear why it should return something\\n      //is never evaluated\\n      return true;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setCornerCursor: function(corner, target, e) {\\n      if (corner in cursorOffset) {\\n        this.setCursor(this._getRotatedCornerCursor(corner, target, e));\\n      }\\n      else if (corner === 'mtr' && target.hasRotatingPoint) {\\n        this.setCursor(this.rotationCursor);\\n      }\\n      else {\\n        this.setCursor(this.defaultCursor);\\n        return false;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getRotatedCornerCursor: function(corner, target, e) {\\n      var n = Math.round((target.getAngle() % 360) / 45);\\n\\n      if (n < 0) {\\n        n += 8; // full circle ahead\\n      }\\n      n += cursorOffset[corner];\\n      if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {\\n        //if we are holding shift and we are on a mx corner...\\n        n += 2;\\n      }\\n      // normalize n to be from 0 to 7\\n      n %= 8;\\n\\n      return this.cursorMap[n];\\n    }\\n  });\\n})();\\n\\n\\n(function() {\\n\\n  var min = Math.min,\\n      max = Math.max;\\n\\n  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object\\n     * @param {fabric.Object} target\\n     * @return {Boolean}\\n     */\\n    _shouldGroup: function(e, target) {\\n      var activeObject = this.getActiveObject();\\n      return e[this.selectionKey] && target && target.selectable &&\\n            (this.getActiveGroup() || (activeObject && activeObject !== target))\\n            && this.selection;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e Event object\\n     * @param {fabric.Object} target\\n     */\\n    _handleGrouping: function (e, target) {\\n      var activeGroup = this.getActiveGroup();\\n\\n      if (target === activeGroup) {\\n        // if it's a group, find target again, using activeGroup objects\\n        target = this.findTarget(e, true);\\n        // if even object is not found, bail out\\n        if (!target) {\\n          return;\\n        }\\n      }\\n      if (activeGroup) {\\n        this._updateActiveGroup(target, e);\\n      }\\n      else {\\n        this._createActiveGroup(target, e);\\n      }\\n\\n      if (this._activeGroup) {\\n        this._activeGroup.saveCoords();\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _updateActiveGroup: function(target, e) {\\n      var activeGroup = this.getActiveGroup();\\n\\n      if (activeGroup.contains(target)) {\\n\\n        activeGroup.removeWithUpdate(target);\\n        target.set('active', false);\\n\\n        if (activeGroup.size() === 1) {\\n          // remove group alltogether if after removal it only contains 1 object\\n          this.discardActiveGroup(e);\\n          // activate last remaining object\\n          this.setActiveObject(activeGroup.item(0));\\n          return;\\n        }\\n      }\\n      else {\\n        activeGroup.addWithUpdate(target);\\n      }\\n      this.fire('selection:created', { target: activeGroup, e: e });\\n      activeGroup.set('active', true);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _createActiveGroup: function(target, e) {\\n\\n      if (this._activeObject && target !== this._activeObject) {\\n\\n        var group = this._createGroup(target);\\n        group.addWithUpdate();\\n\\n        this.setActiveGroup(group);\\n        this._activeObject = null;\\n\\n        this.fire('selection:created', { target: group, e: e });\\n      }\\n\\n      target.set('active', true);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} target\\n     */\\n    _createGroup: function(target) {\\n\\n      var objects = this.getObjects(),\\n          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),\\n          groupObjects = isActiveLower\\n            ? [this._activeObject, target]\\n            : [target, this._activeObject];\\n      this._activeObject.isEditing && this._activeObject.exitEditing();\\n      return new fabric.Group(groupObjects, {\\n        canvas: this\\n      });\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Event} e mouse event\\n     */\\n    _groupSelectedObjects: function (e) {\\n\\n      var group = this._collectObjects();\\n\\n      // do not create group for 1 element only\\n      if (group.length === 1) {\\n        this.setActiveObject(group[0], e);\\n      }\\n      else if (group.length > 1) {\\n        group = new fabric.Group(group.reverse(), {\\n          canvas: this\\n        });\\n        group.addWithUpdate();\\n        this.setActiveGroup(group, e);\\n        group.saveCoords();\\n        this.fire('selection:created', { target: group });\\n        this.renderAll();\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _collectObjects: function() {\\n      var group = [],\\n          currentObject,\\n          x1 = this._groupSelector.ex,\\n          y1 = this._groupSelector.ey,\\n          x2 = x1 + this._groupSelector.left,\\n          y2 = y1 + this._groupSelector.top,\\n          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),\\n          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),\\n          isClick = x1 === x2 && y1 === y2;\\n\\n      for (var i = this._objects.length; i--; ) {\\n        currentObject = this._objects[i];\\n\\n        if (!currentObject || !currentObject.selectable || !currentObject.visible) {\\n          continue;\\n        }\\n\\n        if (currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2) ||\\n            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||\\n            currentObject.containsPoint(selectionX1Y1) ||\\n            currentObject.containsPoint(selectionX2Y2)\\n        ) {\\n          currentObject.set('active', true);\\n          group.push(currentObject);\\n\\n          // only add one object if it's a click\\n          if (isClick) {\\n            break;\\n          }\\n        }\\n      }\\n\\n      return group;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _maybeGroupObjects: function(e) {\\n      if (this.selection && this._groupSelector) {\\n        this._groupSelectedObjects(e);\\n      }\\n\\n      var activeGroup = this.getActiveGroup();\\n      if (activeGroup) {\\n        activeGroup.setObjectsCoords().setCoords();\\n        activeGroup.isMoving = false;\\n        this.setCursor(this.defaultCursor);\\n      }\\n\\n      // clear selection and current transformation\\n      this._groupSelector = null;\\n      this._currentTransform = null;\\n    }\\n  });\\n\\n})();\\n\\n\\n(function () {\\n\\n  var supportQuality = fabric.StaticCanvas.supports('toDataURLWithQuality');\\n\\n  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\\n\\n    /**\\n     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\\n     * @param {Object} [options] Options object\\n     * @param {String} [options.format=png] The format of the output image. Either \\\"jpeg\\\" or \\\"png\\\"\\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\\n     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\\n     * @example <caption>Generate jpeg dataURL with lower quality</caption>\\n     * var dataURL = canvas.toDataURL({\\n     *   format: 'jpeg',\\n     *   quality: 0.8\\n     * });\\n     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\\n     * var dataURL = canvas.toDataURL({\\n     *   format: 'png',\\n     *   left: 100,\\n     *   top: 100,\\n     *   width: 200,\\n     *   height: 200\\n     * });\\n     * @example <caption>Generate double scaled png dataURL</caption>\\n     * var dataURL = canvas.toDataURL({\\n     *   format: 'png',\\n     *   multiplier: 2\\n     * });\\n     */\\n    toDataURL: function (options) {\\n      options || (options = { });\\n\\n      var format = options.format || 'png',\\n          quality = options.quality || 1,\\n          multiplier = options.multiplier || 1,\\n          cropping = {\\n            left: options.left || 0,\\n            top: options.top || 0,\\n            width: options.width || 0,\\n            height: options.height || 0,\\n          };\\n      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {\\n\\n      var origWidth = this.getWidth(),\\n          origHeight = this.getHeight(),\\n          scaledWidth = (cropping.width || this.getWidth()) * multiplier,\\n          scaledHeight = (cropping.height || this.getHeight()) * multiplier,\\n          zoom = this.getZoom(),\\n          newZoom = zoom * multiplier,\\n          vp = this.viewportTransform,\\n          translateX = (vp[4] - cropping.left) * multiplier,\\n          translateY = (vp[5] - cropping.top) * multiplier,\\n          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],\\n          originalInteractive = this.interactive;\\n\\n      this.viewportTransform = newVp;\\n      // setting interactive to false avoid exporting controls\\n      this.interactive && (this.interactive = false);\\n      if (origWidth !== scaledWidth || origHeight !== scaledHeight) {\\n        // this.setDimensions is going to renderAll also;\\n        this.setDimensions({ width: scaledWidth, height: scaledHeight });\\n      }\\n      else {\\n        this.renderAll();\\n      }\\n      var data = this.__toDataURL(format, quality, cropping);\\n      originalInteractive && (this.interactive = originalInteractive);\\n      this.viewportTransform = vp;\\n      //setDimensions with no option object is taking care of:\\n      //this.width, this.height, this.renderAll()\\n      this.setDimensions({ width: origWidth, height: origHeight });\\n      return data;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    __toDataURL: function(format, quality) {\\n\\n      var canvasEl = this.contextContainer.canvas;\\n      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806\\n      if (format === 'jpg') {\\n        format = 'jpeg';\\n      }\\n\\n      var data = supportQuality\\n                ? canvasEl.toDataURL('image/' + format, quality)\\n                : canvasEl.toDataURL('image/' + format);\\n\\n      return data;\\n    },\\n\\n    /**\\n     * Exports canvas element to a dataurl image (allowing to change image size via multiplier).\\n     * @deprecated since 1.0.13\\n     * @param {String} format (png|jpeg)\\n     * @param {Number} multiplier\\n     * @param {Number} quality (0..1)\\n     * @return {String}\\n     */\\n    toDataURLWithMultiplier: function (format, multiplier, quality) {\\n      return this.toDataURL({\\n        format: format,\\n        multiplier: multiplier,\\n        quality: quality\\n      });\\n    },\\n  });\\n\\n})();\\n\\n\\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\\n\\n  /**\\n   * Populates canvas with data from the specified dataless JSON.\\n   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}\\n   * @deprecated since 1.2.2\\n   * @param {String|Object} json JSON string or object\\n   * @param {Function} callback Callback, invoked when json is parsed\\n   *                            and corresponding objects (e.g: {@link fabric.Image})\\n   *                            are initialized\\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\\n   * @return {fabric.Canvas} instance\\n   * @chainable\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\\n   */\\n  loadFromDatalessJSON: function (json, callback, reviver) {\\n    return this.loadFromJSON(json, callback, reviver);\\n  },\\n\\n  /**\\n   * Populates canvas with data from the specified JSON.\\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\\n   * @param {String|Object} json JSON string or object\\n   * @param {Function} callback Callback, invoked when json is parsed\\n   *                            and corresponding objects (e.g: {@link fabric.Image})\\n   *                            are initialized\\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\\n   * @return {fabric.Canvas} instance\\n   * @chainable\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\\n   * @example <caption>loadFromJSON</caption>\\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\\n   * @example <caption>loadFromJSON with reviver</caption>\\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\\n   *   // `o` = json object\\n   *   // `object` = fabric.Object instance\\n   *   // ... do some stuff ...\\n   * });\\n   */\\n  loadFromJSON: function (json, callback, reviver) {\\n    if (!json) {\\n      return;\\n    }\\n\\n    // serialize if it wasn't already\\n    var serialized = (typeof json === 'string')\\n      ? JSON.parse(json)\\n      : fabric.util.object.clone(json);\\n\\n    this.clear();\\n\\n    var _this = this;\\n    this._enlivenObjects(serialized.objects, function () {\\n      _this._setBgOverlay(serialized, function () {\\n        // remove parts i cannot set as options\\n        delete serialized.objects;\\n        delete serialized.backgroundImage;\\n        delete serialized.overlayImage;\\n        delete serialized.background;\\n        delete serialized.overlay;\\n        // this._initOptions does too many things to just\\n        // call it. Normally loading an Object from JSON\\n        // create the Object instance. Here the Canvas is\\n        // already an instance and we are just loading things over it\\n        for (var prop in serialized) {\\n          _this[prop] = serialized[prop];\\n        }\\n        callback && callback();\\n      });\\n    }, reviver);\\n    return this;\\n  },\\n\\n  /**\\n   * @private\\n   * @param {Object} serialized Object with background and overlay information\\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\\n   */\\n  _setBgOverlay: function(serialized, callback) {\\n    var _this = this,\\n        loaded = {\\n          backgroundColor: false,\\n          overlayColor: false,\\n          backgroundImage: false,\\n          overlayImage: false\\n        };\\n\\n    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\\n      callback && callback();\\n      return;\\n    }\\n\\n    var cbIfLoaded = function () {\\n      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\\n        _this.renderAll();\\n        callback && callback();\\n      }\\n    };\\n\\n    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);\\n    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);\\n    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);\\n    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);\\n\\n    cbIfLoaded();\\n  },\\n\\n  /**\\n   * @private\\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\\n   * @param {(Object|String)} value Value to set\\n   * @param {Object} loaded Set loaded property to true if property is set\\n   * @param {Object} callback Callback function to invoke after property is set\\n   */\\n  __setBgOverlay: function(property, value, loaded, callback) {\\n    var _this = this;\\n\\n    if (!value) {\\n      loaded[property] = true;\\n      return;\\n    }\\n\\n    if (property === 'backgroundImage' || property === 'overlayImage') {\\n      fabric.Image.fromObject(value, function(img) {\\n        _this[property] = img;\\n        loaded[property] = true;\\n        callback && callback();\\n      });\\n    }\\n    else {\\n      this['set' + fabric.util.string.capitalize(property, true)](value, function() {\\n        loaded[property] = true;\\n        callback && callback();\\n      });\\n    }\\n  },\\n\\n  /**\\n   * @private\\n   * @param {Array} objects\\n   * @param {Function} callback\\n   * @param {Function} [reviver]\\n   */\\n  _enlivenObjects: function (objects, callback, reviver) {\\n    var _this = this;\\n\\n    if (!objects || objects.length === 0) {\\n      callback && callback();\\n      return;\\n    }\\n\\n    var renderOnAddRemove = this.renderOnAddRemove;\\n    this.renderOnAddRemove = false;\\n\\n    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\\n      enlivenedObjects.forEach(function(obj, index) {\\n        // we splice the array just in case some custom classes restored from JSON\\n        // will add more object to canvas at canvas init.\\n        _this.insertAt(obj, index);\\n      });\\n\\n      _this.renderOnAddRemove = renderOnAddRemove;\\n      callback && callback();\\n    }, null, reviver);\\n  },\\n\\n  /**\\n   * @private\\n   * @param {String} format\\n   * @param {Function} callback\\n   */\\n  _toDataURL: function (format, callback) {\\n    this.clone(function (clone) {\\n      callback(clone.toDataURL(format));\\n    });\\n  },\\n\\n  /**\\n   * @private\\n   * @param {String} format\\n   * @param {Number} multiplier\\n   * @param {Function} callback\\n   */\\n  _toDataURLWithMultiplier: function (format, multiplier, callback) {\\n    this.clone(function (clone) {\\n      callback(clone.toDataURLWithMultiplier(format, multiplier));\\n    });\\n  },\\n\\n  /**\\n   * Clones canvas instance\\n   * @param {Object} [callback] Receives cloned instance as a first argument\\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\\n   */\\n  clone: function (callback, properties) {\\n    var data = JSON.stringify(this.toJSON(properties));\\n    this.cloneWithoutData(function(clone) {\\n      clone.loadFromJSON(data, function() {\\n        callback && callback(clone);\\n      });\\n    });\\n  },\\n\\n  /**\\n   * Clones canvas instance without cloning existing data.\\n   * This essentially copies canvas dimensions, clipping properties, etc.\\n   * but leaves data empty (so that you can populate it with your own)\\n   * @param {Object} [callback] Receives cloned instance as a first argument\\n   */\\n  cloneWithoutData: function(callback) {\\n    var el = fabric.document.createElement('canvas');\\n\\n    el.width = this.getWidth();\\n    el.height = this.getHeight();\\n\\n    var clone = new fabric.Canvas(el);\\n    clone.clipTo = this.clipTo;\\n    if (this.backgroundImage) {\\n      clone.setBackgroundImage(this.backgroundImage.src, function() {\\n        clone.renderAll();\\n        callback && callback(clone);\\n      });\\n      clone.backgroundImageOpacity = this.backgroundImageOpacity;\\n      clone.backgroundImageStretch = this.backgroundImageStretch;\\n    }\\n    else {\\n      callback && callback(clone);\\n    }\\n  }\\n});\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      toFixed = fabric.util.toFixed,\\n      capitalize = fabric.util.string.capitalize,\\n      degreesToRadians = fabric.util.degreesToRadians,\\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),\\n      objectCaching = !fabric.isLikelyNode;\\n\\n  if (fabric.Object) {\\n    return;\\n  }\\n\\n  /**\\n   * Root object class from which all 2d shape classes inherit from\\n   * @class fabric.Object\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}\\n   * @see {@link fabric.Object#initialize} for constructor definition\\n   *\\n   * @fires added\\n   * @fires removed\\n   *\\n   * @fires selected\\n   * @fires deselected\\n   * @fires modified\\n   * @fires rotating\\n   * @fires scaling\\n   * @fires moving\\n   * @fires skewing\\n   *\\n   * @fires mousedown\\n   * @fires mouseup\\n   * @fires mouseover\\n   * @fires mouseout\\n   */\\n  fabric.Object = fabric.util.createClass(/** @lends fabric.Object.prototype */ {\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#clipTo|clipping function}\\n     * @method getClipTo\\n     * @memberOf fabric.Object.prototype\\n     * @return {Function}\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#clipTo|clipping function}\\n     * @method setClipTo\\n     * @memberOf fabric.Object.prototype\\n     * @param {Function} clipTo Clipping function\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#transformMatrix|transformMatrix}\\n     * @method getTransformMatrix\\n     * @memberOf fabric.Object.prototype\\n     * @return {Array} transformMatrix\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#transformMatrix|transformMatrix}\\n     * @method setTransformMatrix\\n     * @memberOf fabric.Object.prototype\\n     * @param {Array} transformMatrix\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#visible|visible} state\\n     * @method getVisible\\n     * @memberOf fabric.Object.prototype\\n     * @return {Boolean} True if visible\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#visible|visible} state\\n     * @method setVisible\\n     * @memberOf fabric.Object.prototype\\n     * @param {Boolean} value visible value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#shadow|shadow}\\n     * @method getShadow\\n     * @memberOf fabric.Object.prototype\\n     * @return {Object} Shadow instance\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#stroke|stroke}\\n     * @method getStroke\\n     * @memberOf fabric.Object.prototype\\n     * @return {String} stroke value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#stroke|stroke}\\n     * @method setStroke\\n     * @memberOf fabric.Object.prototype\\n     * @param {String} value stroke value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#strokeWidth|strokeWidth}\\n     * @method getStrokeWidth\\n     * @memberOf fabric.Object.prototype\\n     * @return {Number} strokeWidth value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#strokeWidth|strokeWidth}\\n     * @method setStrokeWidth\\n     * @memberOf fabric.Object.prototype\\n     * @param {Number} value strokeWidth value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#originX|originX}\\n     * @method getOriginX\\n     * @memberOf fabric.Object.prototype\\n     * @return {String} originX value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#originX|originX}\\n     * @method setOriginX\\n     * @memberOf fabric.Object.prototype\\n     * @param {String} value originX value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#originY|originY}\\n     * @method getOriginY\\n     * @memberOf fabric.Object.prototype\\n     * @return {String} originY value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#originY|originY}\\n     * @method setOriginY\\n     * @memberOf fabric.Object.prototype\\n     * @param {String} value originY value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#fill|fill}\\n     * @method getFill\\n     * @memberOf fabric.Object.prototype\\n     * @return {String} Fill value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#fill|fill}\\n     * @method setFill\\n     * @memberOf fabric.Object.prototype\\n     * @param {String} value Fill value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#opacity|opacity}\\n     * @method getOpacity\\n     * @memberOf fabric.Object.prototype\\n     * @return {Number} Opacity value (0-1)\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#opacity|opacity}\\n     * @method setOpacity\\n     * @memberOf fabric.Object.prototype\\n     * @param {Number} value Opacity value (0-1)\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#angle|angle} (in degrees)\\n     * @method getAngle\\n     * @memberOf fabric.Object.prototype\\n     * @return {Number}\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#top|top position}\\n     * @method getTop\\n     * @memberOf fabric.Object.prototype\\n     * @return {Number} Top value (in pixels)\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#top|top position}\\n     * @method setTop\\n     * @memberOf fabric.Object.prototype\\n     * @param {Number} value Top value (in pixels)\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#left|left position}\\n     * @method getLeft\\n     * @memberOf fabric.Object.prototype\\n     * @return {Number} Left value (in pixels)\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#left|left position}\\n     * @method setLeft\\n     * @memberOf fabric.Object.prototype\\n     * @param {Number} value Left value (in pixels)\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#scaleX|scaleX} value\\n     * @method getScaleX\\n     * @memberOf fabric.Object.prototype\\n     * @return {Number} scaleX value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#scaleX|scaleX} value\\n     * @method setScaleX\\n     * @memberOf fabric.Object.prototype\\n     * @param {Number} value scaleX value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#scaleY|scaleY} value\\n     * @method getScaleY\\n     * @memberOf fabric.Object.prototype\\n     * @return {Number} scaleY value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#scaleY|scaleY} value\\n     * @method setScaleY\\n     * @memberOf fabric.Object.prototype\\n     * @param {Number} value scaleY value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#flipX|flipX} value\\n     * @method getFlipX\\n     * @memberOf fabric.Object.prototype\\n     * @return {Boolean} flipX value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#flipX|flipX} value\\n     * @method setFlipX\\n     * @memberOf fabric.Object.prototype\\n     * @param {Boolean} value flipX value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's {@link fabric.Object#flipY|flipY} value\\n     * @method getFlipY\\n     * @memberOf fabric.Object.prototype\\n     * @return {Boolean} flipY value\\n     */\\n\\n    /**\\n     * Sets object's {@link fabric.Object#flipY|flipY} value\\n     * @method setFlipY\\n     * @memberOf fabric.Object.prototype\\n     * @param {Boolean} value flipY value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n\\n    /**\\n     * Type of an object (rect, circle, path, etc.).\\n     * Note that this property is meant to be read-only and not meant to be modified.\\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\\n     * @type String\\n     * @default\\n     */\\n    type:                     'object',\\n\\n    /**\\n     * Horizontal origin of transformation of an object (one of \\\"left\\\", \\\"right\\\", \\\"center\\\")\\n     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups\\n     * @type String\\n     * @default\\n     */\\n    originX:                  'left',\\n\\n    /**\\n     * Vertical origin of transformation of an object (one of \\\"top\\\", \\\"bottom\\\", \\\"center\\\")\\n     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups\\n     * @type String\\n     * @default\\n     */\\n    originY:                  'top',\\n\\n    /**\\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\\n     * @type Number\\n     * @default\\n     */\\n    top:                      0,\\n\\n    /**\\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\\n     * @type Number\\n     * @default\\n     */\\n    left:                     0,\\n\\n    /**\\n     * Object width\\n     * @type Number\\n     * @default\\n     */\\n    width:                    0,\\n\\n    /**\\n     * Object height\\n     * @type Number\\n     * @default\\n     */\\n    height:                   0,\\n\\n    /**\\n     * Object scale factor (horizontal)\\n     * @type Number\\n     * @default\\n     */\\n    scaleX:                   1,\\n\\n    /**\\n     * Object scale factor (vertical)\\n     * @type Number\\n     * @default\\n     */\\n    scaleY:                   1,\\n\\n    /**\\n     * When true, an object is rendered as flipped horizontally\\n     * @type Boolean\\n     * @default\\n     */\\n    flipX:                    false,\\n\\n    /**\\n     * When true, an object is rendered as flipped vertically\\n     * @type Boolean\\n     * @default\\n     */\\n    flipY:                    false,\\n\\n    /**\\n     * Opacity of an object\\n     * @type Number\\n     * @default\\n     */\\n    opacity:                  1,\\n\\n    /**\\n     * Angle of rotation of an object (in degrees)\\n     * @type Number\\n     * @default\\n     */\\n    angle:                    0,\\n\\n    /**\\n     * Angle of skew on x axes of an object (in degrees)\\n     * @type Number\\n     * @default\\n     */\\n    skewX:                    0,\\n\\n    /**\\n     * Angle of skew on y axes of an object (in degrees)\\n     * @type Number\\n     * @default\\n     */\\n    skewY:                    0,\\n\\n    /**\\n     * Size of object's controlling corners (in pixels)\\n     * @type Number\\n     * @default\\n     */\\n    cornerSize:               13,\\n\\n    /**\\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\\n     * @type Boolean\\n     * @default\\n     */\\n    transparentCorners:       true,\\n\\n    /**\\n     * Default cursor value used when hovering over this object on canvas\\n     * @type String\\n     * @default\\n     */\\n    hoverCursor:              null,\\n\\n    /**\\n     * Default cursor value used when moving this object on canvas\\n     * @type String\\n     * @default\\n     */\\n    moveCursor:               null,\\n\\n    /**\\n     * Padding between object and its controlling borders (in pixels)\\n     * @type Number\\n     * @default\\n     */\\n    padding:                  0,\\n\\n    /**\\n     * Color of controlling borders of an object (when it's active)\\n     * @type String\\n     * @default\\n     */\\n    borderColor:              'rgba(102,153,255,0.75)',\\n\\n    /**\\n     * Array specifying dash pattern of an object's borders (hasBorder must be true)\\n     * @since 1.6.2\\n     * @type Array\\n     */\\n    borderDashArray:          null,\\n\\n    /**\\n     * Color of controlling corners of an object (when it's active)\\n     * @type String\\n     * @default\\n     */\\n    cornerColor:              'rgba(102,153,255,0.5)',\\n\\n    /**\\n     * Color of controlling corners of an object (when it's active and transparentCorners false)\\n     * @since 1.6.2\\n     * @type String\\n     * @default\\n     */\\n    cornerStrokeColor:        null,\\n\\n    /**\\n     * Specify style of control, 'rect' or 'circle'\\n     * @since 1.6.2\\n     * @type String\\n     */\\n    cornerStyle:          'rect',\\n\\n    /**\\n     * Array specifying dash pattern of an object's control (hasBorder must be true)\\n     * @since 1.6.2\\n     * @type Array\\n     */\\n    cornerDashArray:          null,\\n\\n    /**\\n     * When true, this object will use center point as the origin of transformation\\n     * when being scaled via the controls.\\n     * <b>Backwards incompatibility note:</b> This property replaces \\\"centerTransform\\\" (Boolean).\\n     * @since 1.3.4\\n     * @type Boolean\\n     * @default\\n     */\\n    centeredScaling:          false,\\n\\n    /**\\n     * When true, this object will use center point as the origin of transformation\\n     * when being rotated via the controls.\\n     * <b>Backwards incompatibility note:</b> This property replaces \\\"centerTransform\\\" (Boolean).\\n     * @since 1.3.4\\n     * @type Boolean\\n     * @default\\n     */\\n    centeredRotation:         true,\\n\\n    /**\\n     * Color of object's fill\\n     * @type String\\n     * @default\\n     */\\n    fill:                     'rgb(0,0,0)',\\n\\n    /**\\n     * Fill rule used to fill an object\\n     * accepted values are nonzero, evenodd\\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\\n     * @type String\\n     * @default\\n     */\\n    fillRule:                 'nonzero',\\n\\n    /**\\n     * Composite rule used for canvas globalCompositeOperation\\n     * @type String\\n     * @default\\n     */\\n    globalCompositeOperation: 'source-over',\\n\\n    /**\\n     * Background color of an object. Only works with text objects at the moment.\\n     * @type String\\n     * @default\\n     */\\n    backgroundColor:          '',\\n\\n    /**\\n     * Selection Background color of an object. colored layer behind the object when it is active.\\n     * does not mix good with globalCompositeOperation methods.\\n     * @type String\\n     * @default\\n     */\\n    selectionBackgroundColor:          '',\\n\\n    /**\\n     * When defined, an object is rendered via stroke and this property specifies its color\\n     * @type String\\n     * @default\\n     */\\n    stroke:                   null,\\n\\n    /**\\n     * Width of a stroke used to render this object\\n     * @type Number\\n     * @default\\n     */\\n    strokeWidth:              1,\\n\\n    /**\\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\\n     * @type Array\\n     */\\n    strokeDashArray:          null,\\n\\n    /**\\n     * Line endings style of an object's stroke (one of \\\"butt\\\", \\\"round\\\", \\\"square\\\")\\n     * @type String\\n     * @default\\n     */\\n    strokeLineCap:            'butt',\\n\\n    /**\\n     * Corner style of an object's stroke (one of \\\"bevil\\\", \\\"round\\\", \\\"miter\\\")\\n     * @type String\\n     * @default\\n     */\\n    strokeLineJoin:           'miter',\\n\\n    /**\\n     * Maximum miter length (used for strokeLineJoin = \\\"miter\\\") of an object's stroke\\n     * @type Number\\n     * @default\\n     */\\n    strokeMiterLimit:         10,\\n\\n    /**\\n     * Shadow object representing shadow of this shape\\n     * @type fabric.Shadow\\n     * @default\\n     */\\n    shadow:                   null,\\n\\n    /**\\n     * Opacity of object's controlling borders when object is active and moving\\n     * @type Number\\n     * @default\\n     */\\n    borderOpacityWhenMoving:  0.4,\\n\\n    /**\\n     * Scale factor of object's controlling borders\\n     * @type Number\\n     * @default\\n     */\\n    borderScaleFactor:        1,\\n\\n    /**\\n     * Transform matrix (similar to SVG's transform matrix)\\n     * @type Array\\n     */\\n    transformMatrix:          null,\\n\\n    /**\\n     * Minimum allowed scale value of an object\\n     * @type Number\\n     * @default\\n     */\\n    minScaleLimit:            0.01,\\n\\n    /**\\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\\n     * But events still fire on it.\\n     * @type Boolean\\n     * @default\\n     */\\n    selectable:               true,\\n\\n    /**\\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\\n     * @type Boolean\\n     * @default\\n     */\\n    evented:                  true,\\n\\n    /**\\n     * When set to `false`, an object is not rendered on canvas\\n     * @type Boolean\\n     * @default\\n     */\\n    visible:                  true,\\n\\n    /**\\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\\n     * @type Boolean\\n     * @default\\n     */\\n    hasControls:              true,\\n\\n    /**\\n     * When set to `false`, object's controlling borders are not rendered\\n     * @type Boolean\\n     * @default\\n     */\\n    hasBorders:               true,\\n\\n    /**\\n     * When set to `false`, object's controlling rotating point will not be visible or selectable\\n     * @type Boolean\\n     * @default\\n     */\\n    hasRotatingPoint:         true,\\n\\n    /**\\n     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)\\n     * @type Number\\n     * @default\\n     */\\n    rotatingPointOffset:      40,\\n\\n    /**\\n     * When set to `true`, objects are \\\"found\\\" on canvas on per-pixel basis rather than according to bounding box\\n     * @type Boolean\\n     * @default\\n     */\\n    perPixelTargetFind:       false,\\n\\n    /**\\n     * When `false`, default object's values are not included in its serialization\\n     * @type Boolean\\n     * @default\\n     */\\n    includeDefaultValues:     true,\\n\\n    /**\\n     * Function that determines clipping of an object (context is passed as a first argument)\\n     * Note that context origin is at the object's center point (not left/top corner)\\n     * @type Function\\n     */\\n    clipTo:                   null,\\n\\n    /**\\n     * When `true`, object horizontal movement is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockMovementX:            false,\\n\\n    /**\\n     * When `true`, object vertical movement is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockMovementY:            false,\\n\\n    /**\\n     * When `true`, object rotation is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockRotation:             false,\\n\\n    /**\\n     * When `true`, object horizontal scaling is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockScalingX:             false,\\n\\n    /**\\n     * When `true`, object vertical scaling is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockScalingY:             false,\\n\\n    /**\\n     * When `true`, object non-uniform scaling is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockUniScaling:           false,\\n\\n    /**\\n     * When `true`, object horizontal skewing is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockSkewingX:             false,\\n\\n    /**\\n     * When `true`, object vertical skewing is locked\\n     * @type Boolean\\n     * @default\\n     */\\n    lockSkewingY:             false,\\n\\n    /**\\n     * When `true`, object cannot be flipped by scaling into negative values\\n     * @type Boolean\\n     * @default\\n     */\\n    lockScalingFlip:          false,\\n\\n    /**\\n     * When `true`, object is not exported in SVG or OBJECT/JSON\\n     * since 1.6.3\\n     * @type Boolean\\n     * @default\\n     */\\n    excludeFromExport:        false,\\n\\n    /**\\n     * When `true`, object is cached on an additional canvas.\\n     * default to true\\n     * since 1.7.0\\n     * @type Boolean\\n     * @default\\n     */\\n    objectCaching:            objectCaching,\\n\\n    /**\\n     * When `true`, object properties are checked for cache invalidation. In some particular\\n     * situation you may want this to be disabled ( spray brush, very big pathgroups, groups)\\n     * or if your application does not allow you to modify properties for groups child you want\\n     * to disable it for groups.\\n     * default to false\\n     * since 1.7.0\\n     * @type Boolean\\n     * @default false\\n     */\\n    statefullCache:            false,\\n\\n    /**\\n     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled\\n     * too much and will be redrawn with correct details at the end of scaling.\\n     * this setting is performance and application dependant.\\n     * default to false\\n     * since 1.7.0\\n     * @type Boolean\\n     * @default true\\n     */\\n    noScaleCache:              true,\\n\\n    /**\\n     * When set to `true`, object's cache will be rerendered next render call.\\n     * @type Boolean\\n     * @default false\\n     */\\n    dirty:                false,\\n\\n    /**\\n     * List of properties to consider when checking if state\\n     * of an object is changed (fabric.Object#hasStateChanged)\\n     * as well as for history (undo/redo) purposes\\n     * @type Array\\n     */\\n    stateProperties: (\\n      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +\\n      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +\\n      'angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor ' +\\n      'skewX skewY'\\n    ).split(' '),\\n\\n    /**\\n     * List of properties to consider when checking if cache needs refresh\\n     * @type Array\\n     */\\n    cacheProperties: (\\n      'fill stroke strokeWidth strokeDashArray width height stroke strokeWidth strokeDashArray' +\\n      ' strokeLineCap strokeLineJoin strokeMiterLimit fillRule backgroundColor'\\n    ).split(' '),\\n\\n    /**\\n     * Constructor\\n     * @param {Object} [options] Options object\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      if (options) {\\n        this.setOptions(options);\\n      }\\n      if (this.objectCaching) {\\n        this._createCacheCanvas();\\n        this.setupState({ propertySet: 'cacheProperties' });\\n      }\\n    },\\n\\n    /**\\n     * Create a the canvas used to keep the cached copy of the object\\n     * @private\\n     */\\n    _createCacheCanvas: function() {\\n      this._cacheCanvas = fabric.document.createElement('canvas');\\n      this._cacheContext = this._cacheCanvas.getContext('2d');\\n      this._updateCacheCanvas();\\n    },\\n\\n    /**\\n     * Update width and height of the canvas for cache\\n     * returns true or false if canvas needed resize.\\n     * @private\\n     * @return {Boolean} true if the canvas has been resized\\n     */\\n    _updateCacheCanvas: function() {\\n      if (this.noScaleCache && this.canvas && this.canvas._currentTransform) {\\n        var action = this.canvas._currentTransform.action;\\n        if (action.slice(0, 5) === 'scale') {\\n          return false;\\n        }\\n      }\\n      var zoom = this.getViewportTransform()[0],\\n          objectScale = this.getObjectScaling(),\\n          dim = this._getNonTransformedDimensions(),\\n          retina = this.canvas && this.canvas._isRetinaScaling() ? fabric.devicePixelRatio : 1,\\n          zoomX = objectScale.scaleX * zoom * retina,\\n          zoomY = objectScale.scaleY * zoom * retina,\\n          width = dim.x * zoomX,\\n          height = dim.y * zoomY;\\n      if (width !== this.cacheWidth || height !== this.cacheHeight) {\\n        this._cacheCanvas.width = width;\\n        this._cacheCanvas.height = height;\\n        this._cacheContext.translate(width / 2, height / 2);\\n        this._cacheContext.scale(zoomX, zoomY);\\n        this.cacheWidth = width;\\n        this.cacheHeight = height;\\n        this.zoomX = zoomX;\\n        this.zoomY = zoomY;\\n        return true\\n      }\\n      return false\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} [options] Options object\\n     */\\n    _initGradient: function(options) {\\n      if (options.fill && options.fill.colorStops && !(options.fill instanceof fabric.Gradient)) {\\n        this.set('fill', new fabric.Gradient(options.fill));\\n      }\\n      if (options.stroke && options.stroke.colorStops && !(options.stroke instanceof fabric.Gradient)) {\\n        this.set('stroke', new fabric.Gradient(options.stroke));\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} [options] Options object\\n     */\\n    _initPattern: function(options) {\\n      if (options.fill && options.fill.source && !(options.fill instanceof fabric.Pattern)) {\\n        this.set('fill', new fabric.Pattern(options.fill));\\n      }\\n      if (options.stroke && options.stroke.source && !(options.stroke instanceof fabric.Pattern)) {\\n        this.set('stroke', new fabric.Pattern(options.stroke));\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} [options] Options object\\n     */\\n    _initClipping: function(options) {\\n      if (!options.clipTo || typeof options.clipTo !== 'string') {\\n        return;\\n      }\\n\\n      var functionBody = fabric.util.getFunctionBody(options.clipTo);\\n      if (typeof functionBody !== 'undefined') {\\n        this.clipTo = new Function('ctx', functionBody);\\n      }\\n    },\\n\\n    /**\\n     * Sets object's properties from options\\n     * @param {Object} [options] Options object\\n     */\\n    setOptions: function(options) {\\n      for (var prop in options) {\\n        this.set(prop, options[prop]);\\n      }\\n      this._initGradient(options);\\n      this._initPattern(options);\\n      this._initClipping(options);\\n    },\\n\\n    /**\\n     * Transforms context when rendering an object\\n     * @param {CanvasRenderingContext2D} ctx Context\\n     * @param {Boolean} fromLeft When true, context is transformed to object's top/left corner. This is used when rendering text on Node\\n     */\\n    transform: function(ctx, fromLeft) {\\n      if (this.group && !this.group._transformDone && this.group === this.canvas._activeGroup) {\\n        this.group.transform(ctx);\\n      }\\n      var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();\\n      ctx.translate(center.x, center.y);\\n      ctx.rotate(degreesToRadians(this.angle));\\n      ctx.scale(\\n        this.scaleX * (this.flipX ? -1 : 1),\\n        this.scaleY * (this.flipY ? -1 : 1)\\n      );\\n      ctx.transform(1, 0, Math.tan(degreesToRadians(this.skewX)), 1, 0, 0);\\n      ctx.transform(1, Math.tan(degreesToRadians(this.skewY)), 0, 1, 0, 0);\\n    },\\n\\n    /**\\n     * Returns an object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\\n\\n          object = {\\n            type:                     this.type,\\n            originX:                  this.originX,\\n            originY:                  this.originY,\\n            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),\\n            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),\\n            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),\\n            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),\\n            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,\\n            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,\\n            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\\n            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\\n            strokeLineCap:            this.strokeLineCap,\\n            strokeLineJoin:           this.strokeLineJoin,\\n            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\\n            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),\\n            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),\\n            angle:                    toFixed(this.getAngle(), NUM_FRACTION_DIGITS),\\n            flipX:                    this.flipX,\\n            flipY:                    this.flipY,\\n            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),\\n            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,\\n            visible:                  this.visible,\\n            clipTo:                   this.clipTo && String(this.clipTo),\\n            backgroundColor:          this.backgroundColor,\\n            fillRule:                 this.fillRule,\\n            globalCompositeOperation: this.globalCompositeOperation,\\n            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : this.transformMatrix,\\n            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),\\n            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)\\n          };\\n\\n      fabric.util.populateWithProperties(this, object, propertiesToInclude);\\n\\n      if (!this.includeDefaultValues) {\\n        object = this._removeDefaultValues(object);\\n      }\\n\\n      return object;\\n    },\\n\\n    /**\\n     * Returns (dataless) object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toDatalessObject: function(propertiesToInclude) {\\n      // will be overwritten by subclasses\\n      return this.toObject(propertiesToInclude);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} object\\n     */\\n    _removeDefaultValues: function(object) {\\n      var prototype = fabric.util.getKlass(object.type).prototype,\\n          stateProperties = prototype.stateProperties;\\n      stateProperties.forEach(function(prop) {\\n        if (object[prop] === prototype[prop]) {\\n          delete object[prop];\\n        }\\n        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&\\n                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';\\n\\n        // basically a check for [] === []\\n        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {\\n          delete object[prop];\\n        }\\n      });\\n\\n      return object;\\n    },\\n\\n    /**\\n     * Returns a string representation of an instance\\n     * @return {String}\\n     */\\n    toString: function() {\\n      return '#<fabric.' + capitalize(this.type) + '>';\\n    },\\n\\n    /**\\n     * Basic getter\\n     * @param {String} property Property name\\n     * @return {*} value of a property\\n     */\\n    get: function(property) {\\n      return this[property];\\n    },\\n\\n    /**\\n     * Return the object scale factor counting also the group scaling\\n     * @return {Object} object with scaleX and scaleY properties\\n     */\\n    getObjectScaling: function() {\\n      var scaleX = this.scaleX, scaleY = this.scaleY;\\n      if (this.group) {\\n        var scaling = this.group.getObjectScaling();\\n        scaleX *= scaling.scaleX;\\n        scaleY *= scaling.scaleY;\\n      }\\n      return { scaleX: scaleX, scaleY: scaleY };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setObject: function(obj) {\\n      for (var prop in obj) {\\n        this._set(prop, obj[prop]);\\n      }\\n    },\\n\\n    /**\\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    set: function(key, value) {\\n      if (typeof key === 'object') {\\n        this._setObject(key);\\n      }\\n      else {\\n        if (typeof value === 'function' && key !== 'clipTo') {\\n          this._set(key, value(this.get(key)));\\n        }\\n        else {\\n          this._set(key, value);\\n        }\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} key\\n     * @param {*} value\\n     * @return {fabric.Object} thisArg\\n     */\\n    _set: function(key, value) {\\n      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');\\n\\n      if (shouldConstrainValue) {\\n        value = this._constrainScale(value);\\n      }\\n      if (key === 'scaleX' && value < 0) {\\n        this.flipX = !this.flipX;\\n        value *= -1;\\n      }\\n      else if (key === 'scaleY' && value < 0) {\\n        this.flipY = !this.flipY;\\n        value *= -1;\\n      }\\n      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {\\n        value = new fabric.Shadow(value);\\n      }\\n\\n      this[key] = value;\\n\\n      if (this.cacheProperties.indexOf(key) > -1) {\\n        this.dirty = true;\\n      }\\n\\n      if (key === 'width' || key === 'height') {\\n        this.minScaleLimit = Math.min(0.1, 1 / Math.max(this.width, this.height));\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * This callback function is called by the parent group of an object every\\n     * time a non-delegated property changes on the group. It is passed the key\\n     * and value as parameters. Not adding in this function's signature to avoid\\n     * Travis build error about unused variables.\\n     */\\n    setOnGroup: function() {\\n      // implemented by sub-classes, as needed.\\n    },\\n\\n    /**\\n     * Toggles specified property from `true` to `false` or from `false` to `true`\\n     * @param {String} property Property to toggle\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    toggle: function(property) {\\n      var value = this.get(property);\\n      if (typeof value === 'boolean') {\\n        this.set(property, !value);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Sets sourcePath of an object\\n     * @param {String} value Value to set sourcePath to\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    setSourcePath: function(value) {\\n      this.sourcePath = value;\\n      return this;\\n    },\\n\\n    /**\\n     * Retrieves viewportTransform from Object's canvas if possible\\n     * @method getViewportTransform\\n     * @memberOf fabric.Object.prototype\\n     * @return {Boolean} flipY value // TODO\\n     */\\n    getViewportTransform: function() {\\n      if (this.canvas && this.canvas.viewportTransform) {\\n        return this.canvas.viewportTransform;\\n      }\\n      return [1, 0, 0, 1, 0, 0];\\n    },\\n\\n    /**\\n     * Renders an object on a specified context\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    render: function(ctx, noTransform) {\\n      // do not render if width/height are zeros or object is not visible\\n      if ((this.width === 0 && this.height === 0) || !this.visible) {\\n        return;\\n      }\\n      ctx.save();\\n      //setup fill rule for current object\\n      this._setupCompositeOperation(ctx);\\n      this.drawSelectionBackground(ctx);\\n      if (!noTransform) {\\n        this.transform(ctx);\\n      }\\n      this._setOpacity(ctx);\\n      this._setShadow(ctx);\\n      if (this.transformMatrix) {\\n        ctx.transform.apply(ctx, this.transformMatrix);\\n      }\\n      this.clipTo && fabric.util.clipContext(this, ctx);\\n      if (this.objectCaching && !this.group) {\\n        if (this.isCacheDirty(noTransform)) {\\n          this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });\\n          this.drawObject(this._cacheContext, noTransform);\\n          this.dirty = false;\\n        }\\n        this.drawCacheOnCanvas(ctx);\\n      }\\n      else {\\n        this.drawObject(ctx, noTransform);\\n        if (noTransform && this.objectCaching && this.statefullCache) {\\n          this.saveState({ propertySet: 'cacheProperties' });\\n        }\\n      }\\n      this.clipTo && ctx.restore();\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * Execute the drawing operation for an object on a specified context\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    drawObject: function(ctx, noTransform) {\\n      this._renderBackground(ctx);\\n      this._setStrokeStyles(ctx);\\n      this._setFillStyles(ctx);\\n      this._render(ctx, noTransform);\\n    },\\n\\n    /**\\n     * Paint the cached copy of the object on the target context.\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    drawCacheOnCanvas: function(ctx) {\\n      ctx.scale(1 / this.zoomX, 1 / this.zoomY);\\n      ctx.drawImage(this._cacheCanvas, -this.cacheWidth / 2, -this.cacheHeight / 2);\\n    },\\n\\n    /**\\n     * Check if cache is dirty\\n     * @param {Boolean} skipCanvas skip canvas checks because this object is painted\\n     * on parent canvas.\\n     */\\n    isCacheDirty: function(skipCanvas) {\\n      if (!skipCanvas && this._updateCacheCanvas()) {\\n        // in this case the context is already cleared.\\n        return true;\\n      }\\n      else {\\n        if (this.dirty || (this.statefullCache && this.hasStateChanged('cacheProperties'))) {\\n          if (!skipCanvas) {\\n            var dim = this._getNonTransformedDimensions();\\n            this._cacheContext.clearRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\\n          }\\n          return true;\\n        }\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Draws a background for the object big as its untrasformed dimensions\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderBackground: function(ctx) {\\n      if (!this.backgroundColor) {\\n        return;\\n      }\\n      var dim = this._getNonTransformedDimensions();\\n      ctx.fillStyle = this.backgroundColor;\\n\\n      ctx.fillRect(\\n        -dim.x / 2,\\n        -dim.y / 2,\\n        dim.x,\\n        dim.y\\n      );\\n      // if there is background color no other shadows\\n      // should be casted\\n      this._removeShadow(ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _setOpacity: function(ctx) {\\n      ctx.globalAlpha *= this.opacity;\\n    },\\n\\n    _setStrokeStyles: function(ctx) {\\n      if (this.stroke) {\\n        ctx.lineWidth = this.strokeWidth;\\n        ctx.lineCap = this.strokeLineCap;\\n        ctx.lineJoin = this.strokeLineJoin;\\n        ctx.miterLimit = this.strokeMiterLimit;\\n        ctx.strokeStyle = this.stroke.toLive\\n          ? this.stroke.toLive(ctx, this)\\n          : this.stroke;\\n      }\\n    },\\n\\n    _setFillStyles: function(ctx) {\\n      if (this.fill) {\\n        ctx.fillStyle = this.fill.toLive\\n          ? this.fill.toLive(ctx, this)\\n          : this.fill;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * Sets line dash\\n     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on\\n     * @param {Array} dashArray array representing dashes\\n     * @param {Function} alternative function to call if browaser does not support lineDash\\n     */\\n    _setLineDash: function(ctx, dashArray, alternative) {\\n      if (!dashArray) {\\n        return;\\n      }\\n      // Spec requires the concatenation of two copies the dash list when the number of elements is odd\\n      if (1 & dashArray.length) {\\n        dashArray.push.apply(dashArray, dashArray);\\n      }\\n      if (supportsLineDash) {\\n        ctx.setLineDash(dashArray);\\n      }\\n      else {\\n        alternative && alternative(ctx);\\n      }\\n    },\\n\\n    /**\\n     * Renders controls and borders for the object\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    _renderControls: function(ctx, noTransform) {\\n      if (!this.active || noTransform\\n          || (this.group && this.group !== this.canvas.getActiveGroup())) {\\n        return;\\n      }\\n\\n      var vpt = this.getViewportTransform(),\\n          matrix = this.calcTransformMatrix(),\\n          options;\\n      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);\\n      options = fabric.util.qrDecompose(matrix);\\n\\n      ctx.save();\\n      ctx.translate(options.translateX, options.translateY);\\n      ctx.lineWidth = 1 * this.borderScaleFactor;\\n      if (!this.group) {\\n        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\\n      }\\n      if (this.group && this.group === this.canvas.getActiveGroup()) {\\n        ctx.rotate(degreesToRadians(options.angle));\\n        this.drawBordersInGroup(ctx, options);\\n      }\\n      else {\\n        ctx.rotate(degreesToRadians(this.angle));\\n        this.drawBorders(ctx);\\n      }\\n      this.drawControls(ctx);\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _setShadow: function(ctx) {\\n      if (!this.shadow) {\\n        return;\\n      }\\n\\n      var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,\\n          multY = (this.canvas && this.canvas.viewportTransform[3]) || 1,\\n          scaling = this.getObjectScaling();\\n      if (this.canvas && this.canvas._isRetinaScaling()) {\\n        multX *= fabric.devicePixelRatio;\\n        multY *= fabric.devicePixelRatio;\\n      }\\n      ctx.shadowColor = this.shadow.color;\\n      ctx.shadowBlur = this.shadow.blur * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;\\n      ctx.shadowOffsetX = this.shadow.offsetX * multX * scaling.scaleX;\\n      ctx.shadowOffsetY = this.shadow.offsetY * multY * scaling.scaleY;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _removeShadow: function(ctx) {\\n      if (!this.shadow) {\\n        return;\\n      }\\n\\n      ctx.shadowColor = '';\\n      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderFill: function(ctx) {\\n      if (!this.fill) {\\n        return;\\n      }\\n\\n      ctx.save();\\n      if (this.fill.gradientTransform) {\\n        var g = this.fill.gradientTransform;\\n        ctx.transform.apply(ctx, g);\\n      }\\n      if (this.fill.toLive) {\\n        ctx.translate(\\n          -this.width / 2 + this.fill.offsetX || 0,\\n          -this.height / 2 + this.fill.offsetY || 0);\\n      }\\n      if (this.fillRule === 'evenodd') {\\n        ctx.fill('evenodd');\\n      }\\n      else {\\n        ctx.fill();\\n      }\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderStroke: function(ctx) {\\n      if (!this.stroke || this.strokeWidth === 0) {\\n        return;\\n      }\\n\\n      if (this.shadow && !this.shadow.affectStroke) {\\n        this._removeShadow(ctx);\\n      }\\n\\n      ctx.save();\\n\\n      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);\\n      if (this.stroke.gradientTransform) {\\n        var g = this.stroke.gradientTransform;\\n        ctx.transform.apply(ctx, g);\\n      }\\n      if (this.stroke.toLive) {\\n        ctx.translate(\\n          -this.width / 2 + this.stroke.offsetX || 0,\\n          -this.height / 2 + this.stroke.offsetY || 0);\\n      }\\n      ctx.stroke();\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * Clones an instance, some objects are async, so using callback method will work for every object.\\n     * Using the direct return does not work for images and groups.\\n     * @param {Function} callback Callback is invoked with a clone as a first argument\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {fabric.Object} clone of an instance\\n     */\\n    clone: function(callback, propertiesToInclude) {\\n      if (this.constructor.fromObject) {\\n        return this.constructor.fromObject(this.toObject(propertiesToInclude), callback);\\n      }\\n      return new fabric.Object(this.toObject(propertiesToInclude));\\n    },\\n\\n    /**\\n     * Creates an instance of fabric.Image out of an object\\n     * @param {Function} callback callback, invoked with an instance as a first argument\\n     * @param {Object} [options] for clone as image, passed to toDataURL\\n     * @param {Boolean} [options.enableRetinaScaling] enable retina scaling for the cloned image\\n     * @return {fabric.Object} thisArg\\n     */\\n    cloneAsImage: function(callback, options) {\\n      var dataUrl = this.toDataURL(options);\\n      fabric.util.loadImage(dataUrl, function(img) {\\n        if (callback) {\\n          callback(new fabric.Image(img));\\n        }\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Converts an object into a data-url-like string\\n     * @param {Object} options Options object\\n     * @param {String} [options.format=png] The format of the output image. Either \\\"jpeg\\\" or \\\"png\\\"\\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\\n     * @param {Boolean} [options.enableRetina] Enable retina scaling for clone image. Introduce in 1.6.4\\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\\n     */\\n    toDataURL: function(options) {\\n      options || (options = { });\\n\\n      var el = fabric.util.createCanvasElement(),\\n          boundingRect = this.getBoundingRect();\\n\\n      el.width = boundingRect.width;\\n      el.height = boundingRect.height;\\n      fabric.util.wrapElement(el, 'div');\\n      var canvas = new fabric.StaticCanvas(el, { enableRetinaScaling: options.enableRetinaScaling });\\n      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806\\n      if (options.format === 'jpg') {\\n        options.format = 'jpeg';\\n      }\\n\\n      if (options.format === 'jpeg') {\\n        canvas.backgroundColor = '#fff';\\n      }\\n\\n      var origParams = {\\n        active: this.get('active'),\\n        left: this.getLeft(),\\n        top: this.getTop()\\n      };\\n\\n      this.set('active', false);\\n      this.setPositionByOrigin(new fabric.Point(canvas.getWidth() / 2, canvas.getHeight() / 2), 'center', 'center');\\n\\n      var originalCanvas = this.canvas;\\n      canvas.add(this);\\n      var data = canvas.toDataURL(options);\\n\\n      this.set(origParams).setCoords();\\n      this.canvas = originalCanvas;\\n\\n      canvas.dispose();\\n      canvas = null;\\n\\n      return data;\\n    },\\n\\n    /**\\n     * Returns true if specified type is identical to the type of an instance\\n     * @param {String} type Type to check against\\n     * @return {Boolean}\\n     */\\n    isType: function(type) {\\n      return this.type === type;\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function() {\\n      return 0;\\n    },\\n\\n    /**\\n     * Returns a JSON representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} JSON\\n     */\\n    toJSON: function(propertiesToInclude) {\\n      // delegate, not alias\\n      return this.toObject(propertiesToInclude);\\n    },\\n\\n    /**\\n     * Sets gradient (fill or stroke) of an object\\n     * <b>Backwards incompatibility note:</b> This method was named \\\"setGradientFill\\\" until v1.1.0\\n     * @param {String} property Property name 'stroke' or 'fill'\\n     * @param {Object} [options] Options object\\n     * @param {String} [options.type] Type of gradient 'radial' or 'linear'\\n     * @param {Number} [options.x1=0] x-coordinate of start point\\n     * @param {Number} [options.y1=0] y-coordinate of start point\\n     * @param {Number} [options.x2=0] x-coordinate of end point\\n     * @param {Number} [options.y2=0] y-coordinate of end point\\n     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)\\n     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)\\n     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}\\n     * @param {Object} [options.gradientTransform] transforMatrix for gradient\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}\\n     * @example <caption>Set linear gradient</caption>\\n     * object.setGradient('fill', {\\n     *   type: 'linear',\\n     *   x1: -object.width / 2,\\n     *   y1: 0,\\n     *   x2: object.width / 2,\\n     *   y2: 0,\\n     *   colorStops: {\\n     *     0: 'red',\\n     *     0.5: '#005555',\\n     *     1: 'rgba(0,0,255,0.5)'\\n     *   }\\n     * });\\n     * canvas.renderAll();\\n     * @example <caption>Set radial gradient</caption>\\n     * object.setGradient('fill', {\\n     *   type: 'radial',\\n     *   x1: 0,\\n     *   y1: 0,\\n     *   x2: 0,\\n     *   y2: 0,\\n     *   r1: object.width / 2,\\n     *   r2: 10,\\n     *   colorStops: {\\n     *     0: 'red',\\n     *     0.5: '#005555',\\n     *     1: 'rgba(0,0,255,0.5)'\\n     *   }\\n     * });\\n     * canvas.renderAll();\\n     */\\n    setGradient: function(property, options) {\\n      options || (options = { });\\n\\n      var gradient = { colorStops: [] };\\n\\n      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');\\n      gradient.coords = {\\n        x1: options.x1,\\n        y1: options.y1,\\n        x2: options.x2,\\n        y2: options.y2\\n      };\\n\\n      if (options.r1 || options.r2) {\\n        gradient.coords.r1 = options.r1;\\n        gradient.coords.r2 = options.r2;\\n      }\\n\\n      options.gradientTransform && (gradient.gradientTransform = options.gradientTransform);\\n\\n      for (var position in options.colorStops) {\\n        var color = new fabric.Color(options.colorStops[position]);\\n        gradient.colorStops.push({\\n          offset: position,\\n          color: color.toRgb(),\\n          opacity: color.getAlpha()\\n        });\\n      }\\n\\n      return this.set(property, fabric.Gradient.forObject(this, gradient));\\n    },\\n\\n    /**\\n     * Sets pattern fill of an object\\n     * @param {Object} options Options object\\n     * @param {(String|HTMLImageElement)} options.source Pattern source\\n     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\\n     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner\\n     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}\\n     * @example <caption>Set pattern</caption>\\n     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {\\n     *   object.setPatternFill({\\n     *     source: img,\\n     *     repeat: 'repeat'\\n     *   });\\n     *   canvas.renderAll();\\n     * });\\n     */\\n    setPatternFill: function(options) {\\n      return this.set('fill', new fabric.Pattern(options));\\n    },\\n\\n    /**\\n     * Sets {@link fabric.Object#shadow|shadow} of an object\\n     * @param {Object|String} [options] Options object or string (e.g. \\\"2px 2px 10px rgba(0,0,0,0.2)\\\")\\n     * @param {String} [options.color=rgb(0,0,0)] Shadow color\\n     * @param {Number} [options.blur=0] Shadow blur\\n     * @param {Number} [options.offsetX=0] Shadow horizontal offset\\n     * @param {Number} [options.offsetY=0] Shadow vertical offset\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}\\n     * @example <caption>Set shadow with string notation</caption>\\n     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');\\n     * canvas.renderAll();\\n     * @example <caption>Set shadow with object notation</caption>\\n     * object.setShadow({\\n     *   color: 'red',\\n     *   blur: 10,\\n     *   offsetX: 20,\\n     *   offsetY: 20\\n     * });\\n     * canvas.renderAll();\\n     */\\n    setShadow: function(options) {\\n      return this.set('shadow', options ? new fabric.Shadow(options) : null);\\n    },\\n\\n    /**\\n     * Sets \\\"color\\\" of an instance (alias of `set('fill', &hellip;)`)\\n     * @param {String} color Color value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    setColor: function(color) {\\n      this.set('fill', color);\\n      return this;\\n    },\\n\\n    /**\\n     * Sets \\\"angle\\\" of an instance\\n     * @param {Number} angle Angle value (in degrees)\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    setAngle: function(angle) {\\n      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;\\n\\n      if (shouldCenterOrigin) {\\n        this._setOriginToCenter();\\n      }\\n\\n      this.set('angle', angle);\\n\\n      if (shouldCenterOrigin) {\\n        this._resetOrigin();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Centers object horizontally on canvas to which it was added last.\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    centerH: function () {\\n      this.canvas && this.canvas.centerObjectH(this);\\n      return this;\\n    },\\n\\n    /**\\n     * Centers object horizontally on current viewport of canvas to which it was added last.\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    viewportCenterH: function () {\\n      this.canvas && this.canvas.viewportCenterObjectH(this);\\n      return this;\\n    },\\n\\n    /**\\n     * Centers object vertically on canvas to which it was added last.\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    centerV: function () {\\n      this.canvas && this.canvas.centerObjectV(this);\\n      return this;\\n    },\\n\\n    /**\\n     * Centers object vertically on current viewport of canvas to which it was added last.\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    viewportCenterV: function () {\\n      this.canvas && this.canvas.viewportCenterObjectV(this);\\n      return this;\\n    },\\n\\n    /**\\n     * Centers object vertically and horizontally on canvas to which is was added last\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    center: function () {\\n      this.canvas && this.canvas.centerObject(this);\\n      return this;\\n    },\\n\\n    /**\\n     * Centers object on current viewport of canvas to which it was added last.\\n     * You might need to call `setCoords` on an object after centering, to update controls area.\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    viewportCenter: function () {\\n      this.canvas && this.canvas.viewportCenterObject(this);\\n      return this;\\n    },\\n\\n    /**\\n     * Removes object from canvas to which it was added last\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    remove: function() {\\n      this.canvas && this.canvas.remove(this);\\n      return this;\\n    },\\n\\n    /**\\n     * Returns coordinates of a pointer relative to an object\\n     * @param {Event} e Event to operate upon\\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\\n     * @return {Object} Coordinates of a pointer (x, y)\\n     */\\n    getLocalPointer: function(e, pointer) {\\n      pointer = pointer || this.canvas.getPointer(e);\\n      var pClicked = new fabric.Point(pointer.x, pointer.y),\\n          objectLeftTop = this._getLeftTopCoords();\\n      if (this.angle) {\\n        pClicked = fabric.util.rotatePoint(\\n          pClicked, objectLeftTop, fabric.util.degreesToRadians(-this.angle));\\n      }\\n      return {\\n        x: pClicked.x - objectLeftTop.x,\\n        y: pClicked.y - objectLeftTop.y\\n      };\\n    },\\n\\n    /**\\n     * Sets canvas globalCompositeOperation for specific object\\n     * custom composition operation for the particular object can be specifed using globalCompositeOperation property\\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\\n     */\\n    _setupCompositeOperation: function (ctx) {\\n      if (this.globalCompositeOperation) {\\n        ctx.globalCompositeOperation = this.globalCompositeOperation;\\n      }\\n    }\\n  });\\n\\n  fabric.util.createAccessors(fabric.Object);\\n\\n  /**\\n   * Alias for {@link fabric.Object.prototype.setAngle}\\n   * @alias rotate -> setAngle\\n   * @memberOf fabric.Object\\n   */\\n  fabric.Object.prototype.rotate = fabric.Object.prototype.setAngle;\\n\\n  extend(fabric.Object.prototype, fabric.Observable);\\n\\n  /**\\n   * Defines the number of fraction digits to use when serializing object values.\\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\\n   * @static\\n   * @memberOf fabric.Object\\n   * @constant\\n   * @type Number\\n   */\\n  fabric.Object.NUM_FRACTION_DIGITS = 2;\\n\\n  /**\\n   * Unique id used internally when creating SVG elements\\n   * @static\\n   * @memberOf fabric.Object\\n   * @type Number\\n   */\\n  fabric.Object.__uid = 0;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function() {\\n\\n  var degreesToRadians = fabric.util.degreesToRadians,\\n      originXOffset = {\\n        left: -0.5,\\n        center: 0,\\n        right: 0.5\\n      },\\n      originYOffset = {\\n        top: -0.5,\\n        center: 0,\\n        bottom: 0.5\\n      };\\n\\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n\\n    /**\\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\\n     * @return {fabric.Point}\\n     */\\n    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\\n      var x = point.x,\\n          y = point.y,\\n          offsetX, offsetY, dim;\\n\\n      if (typeof fromOriginX === 'string') {\\n        fromOriginX = originXOffset[fromOriginX];\\n      }\\n      else {\\n        fromOriginX -= 0.5;\\n      }\\n\\n      if (typeof toOriginX === 'string') {\\n        toOriginX = originXOffset[toOriginX];\\n      }\\n      else {\\n        toOriginX -= 0.5;\\n      }\\n\\n      offsetX = toOriginX - fromOriginX;\\n\\n      if (typeof fromOriginY === 'string') {\\n        fromOriginY = originYOffset[fromOriginY];\\n      }\\n      else {\\n        fromOriginY -= 0.5;\\n      }\\n\\n      if (typeof toOriginY === 'string') {\\n        toOriginY = originYOffset[toOriginY];\\n      }\\n      else {\\n        toOriginY -= 0.5;\\n      }\\n\\n      offsetY = toOriginY - fromOriginY;\\n\\n      if (offsetX || offsetY) {\\n        dim = this._getTransformedDimensions();\\n        x = point.x + offsetX * dim.x;\\n        y = point.y + offsetY * dim.y;\\n      }\\n\\n      return new fabric.Point(x, y);\\n    },\\n\\n    /**\\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\\n     * @return {fabric.Point}\\n     */\\n    translateToCenterPoint: function(point, originX, originY) {\\n      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');\\n      if (this.angle) {\\n        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\\n      }\\n      return p;\\n    },\\n\\n    /**\\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\\n     * @param {fabric.Point} center The point which corresponds to center of the object\\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\\n     * @return {fabric.Point}\\n     */\\n    translateToOriginPoint: function(center, originX, originY) {\\n      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);\\n      if (this.angle) {\\n        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\\n      }\\n      return p;\\n    },\\n\\n    /**\\n     * Returns the real center coordinates of the object\\n     * @return {fabric.Point}\\n     */\\n    getCenterPoint: function() {\\n      var leftTop = new fabric.Point(this.left, this.top);\\n      return this.translateToCenterPoint(leftTop, this.originX, this.originY);\\n    },\\n\\n    /**\\n     * Returns the coordinates of the object based on center coordinates\\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\\n     * @return {fabric.Point}\\n     */\\n    // getOriginPoint: function(center) {\\n    //   return this.translateToOriginPoint(center, this.originX, this.originY);\\n    // },\\n\\n    /**\\n     * Returns the coordinates of the object as if it has a different origin\\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\\n     * @return {fabric.Point}\\n     */\\n    getPointByOrigin: function(originX, originY) {\\n      var center = this.getCenterPoint();\\n      return this.translateToOriginPoint(center, originX, originY);\\n    },\\n\\n    /**\\n     * Returns the point in local coordinates\\n     * @param {fabric.Point} point The point relative to the global coordinate system\\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\\n     * @return {fabric.Point}\\n     */\\n    toLocalPoint: function(point, originX, originY) {\\n      var center = this.getCenterPoint(),\\n          p, p2;\\n\\n      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {\\n        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);\\n      }\\n      else {\\n        p = new fabric.Point(this.left, this.top);\\n      }\\n\\n      p2 = new fabric.Point(point.x, point.y);\\n      if (this.angle) {\\n        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\\n      }\\n      return p2.subtractEquals(p);\\n    },\\n\\n    /**\\n     * Returns the point in global coordinates\\n     * @param {fabric.Point} The point relative to the local coordinate system\\n     * @return {fabric.Point}\\n     */\\n    // toGlobalPoint: function(point) {\\n    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\\n    // },\\n\\n    /**\\n     * Sets the position of the object taking into consideration the object's origin\\n     * @param {fabric.Point} pos The new position of the object\\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\\n     * @return {void}\\n     */\\n    setPositionByOrigin: function(pos, originX, originY) {\\n      var center = this.translateToCenterPoint(pos, originX, originY),\\n          position = this.translateToOriginPoint(center, this.originX, this.originY);\\n\\n      this.set('left', position.x);\\n      this.set('top', position.y);\\n    },\\n\\n    /**\\n     * @param {String} to One of 'left', 'center', 'right'\\n     */\\n    adjustPosition: function(to) {\\n      var angle = degreesToRadians(this.angle),\\n          hypotFull = this.getWidth(),\\n          xFull = Math.cos(angle) * hypotFull,\\n          yFull = Math.sin(angle) * hypotFull,\\n          offsetFrom, offsetTo;\\n\\n      //TODO: this function does not consider mixed situation like top, center.\\n      if (typeof this.originX === 'string') {\\n        offsetFrom = originXOffset[this.originX];\\n      }\\n      else {\\n        offsetFrom = this.originX - 0.5;\\n      }\\n      if (typeof to === 'string') {\\n        offsetTo = originXOffset[to];\\n      }\\n      else {\\n        offsetTo = to - 0.5;\\n      }\\n      this.left += xFull * (offsetTo - offsetFrom);\\n      this.top += yFull * (offsetTo - offsetFrom);\\n      this.setCoords();\\n      this.originX = to;\\n    },\\n\\n    /**\\n     * Sets the origin/position of the object to it's center point\\n     * @private\\n     * @return {void}\\n     */\\n    _setOriginToCenter: function() {\\n      this._originalOriginX = this.originX;\\n      this._originalOriginY = this.originY;\\n\\n      var center = this.getCenterPoint();\\n\\n      this.originX = 'center';\\n      this.originY = 'center';\\n\\n      this.left = center.x;\\n      this.top = center.y;\\n    },\\n\\n    /**\\n     * Resets the origin/position of the object to it's original origin\\n     * @private\\n     * @return {void}\\n     */\\n    _resetOrigin: function() {\\n      var originPoint = this.translateToOriginPoint(\\n        this.getCenterPoint(),\\n        this._originalOriginX,\\n        this._originalOriginY);\\n\\n      this.originX = this._originalOriginX;\\n      this.originY = this._originalOriginY;\\n\\n      this.left = originPoint.x;\\n      this.top = originPoint.y;\\n\\n      this._originalOriginX = null;\\n      this._originalOriginY = null;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getLeftTopCoords: function() {\\n      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');\\n    }\\n  });\\n\\n})();\\n\\n\\n(function() {\\n\\n  function getCoords(oCoords) {\\n    return [\\n      new fabric.Point(oCoords.tl.x, oCoords.tl.y),\\n      new fabric.Point(oCoords.tr.x, oCoords.tr.y),\\n      new fabric.Point(oCoords.br.x, oCoords.br.y),\\n      new fabric.Point(oCoords.bl.x, oCoords.bl.y)\\n    ];\\n  }\\n\\n  var degreesToRadians = fabric.util.degreesToRadians,\\n      multiplyMatrices = fabric.util.multiplyTransformMatrices;\\n\\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n\\n    /**\\n     * Object containing coordinates of object's controls\\n     * @type Object\\n     * @default\\n     */\\n    oCoords: null,\\n\\n    /**\\n     * Checks if object intersects with an area formed by 2 points\\n     * @param {Object} pointTL top-left point of area\\n     * @param {Object} pointBR bottom-right point of area\\n     * @return {Boolean} true if object intersects with an area formed by 2 points\\n     */\\n    intersectsWithRect: function(pointTL, pointBR) {\\n      var oCoords = getCoords(this.oCoords),\\n          intersection = fabric.Intersection.intersectPolygonRectangle(\\n            oCoords,\\n            pointTL,\\n            pointBR\\n          );\\n      return intersection.status === 'Intersection';\\n    },\\n\\n    /**\\n     * Checks if object intersects with another object\\n     * @param {Object} other Object to test\\n     * @return {Boolean} true if object intersects with another object\\n     */\\n    intersectsWithObject: function(other) {\\n      var intersection = fabric.Intersection.intersectPolygonPolygon(\\n            getCoords(this.oCoords),\\n            getCoords(other.oCoords)\\n          );\\n\\n      return intersection.status === 'Intersection'\\n        || other.isContainedWithinObject(this)\\n        || this.isContainedWithinObject(other);\\n    },\\n\\n    /**\\n     * Checks if object is fully contained within area of another object\\n     * @param {Object} other Object to test\\n     * @return {Boolean} true if object is fully contained within area of another object\\n     */\\n    isContainedWithinObject: function(other) {\\n      var points = getCoords(this.oCoords),\\n          i = 0;\\n      for (; i < 4; i++) {\\n        if (!other.containsPoint(points[i])) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    },\\n\\n    /**\\n     * Checks if object is fully contained within area formed by 2 points\\n     * @param {Object} pointTL top-left point of area\\n     * @param {Object} pointBR bottom-right point of area\\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\\n     */\\n    isContainedWithinRect: function(pointTL, pointBR) {\\n      var boundingRect = this.getBoundingRect();\\n\\n      return (\\n        boundingRect.left >= pointTL.x &&\\n        boundingRect.left + boundingRect.width <= pointBR.x &&\\n        boundingRect.top >= pointTL.y &&\\n        boundingRect.top + boundingRect.height <= pointBR.y\\n      );\\n    },\\n\\n    /**\\n     * Checks if point is inside the object\\n     * @param {fabric.Point} point Point to check against\\n     * @return {Boolean} true if point is inside the object\\n     */\\n    containsPoint: function(point) {\\n      if (!this.oCoords) {\\n        this.setCoords();\\n      }\\n      var lines = this._getImageLines(this.oCoords),\\n          xPoints = this._findCrossPoints(point, lines);\\n\\n      // if xPoints is odd then point is inside the object\\n      return (xPoints !== 0 && xPoints % 2 === 1);\\n    },\\n\\n    /**\\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\\n     * @private\\n     * @param {Object} oCoords Coordinates of the object corners\\n     */\\n    _getImageLines: function(oCoords) {\\n      return {\\n        topline: {\\n          o: oCoords.tl,\\n          d: oCoords.tr\\n        },\\n        rightline: {\\n          o: oCoords.tr,\\n          d: oCoords.br\\n        },\\n        bottomline: {\\n          o: oCoords.br,\\n          d: oCoords.bl\\n        },\\n        leftline: {\\n          o: oCoords.bl,\\n          d: oCoords.tl\\n        }\\n      };\\n    },\\n\\n    /**\\n     * Helper method to determine how many cross points are between the 4 object edges\\n     * and the horizontal line determined by a point on canvas\\n     * @private\\n     * @param {fabric.Point} point Point to check\\n     * @param {Object} oCoords Coordinates of the object being evaluated\\n     */\\n     // remove yi, not used but left code here just in case.\\n    _findCrossPoints: function(point, oCoords) {\\n      var b1, b2, a1, a2, xi, // yi,\\n          xcount = 0,\\n          iLine;\\n\\n      for (var lineKey in oCoords) {\\n        iLine = oCoords[lineKey];\\n        // optimisation 1: line below point. no cross\\n        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {\\n          continue;\\n        }\\n        // optimisation 2: line above point. no cross\\n        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {\\n          continue;\\n        }\\n        // optimisation 3: vertical line case\\n        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {\\n          xi = iLine.o.x;\\n          // yi = point.y;\\n        }\\n        // calculate the intersection point\\n        else {\\n          b1 = 0;\\n          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\\n          a1 = point.y - b1 * point.x;\\n          a2 = iLine.o.y - b2 * iLine.o.x;\\n\\n          xi = -(a1 - a2) / (b1 - b2);\\n          // yi = a1 + b1 * xi;\\n        }\\n        // dont count xi < point.x cases\\n        if (xi >= point.x) {\\n          xcount += 1;\\n        }\\n        // optimisation 4: specific for square images\\n        if (xcount === 2) {\\n          break;\\n        }\\n      }\\n      return xcount;\\n    },\\n\\n    /**\\n     * Returns width of an object's bounding rectangle\\n     * @deprecated since 1.0.4\\n     * @return {Number} width value\\n     */\\n    getBoundingRectWidth: function() {\\n      return this.getBoundingRect().width;\\n    },\\n\\n    /**\\n     * Returns height of an object's bounding rectangle\\n     * @deprecated since 1.0.4\\n     * @return {Number} height value\\n     */\\n    getBoundingRectHeight: function() {\\n      return this.getBoundingRect().height;\\n    },\\n\\n    /**\\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\\n     * the box is intented as aligned to axis of canvas.\\n     * @param {Boolean} ignoreVpt bounding box will not be affected by viewportTransform\\n     * @return {Object} Object with left, top, width, height properties\\n     */\\n    getBoundingRect: function(ignoreVpt) {\\n      var coords = this.calcCoords(ignoreVpt);\\n      return fabric.util.makeBoundingBoxFromPoints([\\n        coords.tl,\\n        coords.tr,\\n        coords.br,\\n        coords.bl\\n      ]);\\n    },\\n\\n    /**\\n     * Returns width of an object bounding box counting transformations\\n     * @return {Number} width value\\n     */\\n    getWidth: function() {\\n      return this._getTransformedDimensions().x;\\n    },\\n\\n    /**\\n     * Returns height of an object bounding box counting transformations\\n     * to be renamed in 2.0\\n     * @return {Number} height value\\n     */\\n    getHeight: function() {\\n      return this._getTransformedDimensions().y;\\n    },\\n\\n    /**\\n     * Makes sure the scale is valid and modifies it if necessary\\n     * @private\\n     * @param {Number} value\\n     * @return {Number}\\n     */\\n    _constrainScale: function(value) {\\n      if (Math.abs(value) < this.minScaleLimit) {\\n        if (value < 0) {\\n          return -this.minScaleLimit;\\n        }\\n        else {\\n          return this.minScaleLimit;\\n        }\\n      }\\n      return value;\\n    },\\n\\n    /**\\n     * Scales an object (equally by x and y)\\n     * @param {Number} value Scale factor\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    scale: function(value) {\\n      value = this._constrainScale(value);\\n\\n      if (value < 0) {\\n        this.flipX = !this.flipX;\\n        this.flipY = !this.flipY;\\n        value *= -1;\\n      }\\n\\n      this.scaleX = value;\\n      this.scaleY = value;\\n      return this.setCoords();\\n    },\\n\\n    /**\\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\\n     * @param {Number} value New width value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    scaleToWidth: function(value) {\\n      // adjust to bounding rect factor so that rotated shapes would fit as well\\n      var boundingRectFactor = this.getBoundingRect().width / this.getWidth();\\n      return this.scale(value / this.width / boundingRectFactor);\\n    },\\n\\n    /**\\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\\n     * @param {Number} value New height value\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    scaleToHeight: function(value) {\\n      // adjust to bounding rect factor so that rotated shapes would fit as well\\n      var boundingRectFactor = this.getBoundingRect().height / this.getHeight();\\n      return this.scale(value / this.height / boundingRectFactor);\\n    },\\n\\n    /**\\n     * Calculate and returns the .coords of an object.\\n     * @return {Object} Object with tl, tr, br, bl ....\\n     * @chainable\\n     */\\n    calcCoords: function(ignoreVpt) {\\n      var theta = degreesToRadians(this.angle),\\n          vpt = this.getViewportTransform(),\\n          dim = ignoreVpt ? this._getTransformedDimensions() : this._calculateCurrentDimensions(),\\n          currentWidth = dim.x, currentHeight = dim.y,\\n          sinTh = Math.sin(theta),\\n          cosTh = Math.cos(theta),\\n          _angle = currentWidth > 0 ? Math.atan(currentHeight / currentWidth) : 0,\\n          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,\\n          offsetX = Math.cos(_angle + theta) * _hypotenuse,\\n          offsetY = Math.sin(_angle + theta) * _hypotenuse,\\n          center = this.getCenterPoint(),\\n          // offset added for rotate and scale actions\\n          coords = ignoreVpt ? center : fabric.util.transformPoint(center, vpt),\\n          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),\\n          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),\\n          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),\\n          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY),\\n          ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),\\n          mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),\\n          mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),\\n          mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),\\n          mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);\\n      // debugging\\n\\n      /* setTimeout(function() {\\n         canvas.contextTop.fillStyle = 'green';\\n         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);\\n         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);\\n         canvas.contextTop.fillRect(br.x, br.y, 3, 3);\\n         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);\\n         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);\\n         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);\\n         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);\\n         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);\\n         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);\\n       }, 50); */\\n\\n      return {\\n        // corners\\n        tl: tl, tr: tr, br: br, bl: bl,\\n        // middle\\n        ml: ml, mt: mt, mr: mr, mb: mb,\\n        // rotating point\\n        mtr: mtr\\n      };\\n    },\\n\\n    /**\\n     * Sets corner position coordinates based on current angle, width and height\\n     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    setCoords: function(ignoreZoom) {\\n      this.oCoords = this.calcCoords(ignoreZoom);\\n\\n      // set coordinates of the draggable boxes in the corners used to scale/rotate the image\\n      ignoreZoom || this._setCornerCoords && this._setCornerCoords();\\n\\n      return this;\\n    },\\n\\n    /*\\n     * calculate rotation matrix of an object\\n     * @return {Array} rotation matrix for the object\\n     */\\n    _calcRotateMatrix: function() {\\n      if (this.angle) {\\n        var theta = degreesToRadians(this.angle), cos = Math.cos(theta), sin = Math.sin(theta);\\n        return [cos, sin, -sin, cos, 0, 0];\\n      }\\n      return [1, 0, 0, 1, 0, 0];\\n    },\\n\\n    /*\\n     * calculate trasform Matrix that represent current transformation from\\n     * object properties.\\n     * @return {Array} matrix Transform Matrix for the object\\n     */\\n    calcTransformMatrix: function() {\\n      var center = this.getCenterPoint(),\\n          translateMatrix = [1, 0, 0, 1, center.x, center.y],\\n          rotateMatrix = this._calcRotateMatrix(),\\n          dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true),\\n          matrix = this.group ? this.group.calcTransformMatrix() : [1, 0, 0, 1, 0, 0];\\n      matrix = multiplyMatrices(matrix, translateMatrix);\\n      matrix = multiplyMatrices(matrix, rotateMatrix);\\n      matrix = multiplyMatrices(matrix, dimensionMatrix);\\n      return matrix;\\n    },\\n\\n    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {\\n      var skewMatrixX = [1, 0, Math.tan(degreesToRadians(skewX)), 1],\\n          skewMatrixY = [1, Math.tan(degreesToRadians(skewY)), 0, 1],\\n          scaleX = this.scaleX * (flipping && this.flipX ? -1 : 1),\\n          scaleY = this.scaleY * (flipping && this.flipY ? -1 : 1),\\n          scaleMatrix = [scaleX, 0, 0, scaleY],\\n          m = multiplyMatrices(scaleMatrix, skewMatrixX, true);\\n      return multiplyMatrices(m, skewMatrixY, true);\\n    }\\n  });\\n})();\\n\\n\\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n\\n  /**\\n   * Moves an object to the bottom of the stack of drawn objects\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  sendToBack: function() {\\n    if (this.group) {\\n      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\\n    }\\n    else {\\n      this.canvas.sendToBack(this);\\n    }\\n    return this;\\n  },\\n\\n  /**\\n   * Moves an object to the top of the stack of drawn objects\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  bringToFront: function() {\\n    if (this.group) {\\n      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\\n    }\\n    else {\\n      this.canvas.bringToFront(this);\\n    }\\n    return this;\\n  },\\n\\n  /**\\n   * Moves an object down in stack of drawn objects\\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  sendBackwards: function(intersecting) {\\n    if (this.group) {\\n      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\\n    }\\n    else {\\n      this.canvas.sendBackwards(this, intersecting);\\n    }\\n    return this;\\n  },\\n\\n  /**\\n   * Moves an object up in stack of drawn objects\\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  bringForward: function(intersecting) {\\n    if (this.group) {\\n      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\\n    }\\n    else {\\n      this.canvas.bringForward(this, intersecting);\\n    }\\n    return this;\\n  },\\n\\n  /**\\n   * Moves an object to specified level in stack of drawn objects\\n   * @param {Number} index New position of object\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  moveTo: function(index) {\\n    if (this.group) {\\n      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\\n    }\\n    else {\\n      this.canvas.moveTo(this, index);\\n    }\\n    return this;\\n  }\\n});\\n\\n\\n/* _TO_SVG_START_ */\\n(function() {\\n\\n  function getSvgColorString(prop, value) {\\n    if (!value) {\\n      return prop + ': none; ';\\n    }\\n    else if (value.toLive) {\\n      return prop + ': url(#SVGID_' + value.id + '); ';\\n    }\\n    else {\\n      var color = new fabric.Color(value),\\n          str = prop + ': ' + color.toRgb() + '; ',\\n          opacity = color.getAlpha();\\n      if (opacity !== 1) {\\n        //change the color in rgb + opacity\\n        str += prop + '-opacity: ' + opacity.toString() + '; ';\\n      }\\n      return str;\\n    }\\n  }\\n\\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n    /**\\n     * Returns styles-string for svg-export\\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\\n     * @return {String}\\n     */\\n    getSvgStyles: function(skipShadow) {\\n\\n      var fillRule = this.fillRule,\\n          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',\\n          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',\\n          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',\\n          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',\\n          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',\\n          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',\\n          visibility = this.visible ? '' : ' visibility: hidden;',\\n          filter = skipShadow ? '' : this.getSvgFilter(),\\n          fill = getSvgColorString('fill', this.fill),\\n          stroke = getSvgColorString('stroke', this.stroke);\\n\\n      return [\\n        stroke,\\n        'stroke-width: ', strokeWidth, '; ',\\n        'stroke-dasharray: ', strokeDashArray, '; ',\\n        'stroke-linecap: ', strokeLineCap, '; ',\\n        'stroke-linejoin: ', strokeLineJoin, '; ',\\n        'stroke-miterlimit: ', strokeMiterLimit, '; ',\\n        fill,\\n        'fill-rule: ', fillRule, '; ',\\n        'opacity: ', opacity, ';',\\n        filter,\\n        visibility\\n      ].join('');\\n    },\\n\\n    /**\\n     * Returns filter for svg shadow\\n     * @return {String}\\n     */\\n    getSvgFilter: function() {\\n      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';\\n    },\\n\\n    /**\\n     * Returns id attribute for svg output\\n     * @return {String}\\n     */\\n    getSvgId: function() {\\n      return this.id ? 'id=\\\"' + this.id + '\\\" ' : '';\\n    },\\n\\n    /**\\n     * Returns transform-string for svg-export\\n     * @return {String}\\n     */\\n    getSvgTransform: function() {\\n      if (this.group && this.group.type === 'path-group') {\\n        return '';\\n      }\\n      var toFixed = fabric.util.toFixed,\\n          angle = this.getAngle(),\\n          skewX = (this.getSkewX() % 360),\\n          skewY = (this.getSkewY() % 360),\\n          center = this.getCenterPoint(),\\n\\n          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\\n\\n          translatePart = this.type === 'path-group' ? '' : 'translate(' +\\n                            toFixed(center.x, NUM_FRACTION_DIGITS) +\\n                            ' ' +\\n                            toFixed(center.y, NUM_FRACTION_DIGITS) +\\n                          ')',\\n\\n          anglePart = angle !== 0\\n            ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')\\n            : '',\\n\\n          scalePart = (this.scaleX === 1 && this.scaleY === 1)\\n            ? '' :\\n            (' scale(' +\\n              toFixed(this.scaleX, NUM_FRACTION_DIGITS) +\\n              ' ' +\\n              toFixed(this.scaleY, NUM_FRACTION_DIGITS) +\\n            ')'),\\n\\n          skewXPart = skewX !== 0 ? ' skewX(' + toFixed(skewX, NUM_FRACTION_DIGITS) + ')' : '',\\n\\n          skewYPart = skewY !== 0 ? ' skewY(' + toFixed(skewY, NUM_FRACTION_DIGITS) + ')' : '',\\n\\n          addTranslateX = this.type === 'path-group' ? this.width : 0,\\n\\n          flipXPart = this.flipX ? ' matrix(-1 0 0 1 ' + addTranslateX + ' 0) ' : '',\\n\\n          addTranslateY = this.type === 'path-group' ? this.height : 0,\\n\\n          flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 ' + addTranslateY + ')' : '';\\n\\n      return [\\n        translatePart, anglePart, scalePart, flipXPart, flipYPart, skewXPart, skewYPart\\n      ].join('');\\n    },\\n\\n    /**\\n     * Returns transform-string for svg-export from the transform matrix of single elements\\n     * @return {String}\\n     */\\n    getSvgTransformMatrix: function() {\\n      return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _createBaseSVGMarkup: function() {\\n      var markup = [];\\n\\n      if (this.fill && this.fill.toLive) {\\n        markup.push(this.fill.toSVG(this, false));\\n      }\\n      if (this.stroke && this.stroke.toLive) {\\n        markup.push(this.stroke.toSVG(this, false));\\n      }\\n      if (this.shadow) {\\n        markup.push(this.shadow.toSVG(this));\\n      }\\n      return markup;\\n    }\\n  });\\n})();\\n/* _TO_SVG_END_ */\\n\\n\\n(function() {\\n\\n  var extend = fabric.util.object.extend,\\n      originalSet = 'stateProperties';\\n\\n  /*\\n    Depends on `stateProperties`\\n  */\\n  function saveProps(origin, destination, props) {\\n    var tmpObj = { }, deep = true;\\n    props.forEach(function(prop) {\\n      tmpObj[prop] = origin[prop];\\n    });\\n    extend(origin[destination], tmpObj, deep);\\n  }\\n\\n  function _isEqual(origValue, currentValue, firstPass) {\\n    if (!fabric.isLikelyNode && origValue instanceof Element) {\\n      // avoid checking deep html elements\\n      return origValue === currentValue;\\n    }\\n    else if (origValue instanceof Array) {\\n      if (origValue.length !== currentValue.length) {\\n        return false\\n      }\\n      for (var i = 0, len = origValue.length; i < len; i++) {\\n        if (origValue[i] !== currentValue[i]) {\\n          return false;\\n        }\\n      }\\n      return true\\n    }\\n    else if (origValue && typeof origValue === 'object') {\\n      if (!firstPass && Object.keys(origValue).length !== Object.keys(currentValue).length) {\\n        return false;\\n      }\\n      for (var key in origValue) {\\n        if (!_isEqual(origValue[key], currentValue[key])) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }\\n    else {\\n      return origValue === currentValue;\\n    }\\n  }\\n\\n\\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n\\n    /**\\n     * Returns true if object state (one of its state properties) was changed\\n     * @param {String} [propertySet] optional name for the set of property we want to save\\n     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\\n     */\\n    hasStateChanged: function(propertySet) {\\n      propertySet = propertySet || originalSet;\\n      propertySet = '_' + propertySet;\\n      return !_isEqual(this[propertySet], this, true);\\n    },\\n\\n    /**\\n     * Saves state of an object\\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\\n     * @return {fabric.Object} thisArg\\n     */\\n    saveState: function(options) {\\n      var propertySet = options && options.propertySet || originalSet,\\n          destination = '_' + propertySet;\\n      saveProps(this, destination, this[propertySet]);\\n      if (options && options.stateProperties) {\\n        saveProps(this, destination, options.stateProperties);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Setups state of an object\\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\\n     * @return {fabric.Object} thisArg\\n     */\\n    setupState: function(options) {\\n      options = options || { };\\n      var propertySet = options.propertySet || originalSet;\\n      options.propertySet = propertySet;\\n      this['_' + propertySet] = { };\\n      this.saveState(options);\\n      return this;\\n    }\\n  });\\n})();\\n\\n\\n(function() {\\n\\n  var degreesToRadians = fabric.util.degreesToRadians,\\n      /* eslint-disable camelcase */\\n      isVML = function() { return typeof G_vmlCanvasManager !== 'undefined'; };\\n      /* eslint-enable camelcase */\\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n\\n    /**\\n     * The object interactivity controls.\\n     * @private\\n     */\\n    _controlsVisibility: null,\\n\\n    /**\\n     * Determines which corner has been clicked\\n     * @private\\n     * @param {Object} pointer The pointer indicating the mouse position\\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\\n     */\\n    _findTargetCorner: function(pointer) {\\n      if (!this.hasControls || !this.active) {\\n        return false;\\n      }\\n\\n      var ex = pointer.x,\\n          ey = pointer.y,\\n          xPoints,\\n          lines;\\n      this.__corner = 0;\\n      for (var i in this.oCoords) {\\n\\n        if (!this.isControlVisible(i)) {\\n          continue;\\n        }\\n\\n        if (i === 'mtr' && !this.hasRotatingPoint) {\\n          continue;\\n        }\\n\\n        if (this.get('lockUniScaling') &&\\n           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {\\n          continue;\\n        }\\n\\n        lines = this._getImageLines(this.oCoords[i].corner);\\n\\n        // debugging\\n\\n        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\\n        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\\n\\n        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\\n        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\\n\\n        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\\n        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\\n\\n        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\\n        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\\n\\n        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);\\n        if (xPoints !== 0 && xPoints % 2 === 1) {\\n          this.__corner = i;\\n          return i;\\n        }\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Sets the coordinates of the draggable boxes in the corners of\\n     * the image used to scale/rotate it.\\n     * @private\\n     */\\n    _setCornerCoords: function() {\\n      var coords = this.oCoords,\\n          newTheta = degreesToRadians(45 - this.angle),\\n          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */\\n          /* 0.707106 stands for sqrt(2)/2 */\\n          cornerHypotenuse = this.cornerSize * 0.707106,\\n          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),\\n          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),\\n          x, y;\\n\\n      for (var point in coords) {\\n        x = coords[point].x;\\n        y = coords[point].y;\\n        coords[point].corner = {\\n          tl: {\\n            x: x - sinHalfOffset,\\n            y: y - cosHalfOffset\\n          },\\n          tr: {\\n            x: x + cosHalfOffset,\\n            y: y - sinHalfOffset\\n          },\\n          bl: {\\n            x: x - cosHalfOffset,\\n            y: y + sinHalfOffset\\n          },\\n          br: {\\n            x: x + sinHalfOffset,\\n            y: y + cosHalfOffset\\n          }\\n        };\\n      }\\n    },\\n\\n    /*\\n     * Calculate object dimensions from its properties\\n     * @private\\n     */\\n    _getNonTransformedDimensions: function() {\\n      var strokeWidth = this.strokeWidth,\\n          w = this.width + strokeWidth,\\n          h = this.height + strokeWidth;\\n      return { x: w, y: h };\\n    },\\n\\n    /*\\n     * @private\\n     */\\n    _getTransformedDimensions: function(skewX, skewY) {\\n      if (typeof skewX === 'undefined') {\\n        skewX = this.skewX;\\n      }\\n      if (typeof skewY === 'undefined') {\\n        skewY = this.skewY;\\n      }\\n      var dimensions = this._getNonTransformedDimensions(),\\n          dimX = dimensions.x / 2, dimY = dimensions.y / 2,\\n          points = [\\n            {\\n              x: -dimX,\\n              y: -dimY\\n            },\\n            {\\n              x: dimX,\\n              y: -dimY\\n            },\\n            {\\n              x: -dimX,\\n              y: dimY\\n            },\\n            {\\n              x: dimX,\\n              y: dimY\\n            }],\\n          i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),\\n          bbox;\\n      for (i = 0; i < points.length; i++) {\\n        points[i] = fabric.util.transformPoint(points[i], transformMatrix);\\n      }\\n      bbox = fabric.util.makeBoundingBoxFromPoints(points);\\n      return { x: bbox.width, y: bbox.height };\\n    },\\n\\n    /*\\n     * private\\n     */\\n    _calculateCurrentDimensions: function()  {\\n      var vpt = this.getViewportTransform(),\\n          dim = this._getTransformedDimensions(),\\n          p = fabric.util.transformPoint(dim, vpt, true);\\n\\n      return p.scalarAdd(2 * this.padding);\\n    },\\n\\n    /**\\n     * Draws a colored layer behind the object, inside its selection borders.\\n     * Requires public options: padding, selectionBackgroundColor\\n     * this function is called when the context is transformed\\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    drawSelectionBackground: function(ctx) {\\n      if (!this.selectionBackgroundColor || this.group || !this.active) {\\n        return this;\\n      }\\n      ctx.save();\\n      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),\\n          vpt = this.canvas.viewportTransform;\\n      ctx.translate(center.x, center.y);\\n      ctx.scale(1 / vpt[0], 1 / vpt[3]);\\n      ctx.rotate(degreesToRadians(this.angle));\\n      ctx.fillStyle = this.selectionBackgroundColor;\\n      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);\\n      ctx.restore();\\n      return this;\\n    },\\n\\n    /**\\n     * Draws borders of an object's bounding box.\\n     * Requires public properties: width, height\\n     * Requires public options: padding, borderColor\\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    drawBorders: function(ctx) {\\n      if (!this.hasBorders) {\\n        return this;\\n      }\\n\\n      var wh = this._calculateCurrentDimensions(),\\n          strokeWidth = 1 / this.borderScaleFactor,\\n          width = wh.x + strokeWidth,\\n          height = wh.y + strokeWidth;\\n\\n      ctx.save();\\n      ctx.strokeStyle = this.borderColor;\\n      this._setLineDash(ctx, this.borderDashArray, null);\\n\\n      ctx.strokeRect(\\n        -width / 2,\\n        -height / 2,\\n        width,\\n        height\\n      );\\n\\n      if (this.hasRotatingPoint && this.isControlVisible('mtr') && !this.get('lockRotation') && this.hasControls) {\\n\\n        var rotateHeight = -height / 2;\\n\\n        ctx.beginPath();\\n        ctx.moveTo(0, rotateHeight);\\n        ctx.lineTo(0, rotateHeight - this.rotatingPointOffset);\\n        ctx.closePath();\\n        ctx.stroke();\\n      }\\n\\n      ctx.restore();\\n      return this;\\n    },\\n\\n    /**\\n     * Draws borders of an object's bounding box when it is inside a group.\\n     * Requires public properties: width, height\\n     * Requires public options: padding, borderColor\\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\\n     * @param {object} options object representing current object parameters\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    drawBordersInGroup: function(ctx, options) {\\n      if (!this.hasBorders) {\\n        return this;\\n      }\\n\\n      var p = this._getNonTransformedDimensions(),\\n          matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),\\n          wh = fabric.util.transformPoint(p, matrix),\\n          strokeWidth = 1 / this.borderScaleFactor,\\n          width = wh.x + strokeWidth,\\n          height = wh.y + strokeWidth;\\n\\n      ctx.save();\\n      this._setLineDash(ctx, this.borderDashArray, null);\\n      ctx.strokeStyle = this.borderColor;\\n\\n      ctx.strokeRect(\\n        -width / 2,\\n        -height / 2,\\n        width,\\n        height\\n      );\\n\\n      ctx.restore();\\n      return this;\\n    },\\n\\n    /**\\n     * Draws corners of an object's bounding box.\\n     * Requires public properties: width, height\\n     * Requires public options: cornerSize, padding\\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    drawControls: function(ctx) {\\n      if (!this.hasControls) {\\n        return this;\\n      }\\n\\n      var wh = this._calculateCurrentDimensions(),\\n          width = wh.x,\\n          height = wh.y,\\n          scaleOffset = this.cornerSize,\\n          left = -(width + scaleOffset) / 2,\\n          top = -(height + scaleOffset) / 2,\\n          methodName = this.transparentCorners ? 'stroke' : 'fill';\\n\\n      ctx.save();\\n      ctx.strokeStyle = ctx.fillStyle = this.cornerColor;\\n      if (!this.transparentCorners) {\\n        ctx.strokeStyle = this.cornerStrokeColor;\\n      }\\n      this._setLineDash(ctx, this.cornerDashArray, null);\\n\\n      // top-left\\n      this._drawControl('tl', ctx, methodName,\\n        left,\\n        top);\\n\\n      // top-right\\n      this._drawControl('tr', ctx, methodName,\\n        left + width,\\n        top);\\n\\n      // bottom-left\\n      this._drawControl('bl', ctx, methodName,\\n        left,\\n        top + height);\\n\\n      // bottom-right\\n      this._drawControl('br', ctx, methodName,\\n        left + width,\\n        top + height);\\n\\n      if (!this.get('lockUniScaling')) {\\n\\n        // middle-top\\n        this._drawControl('mt', ctx, methodName,\\n          left + width / 2,\\n          top);\\n\\n        // middle-bottom\\n        this._drawControl('mb', ctx, methodName,\\n          left + width / 2,\\n          top + height);\\n\\n        // middle-right\\n        this._drawControl('mr', ctx, methodName,\\n          left + width,\\n          top + height / 2);\\n\\n        // middle-left\\n        this._drawControl('ml', ctx, methodName,\\n          left,\\n          top + height / 2);\\n      }\\n\\n      // middle-top-rotate\\n      if (this.hasRotatingPoint) {\\n        this._drawControl('mtr', ctx, methodName,\\n          left + width / 2,\\n          top - this.rotatingPointOffset);\\n      }\\n\\n      ctx.restore();\\n\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _drawControl: function(control, ctx, methodName, left, top) {\\n      if (!this.isControlVisible(control)) {\\n        return;\\n      }\\n      var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;\\n      switch (this.cornerStyle) {\\n        case 'circle':\\n          ctx.beginPath();\\n          ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);\\n          ctx[methodName]();\\n          if (stroke) {\\n            ctx.stroke();\\n          }\\n          break;\\n        default:\\n          isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);\\n          ctx[methodName + 'Rect'](left, top, size, size);\\n          if (stroke) {\\n            ctx.strokeRect(left, top, size, size);\\n          }\\n      }\\n    },\\n\\n    /**\\n     * Returns true if the specified control is visible, false otherwise.\\n     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\\n     * @returns {Boolean} true if the specified control is visible, false otherwise\\n     */\\n    isControlVisible: function(controlName) {\\n      return this._getControlsVisibility()[controlName];\\n    },\\n\\n    /**\\n     * Sets the visibility of the specified control.\\n     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    setControlVisible: function(controlName, visible) {\\n      this._getControlsVisibility()[controlName] = visible;\\n      return this;\\n    },\\n\\n    /**\\n     * Sets the visibility state of object controls.\\n     * @param {Object} [options] Options object\\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\\n     * @return {fabric.Object} thisArg\\n     * @chainable\\n     */\\n    setControlsVisibility: function(options) {\\n      options || (options = { });\\n\\n      for (var p in options) {\\n        this.setControlVisible(p, options[p]);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Returns the instance of the control visibility set for this object.\\n     * @private\\n     * @returns {Object}\\n     */\\n    _getControlsVisibility: function() {\\n      if (!this._controlsVisibility) {\\n        this._controlsVisibility = {\\n          tl: true,\\n          tr: true,\\n          br: true,\\n          bl: true,\\n          ml: true,\\n          mt: true,\\n          mr: true,\\n          mb: true,\\n          mtr: true\\n        };\\n      }\\n      return this._controlsVisibility;\\n    }\\n  });\\n})();\\n\\n\\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\\n\\n  /**\\n   * Animation duration (in ms) for fx* methods\\n   * @type Number\\n   * @default\\n   */\\n  FX_DURATION: 500,\\n\\n  /**\\n   * Centers object horizontally with animation.\\n   * @param {fabric.Object} object Object to center\\n   * @param {Object} [callbacks] Callbacks object with optional \\\"onComplete\\\" and/or \\\"onChange\\\" properties\\n   * @param {Function} [callbacks.onComplete] Invoked on completion\\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\\n   * @return {fabric.Canvas} thisArg\\n   * @chainable\\n   */\\n  fxCenterObjectH: function (object, callbacks) {\\n    callbacks = callbacks || { };\\n\\n    var empty = function() { },\\n        onComplete = callbacks.onComplete || empty,\\n        onChange = callbacks.onChange || empty,\\n        _this = this;\\n\\n    fabric.util.animate({\\n      startValue: object.get('left'),\\n      endValue: this.getCenter().left,\\n      duration: this.FX_DURATION,\\n      onChange: function(value) {\\n        object.set('left', value);\\n        _this.renderAll();\\n        onChange();\\n      },\\n      onComplete: function() {\\n        object.setCoords();\\n        onComplete();\\n      }\\n    });\\n\\n    return this;\\n  },\\n\\n  /**\\n   * Centers object vertically with animation.\\n   * @param {fabric.Object} object Object to center\\n   * @param {Object} [callbacks] Callbacks object with optional \\\"onComplete\\\" and/or \\\"onChange\\\" properties\\n   * @param {Function} [callbacks.onComplete] Invoked on completion\\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\\n   * @return {fabric.Canvas} thisArg\\n   * @chainable\\n   */\\n  fxCenterObjectV: function (object, callbacks) {\\n    callbacks = callbacks || { };\\n\\n    var empty = function() { },\\n        onComplete = callbacks.onComplete || empty,\\n        onChange = callbacks.onChange || empty,\\n        _this = this;\\n\\n    fabric.util.animate({\\n      startValue: object.get('top'),\\n      endValue: this.getCenter().top,\\n      duration: this.FX_DURATION,\\n      onChange: function(value) {\\n        object.set('top', value);\\n        _this.renderAll();\\n        onChange();\\n      },\\n      onComplete: function() {\\n        object.setCoords();\\n        onComplete();\\n      }\\n    });\\n\\n    return this;\\n  },\\n\\n  /**\\n   * Same as `fabric.Canvas#remove` but animated\\n   * @param {fabric.Object} object Object to remove\\n   * @param {Object} [callbacks] Callbacks object with optional \\\"onComplete\\\" and/or \\\"onChange\\\" properties\\n   * @param {Function} [callbacks.onComplete] Invoked on completion\\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\\n   * @return {fabric.Canvas} thisArg\\n   * @chainable\\n   */\\n  fxRemove: function (object, callbacks) {\\n    callbacks = callbacks || { };\\n\\n    var empty = function() { },\\n        onComplete = callbacks.onComplete || empty,\\n        onChange = callbacks.onChange || empty,\\n        _this = this;\\n\\n    fabric.util.animate({\\n      startValue: object.get('opacity'),\\n      endValue: 0,\\n      duration: this.FX_DURATION,\\n      onStart: function() {\\n        object.set('active', false);\\n      },\\n      onChange: function(value) {\\n        object.set('opacity', value);\\n        _this.renderAll();\\n        onChange();\\n      },\\n      onComplete: function () {\\n        _this.remove(object);\\n        onComplete();\\n      }\\n    });\\n\\n    return this;\\n  }\\n});\\n\\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n  /**\\n   * Animates object's properties\\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\\n   * @return {fabric.Object} thisArg\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\\n   * @chainable\\n   *\\n   * As object  multiple properties\\n   *\\n   * object.animate({ left: ..., top: ... });\\n   * object.animate({ left: ..., top: ... }, { duration: ... });\\n   *\\n   * As string  one property\\n   *\\n   * object.animate('left', ...);\\n   * object.animate('left', { duration: ... });\\n   *\\n   */\\n  animate: function() {\\n    if (arguments[0] && typeof arguments[0] === 'object') {\\n      var propsToAnimate = [], prop, skipCallbacks;\\n      for (prop in arguments[0]) {\\n        propsToAnimate.push(prop);\\n      }\\n      for (var i = 0, len = propsToAnimate.length; i < len; i++) {\\n        prop = propsToAnimate[i];\\n        skipCallbacks = i !== len - 1;\\n        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);\\n      }\\n    }\\n    else {\\n      this._animate.apply(this, arguments);\\n    }\\n    return this;\\n  },\\n\\n  /**\\n   * @private\\n   * @param {String} property Property to animate\\n   * @param {String} to Value to animate to\\n   * @param {Object} [options] Options object\\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\\n   */\\n  _animate: function(property, to, options, skipCallbacks) {\\n    var _this = this, propPair;\\n\\n    to = to.toString();\\n\\n    if (!options) {\\n      options = { };\\n    }\\n    else {\\n      options = fabric.util.object.clone(options);\\n    }\\n\\n    if (~property.indexOf('.')) {\\n      propPair = property.split('.');\\n    }\\n\\n    var currentValue = propPair\\n      ? this.get(propPair[0])[propPair[1]]\\n      : this.get(property);\\n\\n    if (!('from' in options)) {\\n      options.from = currentValue;\\n    }\\n\\n    if (~to.indexOf('=')) {\\n      to = currentValue + parseFloat(to.replace('=', ''));\\n    }\\n    else {\\n      to = parseFloat(to);\\n    }\\n\\n    fabric.util.animate({\\n      startValue: options.from,\\n      endValue: to,\\n      byValue: options.by,\\n      easing: options.easing,\\n      duration: options.duration,\\n      abort: options.abort && function() {\\n        return options.abort.call(_this);\\n      },\\n      onChange: function(value) {\\n        if (propPair) {\\n          _this[propPair[0]][propPair[1]] = value;\\n        }\\n        else {\\n          _this.set(property, value);\\n        }\\n        if (skipCallbacks) {\\n          return;\\n        }\\n        options.onChange && options.onChange();\\n      },\\n      onComplete: function() {\\n        if (skipCallbacks) {\\n          return;\\n        }\\n\\n        _this.setCoords();\\n        options.onComplete && options.onComplete();\\n      }\\n    });\\n  }\\n});\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },\\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');\\n\\n  if (fabric.Line) {\\n    fabric.warn('fabric.Line is already defined');\\n    return;\\n  }\\n\\n  /**\\n   * Line class\\n   * @class fabric.Line\\n   * @extends fabric.Object\\n   * @see {@link fabric.Line#initialize} for constructor definition\\n   */\\n  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'line',\\n\\n    /**\\n     * x value or first line edge\\n     * @type Number\\n     * @default\\n     */\\n    x1: 0,\\n\\n    /**\\n     * y value or first line edge\\n     * @type Number\\n     * @default\\n     */\\n    y1: 0,\\n\\n    /**\\n     * x value or second line edge\\n     * @type Number\\n     * @default\\n     */\\n    x2: 0,\\n\\n    /**\\n     * y value or second line edge\\n     * @type Number\\n     * @default\\n     */\\n    y2: 0,\\n\\n    /**\\n     * Constructor\\n     * @param {Array} [points] Array of points\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Line} thisArg\\n     */\\n    initialize: function(points, options) {\\n      if (!points) {\\n        points = [0, 0, 0, 0];\\n      }\\n\\n      this.callSuper('initialize', options);\\n\\n      this.set('x1', points[0]);\\n      this.set('y1', points[1]);\\n      this.set('x2', points[2]);\\n      this.set('y2', points[3]);\\n\\n      this._setWidthHeight(options);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} [options] Options\\n     */\\n    _setWidthHeight: function(options) {\\n      options || (options = { });\\n\\n      this.width = Math.abs(this.x2 - this.x1);\\n      this.height = Math.abs(this.y2 - this.y1);\\n\\n      this.left = 'left' in options\\n        ? options.left\\n        : this._getLeftToOriginX();\\n\\n      this.top = 'top' in options\\n        ? options.top\\n        : this._getTopToOriginY();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} key\\n     * @param {*} value\\n     */\\n    _set: function(key, value) {\\n      this.callSuper('_set', key, value);\\n      if (typeof coordProps[key] !== 'undefined') {\\n        this._setWidthHeight();\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\\n     */\\n    _getLeftToOriginX: makeEdgeToOriginGetter(\\n      { // property names\\n        origin: 'originX',\\n        axis1: 'x1',\\n        axis2: 'x2',\\n        dimension: 'width'\\n      },\\n      { // possible values of origin\\n        nearest: 'left',\\n        center: 'center',\\n        farthest: 'right'\\n      }\\n    ),\\n\\n    /**\\n     * @private\\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\\n     */\\n    _getTopToOriginY: makeEdgeToOriginGetter(\\n      { // property names\\n        origin: 'originY',\\n        axis1: 'y1',\\n        axis2: 'y2',\\n        dimension: 'height'\\n      },\\n      { // possible values of origin\\n        nearest: 'top',\\n        center: 'center',\\n        farthest: 'bottom'\\n      }\\n    ),\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    _render: function(ctx, noTransform) {\\n      ctx.beginPath();\\n\\n      if (noTransform) {\\n        //  Line coords are distances from left-top of canvas to origin of line.\\n        //  To render line in a path-group, we need to translate them to\\n        //  distances from center of path-group to center of line.\\n        var cp = this.getCenterPoint();\\n        ctx.translate(\\n          cp.x - this.strokeWidth / 2,\\n          cp.y - this.strokeWidth / 2\\n        );\\n      }\\n\\n      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {\\n        // move from center (of virtual box) to its left/top corner\\n        // we can't assume x1, y1 is top left and x2, y2 is bottom right\\n        var p = this.calcLinePoints();\\n        ctx.moveTo(p.x1, p.y1);\\n        ctx.lineTo(p.x2, p.y2);\\n      }\\n\\n      ctx.lineWidth = this.strokeWidth;\\n\\n      // TODO: test this\\n      // make sure setting \\\"fill\\\" changes color of a line\\n      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\\n      var origStrokeStyle = ctx.strokeStyle;\\n      ctx.strokeStyle = this.stroke || ctx.fillStyle;\\n      this.stroke && this._renderStroke(ctx);\\n      ctx.strokeStyle = origStrokeStyle;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderDashedStroke: function(ctx) {\\n      var p = this.calcLinePoints();\\n\\n      ctx.beginPath();\\n      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);\\n      ctx.closePath();\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @methd toObject\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());\\n    },\\n\\n    /*\\n     * Calculate object dimensions from its properties\\n     * @private\\n     */\\n    _getNonTransformedDimensions: function() {\\n      var dim = this.callSuper('_getNonTransformedDimensions');\\n      if (this.strokeLineCap === 'butt') {\\n        if (dim.x === 0) {\\n          dim.y -= this.strokeWidth;\\n        }\\n        if (dim.y === 0) {\\n          dim.x -= this.strokeWidth;\\n        }\\n      }\\n      return dim;\\n    },\\n\\n    /**\\n     * Recalculates line points given width and height\\n     * @private\\n     */\\n    calcLinePoints: function() {\\n      var xMult = this.x1 <= this.x2 ? -1 : 1,\\n          yMult = this.y1 <= this.y2 ? -1 : 1,\\n          x1 = (xMult * this.width * 0.5),\\n          y1 = (yMult * this.height * 0.5),\\n          x2 = (xMult * this.width * -0.5),\\n          y2 = (yMult * this.height * -0.5);\\n\\n      return {\\n        x1: x1,\\n        x2: x2,\\n        y1: y1,\\n        y2: y2\\n      };\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns SVG representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var markup = this._createBaseSVGMarkup(),\\n          p = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 };\\n\\n      if (!(this.group && this.group.type === 'path-group')) {\\n        p = this.calcLinePoints();\\n      }\\n      markup.push(\\n        '<line ', this.getSvgId(),\\n          'x1=\\\"', p.x1,\\n          '\\\" y1=\\\"', p.y1,\\n          '\\\" x2=\\\"', p.x2,\\n          '\\\" y2=\\\"', p.y2,\\n          '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\" transform=\\\"', this.getSvgTransform(),\\n          this.getSvgTransformMatrix(),\\n        '\\\"/>\\\\n'\\n      );\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity\\n     */\\n    complexity: function() {\\n      return 1;\\n    }\\n  });\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\\n   * @static\\n   * @memberOf fabric.Line\\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\\n   */\\n  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));\\n\\n  /**\\n   * Returns fabric.Line instance from an SVG element\\n   * @static\\n   * @memberOf fabric.Line\\n   * @param {SVGElement} element Element to parse\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Line} instance of fabric.Line\\n   */\\n  fabric.Line.fromElement = function(element, options) {\\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),\\n        points = [\\n          parsedAttributes.x1 || 0,\\n          parsedAttributes.y1 || 0,\\n          parsedAttributes.x2 || 0,\\n          parsedAttributes.y2 || 0\\n        ];\\n    return new fabric.Line(points, extend(parsedAttributes, options));\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Returns fabric.Line instance from an object representation\\n   * @static\\n   * @memberOf fabric.Line\\n   * @param {Object} object Object to create an instance from\\n   * @param {function} [callback] invoked with new instance as first argument\\n   * @return {fabric.Line} instance of fabric.Line\\n   */\\n  fabric.Line.fromObject = function(object, callback) {\\n    var points = [object.x1, object.y1, object.x2, object.y2],\\n        line = new fabric.Line(points, object);\\n    callback && callback(line);\\n    return line;\\n  };\\n\\n  /**\\n   * Produces a function that calculates distance from canvas edge to Line origin.\\n   */\\n  function makeEdgeToOriginGetter(propertyNames, originValues) {\\n    var origin = propertyNames.origin,\\n        axis1 = propertyNames.axis1,\\n        axis2 = propertyNames.axis2,\\n        dimension = propertyNames.dimension,\\n        nearest = originValues.nearest,\\n        center = originValues.center,\\n        farthest = originValues.farthest;\\n\\n    return function() {\\n      switch (this.get(origin)) {\\n        case nearest:\\n          return Math.min(this.get(axis1), this.get(axis2));\\n        case center:\\n          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));\\n        case farthest:\\n          return Math.max(this.get(axis1), this.get(axis2));\\n      }\\n    };\\n\\n  }\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      pi = Math.PI,\\n      extend = fabric.util.object.extend;\\n\\n  if (fabric.Circle) {\\n    fabric.warn('fabric.Circle is already defined.');\\n    return;\\n  }\\n\\n  /**\\n   * Circle class\\n   * @class fabric.Circle\\n   * @extends fabric.Object\\n   * @see {@link fabric.Circle#initialize} for constructor definition\\n   */\\n  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'circle',\\n\\n    /**\\n     * Radius of this circle\\n     * @type Number\\n     * @default\\n     */\\n    radius: 0,\\n\\n    /**\\n     * Start angle of the circle, moving clockwise\\n     * @type Number\\n     * @default 0\\n     */\\n    startAngle: 0,\\n\\n    /**\\n     * End angle of the circle\\n     * @type Number\\n     * @default 2Pi\\n     */\\n    endAngle: pi * 2,\\n\\n    /**\\n     * Constructor\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Circle} thisArg\\n     */\\n    initialize: function(options) {\\n      this.callSuper('initialize', options);\\n      this.set('radius', options && options.radius || 0);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} key\\n     * @param {*} value\\n     * @return {fabric.Circle} thisArg\\n     */\\n    _set: function(key, value) {\\n      this.callSuper('_set', key, value);\\n\\n      if (key === 'radius') {\\n        this.setRadius(value);\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,\\n          angle = (this.endAngle - this.startAngle) % ( 2 * pi);\\n\\n      if (angle === 0) {\\n        if (this.group && this.group.type === 'path-group') {\\n          x = this.left + this.radius;\\n          y = this.top + this.radius;\\n        }\\n        markup.push(\\n          '<circle ', this.getSvgId(),\\n            'cx=\\\"' + x + '\\\" cy=\\\"' + y + '\\\" ',\\n            'r=\\\"', this.radius,\\n            '\\\" style=\\\"', this.getSvgStyles(),\\n            '\\\" transform=\\\"', this.getSvgTransform(),\\n            ' ', this.getSvgTransformMatrix(),\\n          '\\\"/>\\\\n'\\n        );\\n      }\\n      else {\\n        var startX = Math.cos(this.startAngle) * this.radius,\\n            startY = Math.sin(this.startAngle) * this.radius,\\n            endX = Math.cos(this.endAngle) * this.radius,\\n            endY = Math.sin(this.endAngle) * this.radius,\\n            largeFlag = angle > pi ? '1' : '0';\\n\\n        markup.push(\\n          '<path d=\\\"M ' + startX + ' ' + startY,\\n          ' A ' + this.radius + ' ' + this.radius,\\n          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,\\n          '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\" transform=\\\"', this.getSvgTransform(),\\n          ' ', this.getSvgTransformMatrix(),\\n          '\\\"/>\\\\n'\\n        );\\n      }\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    _render: function(ctx, noTransform) {\\n      ctx.beginPath();\\n      ctx.arc(noTransform ? this.left + this.radius : 0,\\n              noTransform ? this.top + this.radius : 0,\\n              this.radius,\\n              this.startAngle,\\n              this.endAngle, false);\\n      this._renderFill(ctx);\\n      this._renderStroke(ctx);\\n    },\\n\\n    /**\\n     * Returns horizontal radius of an object (according to how an object is scaled)\\n     * @return {Number}\\n     */\\n    getRadiusX: function() {\\n      return this.get('radius') * this.get('scaleX');\\n    },\\n\\n    /**\\n     * Returns vertical radius of an object (according to how an object is scaled)\\n     * @return {Number}\\n     */\\n    getRadiusY: function() {\\n      return this.get('radius') * this.get('scaleY');\\n    },\\n\\n    /**\\n     * Sets radius of an object (and updates width accordingly)\\n     * @return {fabric.Circle} thisArg\\n     */\\n    setRadius: function(value) {\\n      this.radius = value;\\n      return this.set('width', value * 2).set('height', value * 2);\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function() {\\n      return 1;\\n    }\\n  });\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\\n   * @static\\n   * @memberOf fabric.Circle\\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\\n   */\\n  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));\\n\\n  /**\\n   * Returns {@link fabric.Circle} instance from an SVG element\\n   * @static\\n   * @memberOf fabric.Circle\\n   * @param {SVGElement} element Element to parse\\n   * @param {Object} [options] Options object\\n   * @throws {Error} If value of `r` attribute is missing or invalid\\n   * @return {fabric.Circle} Instance of fabric.Circle\\n   */\\n  fabric.Circle.fromElement = function(element, options) {\\n    options || (options = { });\\n\\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\\n\\n    if (!isValidRadius(parsedAttributes)) {\\n      throw new Error('value of `r` attribute is required and can not be negative');\\n    }\\n\\n    parsedAttributes.left = parsedAttributes.left || 0;\\n    parsedAttributes.top = parsedAttributes.top || 0;\\n\\n    var obj = new fabric.Circle(extend(parsedAttributes, options));\\n\\n    obj.left -= obj.radius;\\n    obj.top -= obj.radius;\\n    return obj;\\n  };\\n\\n  /**\\n   * @private\\n   */\\n  function isValidRadius(attributes) {\\n    return (('radius' in attributes) && (attributes.radius >= 0));\\n  }\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Returns {@link fabric.Circle} instance from an object representation\\n   * @static\\n   * @memberOf fabric.Circle\\n   * @param {Object} object Object to create an instance from\\n   * @param {function} [callback] invoked with new instance as first argument\\n   * @return {Object} Instance of fabric.Circle\\n   */\\n  fabric.Circle.fromObject = function(object, callback) {\\n    var circle = new fabric.Circle(object);\\n    callback && callback(circle);\\n    return circle;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { });\\n\\n  if (fabric.Triangle) {\\n    fabric.warn('fabric.Triangle is already defined');\\n    return;\\n  }\\n\\n  /**\\n   * Triangle class\\n   * @class fabric.Triangle\\n   * @extends fabric.Object\\n   * @return {fabric.Triangle} thisArg\\n   * @see {@link fabric.Triangle#initialize} for constructor definition\\n   */\\n  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'triangle',\\n\\n    /**\\n     * Constructor\\n     * @param {Object} [options] Options object\\n     * @return {Object} thisArg\\n     */\\n    initialize: function(options) {\\n      this.callSuper('initialize', options);\\n      this.set('width', options && options.width || 100)\\n          .set('height', options && options.height || 100);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _render: function(ctx) {\\n      var widthBy2 = this.width / 2,\\n          heightBy2 = this.height / 2;\\n\\n      ctx.beginPath();\\n      ctx.moveTo(-widthBy2, heightBy2);\\n      ctx.lineTo(0, -heightBy2);\\n      ctx.lineTo(widthBy2, heightBy2);\\n      ctx.closePath();\\n\\n      this._renderFill(ctx);\\n      this._renderStroke(ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderDashedStroke: function(ctx) {\\n      var widthBy2 = this.width / 2,\\n          heightBy2 = this.height / 2;\\n\\n      ctx.beginPath();\\n      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);\\n      ctx.closePath();\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns SVG representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var markup = this._createBaseSVGMarkup(),\\n          widthBy2 = this.width / 2,\\n          heightBy2 = this.height / 2,\\n          points = [\\n            -widthBy2 + ' ' + heightBy2,\\n            '0 ' + -heightBy2,\\n            widthBy2 + ' ' + heightBy2\\n          ]\\n          .join(',');\\n\\n      markup.push(\\n        '<polygon ', this.getSvgId(),\\n          'points=\\\"', points,\\n          '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\" transform=\\\"', this.getSvgTransform(),\\n        '\\\"/>'\\n      );\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function() {\\n      return 1;\\n    }\\n  });\\n\\n  /**\\n   * Returns fabric.Triangle instance from an object representation\\n   * @static\\n   * @memberOf fabric.Triangle\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when an fabric.Triangle instance is created\\n   * @return {Object} instance of Canvas.Triangle\\n   */\\n  fabric.Triangle.fromObject = function(object, callback) {\\n    var triangle = new fabric.Triangle(object);\\n    callback && callback(triangle);\\n    return triangle;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      piBy2   = Math.PI * 2,\\n      extend = fabric.util.object.extend;\\n\\n  if (fabric.Ellipse) {\\n    fabric.warn('fabric.Ellipse is already defined.');\\n    return;\\n  }\\n\\n  /**\\n   * Ellipse class\\n   * @class fabric.Ellipse\\n   * @extends fabric.Object\\n   * @return {fabric.Ellipse} thisArg\\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\\n   */\\n  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'ellipse',\\n\\n    /**\\n     * Horizontal radius\\n     * @type Number\\n     * @default\\n     */\\n    rx:   0,\\n\\n    /**\\n     * Vertical radius\\n     * @type Number\\n     * @default\\n     */\\n    ry:   0,\\n\\n    /**\\n     * Constructor\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Ellipse} thisArg\\n     */\\n    initialize: function(options) {\\n      this.callSuper('initialize', options);\\n      this.set('rx', options && options.rx || 0);\\n      this.set('ry', options && options.ry || 0);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} key\\n     * @param {*} value\\n     * @return {fabric.Ellipse} thisArg\\n     */\\n    _set: function(key, value) {\\n      this.callSuper('_set', key, value);\\n      switch (key) {\\n\\n        case 'rx':\\n          this.rx = value;\\n          this.set('width', value * 2);\\n          break;\\n\\n        case 'ry':\\n          this.ry = value;\\n          this.set('height', value * 2);\\n          break;\\n\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Returns horizontal radius of an object (according to how an object is scaled)\\n     * @return {Number}\\n     */\\n    getRx: function() {\\n      return this.get('rx') * this.get('scaleX');\\n    },\\n\\n    /**\\n     * Returns Vertical radius of an object (according to how an object is scaled)\\n     * @return {Number}\\n     */\\n    getRy: function() {\\n      return this.get('ry') * this.get('scaleY');\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var markup = this._createBaseSVGMarkup(), x = 0, y = 0;\\n      if (this.group && this.group.type === 'path-group') {\\n        x = this.left + this.rx;\\n        y = this.top + this.ry;\\n      }\\n      markup.push(\\n        '<ellipse ', this.getSvgId(),\\n          'cx=\\\"', x, '\\\" cy=\\\"', y, '\\\" ',\\n          'rx=\\\"', this.rx,\\n          '\\\" ry=\\\"', this.ry,\\n          '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\" transform=\\\"', this.getSvgTransform(),\\n          this.getSvgTransformMatrix(),\\n        '\\\"/>\\\\n'\\n      );\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    _render: function(ctx, noTransform) {\\n      ctx.beginPath();\\n      ctx.save();\\n      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);\\n      ctx.arc(\\n        noTransform ? this.left + this.rx : 0,\\n        noTransform ? (this.top + this.ry) * this.rx / this.ry : 0,\\n        this.rx,\\n        0,\\n        piBy2,\\n        false);\\n      ctx.restore();\\n      this._renderFill(ctx);\\n      this._renderStroke(ctx);\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity\\n     */\\n    complexity: function() {\\n      return 1;\\n    }\\n  });\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\\n   * @static\\n   * @memberOf fabric.Ellipse\\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\\n   */\\n  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));\\n\\n  /**\\n   * Returns {@link fabric.Ellipse} instance from an SVG element\\n   * @static\\n   * @memberOf fabric.Ellipse\\n   * @param {SVGElement} element Element to parse\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Ellipse}\\n   */\\n  fabric.Ellipse.fromElement = function(element, options) {\\n    options || (options = { });\\n\\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\\n\\n    parsedAttributes.left = parsedAttributes.left || 0;\\n    parsedAttributes.top = parsedAttributes.top || 0;\\n\\n    var ellipse = new fabric.Ellipse(extend(parsedAttributes, options));\\n\\n    ellipse.top -= ellipse.ry;\\n    ellipse.left -= ellipse.rx;\\n    return ellipse;\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Returns {@link fabric.Ellipse} instance from an object representation\\n   * @static\\n   * @memberOf fabric.Ellipse\\n   * @param {Object} object Object to create an instance from\\n   * @param {function} [callback] invoked with new instance as first argument\\n   * @return {fabric.Ellipse}\\n   */\\n  fabric.Ellipse.fromObject = function(object, callback) {\\n    var ellipse = new fabric.Ellipse(object);\\n    callback && callback(ellipse);\\n    return ellipse;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend;\\n\\n  if (fabric.Rect) {\\n    fabric.warn('fabric.Rect is already defined');\\n    return;\\n  }\\n\\n  var stateProperties = fabric.Object.prototype.stateProperties.concat();\\n  stateProperties.push('rx', 'ry', 'x', 'y');\\n\\n  /**\\n   * Rectangle class\\n   * @class fabric.Rect\\n   * @extends fabric.Object\\n   * @return {fabric.Rect} thisArg\\n   * @see {@link fabric.Rect#initialize} for constructor definition\\n   */\\n  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\\n\\n    /**\\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\\n     * as well as for history (undo/redo) purposes\\n     * @type Array\\n     */\\n    stateProperties: stateProperties,\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'rect',\\n\\n    /**\\n     * Horizontal border radius\\n     * @type Number\\n     * @default\\n     */\\n    rx:   0,\\n\\n    /**\\n     * Vertical border radius\\n     * @type Number\\n     * @default\\n     */\\n    ry:   0,\\n\\n    /**\\n     * Used to specify dash pattern for stroke on this object\\n     * @type Array\\n     */\\n    strokeDashArray: null,\\n\\n    /**\\n     * Constructor\\n     * @param {Object} [options] Options object\\n     * @return {Object} thisArg\\n     */\\n    initialize: function(options) {\\n      this.callSuper('initialize', options);\\n      this._initRxRy();\\n\\n    },\\n\\n    /**\\n     * Initializes rx/ry attributes\\n     * @private\\n     */\\n    _initRxRy: function() {\\n      if (this.rx && !this.ry) {\\n        this.ry = this.rx;\\n      }\\n      else if (this.ry && !this.rx) {\\n        this.rx = this.ry;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    _render: function(ctx, noTransform) {\\n\\n      // optimize 1x1 case (used in spray brush)\\n      if (this.width === 1 && this.height === 1) {\\n        ctx.fillRect(-0.5, -0.5, 1, 1);\\n        return;\\n      }\\n\\n      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,\\n          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,\\n          w = this.width,\\n          h = this.height,\\n          x = noTransform ? this.left : -this.width / 2,\\n          y = noTransform ? this.top : -this.height / 2,\\n          isRounded = rx !== 0 || ry !== 0,\\n          /* \\\"magic number\\\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */\\n          k = 1 - 0.5522847498;\\n      ctx.beginPath();\\n\\n      ctx.moveTo(x + rx, y);\\n\\n      ctx.lineTo(x + w - rx, y);\\n      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\\n\\n      ctx.lineTo(x + w, y + h - ry);\\n      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\\n\\n      ctx.lineTo(x + rx, y + h);\\n      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\\n\\n      ctx.lineTo(x, y + ry);\\n      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\\n\\n      ctx.closePath();\\n\\n      this._renderFill(ctx);\\n      this._renderStroke(ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderDashedStroke: function(ctx) {\\n      var x = -this.width / 2,\\n          y = -this.height / 2,\\n          w = this.width,\\n          h = this.height;\\n\\n      ctx.beginPath();\\n      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);\\n      ctx.closePath();\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var markup = this._createBaseSVGMarkup(), x = this.left, y = this.top;\\n      if (!(this.group && this.group.type === 'path-group')) {\\n        x = -this.width / 2;\\n        y = -this.height / 2;\\n      }\\n      markup.push(\\n        '<rect ', this.getSvgId(),\\n          'x=\\\"', x, '\\\" y=\\\"', y,\\n          '\\\" rx=\\\"', this.get('rx'), '\\\" ry=\\\"', this.get('ry'),\\n          '\\\" width=\\\"', this.width, '\\\" height=\\\"', this.height,\\n          '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\" transform=\\\"', this.getSvgTransform(),\\n          this.getSvgTransformMatrix(),\\n        '\\\"/>\\\\n');\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity\\n     */\\n    complexity: function() {\\n      return 1;\\n    }\\n  });\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\\n   * @static\\n   * @memberOf fabric.Rect\\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\\n   */\\n  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));\\n\\n  /**\\n   * Returns {@link fabric.Rect} instance from an SVG element\\n   * @static\\n   * @memberOf fabric.Rect\\n   * @param {SVGElement} element Element to parse\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Rect} Instance of fabric.Rect\\n   */\\n  fabric.Rect.fromElement = function(element, options) {\\n    if (!element) {\\n      return null;\\n    }\\n    options = options || { };\\n\\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\\n\\n    parsedAttributes.left = parsedAttributes.left || 0;\\n    parsedAttributes.top  = parsedAttributes.top  || 0;\\n    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));\\n    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;\\n    return rect;\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Returns {@link fabric.Rect} instance from an object representation\\n   * @static\\n   * @memberOf fabric.Rect\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created\\n   * @return {Object} instance of fabric.Rect\\n   */\\n  fabric.Rect.fromObject = function(object, callback) {\\n    var rect = new fabric.Rect(object);\\n    callback && callback(rect);\\n    return rect;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { });\\n\\n  if (fabric.Polyline) {\\n    fabric.warn('fabric.Polyline is already defined');\\n    return;\\n  }\\n\\n  /**\\n   * Polyline class\\n   * @class fabric.Polyline\\n   * @extends fabric.Object\\n   * @see {@link fabric.Polyline#initialize} for constructor definition\\n   */\\n  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'polyline',\\n\\n    /**\\n     * Points array\\n     * @type Array\\n     * @default\\n     */\\n    points: null,\\n\\n    /**\\n     * Minimum X from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minX: 0,\\n\\n    /**\\n     * Minimum Y from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minY: 0,\\n\\n    /**\\n     * Constructor\\n     * @param {Array} points Array of points (where each point is an object with x and y)\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Polyline} thisArg\\n     * @example\\n     * var poly = new fabric.Polyline([\\n     *     { x: 10, y: 10 },\\n     *     { x: 50, y: 30 },\\n     *     { x: 40, y: 70 },\\n     *     { x: 60, y: 50 },\\n     *     { x: 100, y: 150 },\\n     *     { x: 40, y: 100 }\\n     *   ], {\\n     *   stroke: 'red',\\n     *   left: 100,\\n     *   top: 100\\n     * });\\n     */\\n    initialize: function(points, options) {\\n      return fabric.Polygon.prototype.initialize.call(this, points, options);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _calcDimensions: function() {\\n      return fabric.Polygon.prototype._calcDimensions.call(this);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return fabric.Polygon.prototype.toObject.call(this, propertiesToInclude);\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns SVG representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      return fabric.Polygon.prototype.toSVG.call(this, reviver);\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    _render: function(ctx, noTransform) {\\n      if (!fabric.Polygon.prototype.commonRender.call(this, ctx, noTransform)) {\\n        return;\\n      }\\n      this._renderFill(ctx);\\n      this._renderStroke(ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderDashedStroke: function(ctx) {\\n      var p1, p2;\\n\\n      ctx.beginPath();\\n      for (var i = 0, len = this.points.length; i < len; i++) {\\n        p1 = this.points[i];\\n        p2 = this.points[i + 1] || p1;\\n        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);\\n      }\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function() {\\n      return this.get('points').length;\\n    }\\n  });\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\\n   * @static\\n   * @memberOf fabric.Polyline\\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\\n   */\\n  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\\n\\n  /**\\n   * Returns fabric.Polyline instance from an SVG element\\n   * @static\\n   * @memberOf fabric.Polyline\\n   * @param {SVGElement} element Element to parse\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Polyline} Instance of fabric.Polyline\\n   */\\n  fabric.Polyline.fromElement = function(element, options) {\\n    if (!element) {\\n      return null;\\n    }\\n    options || (options = { });\\n\\n    var points = fabric.parsePointsAttribute(element.getAttribute('points')),\\n        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);\\n\\n    return new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options));\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Returns fabric.Polyline instance from an object representation\\n   * @static\\n   * @memberOf fabric.Polyline\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\\n   * @return {fabric.Polyline} Instance of fabric.Polyline\\n   */\\n  fabric.Polyline.fromObject = function(object, callback) {\\n    var polyline = new fabric.Polyline(object.points, object);\\n    callback && callback(polyline);\\n    return polyline;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      min = fabric.util.array.min,\\n      max = fabric.util.array.max,\\n      toFixed = fabric.util.toFixed;\\n\\n  if (fabric.Polygon) {\\n    fabric.warn('fabric.Polygon is already defined');\\n    return;\\n  }\\n\\n  /**\\n   * Polygon class\\n   * @class fabric.Polygon\\n   * @extends fabric.Object\\n   * @see {@link fabric.Polygon#initialize} for constructor definition\\n   */\\n  fabric.Polygon = fabric.util.createClass(fabric.Object, /** @lends fabric.Polygon.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'polygon',\\n\\n    /**\\n     * Points array\\n     * @type Array\\n     * @default\\n     */\\n    points: null,\\n\\n    /**\\n     * Minimum X from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minX: 0,\\n\\n    /**\\n     * Minimum Y from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minY: 0,\\n\\n    /**\\n     * Constructor\\n     * @param {Array} points Array of points\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Polygon} thisArg\\n     */\\n    initialize: function(points, options) {\\n      options = options || {};\\n      this.points = points || [];\\n      this.callSuper('initialize', options);\\n      this._calcDimensions();\\n      if (!('top' in options)) {\\n        this.top = this.minY;\\n      }\\n      if (!('left' in options)) {\\n        this.left = this.minX;\\n      }\\n      this.pathOffset = {\\n        x: this.minX + this.width / 2,\\n        y: this.minY + this.height / 2\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _calcDimensions: function() {\\n\\n      var points = this.points,\\n          minX = min(points, 'x'),\\n          minY = min(points, 'y'),\\n          maxX = max(points, 'x'),\\n          maxY = max(points, 'y');\\n\\n      this.width = (maxX - minX) || 0;\\n      this.height = (maxY - minY) || 0;\\n      this.minX = minX || 0;\\n      this.minY = minY || 0;\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        points: this.points.concat()\\n      });\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var points = [], addTransform,\\n          markup = this._createBaseSVGMarkup();\\n\\n      for (var i = 0, len = this.points.length; i < len; i++) {\\n        points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');\\n      }\\n      if (!(this.group && this.group.type === 'path-group')) {\\n        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';\\n      }\\n      markup.push(\\n        '<', this.type, ' ', this.getSvgId(),\\n          'points=\\\"', points.join(''),\\n          '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\" transform=\\\"', this.getSvgTransform(), addTransform,\\n          ' ', this.getSvgTransformMatrix(),\\n        '\\\"/>\\\\n'\\n      );\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    _render: function(ctx, noTransform) {\\n      if (!this.commonRender(ctx, noTransform)) {\\n        return;\\n      }\\n      this._renderFill(ctx);\\n      if (this.stroke || this.strokeDashArray) {\\n        ctx.closePath();\\n        this._renderStroke(ctx);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    commonRender: function(ctx, noTransform) {\\n      var point, len = this.points.length;\\n\\n      if (!len || isNaN(this.points[len - 1].y)) {\\n        // do not draw if no points or odd points\\n        // NaN comes from parseFloat of a empty string in parser\\n        return false;\\n      }\\n\\n      noTransform || ctx.translate(-this.pathOffset.x, -this.pathOffset.y);\\n      ctx.beginPath();\\n      ctx.moveTo(this.points[0].x, this.points[0].y);\\n      for (var i = 0; i < len; i++) {\\n        point = this.points[i];\\n        ctx.lineTo(point.x, point.y);\\n      }\\n      return true;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderDashedStroke: function(ctx) {\\n      fabric.Polyline.prototype._renderDashedStroke.call(this, ctx);\\n      ctx.closePath();\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function() {\\n      return this.points.length;\\n    }\\n  });\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\\n   * @static\\n   * @memberOf fabric.Polygon\\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\\n   */\\n  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\\n\\n  /**\\n   * Returns {@link fabric.Polygon} instance from an SVG element\\n   * @static\\n   * @memberOf fabric.Polygon\\n   * @param {SVGElement} element Element to parse\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Polygon} Instance of fabric.Polygon\\n   */\\n  fabric.Polygon.fromElement = function(element, options) {\\n    if (!element) {\\n      return null;\\n    }\\n\\n    options || (options = { });\\n\\n    var points = fabric.parsePointsAttribute(element.getAttribute('points')),\\n        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);\\n\\n    return new fabric.Polygon(points, extend(parsedAttributes, options));\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Returns fabric.Polygon instance from an object representation\\n   * @static\\n   * @memberOf fabric.Polygon\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\\n   * @return {fabric.Polygon} Instance of fabric.Polygon\\n   */\\n  fabric.Polygon.fromObject = function(object, callback) {\\n    var polygon = new fabric.Polygon(object.points, object);\\n    callback && callback(polygon);\\n    return polygon;\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      min = fabric.util.array.min,\\n      max = fabric.util.array.max,\\n      extend = fabric.util.object.extend,\\n      _toString = Object.prototype.toString,\\n      drawArc = fabric.util.drawArc,\\n      commandLengths = {\\n        m: 2,\\n        l: 2,\\n        h: 1,\\n        v: 1,\\n        c: 6,\\n        s: 4,\\n        q: 4,\\n        t: 2,\\n        a: 7\\n      },\\n      repeatedCommands = {\\n        m: 'l',\\n        M: 'L'\\n      };\\n\\n  if (fabric.Path) {\\n    fabric.warn('fabric.Path is already defined');\\n    return;\\n  }\\n\\n  /**\\n   * Path class\\n   * @class fabric.Path\\n   * @extends fabric.Object\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\\n   * @see {@link fabric.Path#initialize} for constructor definition\\n   */\\n  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'path',\\n\\n    /**\\n     * Array of path points\\n     * @type Array\\n     * @default\\n     */\\n    path: null,\\n\\n    /**\\n     * Minimum X from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minX: 0,\\n\\n    /**\\n     * Minimum Y from points values, necessary to offset points\\n     * @type Number\\n     * @default\\n     */\\n    minY: 0,\\n\\n    /**\\n     * Constructor\\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \\\"command\\\" tokens)\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Path} thisArg\\n     */\\n    initialize: function(path, options) {\\n      options = options || { };\\n\\n      if (options) {\\n        this.setOptions(options);\\n      }\\n\\n      if (!path) {\\n        path = [];\\n      }\\n\\n      var fromArray = _toString.call(path) === '[object Array]';\\n\\n      this.path = fromArray\\n        ? path\\n        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\\n        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\\n\\n      if (!this.path) {\\n        return;\\n      }\\n\\n      if (!fromArray) {\\n        this.path = this._parsePath();\\n      }\\n\\n      this._setPositionDimensions(options);\\n\\n      if (options.sourcePath) {\\n        this.setSourcePath(options.sourcePath);\\n      }\\n      if (this.objectCaching) {\\n        this._createCacheCanvas();\\n        this.setupState({ propertySet: 'cacheProperties' });\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} options Options object\\n     */\\n    _setPositionDimensions: function(options) {\\n      var calcDim = this._parseDimensions();\\n\\n      this.minX = calcDim.left;\\n      this.minY = calcDim.top;\\n      this.width = calcDim.width;\\n      this.height = calcDim.height;\\n\\n      if (typeof options.left === 'undefined') {\\n        this.left = calcDim.left + (this.originX === 'center'\\n          ? this.width / 2\\n          : this.originX === 'right'\\n            ? this.width\\n            : 0);\\n      }\\n\\n      if (typeof options.top === 'undefined') {\\n        this.top = calcDim.top + (this.originY === 'center'\\n          ? this.height / 2\\n          : this.originY === 'bottom'\\n            ? this.height\\n            : 0);\\n      }\\n\\n      this.pathOffset = this.pathOffset || {\\n        x: this.minX + this.width / 2,\\n        y: this.minY + this.height / 2\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx context to render path on\\n     */\\n    _renderPathCommands: function(ctx) {\\n      var current, // current instruction\\n          previous = null,\\n          subpathStartX = 0,\\n          subpathStartY = 0,\\n          x = 0, // current x\\n          y = 0, // current y\\n          controlX = 0, // current control point x\\n          controlY = 0, // current control point y\\n          tempX,\\n          tempY,\\n          l = -this.pathOffset.x,\\n          t = -this.pathOffset.y;\\n\\n      if (this.group && this.group.type === 'path-group') {\\n        l = 0;\\n        t = 0;\\n      }\\n\\n      ctx.beginPath();\\n\\n      for (var i = 0, len = this.path.length; i < len; ++i) {\\n\\n        current = this.path[i];\\n\\n        switch (current[0]) { // first letter\\n\\n          case 'l': // lineto, relative\\n            x += current[1];\\n            y += current[2];\\n            ctx.lineTo(x + l, y + t);\\n            break;\\n\\n          case 'L': // lineto, absolute\\n            x = current[1];\\n            y = current[2];\\n            ctx.lineTo(x + l, y + t);\\n            break;\\n\\n          case 'h': // horizontal lineto, relative\\n            x += current[1];\\n            ctx.lineTo(x + l, y + t);\\n            break;\\n\\n          case 'H': // horizontal lineto, absolute\\n            x = current[1];\\n            ctx.lineTo(x + l, y + t);\\n            break;\\n\\n          case 'v': // vertical lineto, relative\\n            y += current[1];\\n            ctx.lineTo(x + l, y + t);\\n            break;\\n\\n          case 'V': // verical lineto, absolute\\n            y = current[1];\\n            ctx.lineTo(x + l, y + t);\\n            break;\\n\\n          case 'm': // moveTo, relative\\n            x += current[1];\\n            y += current[2];\\n            subpathStartX = x;\\n            subpathStartY = y;\\n            ctx.moveTo(x + l, y + t);\\n            break;\\n\\n          case 'M': // moveTo, absolute\\n            x = current[1];\\n            y = current[2];\\n            subpathStartX = x;\\n            subpathStartY = y;\\n            ctx.moveTo(x + l, y + t);\\n            break;\\n\\n          case 'c': // bezierCurveTo, relative\\n            tempX = x + current[5];\\n            tempY = y + current[6];\\n            controlX = x + current[3];\\n            controlY = y + current[4];\\n            ctx.bezierCurveTo(\\n              x + current[1] + l, // x1\\n              y + current[2] + t, // y1\\n              controlX + l, // x2\\n              controlY + t, // y2\\n              tempX + l,\\n              tempY + t\\n            );\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'C': // bezierCurveTo, absolute\\n            x = current[5];\\n            y = current[6];\\n            controlX = current[3];\\n            controlY = current[4];\\n            ctx.bezierCurveTo(\\n              current[1] + l,\\n              current[2] + t,\\n              controlX + l,\\n              controlY + t,\\n              x + l,\\n              y + t\\n            );\\n            break;\\n\\n          case 's': // shorthand cubic bezierCurveTo, relative\\n\\n            // transform to absolute x,y\\n            tempX = x + current[3];\\n            tempY = y + current[4];\\n\\n            if (previous[0].match(/[CcSs]/) === null) {\\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\\n              // the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control points\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n\\n            ctx.bezierCurveTo(\\n              controlX + l,\\n              controlY + t,\\n              x + current[1] + l,\\n              y + current[2] + t,\\n              tempX + l,\\n              tempY + t\\n            );\\n            // set control point to 2nd one of this command\\n            // \\\"... the first control point is assumed to be\\n            // the reflection of the second control point on\\n            // the previous command relative to the current point.\\\"\\n            controlX = x + current[1];\\n            controlY = y + current[2];\\n\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'S': // shorthand cubic bezierCurveTo, absolute\\n            tempX = current[3];\\n            tempY = current[4];\\n            if (previous[0].match(/[CcSs]/) === null) {\\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\\n              // the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control points\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n            ctx.bezierCurveTo(\\n              controlX + l,\\n              controlY + t,\\n              current[1] + l,\\n              current[2] + t,\\n              tempX + l,\\n              tempY + t\\n            );\\n            x = tempX;\\n            y = tempY;\\n\\n            // set control point to 2nd one of this command\\n            // \\\"... the first control point is assumed to be\\n            // the reflection of the second control point on\\n            // the previous command relative to the current point.\\\"\\n            controlX = current[1];\\n            controlY = current[2];\\n\\n            break;\\n\\n          case 'q': // quadraticCurveTo, relative\\n            // transform to absolute x,y\\n            tempX = x + current[3];\\n            tempY = y + current[4];\\n\\n            controlX = x + current[1];\\n            controlY = y + current[2];\\n\\n            ctx.quadraticCurveTo(\\n              controlX + l,\\n              controlY + t,\\n              tempX + l,\\n              tempY + t\\n            );\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'Q': // quadraticCurveTo, absolute\\n            tempX = current[3];\\n            tempY = current[4];\\n\\n            ctx.quadraticCurveTo(\\n              current[1] + l,\\n              current[2] + t,\\n              tempX + l,\\n              tempY + t\\n            );\\n            x = tempX;\\n            y = tempY;\\n            controlX = current[1];\\n            controlY = current[2];\\n            break;\\n\\n          case 't': // shorthand quadraticCurveTo, relative\\n\\n            // transform to absolute x,y\\n            tempX = x + current[1];\\n            tempY = y + current[2];\\n\\n            if (previous[0].match(/[QqTt]/) === null) {\\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\\n              // assume the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control point\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n\\n            ctx.quadraticCurveTo(\\n              controlX + l,\\n              controlY + t,\\n              tempX + l,\\n              tempY + t\\n            );\\n            x = tempX;\\n            y = tempY;\\n\\n            break;\\n\\n          case 'T':\\n            tempX = current[1];\\n            tempY = current[2];\\n\\n            if (previous[0].match(/[QqTt]/) === null) {\\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\\n              // assume the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control point\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n            ctx.quadraticCurveTo(\\n              controlX + l,\\n              controlY + t,\\n              tempX + l,\\n              tempY + t\\n            );\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'a':\\n            // TODO: optimize this\\n            drawArc(ctx, x + l, y + t, [\\n              current[1],\\n              current[2],\\n              current[3],\\n              current[4],\\n              current[5],\\n              current[6] + x + l,\\n              current[7] + y + t\\n            ]);\\n            x += current[6];\\n            y += current[7];\\n            break;\\n\\n          case 'A':\\n            // TODO: optimize this\\n            drawArc(ctx, x + l, y + t, [\\n              current[1],\\n              current[2],\\n              current[3],\\n              current[4],\\n              current[5],\\n              current[6] + l,\\n              current[7] + t\\n            ]);\\n            x = current[6];\\n            y = current[7];\\n            break;\\n\\n          case 'z':\\n          case 'Z':\\n            x = subpathStartX;\\n            y = subpathStartY;\\n            ctx.closePath();\\n            break;\\n        }\\n        previous = current;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx context to render path on\\n     */\\n    _render: function(ctx) {\\n      this._renderPathCommands(ctx);\\n      this._renderFill(ctx);\\n      this._renderStroke(ctx);\\n    },\\n\\n    /**\\n     * Returns string representation of an instance\\n     * @return {String} string representation of an instance\\n     */\\n    toString: function() {\\n      return '#<fabric.Path (' + this.complexity() +\\n        '): { \\\"top\\\": ' + this.top + ', \\\"left\\\": ' + this.left + ' }>';\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      var o = extend(this.callSuper('toObject', ['sourcePath', 'pathOffset'].concat(propertiesToInclude)), {\\n        path: this.path.map(function(item) { return item.slice() })\\n      });\\n      return o;\\n    },\\n\\n    /**\\n     * Returns dataless object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toDatalessObject: function(propertiesToInclude) {\\n      var o = this.toObject(propertiesToInclude);\\n      if (this.sourcePath) {\\n        o.path = this.sourcePath;\\n      }\\n      delete o.sourcePath;\\n      return o;\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var chunks = [],\\n          markup = this._createBaseSVGMarkup(), addTransform = '';\\n\\n      for (var i = 0, len = this.path.length; i < len; i++) {\\n        chunks.push(this.path[i].join(' '));\\n      }\\n      var path = chunks.join(' ');\\n      if (!(this.group && this.group.type === 'path-group')) {\\n        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';\\n      }\\n      markup.push(\\n        '<path ', this.getSvgId(),\\n          'd=\\\"', path,\\n          '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\" transform=\\\"', this.getSvgTransform(), addTransform,\\n          this.getSvgTransformMatrix(), '\\\" stroke-linecap=\\\"round\\\" ',\\n        '/>\\\\n'\\n      );\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns number representation of an instance complexity\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function() {\\n      return this.path.length;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _parsePath: function() {\\n      var result = [],\\n          coords = [],\\n          currentPath,\\n          parsed,\\n          re = /([-+]?((\\\\d+\\\\.\\\\d+)|((\\\\d+)|(\\\\.\\\\d+)))(?:e[-+]?\\\\d+)?)/ig,\\n          match,\\n          coordsStr;\\n\\n      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {\\n        currentPath = this.path[i];\\n\\n        coordsStr = currentPath.slice(1).trim();\\n        coords.length = 0;\\n\\n        while ((match = re.exec(coordsStr))) {\\n          coords.push(match[0]);\\n        }\\n\\n        coordsParsed = [currentPath.charAt(0)];\\n\\n        for (var j = 0, jlen = coords.length; j < jlen; j++) {\\n          parsed = parseFloat(coords[j]);\\n          if (!isNaN(parsed)) {\\n            coordsParsed.push(parsed);\\n          }\\n        }\\n\\n        var command = coordsParsed[0],\\n            commandLength = commandLengths[command.toLowerCase()],\\n            repeatedCommand = repeatedCommands[command] || command;\\n\\n        if (coordsParsed.length - 1 > commandLength) {\\n          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {\\n            result.push([command].concat(coordsParsed.slice(k, k + commandLength)));\\n            command = repeatedCommand;\\n          }\\n        }\\n        else {\\n          result.push(coordsParsed);\\n        }\\n      }\\n\\n      return result;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _parseDimensions: function() {\\n\\n      var aX = [],\\n          aY = [],\\n          current, // current instruction\\n          previous = null,\\n          subpathStartX = 0,\\n          subpathStartY = 0,\\n          x = 0, // current x\\n          y = 0, // current y\\n          controlX = 0, // current control point x\\n          controlY = 0, // current control point y\\n          tempX,\\n          tempY,\\n          bounds;\\n\\n      for (var i = 0, len = this.path.length; i < len; ++i) {\\n\\n        current = this.path[i];\\n\\n        switch (current[0]) { // first letter\\n\\n          case 'l': // lineto, relative\\n            x += current[1];\\n            y += current[2];\\n            bounds = [];\\n            break;\\n\\n          case 'L': // lineto, absolute\\n            x = current[1];\\n            y = current[2];\\n            bounds = [];\\n            break;\\n\\n          case 'h': // horizontal lineto, relative\\n            x += current[1];\\n            bounds = [];\\n            break;\\n\\n          case 'H': // horizontal lineto, absolute\\n            x = current[1];\\n            bounds = [];\\n            break;\\n\\n          case 'v': // vertical lineto, relative\\n            y += current[1];\\n            bounds = [];\\n            break;\\n\\n          case 'V': // verical lineto, absolute\\n            y = current[1];\\n            bounds = [];\\n            break;\\n\\n          case 'm': // moveTo, relative\\n            x += current[1];\\n            y += current[2];\\n            subpathStartX = x;\\n            subpathStartY = y;\\n            bounds = [];\\n            break;\\n\\n          case 'M': // moveTo, absolute\\n            x = current[1];\\n            y = current[2];\\n            subpathStartX = x;\\n            subpathStartY = y;\\n            bounds = [];\\n            break;\\n\\n          case 'c': // bezierCurveTo, relative\\n            tempX = x + current[5];\\n            tempY = y + current[6];\\n            controlX = x + current[3];\\n            controlY = y + current[4];\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              x + current[1], // x1\\n              y + current[2], // y1\\n              controlX, // x2\\n              controlY, // y2\\n              tempX,\\n              tempY\\n            );\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'C': // bezierCurveTo, absolute\\n            x = current[5];\\n            y = current[6];\\n            controlX = current[3];\\n            controlY = current[4];\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              current[1],\\n              current[2],\\n              controlX,\\n              controlY,\\n              x,\\n              y\\n            );\\n            break;\\n\\n          case 's': // shorthand cubic bezierCurveTo, relative\\n\\n            // transform to absolute x,y\\n            tempX = x + current[3];\\n            tempY = y + current[4];\\n\\n            if (previous[0].match(/[CcSs]/) === null) {\\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\\n              // the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control points\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              controlX,\\n              controlY,\\n              x + current[1],\\n              y + current[2],\\n              tempX,\\n              tempY\\n            );\\n            // set control point to 2nd one of this command\\n            // \\\"... the first control point is assumed to be\\n            // the reflection of the second control point on\\n            // the previous command relative to the current point.\\\"\\n            controlX = x + current[1];\\n            controlY = y + current[2];\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'S': // shorthand cubic bezierCurveTo, absolute\\n            tempX = current[3];\\n            tempY = current[4];\\n            if (previous[0].match(/[CcSs]/) === null) {\\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\\n              // the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control points\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              controlX,\\n              controlY,\\n              current[1],\\n              current[2],\\n              tempX,\\n              tempY\\n            );\\n            x = tempX;\\n            y = tempY;\\n            // set control point to 2nd one of this command\\n            // \\\"... the first control point is assumed to be\\n            // the reflection of the second control point on\\n            // the previous command relative to the current point.\\\"\\n            controlX = current[1];\\n            controlY = current[2];\\n            break;\\n\\n          case 'q': // quadraticCurveTo, relative\\n            // transform to absolute x,y\\n            tempX = x + current[3];\\n            tempY = y + current[4];\\n            controlX = x + current[1];\\n            controlY = y + current[2];\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              controlX,\\n              controlY,\\n              controlX,\\n              controlY,\\n              tempX,\\n              tempY\\n            );\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'Q': // quadraticCurveTo, absolute\\n            controlX = current[1];\\n            controlY = current[2];\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              controlX,\\n              controlY,\\n              controlX,\\n              controlY,\\n              current[3],\\n              current[4]\\n            );\\n            x = current[3];\\n            y = current[4];\\n            break;\\n\\n          case 't': // shorthand quadraticCurveTo, relative\\n            // transform to absolute x,y\\n            tempX = x + current[1];\\n            tempY = y + current[2];\\n            if (previous[0].match(/[QqTt]/) === null) {\\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\\n              // assume the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control point\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              controlX,\\n              controlY,\\n              controlX,\\n              controlY,\\n              tempX,\\n              tempY\\n            );\\n            x = tempX;\\n            y = tempY;\\n\\n            break;\\n\\n          case 'T':\\n            tempX = current[1];\\n            tempY = current[2];\\n\\n            if (previous[0].match(/[QqTt]/) === null) {\\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\\n              // assume the control point is coincident with the current point\\n              controlX = x;\\n              controlY = y;\\n            }\\n            else {\\n              // calculate reflection of previous control point\\n              controlX = 2 * x - controlX;\\n              controlY = 2 * y - controlY;\\n            }\\n            bounds = fabric.util.getBoundsOfCurve(x, y,\\n              controlX,\\n              controlY,\\n              controlX,\\n              controlY,\\n              tempX,\\n              tempY\\n            );\\n            x = tempX;\\n            y = tempY;\\n            break;\\n\\n          case 'a':\\n            // TODO: optimize this\\n            bounds = fabric.util.getBoundsOfArc(x, y,\\n              current[1],\\n              current[2],\\n              current[3],\\n              current[4],\\n              current[5],\\n              current[6] + x,\\n              current[7] + y\\n            );\\n            x += current[6];\\n            y += current[7];\\n            break;\\n\\n          case 'A':\\n            // TODO: optimize this\\n            bounds = fabric.util.getBoundsOfArc(x, y,\\n              current[1],\\n              current[2],\\n              current[3],\\n              current[4],\\n              current[5],\\n              current[6],\\n              current[7]\\n            );\\n            x = current[6];\\n            y = current[7];\\n            break;\\n\\n          case 'z':\\n          case 'Z':\\n            x = subpathStartX;\\n            y = subpathStartY;\\n            break;\\n        }\\n        previous = current;\\n        bounds.forEach(function (point) {\\n          aX.push(point.x);\\n          aY.push(point.y);\\n        });\\n        aX.push(x);\\n        aY.push(y);\\n      }\\n\\n      var minX = min(aX) || 0,\\n          minY = min(aY) || 0,\\n          maxX = max(aX) || 0,\\n          maxY = max(aY) || 0,\\n          deltaX = maxX - minX,\\n          deltaY = maxY - minY,\\n\\n          o = {\\n            left: minX,\\n            top: minY,\\n            width: deltaX,\\n            height: deltaY\\n          };\\n\\n      return o;\\n    }\\n  });\\n\\n  /**\\n   * Creates an instance of fabric.Path from an object\\n   * @static\\n   * @memberOf fabric.Path\\n   * @param {Object} object\\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\\n   */\\n  fabric.Path.fromObject = function(object, callback) {\\n    // remove this pattern rom 2.0, accept just object.\\n    var path;\\n    if (typeof object.path === 'string') {\\n      fabric.loadSVGFromURL(object.path, function (elements) {\\n        var pathUrl = object.path;\\n        path = elements[0];\\n        delete object.path;\\n\\n        fabric.util.object.extend(path, object);\\n        path.setSourcePath(pathUrl);\\n\\n        callback && callback(path);\\n      });\\n    }\\n    else {\\n      path = new fabric.Path(object.path, object);\\n      callback && callback(path);\\n      return path;\\n    }\\n  };\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\\n   * @static\\n   * @memberOf fabric.Path\\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\\n   */\\n  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);\\n\\n  /**\\n   * Creates an instance of fabric.Path from an SVG <path> element\\n   * @static\\n   * @memberOf fabric.Path\\n   * @param {SVGElement} element to parse\\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\\n   * @param {Object} [options] Options object\\n   */\\n  fabric.Path.fromElement = function(element, callback, options) {\\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\\n    callback && callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Indicates that instances of this type are async\\n   * @static\\n   * @memberOf fabric.Path\\n   * @type Boolean\\n   * @default\\n   */\\n  fabric.Path.async = true;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      invoke = fabric.util.array.invoke,\\n      parentToObject = fabric.Object.prototype.toObject;\\n\\n  if (fabric.PathGroup) {\\n    fabric.warn('fabric.PathGroup is already defined');\\n    return;\\n  }\\n\\n  /**\\n   * Path group class\\n   * @class fabric.PathGroup\\n   * @extends fabric.Path\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\\n   * @see {@link fabric.PathGroup#initialize} for constructor definition\\n   */\\n  fabric.PathGroup = fabric.util.createClass(fabric.Object, /** @lends fabric.PathGroup.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'path-group',\\n\\n    /**\\n     * Fill value\\n     * @type String\\n     * @default\\n     */\\n    fill: '',\\n\\n    /**\\n     * Constructor\\n     * @param {Array} paths\\n     * @param {Object} [options] Options object\\n     * @return {fabric.PathGroup} thisArg\\n     */\\n    initialize: function(paths, options) {\\n\\n      options = options || { };\\n      this.paths = paths || [];\\n\\n      for (var i = this.paths.length; i--;) {\\n        this.paths[i].group = this;\\n      }\\n\\n      if (options.toBeParsed) {\\n        this.parseDimensionsFromPaths(options);\\n        delete options.toBeParsed;\\n      }\\n      this.setOptions(options);\\n      this.setCoords();\\n      if (options.sourcePath) {\\n        this.setSourcePath(options.sourcePath);\\n      }\\n      if (this.objectCaching) {\\n        this._createCacheCanvas();\\n        this.setupState({ propertySet: 'cacheProperties' });\\n      }\\n    },\\n\\n    /**\\n     * Calculate width and height based on paths contained\\n     */\\n    parseDimensionsFromPaths: function(options) {\\n      var points, p, xC = [], yC = [], path, height, width,\\n          m;\\n      for (var j = this.paths.length; j--;) {\\n        path = this.paths[j];\\n        height = path.height + path.strokeWidth;\\n        width = path.width + path.strokeWidth;\\n        points = [\\n          { x: path.left, y: path.top },\\n          { x: path.left + width, y: path.top },\\n          { x: path.left, y: path.top + height },\\n          { x: path.left + width, y: path.top + height }\\n        ];\\n        m = this.paths[j].transformMatrix;\\n        for (var i = 0; i < points.length; i++) {\\n          p = points[i];\\n          if (m) {\\n            p = fabric.util.transformPoint(p, m, false);\\n          }\\n          xC.push(p.x);\\n          yC.push(p.y);\\n        }\\n      }\\n      options.width = Math.max.apply(null, xC);\\n      options.height = Math.max.apply(null, yC);\\n    },\\n\\n    /**\\n     * Execute the drawing operation for an object on a specified context\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    drawObject: function(ctx) {\\n      ctx.save();\\n      ctx.translate(-this.width / 2, -this.height / 2);\\n      for (var i = 0, l = this.paths.length; i < l; ++i) {\\n        this.paths[i].render(ctx, true);\\n      }\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * Check if cache is dirty\\n     */\\n    isCacheDirty: function() {\\n      if (this.callSuper('isCacheDirty')) {\\n        return true\\n      }\\n      if (!this.statefullCache) {\\n        return false;\\n      }\\n      for (var i = 0, len = this.paths.length; i < len; i++) {\\n        if (this.paths[i].isCacheDirty(true)) {\\n          var dim = this._getNonTransformedDimensions();\\n          this._cacheContext.clearRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\\n          return true\\n        }\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Sets certain property to a certain value\\n     * @param {String} prop\\n     * @param {*} value\\n     * @return {fabric.PathGroup} thisArg\\n     */\\n    _set: function(prop, value) {\\n\\n      if (prop === 'fill' && value && this.isSameColor()) {\\n        var i = this.paths.length;\\n        while (i--) {\\n          this.paths[i]._set(prop, value);\\n        }\\n      }\\n\\n      return this.callSuper('_set', prop, value);\\n    },\\n\\n    /**\\n     * Returns object representation of this path group\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      var o = extend(parentToObject.call(this, ['sourcePath'].concat(propertiesToInclude)), {\\n        paths: invoke(this.getObjects(), 'toObject', propertiesToInclude)\\n      });\\n      return o;\\n    },\\n\\n    /**\\n     * Returns dataless object representation of this path group\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} dataless object representation of an instance\\n     */\\n    toDatalessObject: function(propertiesToInclude) {\\n      var o = this.toObject(propertiesToInclude);\\n      if (this.sourcePath) {\\n        o.paths = this.sourcePath;\\n      }\\n      return o;\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var objects = this.getObjects(),\\n          p = this.getPointByOrigin('left', 'top'),\\n          translatePart = 'translate(' + p.x + ' ' + p.y + ')',\\n          markup = this._createBaseSVGMarkup();\\n      markup.push(\\n        '<g ', this.getSvgId(),\\n        'style=\\\"', this.getSvgStyles(), '\\\" ',\\n        'transform=\\\"', this.getSvgTransformMatrix(), translatePart, this.getSvgTransform(), '\\\" ',\\n        '>\\\\n'\\n      );\\n\\n      for (var i = 0, len = objects.length; i < len; i++) {\\n        markup.push('\\\\t', objects[i].toSVG(reviver));\\n      }\\n      markup.push('</g>\\\\n');\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns a string representation of this path group\\n     * @return {String} string representation of an object\\n     */\\n    toString: function() {\\n      return '#<fabric.PathGroup (' + this.complexity() +\\n        '): { top: ' + this.top + ', left: ' + this.left + ' }>';\\n    },\\n\\n    /**\\n     * Returns true if all paths in this group are of same color\\n     * @return {Boolean} true if all paths are of the same color (`fill`)\\n     */\\n    isSameColor: function() {\\n      var firstPathFill = this.getObjects()[0].get('fill') || '';\\n      if (typeof firstPathFill !== 'string') {\\n        return false;\\n      }\\n      firstPathFill = firstPathFill.toLowerCase();\\n      return this.getObjects().every(function(path) {\\n        var pathFill = path.get('fill') || '';\\n        return typeof pathFill === 'string' && (pathFill).toLowerCase() === firstPathFill;\\n      });\\n    },\\n\\n    /**\\n     * Returns number representation of object's complexity\\n     * @return {Number} complexity\\n     */\\n    complexity: function() {\\n      return this.paths.reduce(function(total, path) {\\n        return total + ((path && path.complexity) ? path.complexity() : 0);\\n      }, 0);\\n    },\\n\\n    /**\\n     * Returns all paths in this path group\\n     * @return {Array} array of path objects included in this path group\\n     */\\n    getObjects: function() {\\n      return this.paths;\\n    }\\n  });\\n\\n  /**\\n   * Creates fabric.PathGroup instance from an object representation\\n   * @static\\n   * @memberOf fabric.PathGroup\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when an fabric.PathGroup instance is created\\n   */\\n  fabric.PathGroup.fromObject = function(object, callback) {\\n    // remove this pattern from 2.0 accepts only object\\n    if (typeof object.paths === 'string') {\\n      fabric.loadSVGFromURL(object.paths, function (elements) {\\n\\n        var pathUrl = object.paths;\\n        delete object.paths;\\n\\n        var pathGroup = fabric.util.groupSVGElements(elements, object, pathUrl);\\n\\n        callback(pathGroup);\\n      });\\n    }\\n    else {\\n      fabric.util.enlivenObjects(object.paths, function(enlivenedObjects) {\\n        delete object.paths;\\n        callback(new fabric.PathGroup(enlivenedObjects, object));\\n      });\\n    }\\n  };\\n\\n  /**\\n   * Indicates that instances of this type are async\\n   * @static\\n   * @memberOf fabric.PathGroup\\n   * @type Boolean\\n   * @default\\n   */\\n  fabric.PathGroup.async = true;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      min = fabric.util.array.min,\\n      max = fabric.util.array.max,\\n      invoke = fabric.util.array.invoke;\\n\\n  if (fabric.Group) {\\n    return;\\n  }\\n\\n  // lock-related properties, for use in fabric.Group#get\\n  // to enable locking behavior on group\\n  // when one of its objects has lock-related properties set\\n  var _lockProperties = {\\n    lockMovementX:  true,\\n    lockMovementY:  true,\\n    lockRotation:   true,\\n    lockScalingX:   true,\\n    lockScalingY:   true,\\n    lockUniScaling: true\\n  };\\n\\n  /**\\n   * Group class\\n   * @class fabric.Group\\n   * @extends fabric.Object\\n   * @mixes fabric.Collection\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\\n   * @see {@link fabric.Group#initialize} for constructor definition\\n   */\\n  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'group',\\n\\n    /**\\n     * Width of stroke\\n     * @type Number\\n     * @default\\n     */\\n    strokeWidth: 0,\\n\\n    /**\\n     * Indicates if click events should also check for subtargets\\n     * @type Boolean\\n     * @default\\n     */\\n    subTargetCheck: false,\\n\\n    /**\\n     * Constructor\\n     * @param {Object} objects Group objects\\n     * @param {Object} [options] Options object\\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\\n     * @return {Object} thisArg\\n     */\\n    initialize: function(objects, options, isAlreadyGrouped) {\\n      options = options || { };\\n\\n      this._objects = [];\\n      // if objects enclosed in a group have been grouped already,\\n      // we cannot change properties of objects.\\n      // Thus we need to set options to group without objects,\\n      // because delegatedProperties propagate to objects.\\n      isAlreadyGrouped && this.callSuper('initialize', options);\\n\\n      this._objects = objects || [];\\n      for (var i = this._objects.length; i--; ) {\\n        this._objects[i].group = this;\\n      }\\n\\n      this.originalState = { };\\n\\n      if (options.originX) {\\n        this.originX = options.originX;\\n      }\\n      if (options.originY) {\\n        this.originY = options.originY;\\n      }\\n\\n      if (isAlreadyGrouped) {\\n        // do not change coordinate of objects enclosed in a group,\\n        // because objects coordinate system have been group coodinate system already.\\n        this._updateObjectsCoords(true);\\n      }\\n      else {\\n        this._calcBounds();\\n        this._updateObjectsCoords();\\n        this.callSuper('initialize', options);\\n      }\\n\\n      this.setCoords();\\n      this.saveCoords();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\\n     */\\n    _updateObjectsCoords: function(skipCoordsChange) {\\n      var center = this.getCenterPoint();\\n      for (var i = this._objects.length; i--; ){\\n        this._updateObjectCoords(this._objects[i], center, skipCoordsChange);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} object\\n     * @param {fabric.Point} center, current center of group.\\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of object dose not change\\n     */\\n    _updateObjectCoords: function(object, center, skipCoordsChange) {\\n      // do not display corners of objects enclosed in a group\\n      object.__origHasControls = object.hasControls;\\n      object.hasControls = false;\\n\\n      if (skipCoordsChange) {\\n        return;\\n      }\\n\\n      var objectLeft = object.getLeft(),\\n          objectTop = object.getTop(),\\n          ignoreZoom = true;\\n\\n      object.set({\\n        originalLeft: objectLeft,\\n        originalTop: objectTop,\\n        left: objectLeft - center.x,\\n        top: objectTop - center.y\\n      });\\n      object.setCoords(ignoreZoom);\\n    },\\n\\n    /**\\n     * Returns string represenation of a group\\n     * @return {String}\\n     */\\n    toString: function() {\\n      return '#<fabric.Group: (' + this.complexity() + ')>';\\n    },\\n\\n    /**\\n     * Adds an object to a group; Then recalculates group's dimension, position.\\n     * @param {Object} object\\n     * @return {fabric.Group} thisArg\\n     * @chainable\\n     */\\n    addWithUpdate: function(object) {\\n      this._restoreObjectsState();\\n      fabric.util.resetObjectTransform(this);\\n      if (object) {\\n        this._objects.push(object);\\n        object.group = this;\\n        object._set('canvas', this.canvas);\\n      }\\n      // since _restoreObjectsState set objects inactive\\n      this.forEachObject(this._setObjectActive, this);\\n      this._calcBounds();\\n      this._updateObjectsCoords();\\n      this.dirty = true;\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setObjectActive: function(object) {\\n      object.set('active', true);\\n      object.group = this;\\n    },\\n\\n    /**\\n     * Removes an object from a group; Then recalculates group's dimension, position.\\n     * @param {Object} object\\n     * @return {fabric.Group} thisArg\\n     * @chainable\\n     */\\n    removeWithUpdate: function(object) {\\n      this._restoreObjectsState();\\n      fabric.util.resetObjectTransform(this);\\n      // since _restoreObjectsState set objects inactive\\n      this.forEachObject(this._setObjectActive, this);\\n\\n      this.remove(object);\\n      this._calcBounds();\\n      this._updateObjectsCoords();\\n      this.dirty = true;\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _onObjectAdded: function(object) {\\n      this.dirty = true;\\n      object.group = this;\\n      object._set('canvas', this.canvas);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _onObjectRemoved: function(object) {\\n      this.dirty = true;\\n      delete object.group;\\n      object.set('active', false);\\n    },\\n\\n    /**\\n     * Properties that are delegated to group objects when reading/writing\\n     * @param {Object} delegatedProperties\\n     */\\n    delegatedProperties: {\\n      fill:             true,\\n      stroke:           true,\\n      strokeWidth:      true,\\n      fontFamily:       true,\\n      fontWeight:       true,\\n      fontSize:         true,\\n      fontStyle:        true,\\n      lineHeight:       true,\\n      textDecoration:   true,\\n      textAlign:        true,\\n      backgroundColor:  true\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _set: function(key, value) {\\n      var i = this._objects.length;\\n\\n      if (this.delegatedProperties[key] || key === 'canvas') {\\n        while (i--) {\\n          this._objects[i].set(key, value);\\n        }\\n      }\\n      else {\\n        while (i--) {\\n          this._objects[i].setOnGroup(key, value);\\n        }\\n      }\\n\\n      this.callSuper('_set', key, value);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        objects: invoke(this._objects, 'toObject', propertiesToInclude)\\n      });\\n    },\\n\\n    /**\\n     * Renders instance on a given context\\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\\n     */\\n    render: function(ctx) {\\n      this._transformDone = true;\\n      this.callSuper('render', ctx);\\n      this._transformDone = false;\\n    },\\n\\n    /**\\n     * Execute the drawing operation for an object on a specified context\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    drawObject: function(ctx) {\\n      for (var i = 0, len = this._objects.length; i < len; i++) {\\n        this._renderObject(this._objects[i], ctx);\\n      }\\n    },\\n\\n    /**\\n     * Check if cache is dirty\\n     */\\n    isCacheDirty: function() {\\n      if (this.callSuper('isCacheDirty')) {\\n        return true\\n      }\\n      if (!this.statefullCache) {\\n        return false;\\n      }\\n      for (var i = 0, len = this._objects.length; i < len; i++) {\\n        if (this._objects[i].isCacheDirty(true)) {\\n          var dim = this._getNonTransformedDimensions();\\n          this._cacheContext.clearRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\\n          return true\\n        }\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Renders controls and borders for the object\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} [noTransform] When true, context is not transformed\\n     */\\n    _renderControls: function(ctx, noTransform) {\\n      ctx.save();\\n      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\\n      this.callSuper('_renderControls', ctx, noTransform);\\n      for (var i = 0, len = this._objects.length; i < len; i++) {\\n        this._objects[i]._renderControls(ctx);\\n      }\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _renderObject: function(object, ctx) {\\n      // do not render if object is not visible\\n      if (!object.visible) {\\n        return;\\n      }\\n\\n      var originalHasRotatingPoint = object.hasRotatingPoint;\\n      object.hasRotatingPoint = false;\\n      object.render(ctx);\\n      object.hasRotatingPoint = originalHasRotatingPoint;\\n    },\\n\\n    /**\\n     * Retores original state of each of group objects (original state is that which was before group was created).\\n     * @private\\n     * @return {fabric.Group} thisArg\\n     * @chainable\\n     */\\n    _restoreObjectsState: function() {\\n      this._objects.forEach(this._restoreObjectState, this);\\n      return this;\\n    },\\n\\n    /**\\n     * Realises the transform from this group onto the supplied object\\n     * i.e. it tells you what would happen if the supplied object was in\\n     * the group, and then the group was destroyed. It mutates the supplied\\n     * object.\\n     * @param {fabric.Object} object\\n     * @return {fabric.Object} transformedObject\\n     */\\n    realizeTransform: function(object) {\\n      var matrix = object.calcTransformMatrix(),\\n          options = fabric.util.qrDecompose(matrix),\\n          center = new fabric.Point(options.translateX, options.translateY);\\n      object.flipX = false;\\n      object.flipY = false;\\n      object.set('scaleX', options.scaleX);\\n      object.set('scaleY', options.scaleY);\\n      object.skewX = options.skewX;\\n      object.skewY = options.skewY;\\n      object.angle = options.angle;\\n      object.setPositionByOrigin(center, 'center', 'center');\\n      return object;\\n    },\\n\\n    /**\\n     * Restores original state of a specified object in group\\n     * @private\\n     * @param {fabric.Object} object\\n     * @return {fabric.Group} thisArg\\n     */\\n    _restoreObjectState: function(object) {\\n      this.realizeTransform(object);\\n      object.setCoords();\\n      object.hasControls = object.__origHasControls;\\n      delete object.__origHasControls;\\n      object.set('active', false);\\n      delete object.group;\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Destroys a group (restoring state of its objects)\\n     * @return {fabric.Group} thisArg\\n     * @chainable\\n     */\\n    destroy: function() {\\n      return this._restoreObjectsState();\\n    },\\n\\n    /**\\n     * Saves coordinates of this instance (to be used together with `hasMoved`)\\n     * @saveCoords\\n     * @return {fabric.Group} thisArg\\n     * @chainable\\n     */\\n    saveCoords: function() {\\n      this._originalLeft = this.get('left');\\n      this._originalTop = this.get('top');\\n      return this;\\n    },\\n\\n    /**\\n     * Checks whether this group was moved (since `saveCoords` was called last)\\n     * @return {Boolean} true if an object was moved (since fabric.Group#saveCoords was called)\\n     */\\n    hasMoved: function() {\\n      return this._originalLeft !== this.get('left') ||\\n             this._originalTop !== this.get('top');\\n    },\\n\\n    /**\\n     * Sets coordinates of all group objects\\n     * @return {fabric.Group} thisArg\\n     * @chainable\\n     */\\n    setObjectsCoords: function() {\\n      var ignoreZoom = true;\\n      this.forEachObject(function(object) {\\n        object.setCoords(ignoreZoom);\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _calcBounds: function(onlyWidthHeight) {\\n      var aX = [],\\n          aY = [],\\n          o, prop,\\n          props = ['tr', 'br', 'bl', 'tl'],\\n          i = 0, iLen = this._objects.length,\\n          j, jLen = props.length,\\n          ignoreZoom = true;\\n\\n      for ( ; i < iLen; ++i) {\\n        o = this._objects[i];\\n        o.setCoords(ignoreZoom);\\n        for (j = 0; j < jLen; j++) {\\n          prop = props[j];\\n          aX.push(o.oCoords[prop].x);\\n          aY.push(o.oCoords[prop].y);\\n        }\\n      }\\n\\n      this.set(this._getBounds(aX, aY, onlyWidthHeight));\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getBounds: function(aX, aY, onlyWidthHeight) {\\n      var minXY = new fabric.Point(min(aX), min(aY)),\\n          maxXY = new fabric.Point(max(aX), max(aY)),\\n          obj = {\\n            width: (maxXY.x - minXY.x) || 0,\\n            height: (maxXY.y - minXY.y) || 0\\n          };\\n\\n      if (!onlyWidthHeight) {\\n        obj.left = minXY.x || 0;\\n        obj.top = minXY.y || 0;\\n        if (this.originX === 'center') {\\n          obj.left += obj.width / 2;\\n        }\\n        if (this.originX === 'right') {\\n          obj.left += obj.width;\\n        }\\n        if (this.originY === 'center') {\\n          obj.top += obj.height / 2;\\n        }\\n        if (this.originY === 'bottom') {\\n          obj.top += obj.height;\\n        }\\n      }\\n      return obj;\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns svg representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var markup = this._createBaseSVGMarkup();\\n      markup.push(\\n        '<g ', this.getSvgId(), 'transform=\\\"',\\n        /* avoiding styles intentionally */\\n        this.getSvgTransform(),\\n        this.getSvgTransformMatrix(),\\n        '\\\" style=\\\"',\\n        this.getSvgFilter(),\\n        '\\\">\\\\n'\\n      );\\n\\n      for (var i = 0, len = this._objects.length; i < len; i++) {\\n        markup.push('\\\\t', this._objects[i].toSVG(reviver));\\n      }\\n\\n      markup.push('</g>\\\\n');\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns requested property\\n     * @param {String} prop Property to get\\n     * @return {*}\\n     */\\n    get: function(prop) {\\n      if (prop in _lockProperties) {\\n        if (this[prop]) {\\n          return this[prop];\\n        }\\n        else {\\n          for (var i = 0, len = this._objects.length; i < len; i++) {\\n            if (this._objects[i][prop]) {\\n              return true;\\n            }\\n          }\\n          return false;\\n        }\\n      }\\n      else {\\n        if (prop in this.delegatedProperties) {\\n          return this._objects[0] && this._objects[0].get(prop);\\n        }\\n        return this[prop];\\n      }\\n    }\\n  });\\n\\n  /**\\n   * Returns {@link fabric.Group} instance from an object representation\\n   * @static\\n   * @memberOf fabric.Group\\n   * @param {Object} object Object to create a group from\\n   * @param {Function} [callback] Callback to invoke when an group instance is created\\n   */\\n  fabric.Group.fromObject = function(object, callback) {\\n    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\\n      delete object.objects;\\n      callback && callback(new fabric.Group(enlivenedObjects, object, true));\\n    });\\n  };\\n\\n  /**\\n   * Indicates that instances of this type are async\\n   * @static\\n   * @memberOf fabric.Group\\n   * @type Boolean\\n   * @default\\n   */\\n  fabric.Group.async = true;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var extend = fabric.util.object.extend;\\n\\n  if (!global.fabric) {\\n    global.fabric = { };\\n  }\\n\\n  if (global.fabric.Image) {\\n    fabric.warn('fabric.Image is already defined.');\\n    return;\\n  }\\n\\n  var stateProperties = fabric.Object.prototype.stateProperties.concat();\\n  stateProperties.push(\\n    'alignX',\\n    'alignY',\\n    'meetOrSlice'\\n  );\\n\\n  /**\\n   * Image class\\n   * @class fabric.Image\\n   * @extends fabric.Object\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}\\n   * @see {@link fabric.Image#initialize} for constructor definition\\n   */\\n  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'image',\\n\\n    /**\\n     * crossOrigin value (one of \\\"\\\", \\\"anonymous\\\", \\\"use-credentials\\\")\\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\\n     * @type String\\n     * @default\\n     */\\n    crossOrigin: '',\\n\\n    /**\\n     * AlignX value, part of preserveAspectRatio (one of \\\"none\\\", \\\"mid\\\", \\\"min\\\", \\\"max\\\")\\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\\n     * This parameter defines how the picture is aligned to its viewport when image element width differs from image width.\\n     * @type String\\n     * @default\\n     */\\n    alignX: 'none',\\n\\n    /**\\n     * AlignY value, part of preserveAspectRatio (one of \\\"none\\\", \\\"mid\\\", \\\"min\\\", \\\"max\\\")\\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\\n     * This parameter defines how the picture is aligned to its viewport when image element height differs from image height.\\n     * @type String\\n     * @default\\n     */\\n    alignY: 'none',\\n\\n    /**\\n     * meetOrSlice value, part of preserveAspectRatio  (one of \\\"meet\\\", \\\"slice\\\").\\n     * if meet the image is always fully visibile, if slice the viewport is always filled with image.\\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\\n     * @type String\\n     * @default\\n     */\\n    meetOrSlice: 'meet',\\n\\n    /**\\n     * Width of a stroke.\\n     * For image quality a stroke multiple of 2 gives better results.\\n     * @type Number\\n     * @default\\n     */\\n    strokeWidth: 0,\\n\\n    /**\\n     * private\\n     * contains last value of scaleX to detect\\n     * if the Image got resized after the last Render\\n     * @type Number\\n     */\\n    _lastScaleX: 1,\\n\\n    /**\\n     * private\\n     * contains last value of scaleY to detect\\n     * if the Image got resized after the last Render\\n     * @type Number\\n     */\\n    _lastScaleY: 1,\\n\\n    /**\\n     * minimum scale factor under which any resizeFilter is triggered to resize the image\\n     * 0 will disable the automatic resize. 1 will trigger automatically always.\\n     * number bigger than 1 can be used in case we want to scale with some filter above\\n     * the natural image dimensions\\n     * @type Number\\n     */\\n    minimumScaleTrigger: 0.5,\\n\\n    /**\\n     * List of properties to consider when checking if\\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\\n     * as well as for history (undo/redo) purposes\\n     * @type Array\\n     */\\n    stateProperties: stateProperties,\\n\\n    /**\\n     * When `true`, object is cached on an additional canvas.\\n     * default to false for images\\n     * since 1.7.0\\n     * @type Boolean\\n     * @default\\n     */\\n    objectCaching: false,\\n\\n    /**\\n     * Constructor\\n     * @param {HTMLImageElement | String} element Image element\\n     * @param {Object} [options] Options object\\n     * @param {function} [callback] callback function to call after eventual filters applied.\\n     * @return {fabric.Image} thisArg\\n     */\\n    initialize: function(element, options, callback) {\\n      options || (options = { });\\n      this.filters = [];\\n      this.resizeFilters = [];\\n      this.callSuper('initialize', options);\\n      this._initElement(element, options, callback);\\n    },\\n\\n    /**\\n     * Returns image element which this instance if based on\\n     * @return {HTMLImageElement} Image element\\n     */\\n    getElement: function() {\\n      return this._element;\\n    },\\n\\n    /**\\n     * Sets image element for this instance to a specified one.\\n     * If filters defined they are applied to new image.\\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\\n     * @param {HTMLImageElement} element\\n     * @param {Function} [callback] Callback is invoked when all filters have been applied and new image is generated\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Image} thisArg\\n     * @chainable\\n     */\\n    setElement: function(element, callback, options) {\\n\\n      var _callback, _this;\\n\\n      this._element = element;\\n      this._originalElement = element;\\n      this._initConfig(options);\\n\\n      if (this.resizeFilters.length === 0) {\\n        _callback = callback;\\n      }\\n      else {\\n        _this = this;\\n        _callback = function() {\\n          _this.applyFilters(callback, _this.resizeFilters, _this._filteredEl || _this._originalElement, true);\\n        };\\n      }\\n\\n      if (this.filters.length !== 0) {\\n        this.applyFilters(_callback);\\n      }\\n      else if (_callback) {\\n        _callback(this);\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Sets crossOrigin value (on an instance and corresponding image element)\\n     * @return {fabric.Image} thisArg\\n     * @chainable\\n     */\\n    setCrossOrigin: function(value) {\\n      this.crossOrigin = value;\\n      this._element.crossOrigin = value;\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Returns original size of an image\\n     * @return {Object} Object with \\\"width\\\" and \\\"height\\\" properties\\n     */\\n    getOriginalSize: function() {\\n      var element = this.getElement();\\n      return {\\n        width: element.width,\\n        height: element.height\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _stroke: function(ctx) {\\n      if (!this.stroke || this.strokeWidth === 0) {\\n        return;\\n      }\\n      var w = this.width / 2, h = this.height / 2;\\n      ctx.beginPath();\\n      ctx.moveTo(-w, -h);\\n      ctx.lineTo(w, -h);\\n      ctx.lineTo(w, h);\\n      ctx.lineTo(-w, h);\\n      ctx.lineTo(-w, -h);\\n      ctx.closePath();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderDashedStroke: function(ctx) {\\n      var x = -this.width / 2,\\n          y = -this.height / 2,\\n          w = this.width,\\n          h = this.height;\\n\\n      ctx.save();\\n      this._setStrokeStyles(ctx);\\n\\n      ctx.beginPath();\\n      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);\\n      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);\\n      ctx.closePath();\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      var filters = [], resizeFilters = [],\\n          scaleX = 1, scaleY = 1;\\n\\n      this.filters.forEach(function(filterObj) {\\n        if (filterObj) {\\n          if (filterObj.type === 'Resize') {\\n            scaleX *= filterObj.scaleX;\\n            scaleY *= filterObj.scaleY;\\n          }\\n          filters.push(filterObj.toObject());\\n        }\\n      });\\n\\n      this.resizeFilters.forEach(function(filterObj) {\\n        filterObj && resizeFilters.push(filterObj.toObject());\\n      });\\n      var object = extend(\\n        this.callSuper(\\n          'toObject',\\n          ['crossOrigin', 'alignX', 'alignY', 'meetOrSlice'].concat(propertiesToInclude)\\n        ), {\\n          src: this.getSrc(),\\n          filters: filters,\\n          resizeFilters: resizeFilters,\\n        });\\n\\n      object.width /= scaleX;\\n      object.height /= scaleY;\\n\\n      return object;\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns SVG representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2,\\n          preserveAspectRatio = 'none', filtered = true;\\n      if (this.group && this.group.type === 'path-group') {\\n        x = this.left;\\n        y = this.top;\\n      }\\n      if (this.alignX !== 'none' && this.alignY !== 'none') {\\n        preserveAspectRatio = 'x' + this.alignX + 'Y' + this.alignY + ' ' + this.meetOrSlice;\\n      }\\n      markup.push(\\n        '<g transform=\\\"', this.getSvgTransform(), this.getSvgTransformMatrix(), '\\\">\\\\n',\\n          '<image ', this.getSvgId(), 'xlink:href=\\\"', this.getSvgSrc(filtered),\\n            '\\\" x=\\\"', x, '\\\" y=\\\"', y,\\n            '\\\" style=\\\"', this.getSvgStyles(),\\n            // we're essentially moving origin of transformation from top/left corner to the center of the shape\\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\\n            // so that object's center aligns with container's left/top\\n            '\\\" width=\\\"', this.width,\\n            '\\\" height=\\\"', this.height,\\n            '\\\" preserveAspectRatio=\\\"', preserveAspectRatio, '\\\"',\\n          '></image>\\\\n'\\n      );\\n\\n      if (this.stroke || this.strokeDashArray) {\\n        var origFill = this.fill;\\n        this.fill = null;\\n        markup.push(\\n          '<rect ',\\n            'x=\\\"', x, '\\\" y=\\\"', y,\\n            '\\\" width=\\\"', this.width, '\\\" height=\\\"', this.height,\\n            '\\\" style=\\\"', this.getSvgStyles(),\\n          '\\\"/>\\\\n'\\n        );\\n        this.fill = origFill;\\n      }\\n\\n      markup.push('</g>\\\\n');\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Returns source of an image\\n     * @param {Boolean} filtered indicates if the src is needed for svg\\n     * @return {String} Source of an image\\n     */\\n    getSrc: function(filtered) {\\n      var element = filtered ? this._element : this._originalElement;\\n      if (element) {\\n        return fabric.isLikelyNode ? element._src : element.src;\\n      }\\n      else {\\n        return this.src || '';\\n      }\\n    },\\n\\n    /**\\n     * Sets source of an image\\n     * @param {String} src Source string (URL)\\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Image} thisArg\\n     * @chainable\\n     */\\n    setSrc: function(src, callback, options) {\\n      fabric.util.loadImage(src, function(img) {\\n        return this.setElement(img, callback, options);\\n      }, this, options && options.crossOrigin);\\n    },\\n\\n    /**\\n     * Returns string representation of an instance\\n     * @return {String} String representation of an instance\\n     */\\n    toString: function() {\\n      return '#<fabric.Image: { src: \\\"' + this.getSrc() + '\\\" }>';\\n    },\\n\\n    /**\\n     * Applies filters assigned to this image (from \\\"filters\\\" array)\\n     * @method applyFilters\\n     * @param {Function} callback Callback is invoked when all filters have been applied and new image is generated\\n     * @param {Array} filters to be applied\\n     * @param {fabric.Image} imgElement image to filter ( default to this._element )\\n     * @param {Boolean} forResizing\\n     * @return {CanvasElement} canvasEl to be drawn immediately\\n     * @chainable\\n     */\\n    applyFilters: function(callback, filters, imgElement, forResizing) {\\n\\n      filters = filters || this.filters;\\n      imgElement = imgElement || this._originalElement;\\n\\n      if (!imgElement) {\\n        return;\\n      }\\n\\n      var replacement = fabric.util.createImage(),\\n          retinaScaling = this.canvas ? this.canvas.getRetinaScaling() : fabric.devicePixelRatio,\\n          minimumScale = this.minimumScaleTrigger / retinaScaling,\\n          _this = this, scaleX, scaleY;\\n\\n      if (filters.length === 0) {\\n        this._element = imgElement;\\n        callback && callback(this);\\n        return imgElement;\\n      }\\n\\n      var canvasEl = fabric.util.createCanvasElement();\\n      canvasEl.width = imgElement.width;\\n      canvasEl.height = imgElement.height;\\n      canvasEl.getContext('2d').drawImage(imgElement, 0, 0, imgElement.width, imgElement.height);\\n\\n      filters.forEach(function(filter) {\\n        if (!filter) {\\n          return;\\n        }\\n        if (forResizing) {\\n          scaleX = _this.scaleX < minimumScale ? _this.scaleX : 1;\\n          scaleY = _this.scaleY < minimumScale ? _this.scaleY : 1;\\n          if (scaleX * retinaScaling < 1) {\\n            scaleX *= retinaScaling;\\n          }\\n          if (scaleY * retinaScaling < 1) {\\n            scaleY *= retinaScaling;\\n          }\\n        }\\n        else {\\n          scaleX = filter.scaleX;\\n          scaleY = filter.scaleY;\\n        }\\n        filter.applyTo(canvasEl, scaleX, scaleY);\\n        if (!forResizing && filter.type === 'Resize') {\\n          _this.width *= filter.scaleX;\\n          _this.height *= filter.scaleY;\\n        }\\n      });\\n\\n      /** @ignore */\\n      replacement.width = canvasEl.width;\\n      replacement.height = canvasEl.height;\\n      if (fabric.isLikelyNode) {\\n        replacement.src = canvasEl.toBuffer(undefined, fabric.Image.pngCompression);\\n        // onload doesn't fire in some node versions, so we invoke callback manually\\n        _this._element = replacement;\\n        !forResizing && (_this._filteredEl = replacement);\\n        callback && callback(_this);\\n      }\\n      else {\\n        replacement.onload = function() {\\n          _this._element = replacement;\\n          !forResizing && (_this._filteredEl = replacement);\\n          callback && callback(_this);\\n          replacement.onload = canvasEl = null;\\n        };\\n        replacement.src = canvasEl.toDataURL('image/png');\\n      }\\n      return canvasEl;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    _render: function(ctx, noTransform) {\\n      var x, y, imageMargins = this._findMargins(), elementToDraw;\\n\\n      x = (noTransform ? this.left : -this.width / 2);\\n      y = (noTransform ? this.top : -this.height / 2);\\n\\n      if (this.meetOrSlice === 'slice') {\\n        ctx.beginPath();\\n        ctx.rect(x, y, this.width, this.height);\\n        ctx.clip();\\n      }\\n\\n      if (this.isMoving === false && this.resizeFilters.length && this._needsResize()) {\\n        this._lastScaleX = this.scaleX;\\n        this._lastScaleY = this.scaleY;\\n        elementToDraw = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, true);\\n      }\\n      else {\\n        elementToDraw = this._element;\\n      }\\n      elementToDraw && ctx.drawImage(elementToDraw,\\n                                     x + imageMargins.marginX,\\n                                     y + imageMargins.marginY,\\n                                     imageMargins.width,\\n                                     imageMargins.height\\n                                    );\\n\\n      this._stroke(ctx);\\n      this._renderStroke(ctx);\\n    },\\n\\n    /**\\n     * @private, needed to check if image needs resize\\n     */\\n    _needsResize: function() {\\n      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _findMargins: function() {\\n      var width = this.width, height = this.height, scales,\\n          scale, marginX = 0, marginY = 0;\\n\\n      if (this.alignX !== 'none' || this.alignY !== 'none') {\\n        scales = [this.width / this._element.width, this.height / this._element.height];\\n        scale = this.meetOrSlice === 'meet'\\n                ? Math.min.apply(null, scales) : Math.max.apply(null, scales);\\n        width = this._element.width * scale;\\n        height = this._element.height * scale;\\n        if (this.alignX === 'Mid') {\\n          marginX = (this.width - width) / 2;\\n        }\\n        if (this.alignX === 'Max') {\\n          marginX = this.width - width;\\n        }\\n        if (this.alignY === 'Mid') {\\n          marginY = (this.height - height) / 2;\\n        }\\n        if (this.alignY === 'Max') {\\n          marginY = this.height - height;\\n        }\\n      }\\n      return {\\n        width:  width,\\n        height: height,\\n        marginX: marginX,\\n        marginY: marginY\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _resetWidthHeight: function() {\\n      var element = this.getElement();\\n\\n      this.set('width', element.width);\\n      this.set('height', element.height);\\n    },\\n\\n    /**\\n     * The Image class's initialization method. This method is automatically\\n     * called by the constructor.\\n     * @private\\n     * @param {HTMLImageElement|String} element The element representing the image\\n     * @param {Object} [options] Options object\\n     */\\n    _initElement: function(element, options, callback) {\\n      this.setElement(fabric.util.getById(element), callback, options);\\n      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} [options] Options object\\n     */\\n    _initConfig: function(options) {\\n      options || (options = { });\\n      this.setOptions(options);\\n      this._setWidthHeight(options);\\n      if (this._element && this.crossOrigin) {\\n        this._element.crossOrigin = this.crossOrigin;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Array} filters to be initialized\\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\\n     */\\n    _initFilters: function(filters, callback) {\\n      if (filters && filters.length) {\\n        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\\n          callback && callback(enlivenedObjects);\\n        }, 'fabric.Image.filters');\\n      }\\n      else {\\n        callback && callback();\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} [options] Object with width/height properties\\n     */\\n    _setWidthHeight: function(options) {\\n      this.width = 'width' in options\\n        ? options.width\\n        : (this.getElement()\\n            ? this.getElement().width || 0\\n            : 0);\\n\\n      this.height = 'height' in options\\n        ? options.height\\n        : (this.getElement()\\n            ? this.getElement().height || 0\\n            : 0);\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity of this instance\\n     */\\n    complexity: function() {\\n      return 1;\\n    }\\n  });\\n\\n  /**\\n   * Default CSS class name for canvas\\n   * @static\\n   * @type String\\n   * @default\\n   */\\n  fabric.Image.CSS_CANVAS = 'canvas-img';\\n\\n  /**\\n   * Alias for getSrc\\n   * @static\\n   */\\n  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\\n\\n  /**\\n   * Creates an instance of fabric.Image from its object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} callback Callback to invoke when an image instance is created\\n   */\\n  fabric.Image.fromObject = function(object, callback) {\\n    fabric.util.loadImage(object.src, function(img) {\\n      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\\n        object.filters = filters || [];\\n        fabric.Image.prototype._initFilters.call(object, object.resizeFilters, function(resizeFilters) {\\n          object.resizeFilters = resizeFilters || [];\\n          return new fabric.Image(img, object, callback);\\n        });\\n      });\\n    }, null, object.crossOrigin);\\n  };\\n\\n  /**\\n   * Creates an instance of fabric.Image from an URL string\\n   * @static\\n   * @param {String} url URL to create an image from\\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)\\n   * @param {Object} [imgOptions] Options object\\n   */\\n  fabric.Image.fromURL = function(url, callback, imgOptions) {\\n    fabric.util.loadImage(url, function(img) {\\n      callback && callback(new fabric.Image(img, imgOptions));\\n    }, null, imgOptions && imgOptions.crossOrigin);\\n  };\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\\n   * @static\\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\\n   */\\n  fabric.Image.ATTRIBUTE_NAMES =\\n    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href'.split(' '));\\n\\n  /**\\n   * Returns {@link fabric.Image} instance from an SVG element\\n   * @static\\n   * @param {SVGElement} element Element to parse\\n   * @param {Function} callback Callback to execute when fabric.Image object is created\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Image} Instance of fabric.Image\\n   */\\n  fabric.Image.fromElement = function(element, callback, options) {\\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES),\\n        preserveAR;\\n\\n    if (parsedAttributes.preserveAspectRatio) {\\n      preserveAR = fabric.util.parsePreserveAspectRatioAttribute(parsedAttributes.preserveAspectRatio);\\n      extend(parsedAttributes, preserveAR);\\n    }\\n\\n    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,\\n      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Indicates that instances of this type are async\\n   * @static\\n   * @type Boolean\\n   * @default\\n   */\\n  fabric.Image.async = true;\\n\\n  /**\\n   * Indicates compression level used when generating PNG under Node (in applyFilters). Any of 0-9\\n   * @static\\n   * @type Number\\n   * @default\\n   */\\n  fabric.Image.pngCompression = 1;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\\n\\n  /**\\n   * @private\\n   * @return {Number} angle value\\n   */\\n  _getAngleValueForStraighten: function() {\\n    var angle = this.getAngle() % 360;\\n    if (angle > 0) {\\n      return Math.round((angle - 1) / 90) * 90;\\n    }\\n    return Math.round(angle / 90) * 90;\\n  },\\n\\n  /**\\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  straighten: function() {\\n    this.setAngle(this._getAngleValueForStraighten());\\n    return this;\\n  },\\n\\n  /**\\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\\n   * @param {Object} callbacks Object with callback functions\\n   * @param {Function} [callbacks.onComplete] Invoked on completion\\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\\n   * @return {fabric.Object} thisArg\\n   * @chainable\\n   */\\n  fxStraighten: function(callbacks) {\\n    callbacks = callbacks || { };\\n\\n    var empty = function() { },\\n        onComplete = callbacks.onComplete || empty,\\n        onChange = callbacks.onChange || empty,\\n        _this = this;\\n\\n    fabric.util.animate({\\n      startValue: this.get('angle'),\\n      endValue: this._getAngleValueForStraighten(),\\n      duration: this.FX_DURATION,\\n      onChange: function(value) {\\n        _this.setAngle(value);\\n        onChange();\\n      },\\n      onComplete: function() {\\n        _this.setCoords();\\n        onComplete();\\n      },\\n      onStart: function() {\\n        _this.set('active', false);\\n      }\\n    });\\n\\n    return this;\\n  }\\n});\\n\\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\\n\\n  /**\\n   * Straightens object, then rerenders canvas\\n   * @param {fabric.Object} object Object to straighten\\n   * @return {fabric.Canvas} thisArg\\n   * @chainable\\n   */\\n  straightenObject: function (object) {\\n    object.straighten();\\n    this.renderAll();\\n    return this;\\n  },\\n\\n  /**\\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\\n   * @param {fabric.Object} object Object to straighten\\n   * @return {fabric.Canvas} thisArg\\n   * @chainable\\n   */\\n  fxStraightenObject: function (object) {\\n    object.fxStraighten({\\n      onChange: this.renderAll.bind(this)\\n    });\\n    return this;\\n  }\\n});\\n\\n\\n/**\\n * @namespace fabric.Image.filters\\n * @memberOf fabric.Image\\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}\\n * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n */\\nfabric.Image.filters = fabric.Image.filters || { };\\n\\n/**\\n * Root filter class from which all filter classes inherit from\\n * @class fabric.Image.filters.BaseFilter\\n * @memberOf fabric.Image.filters\\n */\\nfabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\\n\\n  /**\\n   * Filter type\\n   * @param {String} type\\n   * @default\\n   */\\n  type: 'BaseFilter',\\n\\n  /**\\n   * Constructor\\n   * @param {Object} [options] Options object\\n   */\\n  initialize: function(options) {\\n    if (options) {\\n      this.setOptions(options);\\n    }\\n  },\\n\\n  /**\\n   * Sets filter's properties from options\\n   * @param {Object} [options] Options object\\n   */\\n  setOptions: function(options) {\\n    for (var prop in options) {\\n      this[prop] = options[prop];\\n    }\\n  },\\n\\n  /**\\n   * Returns object representation of an instance\\n   * @return {Object} Object representation of an instance\\n   */\\n  toObject: function() {\\n    return { type: this.type };\\n  },\\n\\n  /**\\n   * Returns a JSON representation of an instance\\n   * @return {Object} JSON\\n   */\\n  toJSON: function() {\\n    // delegate, not alias\\n    return this.toObject();\\n  }\\n});\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Brightness filter class\\n   * @class fabric.Image.filters.Brightness\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Brightness({\\n   *   brightness: 200\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Brightness',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Brightness.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Number} [options.brightness=0] Value to brighten the image up (-255..255)\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      this.brightness = options.brightness || 0;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          brightness = this.brightness;\\n\\n      for (var i = 0, len = data.length; i < len; i += 4) {\\n        data[i] += brightness;\\n        data[i + 1] += brightness;\\n        data[i + 2] += brightness;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        brightness: this.brightness\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\\n   */\\n  fabric.Image.filters.Brightness.fromObject = function(object) {\\n    return new fabric.Image.filters.Brightness(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Adapted from <a href=\\\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\\\">html5rocks article</a>\\n   * @class fabric.Image.filters.Convolute\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example <caption>Sharpen filter</caption>\\n   * var filter = new fabric.Image.filters.Convolute({\\n   *   matrix: [ 0, -1,  0,\\n   *            -1,  5, -1,\\n   *             0, -1,  0 ]\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   * @example <caption>Blur filter</caption>\\n   * var filter = new fabric.Image.filters.Convolute({\\n   *   matrix: [ 1/9, 1/9, 1/9,\\n   *             1/9, 1/9, 1/9,\\n   *             1/9, 1/9, 1/9 ]\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   * @example <caption>Emboss filter</caption>\\n   * var filter = new fabric.Image.filters.Convolute({\\n   *   matrix: [ 1,   1,  1,\\n   *             1, 0.7, -1,\\n   *            -1,  -1, -1 ]\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   * @example <caption>Emboss filter with opaqueness</caption>\\n   * var filter = new fabric.Image.filters.Convolute({\\n   *   opaque: true,\\n   *   matrix: [ 1,   1,  1,\\n   *             1, 0.7, -1,\\n   *            -1,  -1, -1 ]\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Convolute',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Convolute.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\\n     * @param {Array} [options.matrix] Filter matrix\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n\\n      this.opaque = options.opaque;\\n      this.matrix = options.matrix || [\\n        0, 0, 0,\\n        0, 1, 0,\\n        0, 0, 0\\n      ];\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n\\n      var weights = this.matrix,\\n          context = canvasEl.getContext('2d'),\\n          pixels = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n\\n          side = Math.round(Math.sqrt(weights.length)),\\n          halfSide = Math.floor(side / 2),\\n          src = pixels.data,\\n          sw = pixels.width,\\n          sh = pixels.height,\\n          output = context.createImageData(sw, sh),\\n          dst = output.data,\\n          // go through the destination image pixels\\n          alphaFac = this.opaque ? 1 : 0,\\n          r, g, b, a, dstOff,\\n          scx, scy, srcOff, wt;\\n\\n      for (var y = 0; y < sh; y++) {\\n        for (var x = 0; x < sw; x++) {\\n          dstOff = (y * sw + x) * 4;\\n          // calculate the weighed sum of the source image pixels that\\n          // fall under the convolution matrix\\n          r = 0; g = 0; b = 0; a = 0;\\n\\n          for (var cy = 0; cy < side; cy++) {\\n            for (var cx = 0; cx < side; cx++) {\\n              scy = y + cy - halfSide;\\n              scx = x + cx - halfSide;\\n\\n              // eslint-disable-next-line max-depth\\n              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {\\n                continue;\\n              }\\n\\n              srcOff = (scy * sw + scx) * 4;\\n              wt = weights[cy * side + cx];\\n\\n              r += src[srcOff] * wt;\\n              g += src[srcOff + 1] * wt;\\n              b += src[srcOff + 2] * wt;\\n              a += src[srcOff + 3] * wt;\\n            }\\n          }\\n          dst[dstOff] = r;\\n          dst[dstOff + 1] = g;\\n          dst[dstOff + 2] = b;\\n          dst[dstOff + 3] = a + alphaFac * (255 - a);\\n        }\\n      }\\n\\n      context.putImageData(output, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        opaque: this.opaque,\\n        matrix: this.matrix\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\\n   */\\n  fabric.Image.filters.Convolute.fromObject = function(object) {\\n    return new fabric.Image.filters.Convolute(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * GradientTransparency filter class\\n   * @class fabric.Image.filters.GradientTransparency\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.GradientTransparency#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.GradientTransparency({\\n   *   threshold: 200\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n   // eslint-disable-next-line max-len\\n  filters.GradientTransparency = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.GradientTransparency.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'GradientTransparency',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.GradientTransparency.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Number} [options.threshold=100] Threshold value\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      this.threshold = options.threshold || 100;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          threshold = this.threshold,\\n          total = data.length;\\n\\n      for (var i = 0, len = data.length; i < len; i += 4) {\\n        data[i + 3] = threshold + 255 * (total - i) / total;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        threshold: this.threshold\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.GradientTransparency} Instance of fabric.Image.filters.GradientTransparency\\n   */\\n  fabric.Image.filters.GradientTransparency.fromObject = function(object) {\\n    return new fabric.Image.filters.GradientTransparency(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Grayscale image filter class\\n   * @class fabric.Image.filters.Grayscale\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Grayscale();\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Grayscale',\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @memberOf fabric.Image.filters.Grayscale.prototype\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          len = imageData.width * imageData.height * 4,\\n          index = 0,\\n          average;\\n\\n      while (index < len) {\\n        average = (data[index] + data[index + 1] + data[index + 2]) / 3;\\n        data[index]     = average;\\n        data[index + 1] = average;\\n        data[index + 2] = average;\\n        index += 4;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\\n   */\\n  fabric.Image.filters.Grayscale.fromObject = function() {\\n    return new fabric.Image.filters.Grayscale();\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Invert filter class\\n   * @class fabric.Image.filters.Invert\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Invert();\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Invert',\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @memberOf fabric.Image.filters.Invert.prototype\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          iLen = data.length, i;\\n\\n      for (i = 0; i < iLen; i += 4) {\\n        data[i] = 255 - data[i];\\n        data[i + 1] = 255 - data[i + 1];\\n        data[i + 2] = 255 - data[i + 2];\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\\n   */\\n  fabric.Image.filters.Invert.fromObject = function() {\\n    return new fabric.Image.filters.Invert();\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Mask filter class\\n   * See http://resources.aleph-1.com/mask/\\n   * @class fabric.Image.filters.Mask\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Mask#initialize} for constructor definition\\n   */\\n  filters.Mask = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Mask.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Mask',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Mask.prototype\\n     * @param {Object} [options] Options object\\n     * @param {fabric.Image} [options.mask] Mask image object\\n     * @param {Number} [options.channel=0] Rgb channel (0, 1, 2 or 3)\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n\\n      this.mask = options.mask;\\n      this.channel = [0, 1, 2, 3].indexOf(options.channel) > -1 ? options.channel : 0;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      if (!this.mask) {\\n        return;\\n      }\\n\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          maskEl = this.mask.getElement(),\\n          maskCanvasEl = fabric.util.createCanvasElement(),\\n          channel = this.channel,\\n          i,\\n          iLen = imageData.width * imageData.height * 4;\\n\\n      maskCanvasEl.width = canvasEl.width;\\n      maskCanvasEl.height = canvasEl.height;\\n\\n      maskCanvasEl.getContext('2d').drawImage(maskEl, 0, 0, canvasEl.width, canvasEl.height);\\n\\n      var maskImageData = maskCanvasEl.getContext('2d').getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          maskData = maskImageData.data;\\n\\n      for (i = 0; i < iLen; i += 4) {\\n        data[i + 3] = maskData[i + channel];\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        mask: this.mask.toObject(),\\n        channel: this.channel\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when a mask filter instance is created\\n   */\\n  fabric.Image.filters.Mask.fromObject = function(object, callback) {\\n    fabric.util.loadImage(object.mask.src, function(img) {\\n      object.mask = new fabric.Image(img, object.mask);\\n      callback && callback(new fabric.Image.filters.Mask(object));\\n    });\\n  };\\n\\n  /**\\n   * Indicates that instances of this type are async\\n   * @static\\n   * @type Boolean\\n   * @default\\n   */\\n  fabric.Image.filters.Mask.async = true;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Noise filter class\\n   * @class fabric.Image.filters.Noise\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Noise({\\n   *   noise: 700\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Noise',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Noise.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Number} [options.noise=0] Noise value\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      this.noise = options.noise || 0;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          noise = this.noise, rand;\\n\\n      for (var i = 0, len = data.length; i < len; i += 4) {\\n\\n        rand = (0.5 - Math.random()) * noise;\\n\\n        data[i] += rand;\\n        data[i + 1] += rand;\\n        data[i + 2] += rand;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        noise: this.noise\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\\n   */\\n  fabric.Image.filters.Noise.fromObject = function(object) {\\n    return new fabric.Image.filters.Noise(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Pixelate filter class\\n   * @class fabric.Image.filters.Pixelate\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Pixelate({\\n   *   blocksize: 8\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Pixelate',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Pixelate.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Number} [options.blocksize=4] Blocksize for pixelate\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      this.blocksize = options.blocksize || 4;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          iLen = imageData.height,\\n          jLen = imageData.width,\\n          index, i, j, r, g, b, a;\\n\\n      for (i = 0; i < iLen; i += this.blocksize) {\\n        for (j = 0; j < jLen; j += this.blocksize) {\\n\\n          index = (i * 4) * jLen + (j * 4);\\n\\n          r = data[index];\\n          g = data[index + 1];\\n          b = data[index + 2];\\n          a = data[index + 3];\\n\\n          /*\\n           blocksize: 4\\n\\n           [1,x,x,x,1]\\n           [x,x,x,x,1]\\n           [x,x,x,x,1]\\n           [x,x,x,x,1]\\n           [1,1,1,1,1]\\n           */\\n\\n          for (var _i = i, _ilen = i + this.blocksize; _i < _ilen; _i++) {\\n            for (var _j = j, _jlen = j + this.blocksize; _j < _jlen; _j++) {\\n              index = (_i * 4) * jLen + (_j * 4);\\n              data[index] = r;\\n              data[index + 1] = g;\\n              data[index + 2] = b;\\n              data[index + 3] = a;\\n            }\\n          }\\n        }\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        blocksize: this.blocksize\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\\n   */\\n  fabric.Image.filters.Pixelate.fromObject = function(object) {\\n    return new fabric.Image.filters.Pixelate(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Remove white filter class\\n   * @class fabric.Image.filters.RemoveWhite\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.RemoveWhite#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.RemoveWhite({\\n   *   threshold: 40,\\n   *   distance: 140\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.RemoveWhite = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveWhite.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'RemoveWhite',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Number} [options.threshold=30] Threshold value\\n     * @param {Number} [options.distance=20] Distance value\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      this.threshold = options.threshold || 30;\\n      this.distance = options.distance || 20;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          threshold = this.threshold,\\n          distance = this.distance,\\n          limit = 255 - threshold,\\n          abs = Math.abs,\\n          r, g, b;\\n\\n      for (var i = 0, len = data.length; i < len; i += 4) {\\n        r = data[i];\\n        g = data[i + 1];\\n        b = data[i + 2];\\n\\n        if (r > limit &&\\n            g > limit &&\\n            b > limit &&\\n            abs(r - g) < distance &&\\n            abs(r - b) < distance &&\\n            abs(g - b) < distance\\n        ) {\\n          data[i + 3] = 0;\\n        }\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        threshold: this.threshold,\\n        distance: this.distance\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.RemoveWhite} Instance of fabric.Image.filters.RemoveWhite\\n   */\\n  fabric.Image.filters.RemoveWhite.fromObject = function(object) {\\n    return new fabric.Image.filters.RemoveWhite(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Sepia filter class\\n   * @class fabric.Image.filters.Sepia\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Sepia();\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Sepia = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Sepia.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Sepia',\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @memberOf fabric.Image.filters.Sepia.prototype\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          iLen = data.length, i, avg;\\n\\n      for (i = 0; i < iLen; i += 4) {\\n        avg = 0.3  * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];\\n        data[i] = avg + 100;\\n        data[i + 1] = avg + 50;\\n        data[i + 2] = avg + 255;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @return {fabric.Image.filters.Sepia} Instance of fabric.Image.filters.Sepia\\n   */\\n  fabric.Image.filters.Sepia.fromObject = function() {\\n    return new fabric.Image.filters.Sepia();\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Sepia2 filter class\\n   * @class fabric.Image.filters.Sepia2\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Sepia2();\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Sepia2 = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Sepia2.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Sepia2',\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @memberOf fabric.Image.filters.Sepia.prototype\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          iLen = data.length, i, r, g, b;\\n\\n      for (i = 0; i < iLen; i += 4) {\\n        r = data[i];\\n        g = data[i + 1];\\n        b = data[i + 2];\\n\\n        data[i] = (r * 0.393 + g * 0.769 + b * 0.189 ) / 1.351;\\n        data[i + 1] = (r * 0.349 + g * 0.686 + b * 0.168 ) / 1.203;\\n        data[i + 2] = (r * 0.272 + g * 0.534 + b * 0.131 ) / 2.140;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @return {fabric.Image.filters.Sepia2} Instance of fabric.Image.filters.Sepia2\\n   */\\n  fabric.Image.filters.Sepia2.fromObject = function() {\\n    return new fabric.Image.filters.Sepia2();\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Tint filter class\\n   * Adapted from <a href=\\\"https://github.com/mezzoblue/PaintbrushJS\\\">https://github.com/mezzoblue/PaintbrushJS</a>\\n   * @class fabric.Image.filters.Tint\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Tint#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example <caption>Tint filter with hex color and opacity</caption>\\n   * var filter = new fabric.Image.filters.Tint({\\n   *   color: '#3513B0',\\n   *   opacity: 0.5\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   * @example <caption>Tint filter with rgba color</caption>\\n   * var filter = new fabric.Image.filters.Tint({\\n   *   color: 'rgba(53, 21, 176, 0.5)'\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Tint = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Tint.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Tint',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Tint.prototype\\n     * @param {Object} [options] Options object\\n     * @param {String} [options.color=#000000] Color to tint the image with\\n     * @param {Number} [options.opacity] Opacity value that controls the tint effect's transparency (0..1)\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n\\n      this.color = options.color || '#000000';\\n      this.opacity = typeof options.opacity !== 'undefined'\\n                      ? options.opacity\\n                      : new fabric.Color(this.color).getAlpha();\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          iLen = data.length, i,\\n          tintR, tintG, tintB,\\n          r, g, b, alpha1,\\n          source;\\n\\n      source = new fabric.Color(this.color).getSource();\\n\\n      tintR = source[0] * this.opacity;\\n      tintG = source[1] * this.opacity;\\n      tintB = source[2] * this.opacity;\\n\\n      alpha1 = 1 - this.opacity;\\n\\n      for (i = 0; i < iLen; i += 4) {\\n        r = data[i];\\n        g = data[i + 1];\\n        b = data[i + 2];\\n\\n        // alpha compositing\\n        data[i] = tintR + r * alpha1;\\n        data[i + 1] = tintG + g * alpha1;\\n        data[i + 2] = tintB + b * alpha1;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        color: this.color,\\n        opacity: this.opacity\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Tint} Instance of fabric.Image.filters.Tint\\n   */\\n  fabric.Image.filters.Tint.fromObject = function(object) {\\n    return new fabric.Image.filters.Tint(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Multiply filter class\\n   * Adapted from <a href=\\\"http://www.laurenscorijn.com/articles/colormath-basics\\\">http://www.laurenscorijn.com/articles/colormath-basics</a>\\n   * @class fabric.Image.filters.Multiply\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @example <caption>Multiply filter with hex color</caption>\\n   * var filter = new fabric.Image.filters.Multiply({\\n   *   color: '#F0F'\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   * @example <caption>Multiply filter with rgb color</caption>\\n   * var filter = new fabric.Image.filters.Multiply({\\n   *   color: 'rgb(53, 21, 176)'\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Multiply = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Multiply.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Multiply',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Multiply.prototype\\n     * @param {Object} [options] Options object\\n     * @param {String} [options.color=#000000] Color to multiply the image pixels with\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n\\n      this.color = options.color || '#000000';\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          iLen = data.length, i,\\n          source;\\n\\n      source = new fabric.Color(this.color).getSource();\\n\\n      for (i = 0; i < iLen; i += 4) {\\n        data[i] *= source[0] / 255;\\n        data[i + 1] *= source[1] / 255;\\n        data[i + 2] *= source[2] / 255;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        color: this.color\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Multiply} Instance of fabric.Image.filters.Multiply\\n   */\\n  fabric.Image.filters.Multiply.fromObject = function(object) {\\n    return new fabric.Image.filters.Multiply(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n  'use strict';\\n\\n  var fabric = global.fabric,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Color Blend filter class\\n   * @class fabric.Image.filter.Blend\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @example\\n   * var filter = new fabric.Image.filters.Blend({\\n   *  color: '#000',\\n   *  mode: 'multiply'\\n   * });\\n   *\\n   * var filter = new fabric.Image.filters.Blend({\\n   *  image: fabricImageObject,\\n   *  mode: 'multiply',\\n   *  alpha: 0.5\\n   * });\\n\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n\\n  filters.Blend = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {\\n    type: 'Blend',\\n\\n    initialize: function(options) {\\n      options = options || {};\\n      this.color = options.color || '#000';\\n      this.image = options.image || false;\\n      this.mode = options.mode || 'multiply';\\n      this.alpha = options.alpha || 1;\\n    },\\n\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          tr, tg, tb,\\n          r, g, b,\\n          _r, _g, _b,\\n          source,\\n          isImage = false;\\n\\n      if (this.image) {\\n        // Blend images\\n        isImage = true;\\n\\n        var _el = fabric.util.createCanvasElement();\\n        _el.width = this.image.width;\\n        _el.height = this.image.height;\\n\\n        var tmpCanvas = new fabric.StaticCanvas(_el);\\n        tmpCanvas.add(this.image);\\n        var context2 =  tmpCanvas.getContext('2d');\\n        source = context2.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;\\n      }\\n      else {\\n        // Blend color\\n        source = new fabric.Color(this.color).getSource();\\n\\n        tr = source[0] * this.alpha;\\n        tg = source[1] * this.alpha;\\n        tb = source[2] * this.alpha;\\n      }\\n\\n      for (var i = 0, len = data.length; i < len; i += 4) {\\n\\n        r = data[i];\\n        g = data[i + 1];\\n        b = data[i + 2];\\n\\n        if (isImage) {\\n          tr = source[i] * this.alpha;\\n          tg = source[i + 1] * this.alpha;\\n          tb = source[i + 2] * this.alpha;\\n        }\\n\\n        switch (this.mode) {\\n          case 'multiply':\\n            data[i] = r * tr / 255;\\n            data[i + 1] = g * tg / 255;\\n            data[i + 2] = b * tb / 255;\\n            break;\\n          case 'screen':\\n            data[i] = 1 - (1 - r) * (1 - tr);\\n            data[i + 1] = 1 - (1 - g) * (1 - tg);\\n            data[i + 2] = 1 - (1 - b) * (1 - tb);\\n            break;\\n          case 'add':\\n            data[i] = Math.min(255, r + tr);\\n            data[i + 1] = Math.min(255, g + tg);\\n            data[i + 2] = Math.min(255, b + tb);\\n            break;\\n          case 'diff':\\n          case 'difference':\\n            data[i] = Math.abs(r - tr);\\n            data[i + 1] = Math.abs(g - tg);\\n            data[i + 2] = Math.abs(b - tb);\\n            break;\\n          case 'subtract':\\n            _r = r - tr;\\n            _g = g - tg;\\n            _b = b - tb;\\n\\n            data[i] = (_r < 0) ? 0 : _r;\\n            data[i + 1] = (_g < 0) ? 0 : _g;\\n            data[i + 2] = (_b < 0) ? 0 : _b;\\n            break;\\n          case 'darken':\\n            data[i] = Math.min(r, tr);\\n            data[i + 1] = Math.min(g, tg);\\n            data[i + 2] = Math.min(b, tb);\\n            break;\\n          case 'lighten':\\n            data[i] = Math.max(r, tr);\\n            data[i + 1] = Math.max(g, tg);\\n            data[i + 2] = Math.max(b, tb);\\n            break;\\n        }\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return {\\n        color: this.color,\\n        image: this.image,\\n        mode: this.mode,\\n        alpha: this.alpha\\n      };\\n    }\\n  });\\n\\n  fabric.Image.filters.Blend.fromObject = function(object) {\\n    return new fabric.Image.filters.Blend(object);\\n  };\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,\\n      sqrt = Math.sqrt, abs = Math.abs, max = Math.max, round = Math.round, sin = Math.sin,\\n      ceil = Math.ceil,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Resize image filter class\\n   * @class fabric.Image.filters.Resize\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Resize();\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Resize',\\n\\n    /**\\n     * Resize type\\n     * @param {String} resizeType\\n     * @default\\n     */\\n    resizeType: 'hermite',\\n\\n    /**\\n     * Scale factor for resizing, x axis\\n     * @param {Number} scaleX\\n     * @default\\n     */\\n    scaleX: 0,\\n\\n    /**\\n     * Scale factor for resizing, y axis\\n     * @param {Number} scaleY\\n     * @default\\n     */\\n    scaleY: 0,\\n\\n    /**\\n     * LanczosLobes parameter for lanczos filter\\n     * @param {Number} lanczosLobes\\n     * @default\\n     */\\n    lanczosLobes: 3,\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @memberOf fabric.Image.filters.Resize.prototype\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     * @param {Number} scaleX\\n     * @param {Number} scaleY\\n     */\\n    applyTo: function(canvasEl, scaleX, scaleY) {\\n      if (scaleX === 1 && scaleY === 1) {\\n        return;\\n      }\\n\\n      this.rcpScaleX = 1 / scaleX;\\n      this.rcpScaleY = 1 / scaleY;\\n\\n      var oW = canvasEl.width, oH = canvasEl.height,\\n          dW = round(oW * scaleX), dH = round(oH * scaleY),\\n          imageData;\\n\\n      if (this.resizeType === 'sliceHack') {\\n        imageData = this.sliceByTwo(canvasEl, oW, oH, dW, dH);\\n      }\\n      if (this.resizeType === 'hermite') {\\n        imageData = this.hermiteFastResize(canvasEl, oW, oH, dW, dH);\\n      }\\n      if (this.resizeType === 'bilinear') {\\n        imageData = this.bilinearFiltering(canvasEl, oW, oH, dW, dH);\\n      }\\n      if (this.resizeType === 'lanczos') {\\n        imageData = this.lanczosResize(canvasEl, oW, oH, dW, dH);\\n      }\\n      canvasEl.width = dW;\\n      canvasEl.height = dH;\\n      canvasEl.getContext('2d').putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Filter sliceByTwo\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     * @param {Number} oW Original Width\\n     * @param {Number} oH Original Height\\n     * @param {Number} dW Destination Width\\n     * @param {Number} dH Destination Height\\n     * @returns {ImageData}\\n     */\\n    sliceByTwo: function(canvasEl, oW, oH, dW, dH) {\\n      var context = canvasEl.getContext('2d'), imageData,\\n          multW = 0.5, multH = 0.5, signW = 1, signH = 1,\\n          doneW = false, doneH = false, stepW = oW, stepH = oH,\\n          tmpCanvas = fabric.util.createCanvasElement(),\\n          tmpCtx = tmpCanvas.getContext('2d');\\n      dW = floor(dW);\\n      dH = floor(dH);\\n      tmpCanvas.width = max(dW, oW);\\n      tmpCanvas.height = max(dH, oH);\\n\\n      if (dW > oW) {\\n        multW = 2;\\n        signW = -1;\\n      }\\n      if (dH > oH) {\\n        multH = 2;\\n        signH = -1;\\n      }\\n      imageData = context.getImageData(0, 0, oW, oH);\\n      canvasEl.width = max(dW, oW);\\n      canvasEl.height = max(dH, oH);\\n      context.putImageData(imageData, 0, 0);\\n\\n      while (!doneW || !doneH) {\\n        oW = stepW;\\n        oH = stepH;\\n        if (dW * signW < floor(stepW * multW * signW)) {\\n          stepW = floor(stepW * multW);\\n        }\\n        else {\\n          stepW = dW;\\n          doneW = true;\\n        }\\n        if (dH * signH < floor(stepH * multH * signH)) {\\n          stepH = floor(stepH * multH);\\n        }\\n        else {\\n          stepH = dH;\\n          doneH = true;\\n        }\\n        imageData = context.getImageData(0, 0, oW, oH);\\n        tmpCtx.putImageData(imageData, 0, 0);\\n        context.clearRect(0, 0, stepW, stepH);\\n        context.drawImage(tmpCanvas, 0, 0, oW, oH, 0, 0, stepW, stepH);\\n      }\\n      return context.getImageData(0, 0, dW, dH);\\n    },\\n\\n    /**\\n     * Filter lanczosResize\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     * @param {Number} oW Original Width\\n     * @param {Number} oH Original Height\\n     * @param {Number} dW Destination Width\\n     * @param {Number} dH Destination Height\\n     * @returns {ImageData}\\n     */\\n    lanczosResize: function(canvasEl, oW, oH, dW, dH) {\\n\\n      function lanczosCreate(lobes) {\\n        return function(x) {\\n          if (x > lobes) {\\n            return 0;\\n          }\\n          x *= Math.PI;\\n          if (abs(x) < 1e-16) {\\n            return 1;\\n          }\\n          var xx = x / lobes;\\n          return sin(x) * sin(xx) / x / xx;\\n        };\\n      }\\n\\n      function process(u) {\\n        var v, i, weight, idx, a, red, green,\\n            blue, alpha, fX, fY;\\n        center.x = (u + 0.5) * ratioX;\\n        icenter.x = floor(center.x);\\n        for (v = 0; v < dH; v++) {\\n          center.y = (v + 0.5) * ratioY;\\n          icenter.y = floor(center.y);\\n          a = 0; red = 0; green = 0; blue = 0; alpha = 0;\\n          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {\\n            if (i < 0 || i >= oW) {\\n              continue;\\n            }\\n            fX = floor(1000 * abs(i - center.x));\\n            if (!cacheLanc[fX]) {\\n              cacheLanc[fX] = { };\\n            }\\n            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {\\n              if (j < 0 || j >= oH) {\\n                continue;\\n              }\\n              fY = floor(1000 * abs(j - center.y));\\n              if (!cacheLanc[fX][fY]) {\\n                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\\n              }\\n              weight = cacheLanc[fX][fY];\\n              if (weight > 0) {\\n                idx = (j * oW + i) * 4;\\n                a += weight;\\n                red += weight * srcData[idx];\\n                green += weight * srcData[idx + 1];\\n                blue += weight * srcData[idx + 2];\\n                alpha += weight * srcData[idx + 3];\\n              }\\n            }\\n          }\\n          idx = (v * dW + u) * 4;\\n          destData[idx] = red / a;\\n          destData[idx + 1] = green / a;\\n          destData[idx + 2] = blue / a;\\n          destData[idx + 3] = alpha / a;\\n        }\\n\\n        if (++u < dW) {\\n          return process(u);\\n        }\\n        else {\\n          return destImg;\\n        }\\n      }\\n\\n      var context = canvasEl.getContext('2d'),\\n          srcImg = context.getImageData(0, 0, oW, oH),\\n          destImg = context.getImageData(0, 0, dW, dH),\\n          srcData = srcImg.data, destData = destImg.data,\\n          lanczos = lanczosCreate(this.lanczosLobes),\\n          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,\\n          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,\\n          range2X = ceil(ratioX * this.lanczosLobes / 2),\\n          range2Y = ceil(ratioY * this.lanczosLobes / 2),\\n          cacheLanc = { }, center = { }, icenter = { };\\n\\n      return process(0);\\n    },\\n\\n    /**\\n     * bilinearFiltering\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     * @param {Number} oW Original Width\\n     * @param {Number} oH Original Height\\n     * @param {Number} dW Destination Width\\n     * @param {Number} dH Destination Height\\n     * @returns {ImageData}\\n     */\\n    bilinearFiltering: function(canvasEl, oW, oH, dW, dH) {\\n      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,\\n          color, offset = 0, origPix, ratioX = this.rcpScaleX,\\n          ratioY = this.rcpScaleY, context = canvasEl.getContext('2d'),\\n          w4 = 4 * (oW - 1), img = context.getImageData(0, 0, oW, oH),\\n          pixels = img.data, destImage = context.getImageData(0, 0, dW, dH),\\n          destPixels = destImage.data;\\n      for (i = 0; i < dH; i++) {\\n        for (j = 0; j < dW; j++) {\\n          x = floor(ratioX * j);\\n          y = floor(ratioY * i);\\n          xDiff = ratioX * j - x;\\n          yDiff = ratioY * i - y;\\n          origPix = 4 * (y * oW + x);\\n\\n          for (chnl = 0; chnl < 4; chnl++) {\\n            a = pixels[origPix + chnl];\\n            b = pixels[origPix + 4 + chnl];\\n            c = pixels[origPix + w4 + chnl];\\n            d = pixels[origPix + w4 + 4 + chnl];\\n            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +\\n                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\\n            destPixels[offset++] = color;\\n          }\\n        }\\n      }\\n      return destImage;\\n    },\\n\\n    /**\\n     * hermiteFastResize\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     * @param {Number} oW Original Width\\n     * @param {Number} oH Original Height\\n     * @param {Number} dW Destination Width\\n     * @param {Number} dH Destination Height\\n     * @returns {ImageData}\\n     */\\n    hermiteFastResize: function(canvasEl, oW, oH, dW, dH) {\\n      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,\\n          ratioWHalf = ceil(ratioW / 2),\\n          ratioHHalf = ceil(ratioH / 2),\\n          context = canvasEl.getContext('2d'),\\n          img = context.getImageData(0, 0, oW, oH), data = img.data,\\n          img2 = context.getImageData(0, 0, dW, dH), data2 = img2.data;\\n      for (var j = 0; j < dH; j++) {\\n        for (var i = 0; i < dW; i++) {\\n          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,\\n              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\\n          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {\\n            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,\\n                centerX = (i + 0.5) * ratioW, w0 = dy * dy;\\n            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {\\n              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,\\n                  w = sqrt(w0 + dx * dx);\\n              /* eslint-disable max-depth */\\n              if (w > 1 && w < -1) {\\n                continue;\\n              }\\n              //hermite filter\\n              weight = 2 * w * w * w - 3 * w * w + 1;\\n              if (weight > 0) {\\n                dx = 4 * (xx + yy * oW);\\n                //alpha\\n                gxA += weight * data[dx + 3];\\n                weightsAlpha += weight;\\n                //colors\\n                if (data[dx + 3] < 255) {\\n                  weight = weight * data[dx + 3] / 250;\\n                }\\n                gxR += weight * data[dx];\\n                gxG += weight * data[dx + 1];\\n                gxB += weight * data[dx + 2];\\n                weights += weight;\\n              }\\n              /* eslint-enable max-depth */\\n            }\\n          }\\n          data2[x2] = gxR / weights;\\n          data2[x2 + 1] = gxG / weights;\\n          data2[x2 + 2] = gxB / weights;\\n          data2[x2 + 3] = gxA / weightsAlpha;\\n        }\\n      }\\n      return img2;\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return {\\n        type: this.type,\\n        scaleX: this.scaleX,\\n        scaleY: this.scaleY,\\n        resizeType: this.resizeType,\\n        lanczosLobes: this.lanczosLobes\\n      };\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\\n   */\\n  fabric.Image.filters.Resize.fromObject = function(object) {\\n    return new fabric.Image.filters.Resize(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Color Matrix filter class\\n   * @class fabric.Image.filters.ColorMatrix\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}\\n   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}\\n   * @example <caption>Kodachrome filter</caption>\\n   * var filter = new fabric.Image.filters.ColorMatrix({\\n   *  matrix: [\\n       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\\n       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\\n       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\\n       0, 0, 0, 1, 0\\n      ]\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'ColorMatrix',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.ColorMatrix.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Array} [options.matrix] Color Matrix to modify the image data with\\n     */\\n    initialize: function( options ) {\\n      options || ( options = {} );\\n      this.matrix = options.matrix || [\\n        1, 0, 0, 0, 0,\\n        0, 1, 0, 0, 0,\\n        0, 0, 1, 0, 0,\\n        0, 0, 0, 1, 0\\n      ];\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function( canvasEl ) {\\n      var context = canvasEl.getContext( '2d' ),\\n          imageData = context.getImageData( 0, 0, canvasEl.width, canvasEl.height ),\\n          data = imageData.data,\\n          iLen = data.length,\\n          i,\\n          r,\\n          g,\\n          b,\\n          a,\\n          m = this.matrix;\\n\\n      for ( i = 0; i < iLen; i += 4 ) {\\n        r = data[ i ];\\n        g = data[ i + 1 ];\\n        b = data[ i + 2 ];\\n        a = data[ i + 3 ];\\n\\n        data[ i ] = r * m[ 0 ] + g * m[ 1 ] + b * m[ 2 ] + a * m[ 3 ] + m[ 4 ];\\n        data[ i + 1 ] = r * m[ 5 ] + g * m[ 6 ] + b * m[ 7 ] + a * m[ 8 ] + m[ 9 ];\\n        data[ i + 2 ] = r * m[ 10 ] + g * m[ 11 ] + b * m[ 12 ] + a * m[ 13 ] + m[ 14 ];\\n        data[ i + 3 ] = r * m[ 15 ] + g * m[ 16 ] + b * m[ 17 ] + a * m[ 18 ] + m[ 19 ];\\n      }\\n\\n      context.putImageData( imageData, 0, 0 );\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        type: this.type,\\n        matrix: this.matrix\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix\\n   */\\n  fabric.Image.filters.ColorMatrix.fromObject = function( object ) {\\n    return new fabric.Image.filters.ColorMatrix( object );\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Contrast filter class\\n   * @class fabric.Image.filters.Contrast\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Contrast({\\n   *   contrast: 40\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Contrast',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Contrast.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Number} [options.contrast=0] Value to contrast the image up (-255...255)\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      this.contrast = options.contrast || 0;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          contrastF = 259 * (this.contrast + 255) / (255 * (259 - this.contrast));\\n\\n      for (var i = 0, len = data.length; i < len; i += 4) {\\n        data[i] = contrastF * (data[i] - 128) + 128;\\n        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;\\n        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        contrast: this.contrast\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast\\n   */\\n  fabric.Image.filters.Contrast.fromObject = function(object) {\\n    return new fabric.Image.filters.Contrast(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric  = global.fabric || (global.fabric = { }),\\n      extend = fabric.util.object.extend,\\n      filters = fabric.Image.filters,\\n      createClass = fabric.util.createClass;\\n\\n  /**\\n   * Saturate filter class\\n   * @class fabric.Image.filters.Saturate\\n   * @memberOf fabric.Image.filters\\n   * @extends fabric.Image.filters.BaseFilter\\n   * @see {@link fabric.Image.filters.Saturate#initialize} for constructor definition\\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\\n   * @example\\n   * var filter = new fabric.Image.filters.Saturate({\\n   *   saturate: 100\\n   * });\\n   * object.filters.push(filter);\\n   * object.applyFilters(canvas.renderAll.bind(canvas));\\n   */\\n  filters.Saturate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturate.prototype */ {\\n\\n    /**\\n     * Filter type\\n     * @param {String} type\\n     * @default\\n     */\\n    type: 'Saturate',\\n\\n    /**\\n     * Constructor\\n     * @memberOf fabric.Image.filters.Saturate.prototype\\n     * @param {Object} [options] Options object\\n     * @param {Number} [options.saturate=0] Value to saturate the image (-100...100)\\n     */\\n    initialize: function(options) {\\n      options = options || { };\\n      this.saturate = options.saturate || 0;\\n    },\\n\\n    /**\\n     * Applies filter to canvas element\\n     * @param {Object} canvasEl Canvas element to apply filter to\\n     */\\n    applyTo: function(canvasEl) {\\n      var context = canvasEl.getContext('2d'),\\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\\n          data = imageData.data,\\n          max, adjust = -this.saturate * 0.01;\\n\\n      for (var i = 0, len = data.length; i < len; i += 4) {\\n        max = Math.max(data[i], data[i + 1], data[i + 2]);\\n        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;\\n        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;\\n        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;\\n      }\\n\\n      context.putImageData(imageData, 0, 0);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function() {\\n      return extend(this.callSuper('toObject'), {\\n        saturate: this.saturate\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns filter instance from an object representation\\n   * @static\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Image.filters.Saturate} Instance of fabric.Image.filters.Saturate\\n   */\\n  fabric.Image.filters.Saturate.fromObject = function(object) {\\n    return new fabric.Image.filters.Saturate(object);\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = { }),\\n      clone = fabric.util.object.clone,\\n      toFixed = fabric.util.toFixed,\\n      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\\n      MIN_TEXT_WIDTH = 2;\\n\\n  if (fabric.Text) {\\n    fabric.warn('fabric.Text is already defined');\\n    return;\\n  }\\n\\n  var stateProperties = fabric.Object.prototype.stateProperties.concat();\\n  stateProperties.push(\\n    'fontFamily',\\n    'fontWeight',\\n    'fontSize',\\n    'text',\\n    'textDecoration',\\n    'textAlign',\\n    'fontStyle',\\n    'lineHeight',\\n    'textBackgroundColor',\\n    'charSpacing'\\n  );\\n\\n  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();\\n  cacheProperties.push(\\n    'fontFamily',\\n    'fontWeight',\\n    'fontSize',\\n    'text',\\n    'textDecoration',\\n    'textAlign',\\n    'fontStyle',\\n    'lineHeight',\\n    'textBackgroundColor',\\n    'charSpacing',\\n    'styles'\\n  );\\n  /**\\n   * Text class\\n   * @class fabric.Text\\n   * @extends fabric.Object\\n   * @return {fabric.Text} thisArg\\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\\n   * @see {@link fabric.Text#initialize} for constructor definition\\n   */\\n  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\\n\\n    /**\\n     * Properties which when set cause object to change dimensions\\n     * @type Object\\n     * @private\\n     */\\n    _dimensionAffectingProps: [\\n      'fontSize',\\n      'fontWeight',\\n      'fontFamily',\\n      'fontStyle',\\n      'lineHeight',\\n      'text',\\n      'charSpacing',\\n      'textAlign'\\n    ],\\n\\n    /**\\n     * @private\\n     */\\n    _reNewline: /\\\\r?\\\\n/,\\n\\n    /**\\n     * Use this regular expression to filter for whitespace that is not a new line.\\n     * Mostly used when text is 'justify' aligned.\\n     * @private\\n     */\\n    _reSpacesAndTabs: /[ \\\\t\\\\r]+/g,\\n\\n    /**\\n     * Retrieves object's fontSize\\n     * @method getFontSize\\n     * @memberOf fabric.Text.prototype\\n     * @return {String} Font size (in pixels)\\n     */\\n\\n    /**\\n     * Sets object's fontSize\\n     * Does not update the object .width and .height,\\n     * call ._initDimensions() to update the values.\\n     * @method setFontSize\\n     * @memberOf fabric.Text.prototype\\n     * @param {Number} fontSize Font size (in pixels)\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's fontWeight\\n     * @method getFontWeight\\n     * @memberOf fabric.Text.prototype\\n     * @return {(String|Number)} Font weight\\n     */\\n\\n    /**\\n     * Sets object's fontWeight\\n     * Does not update the object .width and .height,\\n     * call ._initDimensions() to update the values.\\n     * @method setFontWeight\\n     * @memberOf fabric.Text.prototype\\n     * @param {(Number|String)} fontWeight Font weight\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's fontFamily\\n     * @method getFontFamily\\n     * @memberOf fabric.Text.prototype\\n     * @return {String} Font family\\n     */\\n\\n    /**\\n     * Sets object's fontFamily\\n     * Does not update the object .width and .height,\\n     * call ._initDimensions() to update the values.\\n     * @method setFontFamily\\n     * @memberOf fabric.Text.prototype\\n     * @param {String} fontFamily Font family\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's text\\n     * @method getText\\n     * @memberOf fabric.Text.prototype\\n     * @return {String} text\\n     */\\n\\n    /**\\n     * Sets object's text\\n     * Does not update the object .width and .height,\\n     * call ._initDimensions() to update the values.\\n     * @method setText\\n     * @memberOf fabric.Text.prototype\\n     * @param {String} text Text\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's textDecoration\\n     * @method getTextDecoration\\n     * @memberOf fabric.Text.prototype\\n     * @return {String} Text decoration\\n     */\\n\\n    /**\\n     * Sets object's textDecoration\\n     * @method setTextDecoration\\n     * @memberOf fabric.Text.prototype\\n     * @param {String} textDecoration Text decoration\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's fontStyle\\n     * @method getFontStyle\\n     * @memberOf fabric.Text.prototype\\n     * @return {String} Font style\\n     */\\n\\n    /**\\n     * Sets object's fontStyle\\n     * Does not update the object .width and .height,\\n     * call ._initDimensions() to update the values.\\n     * @method setFontStyle\\n     * @memberOf fabric.Text.prototype\\n     * @param {String} fontStyle Font style\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's lineHeight\\n     * @method getLineHeight\\n     * @memberOf fabric.Text.prototype\\n     * @return {Number} Line height\\n     */\\n\\n    /**\\n     * Sets object's lineHeight\\n     * @method setLineHeight\\n     * @memberOf fabric.Text.prototype\\n     * @param {Number} lineHeight Line height\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's textAlign\\n     * @method getTextAlign\\n     * @memberOf fabric.Text.prototype\\n     * @return {String} Text alignment\\n     */\\n\\n    /**\\n     * Sets object's textAlign\\n     * @method setTextAlign\\n     * @memberOf fabric.Text.prototype\\n     * @param {String} textAlign Text alignment\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Retrieves object's textBackgroundColor\\n     * @method getTextBackgroundColor\\n     * @memberOf fabric.Text.prototype\\n     * @return {String} Text background color\\n     */\\n\\n    /**\\n     * Sets object's textBackgroundColor\\n     * @method setTextBackgroundColor\\n     * @memberOf fabric.Text.prototype\\n     * @param {String} textBackgroundColor Text background color\\n     * @return {fabric.Text}\\n     * @chainable\\n     */\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type:                 'text',\\n\\n    /**\\n     * Font size (in pixels)\\n     * @type Number\\n     * @default\\n     */\\n    fontSize:             40,\\n\\n    /**\\n     * Font weight (e.g. bold, normal, 400, 600, 800)\\n     * @type {(Number|String)}\\n     * @default\\n     */\\n    fontWeight:           'normal',\\n\\n    /**\\n     * Font family\\n     * @type String\\n     * @default\\n     */\\n    fontFamily:           'Times New Roman',\\n\\n    /**\\n     * Text decoration Possible values: \\\"\\\", \\\"underline\\\", \\\"overline\\\" or \\\"line-through\\\".\\n     * @type String\\n     * @default\\n     */\\n    textDecoration:       '',\\n\\n    /**\\n     * Text alignment. Possible values: \\\"left\\\", \\\"center\\\", \\\"right\\\" or \\\"justify\\\".\\n     * @type String\\n     * @default\\n     */\\n    textAlign:            'left',\\n\\n    /**\\n     * Font style . Possible values: \\\"\\\", \\\"normal\\\", \\\"italic\\\" or \\\"oblique\\\".\\n     * @type String\\n     * @default\\n     */\\n    fontStyle:            '',\\n\\n    /**\\n     * Line height\\n     * @type Number\\n     * @default\\n     */\\n    lineHeight:           1.16,\\n\\n    /**\\n     * Background color of text lines\\n     * @type String\\n     * @default\\n     */\\n    textBackgroundColor:  '',\\n\\n    /**\\n     * List of properties to consider when checking if\\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\\n     * as well as for history (undo/redo) purposes\\n     * @type Array\\n     */\\n    stateProperties:      stateProperties,\\n\\n    /**\\n     * List of properties to consider when checking if cache needs refresh\\n     * @type Array\\n     */\\n    cacheProperties:      cacheProperties,\\n\\n    /**\\n     * When defined, an object is rendered via stroke and this property specifies its color.\\n     * <b>Backwards incompatibility note:</b> This property was named \\\"strokeStyle\\\" until v1.1.6\\n     * @type String\\n     * @default\\n     */\\n    stroke:               null,\\n\\n    /**\\n     * Shadow object representing shadow of this shape.\\n     * <b>Backwards incompatibility note:</b> This property was named \\\"textShadow\\\" (String) until v1.2.11\\n     * @type fabric.Shadow\\n     * @default\\n     */\\n    shadow:               null,\\n\\n    /**\\n     * @private\\n     */\\n    _fontSizeFraction: 0.25,\\n\\n    /**\\n     * Text Line proportion to font Size (in pixels)\\n     * @type Number\\n     * @default\\n     */\\n    _fontSizeMult:             1.13,\\n\\n    /**\\n     * additional space between characters\\n     * expressed in thousands of em unit\\n     * @type Number\\n     * @default\\n     */\\n    charSpacing:             0,\\n\\n    /**\\n     * Constructor\\n     * @param {String} text Text string\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Text} thisArg\\n     */\\n    initialize: function(text, options) {\\n      options = options || { };\\n      this.text = text;\\n      this.__skipDimension = true;\\n      this.callSuper('initialize', options);\\n      this.__skipDimension = false;\\n      this._initDimensions();\\n      this.setupState({ propertySet: '_dimensionAffectingProps' });\\n    },\\n\\n    /**\\n     * Initialize text dimensions. Render all text on given context\\n     * or on a offscreen canvas to get the text width with measureText.\\n     * Updates this.width and this.height with the proper values.\\n     * Does not return dimensions.\\n     * @param {CanvasRenderingContext2D} [ctx] Context to render on\\n     * @private\\n     */\\n    _initDimensions: function(ctx) {\\n      if (this.__skipDimension) {\\n        return;\\n      }\\n      if (!ctx) {\\n        ctx = fabric.util.createCanvasElement().getContext('2d');\\n        this._setTextStyles(ctx);\\n      }\\n      this._textLines = this._splitTextIntoLines();\\n      this._clearCache();\\n      this.width = this._getTextWidth(ctx) || this.cursorWidth || MIN_TEXT_WIDTH;\\n      this.height = this._getTextHeight(ctx);\\n    },\\n\\n    /**\\n     * Returns string representation of an instance\\n     * @return {String} String representation of text object\\n     */\\n    toString: function() {\\n      return '#<fabric.Text (' + this.complexity() +\\n        '): { \\\"text\\\": \\\"' + this.text + '\\\", \\\"fontFamily\\\": \\\"' + this.fontFamily + '\\\" }>';\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _render: function(ctx) {\\n      this._setTextStyles(ctx);\\n      if (this.group && this.group.type === 'path-group') {\\n        ctx.translate(this.left, this.top);\\n      }\\n      this._renderTextLinesBackground(ctx);\\n      this._renderText(ctx);\\n      this._renderTextDecoration(ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderText: function(ctx) {\\n      this._renderTextFill(ctx);\\n      this._renderTextStroke(ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _setTextStyles: function(ctx) {\\n      ctx.textBaseline = 'alphabetic';\\n      ctx.font = this._getFontDeclaration();\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Number} Height of fabric.Text object\\n     */\\n    _getTextHeight: function() {\\n      return this._getHeightOfSingleLine() + (this._textLines.length - 1) * this._getHeightOfLine();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @return {Number} Maximum width of fabric.Text object\\n     */\\n    _getTextWidth: function(ctx) {\\n      var maxWidth = this._getLineWidth(ctx, 0);\\n\\n      for (var i = 1, len = this._textLines.length; i < len; i++) {\\n        var currentLineWidth = this._getLineWidth(ctx, i);\\n        if (currentLineWidth > maxWidth) {\\n          maxWidth = currentLineWidth;\\n        }\\n      }\\n      return maxWidth;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} method Method name (\\\"fillText\\\" or \\\"strokeText\\\")\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} chars Chars to render\\n     * @param {Number} left Left position of text\\n     * @param {Number} top Top position of text\\n     */\\n    _renderChars: function(method, ctx, chars, left, top) {\\n      // remove Text word from method var\\n      var shortM = method.slice(0, -4), char, width;\\n      if (this[shortM].toLive) {\\n        var offsetX = -this.width / 2 + this[shortM].offsetX || 0,\\n            offsetY = -this.height / 2 + this[shortM].offsetY || 0;\\n        ctx.save();\\n        ctx.translate(offsetX, offsetY);\\n        left -= offsetX;\\n        top -= offsetY;\\n      }\\n      if (this.charSpacing !== 0) {\\n        var additionalSpace = this._getWidthOfCharSpacing();\\n        chars = chars.split('');\\n        for (var i = 0, len = chars.length; i < len; i++) {\\n          char = chars[i];\\n          width = ctx.measureText(char).width + additionalSpace;\\n          ctx[method](char, left, top);\\n          left += width > 0 ? width : 0;\\n        }\\n      }\\n      else {\\n        ctx[method](chars, left, top);\\n      }\\n      this[shortM].toLive && ctx.restore();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} method Method name (\\\"fillText\\\" or \\\"strokeText\\\")\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} line Text to render\\n     * @param {Number} left Left position of text\\n     * @param {Number} top Top position of text\\n     * @param {Number} lineIndex Index of a line in a text\\n     */\\n    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\\n      // lift the line by quarter of fontSize\\n      top -= this.fontSize * this._fontSizeFraction;\\n\\n      // short-circuit\\n      var lineWidth = this._getLineWidth(ctx, lineIndex);\\n      if (this.textAlign !== 'justify' || this.width < lineWidth) {\\n        this._renderChars(method, ctx, line, left, top, lineIndex);\\n        return;\\n      }\\n\\n      // stretch the line\\n      var words = line.split(/\\\\s+/),\\n          charOffset = 0,\\n          wordsWidth = this._getWidthOfWords(ctx, words.join(' '), lineIndex, 0),\\n          widthDiff = this.width - wordsWidth,\\n          numSpaces = words.length - 1,\\n          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,\\n          leftOffset = 0, word;\\n\\n      for (var i = 0, len = words.length; i < len; i++) {\\n        while (line[charOffset] === ' ' && charOffset < line.length) {\\n          charOffset++;\\n        }\\n        word = words[i];\\n        this._renderChars(method, ctx, word, left + leftOffset, top, lineIndex, charOffset);\\n        leftOffset += this._getWidthOfWords(ctx, word, lineIndex, charOffset) + spaceWidth;\\n        charOffset += word.length;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} word\\n     */\\n    _getWidthOfWords: function (ctx, word) {\\n      var width = ctx.measureText(word).width, charCount, additionalSpace;\\n      if (this.charSpacing !== 0) {\\n        charCount = word.split('').length;\\n        additionalSpace = charCount * this._getWidthOfCharSpacing();\\n        width += additionalSpace;\\n      }\\n      return width > 0 ? width : 0;\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Number} Left offset\\n     */\\n    _getLeftOffset: function() {\\n      return -this.width / 2;\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Number} Top offset\\n     */\\n    _getTopOffset: function() {\\n      return -this.height / 2;\\n    },\\n\\n    /**\\n     * Returns true because text has no style\\n     */\\n    isEmptyStyles: function() {\\n      return true;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} method Method name (\\\"fillText\\\" or \\\"strokeText\\\")\\n     */\\n    _renderTextCommon: function(ctx, method) {\\n\\n      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();\\n\\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\\n        var heightOfLine = this._getHeightOfLine(ctx, i),\\n            maxHeight = heightOfLine / this.lineHeight,\\n            lineWidth = this._getLineWidth(ctx, i),\\n            leftOffset = this._getLineLeftOffset(lineWidth);\\n        this._renderTextLine(\\n          method,\\n          ctx,\\n          this._textLines[i],\\n          left + leftOffset,\\n          top + lineHeights + maxHeight,\\n          i\\n        );\\n        lineHeights += heightOfLine;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderTextFill: function(ctx) {\\n      if (!this.fill && this.isEmptyStyles()) {\\n        return;\\n      }\\n\\n      this._renderTextCommon(ctx, 'fillText');\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderTextStroke: function(ctx) {\\n      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\\n        return;\\n      }\\n\\n      if (this.shadow && !this.shadow.affectStroke) {\\n        this._removeShadow(ctx);\\n      }\\n\\n      ctx.save();\\n      this._setLineDash(ctx, this.strokeDashArray);\\n      ctx.beginPath();\\n      this._renderTextCommon(ctx, 'strokeText');\\n      ctx.closePath();\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Number} height of line\\n     */\\n    _getHeightOfLine: function() {\\n      return this._getHeightOfSingleLine() * this.lineHeight;\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Number} height of line without lineHeight\\n     */\\n    _getHeightOfSingleLine: function() {\\n      return this.fontSize * this._fontSizeMult;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderTextLinesBackground: function(ctx) {\\n      if (!this.textBackgroundColor) {\\n        return;\\n      }\\n      var lineTopOffset = 0, heightOfLine,\\n          lineWidth, lineLeftOffset, originalFill = ctx.fillStyle;\\n\\n      ctx.fillStyle = this.textBackgroundColor;\\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\\n        heightOfLine = this._getHeightOfLine(ctx, i);\\n        lineWidth = this._getLineWidth(ctx, i);\\n        if (lineWidth > 0) {\\n          lineLeftOffset = this._getLineLeftOffset(lineWidth);\\n          ctx.fillRect(\\n            this._getLeftOffset() + lineLeftOffset,\\n            this._getTopOffset() + lineTopOffset,\\n            lineWidth,\\n            heightOfLine / this.lineHeight\\n          );\\n        }\\n        lineTopOffset += heightOfLine;\\n      }\\n      ctx.fillStyle = originalFill;\\n      // if there is text background color no\\n      // other shadows should be casted\\n      this._removeShadow(ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Number} lineWidth Width of text line\\n     * @return {Number} Line left offset\\n     */\\n    _getLineLeftOffset: function(lineWidth) {\\n      if (this.textAlign === 'center') {\\n        return (this.width - lineWidth) / 2;\\n      }\\n      if (this.textAlign === 'right') {\\n        return this.width - lineWidth;\\n      }\\n      return 0;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _clearCache: function() {\\n      this.__lineWidths = [];\\n      this.__lineHeights = [];\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _shouldClearDimensionCache: function() {\\n      var shouldClear = false;\\n      if (this._forceClearCache) {\\n        this._forceClearCache = false;\\n        this.dirty = true;\\n        return true;\\n      }\\n      shouldClear = this.hasStateChanged('_dimensionAffectingProps');\\n      if (shouldClear) {\\n        this.saveState({ propertySet: '_dimensionAffectingProps' });\\n        this.dirty = true;\\n      }\\n      return shouldClear;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Number} lineIndex line number\\n     * @return {Number} Line width\\n     */\\n    _getLineWidth: function(ctx, lineIndex) {\\n      if (this.__lineWidths[lineIndex]) {\\n        return this.__lineWidths[lineIndex] === -1 ? this.width : this.__lineWidths[lineIndex];\\n      }\\n\\n      var width, wordCount, line = this._textLines[lineIndex];\\n\\n      if (line === '') {\\n        width = 0;\\n      }\\n      else {\\n        width = this._measureLine(ctx, lineIndex);\\n      }\\n      this.__lineWidths[lineIndex] = width;\\n\\n      if (width && this.textAlign === 'justify') {\\n        wordCount = line.split(/\\\\s+/);\\n        if (wordCount.length > 1) {\\n          this.__lineWidths[lineIndex] = -1;\\n        }\\n      }\\n      return width;\\n    },\\n\\n    _getWidthOfCharSpacing: function() {\\n      if (this.charSpacing !== 0) {\\n        return this.fontSize * this.charSpacing / 1000;\\n      }\\n      return 0;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Number} lineIndex line number\\n     * @return {Number} Line width\\n     */\\n    _measureLine: function(ctx, lineIndex) {\\n      var line = this._textLines[lineIndex],\\n          width = ctx.measureText(line).width,\\n          additionalSpace = 0, charCount, finalWidth;\\n      if (this.charSpacing !== 0) {\\n        charCount = line.split('').length;\\n        additionalSpace = (charCount - 1) * this._getWidthOfCharSpacing();\\n      }\\n      finalWidth = width + additionalSpace;\\n      return finalWidth > 0 ? finalWidth : 0;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderTextDecoration: function(ctx) {\\n      if (!this.textDecoration) {\\n        return;\\n      }\\n      var halfOfVerticalBox = this.height / 2,\\n          _this = this, offsets = [];\\n\\n      /** @ignore */\\n      function renderLinesAtOffset(offsets) {\\n        var i, lineHeight = 0, len, j, oLen, lineWidth,\\n            lineLeftOffset, heightOfLine;\\n\\n        for (i = 0, len = _this._textLines.length; i < len; i++) {\\n\\n          lineWidth = _this._getLineWidth(ctx, i);\\n          lineLeftOffset = _this._getLineLeftOffset(lineWidth);\\n          heightOfLine = _this._getHeightOfLine(ctx, i);\\n\\n          for (j = 0, oLen = offsets.length; j < oLen; j++) {\\n            ctx.fillRect(\\n              _this._getLeftOffset() + lineLeftOffset,\\n              lineHeight + (_this._fontSizeMult - 1 + offsets[j] ) * _this.fontSize - halfOfVerticalBox,\\n              lineWidth,\\n              _this.fontSize / 15);\\n          }\\n          lineHeight += heightOfLine;\\n        }\\n      }\\n\\n      if (this.textDecoration.indexOf('underline') > -1) {\\n        offsets.push(0.85); // 1 - 3/16\\n      }\\n      if (this.textDecoration.indexOf('line-through') > -1) {\\n        offsets.push(0.43);\\n      }\\n      if (this.textDecoration.indexOf('overline') > -1) {\\n        offsets.push(-0.12);\\n      }\\n      if (offsets.length > 0) {\\n        renderLinesAtOffset(offsets);\\n      }\\n    },\\n\\n    /**\\n     * return font declaration string for canvas context\\n     * @returns {String} font declaration formatted for canvas context.\\n     */\\n    _getFontDeclaration: function() {\\n      return [\\n        // node-canvas needs \\\"weight style\\\", while browsers need \\\"style weight\\\"\\n        (fabric.isLikelyNode ? this.fontWeight : this.fontStyle),\\n        (fabric.isLikelyNode ? this.fontStyle : this.fontWeight),\\n        this.fontSize + 'px',\\n        (fabric.isLikelyNode ? ('\\\"' + this.fontFamily + '\\\"') : this.fontFamily)\\n      ].join(' ');\\n    },\\n\\n    /**\\n     * Renders text instance on a specified context\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    render: function(ctx, noTransform) {\\n      // do not render if object is not visible\\n      if (!this.visible) {\\n        return;\\n      }\\n      if (this._shouldClearDimensionCache()) {\\n        this._setTextStyles(ctx);\\n        this._initDimensions(ctx);\\n      }\\n      this.callSuper('render', ctx, noTransform);\\n    },\\n\\n    /**\\n     * Returns the text as an array of lines.\\n     * @returns {Array} Lines in the text\\n     */\\n    _splitTextIntoLines: function() {\\n      return this.text.split(this._reNewline);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      var additionalProperties = [\\n        'text',\\n        'fontSize',\\n        'fontWeight',\\n        'fontFamily',\\n        'fontStyle',\\n        'lineHeight',\\n        'textDecoration',\\n        'textAlign',\\n        'textBackgroundColor',\\n        'charSpacing'\\n      ].concat(propertiesToInclude);\\n      return this.callSuper('toObject', additionalProperties);\\n    },\\n\\n    /* _TO_SVG_START_ */\\n    /**\\n     * Returns SVG representation of an instance\\n     * @param {Function} [reviver] Method for further parsing of svg representation.\\n     * @return {String} svg representation of an instance\\n     */\\n    toSVG: function(reviver) {\\n      if (!this.ctx) {\\n        this.ctx = fabric.util.createCanvasElement().getContext('2d');\\n      }\\n      var markup = this._createBaseSVGMarkup(),\\n          offsets = this._getSVGLeftTopOffsets(this.ctx),\\n          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\\n      this._wrapSVGTextAndBg(markup, textAndBg);\\n\\n      return reviver ? reviver(markup.join('')) : markup.join('');\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getSVGLeftTopOffsets: function(ctx) {\\n      var lineTop = this._getHeightOfLine(ctx, 0),\\n          textLeft = -this.width / 2,\\n          textTop = 0;\\n\\n      return {\\n        textLeft: textLeft + (this.group && this.group.type === 'path-group' ? this.left : 0),\\n        textTop: textTop + (this.group && this.group.type === 'path-group' ? -this.top : 0),\\n        lineTop: lineTop\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _wrapSVGTextAndBg: function(markup, textAndBg) {\\n      var noShadow = true, filter = this.getSvgFilter(),\\n          style = filter === '' ? '' : ' style=\\\"' + filter + '\\\"';\\n\\n      markup.push(\\n        '\\\\t<g ', this.getSvgId(), 'transform=\\\"', this.getSvgTransform(), this.getSvgTransformMatrix(), '\\\"',\\n          style, '>\\\\n',\\n          textAndBg.textBgRects.join(''),\\n          '\\\\t\\\\t<text ',\\n            (this.fontFamily ? 'font-family=\\\"' + this.fontFamily.replace(/\\\"/g, '\\\\'') + '\\\" ' : ''),\\n            (this.fontSize ? 'font-size=\\\"' + this.fontSize + '\\\" ' : ''),\\n            (this.fontStyle ? 'font-style=\\\"' + this.fontStyle + '\\\" ' : ''),\\n            (this.fontWeight ? 'font-weight=\\\"' + this.fontWeight + '\\\" ' : ''),\\n            (this.textDecoration ? 'text-decoration=\\\"' + this.textDecoration + '\\\" ' : ''),\\n            'style=\\\"', this.getSvgStyles(noShadow), '\\\" >\\\\n',\\n            textAndBg.textSpans.join(''),\\n          '\\\\t\\\\t</text>\\\\n',\\n        '\\\\t</g>\\\\n'\\n      );\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Number} textTopOffset Text top offset\\n     * @param {Number} textLeftOffset Text left offset\\n     * @return {Object}\\n     */\\n    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\\n      var textSpans = [],\\n          textBgRects = [],\\n          height = 0;\\n      // bounding-box background\\n      this._setSVGBg(textBgRects);\\n\\n      // text and text-background\\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\\n        if (this.textBackgroundColor) {\\n          this._setSVGTextLineBg(textBgRects, i, textLeftOffset, textTopOffset, height);\\n        }\\n        this._setSVGTextLineText(i, textSpans, height, textLeftOffset, textTopOffset, textBgRects);\\n        height += this._getHeightOfLine(this.ctx, i);\\n      }\\n\\n      return {\\n        textSpans: textSpans,\\n        textBgRects: textBgRects\\n      };\\n    },\\n\\n    _setSVGTextLineText: function(i, textSpans, height, textLeftOffset, textTopOffset) {\\n      var yPos = this.fontSize * (this._fontSizeMult - this._fontSizeFraction)\\n        - textTopOffset + height - this.height / 2;\\n      if (this.textAlign === 'justify') {\\n        // i call from here to do not intefere with IText\\n        this._setSVGTextLineJustifed(i, textSpans, yPos, textLeftOffset);\\n        return;\\n      }\\n      textSpans.push(\\n        '\\\\t\\\\t\\\\t<tspan x=\\\"',\\n          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS), '\\\" ',\\n          'y=\\\"',\\n          toFixed(yPos, NUM_FRACTION_DIGITS),\\n          '\\\" ',\\n          // doing this on <tspan> elements since setting opacity\\n          // on containing <text> one doesn't work in Illustrator\\n          this._getFillAttributes(this.fill), '>',\\n          fabric.util.string.escapeXml(this._textLines[i]),\\n        '</tspan>\\\\n'\\n      );\\n    },\\n\\n    _setSVGTextLineJustifed: function(i, textSpans, yPos, textLeftOffset) {\\n      var ctx = fabric.util.createCanvasElement().getContext('2d');\\n\\n      this._setTextStyles(ctx);\\n\\n      var line = this._textLines[i],\\n          words = line.split(/\\\\s+/),\\n          wordsWidth = this._getWidthOfWords(ctx, words.join('')),\\n          widthDiff = this.width - wordsWidth,\\n          numSpaces = words.length - 1,\\n          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,\\n          word, attributes = this._getFillAttributes(this.fill),\\n          len;\\n\\n      textLeftOffset += this._getLineLeftOffset(this._getLineWidth(ctx, i));\\n\\n      for (i = 0, len = words.length; i < len; i++) {\\n        word = words[i];\\n        textSpans.push(\\n          '\\\\t\\\\t\\\\t<tspan x=\\\"',\\n            toFixed(textLeftOffset, NUM_FRACTION_DIGITS), '\\\" ',\\n            'y=\\\"',\\n            toFixed(yPos, NUM_FRACTION_DIGITS),\\n            '\\\" ',\\n            // doing this on <tspan> elements since setting opacity\\n            // on containing <text> one doesn't work in Illustrator\\n            attributes, '>',\\n            fabric.util.string.escapeXml(word),\\n          '</tspan>\\\\n'\\n        );\\n        textLeftOffset += this._getWidthOfWords(ctx, word) + spaceWidth;\\n      }\\n    },\\n\\n    _setSVGTextLineBg: function(textBgRects, i, textLeftOffset, textTopOffset, height) {\\n      textBgRects.push(\\n        '\\\\t\\\\t<rect ',\\n          this._getFillAttributes(this.textBackgroundColor),\\n          ' x=\\\"',\\n          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS),\\n          '\\\" y=\\\"',\\n          toFixed(height - this.height / 2, NUM_FRACTION_DIGITS),\\n          '\\\" width=\\\"',\\n          toFixed(this._getLineWidth(this.ctx, i), NUM_FRACTION_DIGITS),\\n          '\\\" height=\\\"',\\n          toFixed(this._getHeightOfLine(this.ctx, i) / this.lineHeight, NUM_FRACTION_DIGITS),\\n        '\\\"></rect>\\\\n');\\n    },\\n\\n    _setSVGBg: function(textBgRects) {\\n      if (this.backgroundColor) {\\n        textBgRects.push(\\n          '\\\\t\\\\t<rect ',\\n            this._getFillAttributes(this.backgroundColor),\\n            ' x=\\\"',\\n            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),\\n            '\\\" y=\\\"',\\n            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),\\n            '\\\" width=\\\"',\\n            toFixed(this.width, NUM_FRACTION_DIGITS),\\n            '\\\" height=\\\"',\\n            toFixed(this.height, NUM_FRACTION_DIGITS),\\n          '\\\"></rect>\\\\n');\\n      }\\n    },\\n\\n    /**\\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\\n     * we work around it by \\\"moving\\\" alpha channel into opacity attribute and setting fill's alpha to 1\\n     *\\n     * @private\\n     * @param {*} value\\n     * @return {String}\\n     */\\n    _getFillAttributes: function(value) {\\n      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';\\n      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\\n        return 'fill=\\\"' + value + '\\\"';\\n      }\\n      return 'opacity=\\\"' + fillColor.getAlpha() + '\\\" fill=\\\"' + fillColor.setAlpha(1).toRgb() + '\\\"';\\n    },\\n    /* _TO_SVG_END_ */\\n\\n    /**\\n     * Sets specified property to a specified value\\n     * @param {String} key\\n     * @param {*} value\\n     * @return {fabric.Text} thisArg\\n     * @chainable\\n     */\\n    _set: function(key, value) {\\n      this.callSuper('_set', key, value);\\n\\n      if (this._dimensionAffectingProps.indexOf(key) > -1) {\\n        this._initDimensions();\\n        this.setCoords();\\n      }\\n    },\\n\\n    /**\\n     * Returns complexity of an instance\\n     * @return {Number} complexity\\n     */\\n    complexity: function() {\\n      return 1;\\n    }\\n  });\\n\\n  /* _FROM_SVG_START_ */\\n  /**\\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\\n   * @static\\n   * @memberOf fabric.Text\\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\\n   */\\n  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\\n    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));\\n\\n  /**\\n   * Default SVG font size\\n   * @static\\n   * @memberOf fabric.Text\\n   */\\n  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\\n\\n  /**\\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\\n   * @static\\n   * @memberOf fabric.Text\\n   * @param {SVGElement} element Element to parse\\n   * @param {Object} [options] Options object\\n   * @return {fabric.Text} Instance of fabric.Text\\n   */\\n  fabric.Text.fromElement = function(element, options) {\\n    if (!element) {\\n      return null;\\n    }\\n\\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES);\\n    options = fabric.util.object.extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes);\\n\\n    options.top = options.top || 0;\\n    options.left = options.left || 0;\\n    if ('dx' in parsedAttributes) {\\n      options.left += parsedAttributes.dx;\\n    }\\n    if ('dy' in parsedAttributes) {\\n      options.top += parsedAttributes.dy;\\n    }\\n    if (!('fontSize' in options)) {\\n      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\\n    }\\n\\n    if (!options.originX) {\\n      options.originX = 'left';\\n    }\\n\\n    var textContent = '';\\n\\n    // The XML is not properly parsed in IE9 so a workaround to get\\n    // textContent is through firstChild.data. Another workaround would be\\n    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)\\n    if (!('textContent' in element)) {\\n      if ('firstChild' in element && element.firstChild !== null) {\\n        if ('data' in element.firstChild && element.firstChild.data !== null) {\\n          textContent = element.firstChild.data;\\n        }\\n      }\\n    }\\n    else {\\n      textContent = element.textContent;\\n    }\\n\\n    textContent = textContent.replace(/^\\\\s+|\\\\s+$|\\\\n+/g, '').replace(/\\\\s+/g, ' ');\\n\\n    var text = new fabric.Text(textContent, options),\\n        textHeightScaleFactor = text.getHeight() / text.height,\\n        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,\\n        scaledDiff = lineHeightDiff * textHeightScaleFactor,\\n        textHeight = text.getHeight() + scaledDiff,\\n        offX = 0;\\n    /*\\n      Adjust positioning:\\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\\n        top/left properties in Fabric correspond to center point of text bounding box\\n    */\\n    if (text.originX === 'left') {\\n      offX = text.getWidth() / 2;\\n    }\\n    if (text.originX === 'right') {\\n      offX = -text.getWidth() / 2;\\n    }\\n    text.set({\\n      left: text.getLeft() + offX,\\n      top: text.getTop() - textHeight / 2 + text.fontSize * (0.18 + text._fontSizeFraction) / text.lineHeight /* 0.3 is the old lineHeight */\\n    });\\n\\n    return text;\\n  };\\n  /* _FROM_SVG_END_ */\\n\\n  /**\\n   * Returns fabric.Text instance from an object representation\\n   * @static\\n   * @memberOf fabric.Text\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created\\n   * @return {fabric.Text} Instance of fabric.Text\\n   */\\n  fabric.Text.fromObject = function(object, callback) {\\n    var text = new fabric.Text(object.text, clone(object));\\n    callback && callback(text);\\n    return text;\\n  };\\n\\n  fabric.util.createAccessors(fabric.Text);\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function() {\\n\\n  var clone = fabric.util.object.clone;\\n\\n  /**\\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \\\"text:\\\"\\n   * prefix when observing canvas.\\n   * @class fabric.IText\\n   * @extends fabric.Text\\n   * @mixes fabric.Observable\\n   *\\n   * @fires changed\\n   * @fires selection:changed\\n   * @fires editing:entered\\n   * @fires editing:exited\\n   *\\n   * @return {fabric.IText} thisArg\\n   * @see {@link fabric.IText#initialize} for constructor definition\\n   *\\n   * <p>Supported key combinations:</p>\\n   * <pre>\\n   *   Move cursor:                    left, right, up, down\\n   *   Select character:               shift + left, shift + right\\n   *   Select text vertically:         shift + up, shift + down\\n   *   Move cursor by word:            alt + left, alt + right\\n   *   Select words:                   shift + alt + left, shift + alt + right\\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\\n   *   Jump to start/end of text:      cmd + up, cmd + down\\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\\n   *   Delete character:               backspace\\n   *   Delete word:                    alt + backspace\\n   *   Delete line:                    cmd + backspace\\n   *   Forward delete:                 delete\\n   *   Copy text:                      ctrl/cmd + c\\n   *   Paste text:                     ctrl/cmd + v\\n   *   Cut text:                       ctrl/cmd + x\\n   *   Select entire text:             ctrl/cmd + a\\n   *   Quit editing                    tab or esc\\n   * </pre>\\n   *\\n   * <p>Supported mouse/touch combination</p>\\n   * <pre>\\n   *   Position cursor:                click/touch\\n   *   Create selection:               click/touch & drag\\n   *   Create selection:               click & shift + click\\n   *   Select word:                    double click\\n   *   Select line:                    triple click\\n   * </pre>\\n   */\\n  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'i-text',\\n\\n    /**\\n     * Index where text selection starts (or where cursor is when there is no selection)\\n     * @type Number\\n     * @default\\n     */\\n    selectionStart: 0,\\n\\n    /**\\n     * Index where text selection ends\\n     * @type Number\\n     * @default\\n     */\\n    selectionEnd: 0,\\n\\n    /**\\n     * Color of text selection\\n     * @type String\\n     * @default\\n     */\\n    selectionColor: 'rgba(17,119,255,0.3)',\\n\\n    /**\\n     * Indicates whether text is in editing mode\\n     * @type Boolean\\n     * @default\\n     */\\n    isEditing: false,\\n\\n    /**\\n     * Indicates whether a text can be edited\\n     * @type Boolean\\n     * @default\\n     */\\n    editable: true,\\n\\n    /**\\n     * Border color of text object while it's in editing mode\\n     * @type String\\n     * @default\\n     */\\n    editingBorderColor: 'rgba(102,153,255,0.25)',\\n\\n    /**\\n     * Width of cursor (in px)\\n     * @type Number\\n     * @default\\n     */\\n    cursorWidth: 2,\\n\\n    /**\\n     * Color of default cursor (when not overwritten by character style)\\n     * @type String\\n     * @default\\n     */\\n    cursorColor: '#333',\\n\\n    /**\\n     * Delay between cursor blink (in ms)\\n     * @type Number\\n     * @default\\n     */\\n    cursorDelay: 1000,\\n\\n    /**\\n     * Duration of cursor fadein (in ms)\\n     * @type Number\\n     * @default\\n     */\\n    cursorDuration: 600,\\n\\n    /**\\n     * Object containing character styles\\n     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)\\n     * @type Object\\n     * @default\\n     */\\n    styles: null,\\n\\n    /**\\n     * Indicates whether internal text char widths can be cached\\n     * @type Boolean\\n     * @default\\n     */\\n    caching: true,\\n\\n    /**\\n     * @private\\n     */\\n    _reSpace: /\\\\s|\\\\n/,\\n\\n    /**\\n     * @private\\n     */\\n    _currentCursorOpacity: 0,\\n\\n    /**\\n     * @private\\n     */\\n    _selectionDirection: null,\\n\\n    /**\\n     * @private\\n     */\\n    _abortCursorAnimation: false,\\n\\n    /**\\n     * @private\\n     */\\n    __widthOfSpace: [],\\n\\n    /**\\n     * Constructor\\n     * @param {String} text Text string\\n     * @param {Object} [options] Options object\\n     * @return {fabric.IText} thisArg\\n     */\\n    initialize: function(text, options) {\\n      this.styles = options ? (options.styles || { }) : { };\\n      this.callSuper('initialize', text, options);\\n      this.initBehavior();\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _clearCache: function() {\\n      this.callSuper('_clearCache');\\n      this.__widthOfSpace = [];\\n    },\\n\\n    /**\\n     * Returns true if object has no styling\\n     */\\n    isEmptyStyles: function() {\\n      if (!this.styles) {\\n        return true;\\n      }\\n      var obj = this.styles;\\n\\n      for (var p1 in obj) {\\n        for (var p2 in obj[p1]) {\\n          // eslint-disable-next-line no-unused-vars\\n          for (var p3 in obj[p1][p2]) {\\n            return false;\\n          }\\n        }\\n      }\\n      return true;\\n    },\\n\\n    /**\\n     * Sets selection start (left boundary of a selection)\\n     * @param {Number} index Index to set selection start to\\n     */\\n    setSelectionStart: function(index) {\\n      index = Math.max(index, 0);\\n      this._updateAndFire('selectionStart', index);\\n    },\\n\\n    /**\\n     * Sets selection end (right boundary of a selection)\\n     * @param {Number} index Index to set selection end to\\n     */\\n    setSelectionEnd: function(index) {\\n      index = Math.min(index, this.text.length);\\n      this._updateAndFire('selectionEnd', index);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} property 'selectionStart' or 'selectionEnd'\\n     * @param {Number} index new position of property\\n     */\\n    _updateAndFire: function(property, index) {\\n      if (this[property] !== index) {\\n        this._fireSelectionChanged();\\n        this[property] = index;\\n      }\\n      this._updateTextarea();\\n    },\\n\\n    /**\\n     * Fires the even of selection changed\\n     * @private\\n     */\\n    _fireSelectionChanged: function() {\\n      this.fire('selection:changed');\\n      this.canvas && this.canvas.fire('text:selection:changed', { target: this });\\n    },\\n\\n    /**\\n     * Gets style of a current selection/cursor (at the start position)\\n     * @param {Number} [startIndex] Start index to get styles at\\n     * @param {Number} [endIndex] End index to get styles at\\n     * @return {Object} styles Style object at a specified (or current) index\\n     */\\n    getSelectionStyles: function(startIndex, endIndex) {\\n\\n      if (arguments.length === 2) {\\n        var styles = [];\\n        for (var i = startIndex; i < endIndex; i++) {\\n          styles.push(this.getSelectionStyles(i));\\n        }\\n        return styles;\\n      }\\n\\n      var loc = this.get2DCursorLocation(startIndex),\\n          style = this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\\n\\n      return style || {};\\n    },\\n\\n    /**\\n     * Sets style of a current selection\\n     * @param {Object} [styles] Styles object\\n     * @return {fabric.IText} thisArg\\n     * @chainable\\n     */\\n    setSelectionStyles: function(styles) {\\n      if (this.selectionStart === this.selectionEnd) {\\n        this._extendStyles(this.selectionStart, styles);\\n      }\\n      else {\\n        for (var i = this.selectionStart; i < this.selectionEnd; i++) {\\n          this._extendStyles(i, styles);\\n        }\\n      }\\n      /* not included in _extendStyles to avoid clearing cache more than once */\\n      this._forceClearCache = true;\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _extendStyles: function(index, styles) {\\n      var loc = this.get2DCursorLocation(index);\\n\\n      if (!this._getLineStyle(loc.lineIndex)) {\\n        this._setLineStyle(loc.lineIndex, {});\\n      }\\n\\n      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\\n        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\\n      }\\n\\n      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\\n    },\\n\\n    /**\\n     * Initialize text dimensions. Render all text on given context\\n     * or on a offscreen canvas to get the text width with measureText.\\n     * Updates this.width and this.height with the proper values.\\n     * Does not return dimensions.\\n     * @param {CanvasRenderingContext2D} [ctx] Context to render on\\n     * @private\\n     */\\n    _initDimensions: function(ctx) {\\n      if (!ctx) {\\n        this.clearContextTop();\\n      }\\n      this.callSuper('_initDimensions', ctx);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Boolean} noTransform\\n     */\\n    render: function(ctx, noTransform) {\\n      this.clearContextTop();\\n      this.callSuper('render', ctx, noTransform);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _render: function(ctx) {\\n      this.callSuper('_render', ctx);\\n      this.ctx = ctx;\\n      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor\\n      // the correct position but not at every cursor animation.\\n      this.cursorOffsetCache = { };\\n      this.renderCursorOrSelection();\\n    },\\n\\n    /**\\n     * Prepare and clean the contextTop\\n     */\\n    clearContextTop: function() {\\n      if (!this.active || !this.isEditing) {\\n        return;\\n      }\\n      if (this.canvas && this.canvas.contextTop) {\\n        var ctx = this.canvas.contextTop;\\n        ctx.save();\\n        ctx.transform.apply(ctx, this.canvas.viewportTransform);\\n        this.transform(ctx);\\n        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);\\n        this._clearTextArea(ctx);\\n        ctx.restore();\\n      }\\n    },\\n\\n    /**\\n     * Renders cursor or selection (depending on what exists)\\n     */\\n    renderCursorOrSelection: function() {\\n      if (!this.active || !this.isEditing) {\\n        return;\\n      }\\n      var chars = this.text.split(''),\\n          boundaries, ctx;\\n      if (this.canvas && this.canvas.contextTop) {\\n        ctx = this.canvas.contextTop;\\n        ctx.save();\\n        ctx.transform.apply(ctx, this.canvas.viewportTransform);\\n        this.transform(ctx);\\n        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);\\n        this._clearTextArea(ctx);\\n      }\\n      else {\\n        ctx = this.ctx;\\n        ctx.save();\\n      }\\n      if (this.selectionStart === this.selectionEnd) {\\n        boundaries = this._getCursorBoundaries(chars, 'cursor');\\n        this.renderCursor(boundaries, ctx);\\n      }\\n      else {\\n        boundaries = this._getCursorBoundaries(chars, 'selection');\\n        this.renderSelection(chars, boundaries, ctx);\\n      }\\n      ctx.restore();\\n    },\\n\\n    _clearTextArea: function(ctx) {\\n      // we add 4 pixel, to be sure to do not leave any pixel out\\n      var width = this.width + 4, height = this.height + 4;\\n      ctx.clearRect(-width / 2, -height / 2, width, height);\\n    },\\n    /**\\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\\n     */\\n    get2DCursorLocation: function(selectionStart) {\\n      if (typeof selectionStart === 'undefined') {\\n        selectionStart = this.selectionStart;\\n      }\\n      var len = this._textLines.length;\\n      for (var i = 0; i < len; i++) {\\n        if (selectionStart <= this._textLines[i].length) {\\n          return {\\n            lineIndex: i,\\n            charIndex: selectionStart\\n          };\\n        }\\n        selectionStart -= this._textLines[i].length + 1;\\n      }\\n      return {\\n        lineIndex: i - 1,\\n        charIndex: this._textLines[i - 1].length < selectionStart ? this._textLines[i - 1].length : selectionStart\\n      };\\n    },\\n\\n    /**\\n     * Returns complete style of char at the current cursor\\n     * @param {Number} lineIndex Line index\\n     * @param {Number} charIndex Char index\\n     * @return {Object} Character style\\n     */\\n    getCurrentCharStyle: function(lineIndex, charIndex) {\\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\\n\\n      return {\\n        fontSize: style && style.fontSize || this.fontSize,\\n        fill: style && style.fill || this.fill,\\n        textBackgroundColor: style && style.textBackgroundColor || this.textBackgroundColor,\\n        textDecoration: style && style.textDecoration || this.textDecoration,\\n        fontFamily: style && style.fontFamily || this.fontFamily,\\n        fontWeight: style && style.fontWeight || this.fontWeight,\\n        fontStyle: style && style.fontStyle || this.fontStyle,\\n        stroke: style && style.stroke || this.stroke,\\n        strokeWidth: style && style.strokeWidth || this.strokeWidth\\n      };\\n    },\\n\\n    /**\\n     * Returns fontSize of char at the current cursor\\n     * @param {Number} lineIndex Line index\\n     * @param {Number} charIndex Char index\\n     * @return {Number} Character font size\\n     */\\n    getCurrentCharFontSize: function(lineIndex, charIndex) {\\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\\n      return style && style.fontSize ? style.fontSize : this.fontSize;\\n    },\\n\\n    /**\\n     * Returns color (fill) of char at the current cursor\\n     * @param {Number} lineIndex Line index\\n     * @param {Number} charIndex Char index\\n     * @return {String} Character color (fill)\\n     */\\n    getCurrentCharColor: function(lineIndex, charIndex) {\\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\\n      return style && style.fill ? style.fill : this.cursorColor;\\n    },\\n\\n    /**\\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\\n     * @private\\n     * @param {Array} chars Array of characters\\n     * @param {String} typeOfBoundaries\\n     */\\n    _getCursorBoundaries: function(chars, typeOfBoundaries) {\\n\\n      // left/top are left/top of entire text box\\n      // leftOffset/topOffset are offset from that left/top point of a text box\\n\\n      var left = Math.round(this._getLeftOffset()),\\n          top = this._getTopOffset(),\\n\\n          offsets = this._getCursorBoundariesOffsets(\\n                      chars, typeOfBoundaries);\\n\\n      return {\\n        left: left,\\n        top: top,\\n        leftOffset: offsets.left + offsets.lineLeft,\\n        topOffset: offsets.top\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {\\n      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {\\n        return this.cursorOffsetCache;\\n      }\\n      var lineLeftOffset = 0,\\n          lineIndex = 0,\\n          charIndex = 0,\\n          topOffset = 0,\\n          leftOffset = 0,\\n          boundaries;\\n\\n      for (var i = 0; i < this.selectionStart; i++) {\\n        if (chars[i] === '\\\\n') {\\n          leftOffset = 0;\\n          topOffset += this._getHeightOfLine(this.ctx, lineIndex);\\n\\n          lineIndex++;\\n          charIndex = 0;\\n        }\\n        else {\\n          leftOffset += this._getWidthOfChar(this.ctx, chars[i], lineIndex, charIndex);\\n          charIndex++;\\n        }\\n\\n        lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex));\\n      }\\n      if (typeOfBoundaries === 'cursor') {\\n        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, lineIndex) / this.lineHeight\\n          - this.getCurrentCharFontSize(lineIndex, charIndex) * (1 - this._fontSizeFraction);\\n      }\\n      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {\\n        leftOffset -= this._getWidthOfCharSpacing();\\n      }\\n      boundaries = {\\n        top: topOffset,\\n        left: leftOffset > 0 ? leftOffset : 0,\\n        lineLeft: lineLeftOffset\\n      };\\n      this.cursorOffsetCache = boundaries;\\n      return this.cursorOffsetCache;\\n    },\\n\\n    /**\\n     * Renders cursor\\n     * @param {Object} boundaries\\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\\n     */\\n    renderCursor: function(boundaries, ctx) {\\n\\n      var cursorLocation = this.get2DCursorLocation(),\\n          lineIndex = cursorLocation.lineIndex,\\n          charIndex = cursorLocation.charIndex,\\n          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),\\n          leftOffset = (lineIndex === 0 && charIndex === 0)\\n                    ? this._getLineLeftOffset(this._getLineWidth(ctx, lineIndex))\\n                    : boundaries.leftOffset,\\n          multiplier = this.scaleX * this.canvas.getZoom(),\\n          cursorWidth = this.cursorWidth / multiplier;\\n\\n      ctx.fillStyle = this.getCurrentCharColor(lineIndex, charIndex);\\n      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\\n\\n      ctx.fillRect(\\n        boundaries.left + leftOffset - cursorWidth / 2,\\n        boundaries.top + boundaries.topOffset,\\n        cursorWidth,\\n        charHeight);\\n    },\\n\\n    /**\\n     * Renders text selection\\n     * @param {Array} chars Array of characters\\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\\n     */\\n    renderSelection: function(chars, boundaries, ctx) {\\n\\n      ctx.fillStyle = this.selectionColor;\\n\\n      var start = this.get2DCursorLocation(this.selectionStart),\\n          end = this.get2DCursorLocation(this.selectionEnd),\\n          startLine = start.lineIndex,\\n          endLine = end.lineIndex;\\n      for (var i = startLine; i <= endLine; i++) {\\n        var lineOffset = this._getLineLeftOffset(this._getLineWidth(ctx, i)) || 0,\\n            lineHeight = this._getHeightOfLine(this.ctx, i),\\n            realLineHeight = 0, boxWidth = 0, line = this._textLines[i];\\n\\n        if (i === startLine) {\\n          for (var j = 0, len = line.length; j < len; j++) {\\n            if (j >= start.charIndex && (i !== endLine || j < end.charIndex)) {\\n              boxWidth += this._getWidthOfChar(ctx, line[j], i, j);\\n            }\\n            if (j < start.charIndex) {\\n              lineOffset += this._getWidthOfChar(ctx, line[j], i, j);\\n            }\\n          }\\n          if (j === line.length) {\\n            boxWidth -= this._getWidthOfCharSpacing();\\n          }\\n        }\\n        else if (i > startLine && i < endLine) {\\n          boxWidth += this._getLineWidth(ctx, i) || 5;\\n        }\\n        else if (i === endLine) {\\n          for (var j2 = 0, j2len = end.charIndex; j2 < j2len; j2++) {\\n            boxWidth += this._getWidthOfChar(ctx, line[j2], i, j2);\\n          }\\n          if (end.charIndex === line.length) {\\n            boxWidth -= this._getWidthOfCharSpacing();\\n          }\\n        }\\n        realLineHeight = lineHeight;\\n        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {\\n          lineHeight /= this.lineHeight;\\n        }\\n        ctx.fillRect(\\n          boundaries.left + lineOffset,\\n          boundaries.top + boundaries.topOffset,\\n          boxWidth > 0 ? boxWidth : 0,\\n          lineHeight);\\n\\n        boundaries.topOffset += realLineHeight;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} method\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} line Content of the line\\n     * @param {Number} left\\n     * @param {Number} top\\n     * @param {Number} lineIndex\\n     * @param {Number} charOffset\\n     */\\n    _renderChars: function(method, ctx, line, left, top, lineIndex, charOffset) {\\n\\n      if (this.isEmptyStyles()) {\\n        return this._renderCharsFast(method, ctx, line, left, top);\\n      }\\n\\n      charOffset = charOffset || 0;\\n\\n      // set proper line offset\\n      var lineHeight = this._getHeightOfLine(ctx, lineIndex),\\n          prevStyle,\\n          thisStyle,\\n          charsToRender = '';\\n\\n      ctx.save();\\n      top -= lineHeight / this.lineHeight * this._fontSizeFraction;\\n      for (var i = charOffset, len = line.length + charOffset; i <= len; i++) {\\n        prevStyle = prevStyle || this.getCurrentCharStyle(lineIndex, i);\\n        thisStyle = this.getCurrentCharStyle(lineIndex, i + 1);\\n\\n        if (this._hasStyleChanged(prevStyle, thisStyle) || i === len) {\\n          this._renderChar(method, ctx, lineIndex, i - 1, charsToRender, left, top, lineHeight);\\n          charsToRender = '';\\n          prevStyle = thisStyle;\\n        }\\n        charsToRender += line[i - charOffset];\\n      }\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} method\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} line Content of the line\\n     * @param {Number} left Left coordinate\\n     * @param {Number} top Top coordinate\\n     */\\n    _renderCharsFast: function(method, ctx, line, left, top) {\\n\\n      if (method === 'fillText' && this.fill) {\\n        this.callSuper('_renderChars', method, ctx, line, left, top);\\n      }\\n      if (method === 'strokeText' && ((this.stroke && this.strokeWidth > 0) || this.skipFillStrokeCheck)) {\\n        this.callSuper('_renderChars', method, ctx, line, left, top);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} method\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Number} lineIndex\\n     * @param {Number} i\\n     * @param {String} _char\\n     * @param {Number} left Left coordinate\\n     * @param {Number} top Top coordinate\\n     * @param {Number} lineHeight Height of the line\\n     */\\n    _renderChar: function(method, ctx, lineIndex, i, _char, left, top, lineHeight) {\\n      var charWidth, charHeight, shouldFill, shouldStroke,\\n          decl = this._getStyleDeclaration(lineIndex, i),\\n          offset, textDecoration, chars, additionalSpace, _charWidth;\\n\\n      if (decl) {\\n        charHeight = this._getHeightOfChar(ctx, _char, lineIndex, i);\\n        shouldStroke = decl.stroke;\\n        shouldFill = decl.fill;\\n        textDecoration = decl.textDecoration;\\n      }\\n      else {\\n        charHeight = this.fontSize;\\n      }\\n\\n      shouldStroke = (shouldStroke || this.stroke) && method === 'strokeText';\\n      shouldFill = (shouldFill || this.fill) && method === 'fillText';\\n\\n      decl && ctx.save();\\n\\n      charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i, decl || null);\\n      textDecoration = textDecoration || this.textDecoration;\\n\\n      if (decl && decl.textBackgroundColor) {\\n        this._removeShadow(ctx);\\n      }\\n      if (this.charSpacing !== 0) {\\n        additionalSpace = this._getWidthOfCharSpacing();\\n        chars = _char.split('');\\n        charWidth = 0;\\n        for (var j = 0, len = chars.length, char; j < len; j++) {\\n          char = chars[j];\\n          shouldFill && ctx.fillText(char, left + charWidth, top);\\n          shouldStroke && ctx.strokeText(char, left + charWidth, top);\\n          _charWidth = ctx.measureText(char).width + additionalSpace;\\n          charWidth += _charWidth > 0 ? _charWidth : 0;\\n        }\\n      }\\n      else {\\n        shouldFill && ctx.fillText(_char, left, top);\\n        shouldStroke && ctx.strokeText(_char, left, top);\\n      }\\n\\n      if (textDecoration || textDecoration !== '') {\\n        offset = this._fontSizeFraction * lineHeight / this.lineHeight;\\n        this._renderCharDecoration(ctx, textDecoration, left, top, offset, charWidth, charHeight);\\n      }\\n\\n      decl && ctx.restore();\\n      ctx.translate(charWidth, 0);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} prevStyle\\n     * @param {Object} thisStyle\\n     */\\n    _hasStyleChanged: function(prevStyle, thisStyle) {\\n      return (prevStyle.fill !== thisStyle.fill ||\\n              prevStyle.fontSize !== thisStyle.fontSize ||\\n              prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor ||\\n              prevStyle.textDecoration !== thisStyle.textDecoration ||\\n              prevStyle.fontFamily !== thisStyle.fontFamily ||\\n              prevStyle.fontWeight !== thisStyle.fontWeight ||\\n              prevStyle.fontStyle !== thisStyle.fontStyle ||\\n              prevStyle.stroke !== thisStyle.stroke ||\\n              prevStyle.strokeWidth !== thisStyle.strokeWidth\\n      );\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderCharDecoration: function(ctx, textDecoration, left, top, offset, charWidth, charHeight) {\\n\\n      if (!textDecoration) {\\n        return;\\n      }\\n\\n      var decorationWeight = charHeight / 15,\\n          positions = {\\n            underline: top + charHeight / 10,\\n            'line-through': top - charHeight * (this._fontSizeFraction + this._fontSizeMult - 1) + decorationWeight,\\n            overline: top - (this._fontSizeMult - this._fontSizeFraction) * charHeight\\n          },\\n          decorations = ['underline', 'line-through', 'overline'], i, decoration;\\n\\n      for (i = 0; i < decorations.length; i++) {\\n        decoration = decorations[i];\\n        if (textDecoration.indexOf(decoration) > -1) {\\n          ctx.fillRect(left, positions[decoration], charWidth , decorationWeight);\\n        }\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} method\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} line\\n     * @param {Number} left\\n     * @param {Number} top\\n     * @param {Number} lineIndex\\n     */\\n    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\\n      // to \\\"cancel\\\" this.fontSize subtraction in fabric.Text#_renderTextLine\\n      // the adding 0.03 is just to align text with itext by overlap test\\n      if (!this.isEmptyStyles()) {\\n        top += this.fontSize * (this._fontSizeFraction + 0.03);\\n      }\\n      this.callSuper('_renderTextLine', method, ctx, line, left, top, lineIndex);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderTextDecoration: function(ctx) {\\n      if (this.isEmptyStyles()) {\\n        return this.callSuper('_renderTextDecoration', ctx);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _renderTextLinesBackground: function(ctx) {\\n      this.callSuper('_renderTextLinesBackground', ctx);\\n\\n      var lineTopOffset = 0, heightOfLine,\\n          lineWidth, lineLeftOffset,\\n          leftOffset = this._getLeftOffset(),\\n          topOffset = this._getTopOffset(),\\n          line, _char, style;\\n      ctx.save();\\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\\n        heightOfLine = this._getHeightOfLine(ctx, i);\\n        line = this._textLines[i];\\n\\n        if (line === '' || !this.styles || !this._getLineStyle(i)) {\\n          lineTopOffset += heightOfLine;\\n          continue;\\n        }\\n\\n        lineWidth = this._getLineWidth(ctx, i);\\n        lineLeftOffset = this._getLineLeftOffset(lineWidth);\\n\\n        for (var j = 0, jlen = line.length; j < jlen; j++) {\\n          style = this._getStyleDeclaration(i, j);\\n          if (!style || !style.textBackgroundColor) {\\n            continue;\\n          }\\n          _char = line[j];\\n\\n          ctx.fillStyle = style.textBackgroundColor;\\n\\n          ctx.fillRect(\\n            leftOffset + lineLeftOffset + this._getWidthOfCharsAt(ctx, i, j),\\n            topOffset + lineTopOffset,\\n            this._getWidthOfChar(ctx, _char, i, j),\\n            heightOfLine / this.lineHeight\\n          );\\n        }\\n        lineTopOffset += heightOfLine;\\n      }\\n      ctx.restore();\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getCacheProp: function(_char, styleDeclaration) {\\n      return _char +\\n             styleDeclaration.fontSize +\\n             styleDeclaration.fontWeight +\\n             styleDeclaration.fontStyle;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {String} fontFamily name\\n     * @return {Object} reference to cache\\n     */\\n    _getFontCache: function(fontFamily) {\\n      if (!fabric.charWidthsCache[fontFamily]) {\\n        fabric.charWidthsCache[fontFamily] = { };\\n      }\\n      return fabric.charWidthsCache[fontFamily];\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} _char\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     * @param {Object} [decl]\\n     */\\n    _applyCharStylesGetWidth: function(ctx, _char, lineIndex, charIndex, decl) {\\n      var charDecl = decl || this._getStyleDeclaration(lineIndex, charIndex),\\n          styleDeclaration = clone(charDecl),\\n          width, cacheProp, charWidthsCache;\\n\\n      this._applyFontStyles(styleDeclaration);\\n      charWidthsCache = this._getFontCache(styleDeclaration.fontFamily);\\n      cacheProp = this._getCacheProp(_char, styleDeclaration);\\n\\n      // short-circuit if no styles for this char\\n      // global style from object is always applyed and handled by save and restore\\n      if (!charDecl && charWidthsCache[cacheProp] && this.caching) {\\n        return charWidthsCache[cacheProp];\\n      }\\n\\n      if (typeof styleDeclaration.shadow === 'string') {\\n        styleDeclaration.shadow = new fabric.Shadow(styleDeclaration.shadow);\\n      }\\n\\n      var fill = styleDeclaration.fill || this.fill;\\n      ctx.fillStyle = fill.toLive\\n        ? fill.toLive(ctx, this)\\n        : fill;\\n\\n      if (styleDeclaration.stroke) {\\n        ctx.strokeStyle = (styleDeclaration.stroke && styleDeclaration.stroke.toLive)\\n          ? styleDeclaration.stroke.toLive(ctx, this)\\n          : styleDeclaration.stroke;\\n      }\\n\\n      ctx.lineWidth = styleDeclaration.strokeWidth || this.strokeWidth;\\n      ctx.font = this._getFontDeclaration.call(styleDeclaration);\\n\\n      //if we want this._setShadow.call to work with styleDeclarion\\n      //we have to add those references\\n      if (styleDeclaration.shadow) {\\n        styleDeclaration.scaleX = this.scaleX;\\n        styleDeclaration.scaleY = this.scaleY;\\n        styleDeclaration.canvas = this.canvas;\\n        styleDeclaration.getObjectScaling = this.getObjectScaling;\\n        this._setShadow.call(styleDeclaration, ctx);\\n      }\\n\\n      if (!this.caching || !charWidthsCache[cacheProp]) {\\n        width = ctx.measureText(_char).width;\\n        this.caching && (charWidthsCache[cacheProp] = width);\\n        return width;\\n      }\\n\\n      return charWidthsCache[cacheProp];\\n    },\\n\\n    /**\\n     * @private\\n     * @param {Object} styleDeclaration\\n     */\\n    _applyFontStyles: function(styleDeclaration) {\\n      if (!styleDeclaration.fontFamily) {\\n        styleDeclaration.fontFamily = this.fontFamily;\\n      }\\n      if (!styleDeclaration.fontSize) {\\n        styleDeclaration.fontSize = this.fontSize;\\n      }\\n      if (!styleDeclaration.fontWeight) {\\n        styleDeclaration.fontWeight = this.fontWeight;\\n      }\\n      if (!styleDeclaration.fontStyle) {\\n        styleDeclaration.fontStyle = this.fontStyle;\\n      }\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     * @param {Boolean} [returnCloneOrEmpty=false]\\n     * @private\\n     */\\n    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {\\n      if (returnCloneOrEmpty) {\\n        return (this.styles[lineIndex] && this.styles[lineIndex][charIndex])\\n          ? clone(this.styles[lineIndex][charIndex])\\n          : { };\\n      }\\n\\n      return this.styles[lineIndex] && this.styles[lineIndex][charIndex] ? this.styles[lineIndex][charIndex] : null;\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     * @param {Object} style\\n     * @private\\n     */\\n    _setStyleDeclaration: function(lineIndex, charIndex, style) {\\n      this.styles[lineIndex][charIndex] = style;\\n    },\\n\\n    /**\\n     *\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     * @private\\n     */\\n    _deleteStyleDeclaration: function(lineIndex, charIndex) {\\n      delete this.styles[lineIndex][charIndex];\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @private\\n     */\\n    _getLineStyle: function(lineIndex) {\\n      return this.styles[lineIndex];\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @param {Object} style\\n     * @private\\n     */\\n    _setLineStyle: function(lineIndex, style) {\\n      this.styles[lineIndex] = style;\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @private\\n     */\\n    _deleteLineStyle: function(lineIndex) {\\n      delete this.styles[lineIndex];\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _getWidthOfChar: function(ctx, _char, lineIndex, charIndex) {\\n      if (!this._isMeasuring && this.textAlign === 'justify' && this._reSpacesAndTabs.test(_char)) {\\n        return this._getWidthOfSpace(ctx, lineIndex);\\n      }\\n      ctx.save();\\n      var width = this._applyCharStylesGetWidth(ctx, _char, lineIndex, charIndex);\\n      if (this.charSpacing !== 0) {\\n        width += this._getWidthOfCharSpacing();\\n      }\\n      ctx.restore();\\n      return width > 0 ? width : 0\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     */\\n    _getHeightOfChar: function(ctx, lineIndex, charIndex) {\\n      var style = this._getStyleDeclaration(lineIndex, charIndex);\\n      return style && style.fontSize ? style.fontSize : this.fontSize;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     */\\n    _getWidthOfCharsAt: function(ctx, lineIndex, charIndex) {\\n      var width = 0, i, _char;\\n      for (i = 0; i < charIndex; i++) {\\n        _char = this._textLines[lineIndex][i];\\n        width += this._getWidthOfChar(ctx, _char, lineIndex, i);\\n      }\\n      return width;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Number} lineIndex line number\\n     * @return {Number} Line width\\n     */\\n    _measureLine: function(ctx, lineIndex) {\\n      this._isMeasuring = true;\\n      var width = this._getWidthOfCharsAt(ctx, lineIndex, this._textLines[lineIndex].length);\\n      if (this.charSpacing !== 0) {\\n        width -= this._getWidthOfCharSpacing();\\n      }\\n      this._isMeasuring = false;\\n      return width > 0 ? width : 0;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {Number} lineIndex\\n     */\\n    _getWidthOfSpace: function (ctx, lineIndex) {\\n      if (this.__widthOfSpace[lineIndex]) {\\n        return this.__widthOfSpace[lineIndex];\\n      }\\n      var line = this._textLines[lineIndex],\\n          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex, 0),\\n          widthDiff = this.width - wordsWidth,\\n          numSpaces = line.length - line.replace(this._reSpacesAndTabs, '').length,\\n          width = Math.max(widthDiff / numSpaces, ctx.measureText(' ').width);\\n      this.__widthOfSpace[lineIndex] = width;\\n      return width;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     * @param {String} line\\n     * @param {Number} lineIndex\\n     * @param {Number} charOffset\\n     */\\n    _getWidthOfWords: function (ctx, line, lineIndex, charOffset) {\\n      var width = 0;\\n\\n      for (var charIndex = 0; charIndex < line.length; charIndex++) {\\n        var _char = line[charIndex];\\n\\n        if (!_char.match(/\\\\s/)) {\\n          width += this._getWidthOfChar(ctx, _char, lineIndex, charIndex + charOffset);\\n        }\\n      }\\n\\n      return width;\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _getHeightOfLine: function(ctx, lineIndex) {\\n      if (this.__lineHeights[lineIndex]) {\\n        return this.__lineHeights[lineIndex];\\n      }\\n\\n      var line = this._textLines[lineIndex],\\n          maxHeight = this._getHeightOfChar(ctx, lineIndex, 0);\\n\\n      for (var i = 1, len = line.length; i < len; i++) {\\n        var currentCharHeight = this._getHeightOfChar(ctx, lineIndex, i);\\n        if (currentCharHeight > maxHeight) {\\n          maxHeight = currentCharHeight;\\n        }\\n      }\\n      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\\n      return this.__lineHeights[lineIndex];\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _getTextHeight: function(ctx) {\\n      var lineHeight, height = 0;\\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\\n        lineHeight = this._getHeightOfLine(ctx, i);\\n        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);\\n      }\\n      return height;\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @method toObject\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {\\n        styles: clone(this.styles, true)\\n      });\\n    }\\n  });\\n\\n  /**\\n   * Returns fabric.IText instance from an object representation\\n   * @static\\n   * @memberOf fabric.IText\\n   * @param {Object} object Object to create an instance from\\n   * @param {function} [callback] invoked with new instance as argument\\n   * @return {fabric.IText} instance of fabric.IText\\n   */\\n  fabric.IText.fromObject = function(object, callback) {\\n    var iText = new fabric.IText(object.text, clone(object));\\n    callback && callback(iText);\\n    return iText;\\n  };\\n})();\\n\\n\\n(function() {\\n\\n  var clone = fabric.util.object.clone;\\n\\n  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\\n\\n    /**\\n     * Initializes all the interactive behavior of IText\\n     */\\n    initBehavior: function() {\\n      this.initAddedHandler();\\n      this.initRemovedHandler();\\n      this.initCursorSelectionHandlers();\\n      this.initDoubleClickSimulation();\\n      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\\n    },\\n\\n    /**\\n     * Initializes \\\"selected\\\" event handler\\n     */\\n    initSelectedHandler: function() {\\n      this.on('selected', function() {\\n\\n        var _this = this;\\n        setTimeout(function() {\\n          _this.selected = true;\\n        }, 100);\\n      });\\n    },\\n\\n    /**\\n     * Initializes \\\"added\\\" event handler\\n     */\\n    initAddedHandler: function() {\\n      var _this = this;\\n      this.on('added', function() {\\n        var canvas = _this.canvas;\\n        if (canvas) {\\n          if (!canvas._hasITextHandlers) {\\n            canvas._hasITextHandlers = true;\\n            _this._initCanvasHandlers(canvas);\\n          }\\n          canvas._iTextInstances = canvas._iTextInstances || [];\\n          canvas._iTextInstances.push(_this);\\n        }\\n      });\\n    },\\n\\n    initRemovedHandler: function() {\\n      var _this = this;\\n      this.on('removed', function() {\\n        var canvas = _this.canvas;\\n        if (canvas) {\\n          canvas._iTextInstances = canvas._iTextInstances || [];\\n          fabric.util.removeFromArray(canvas._iTextInstances, _this);\\n          if (canvas._iTextInstances.length === 0) {\\n            canvas._hasITextHandlers = false;\\n            _this._removeCanvasHandlers(canvas);\\n          }\\n        }\\n      });\\n    },\\n\\n    /**\\n     * register canvas event to manage exiting on other instances\\n     * @private\\n     */\\n    _initCanvasHandlers: function(canvas) {\\n      canvas._canvasITextSelectionClearedHanlder = (function() {\\n        fabric.IText.prototype.exitEditingOnOthers(canvas);\\n      }).bind(this);\\n      canvas._mouseUpITextHandler = (function() {\\n        if (canvas._iTextInstances) {\\n          canvas._iTextInstances.forEach(function(obj) {\\n            obj.__isMousedown = false;\\n          });\\n        }\\n      }).bind(this);\\n      canvas.on('selection:cleared', canvas._canvasITextSelectionClearedHanlder);\\n      canvas.on('object:selected', canvas._canvasITextSelectionClearedHanlder);\\n      canvas.on('mouse:up', canvas._mouseUpITextHandler);\\n    },\\n\\n    /**\\n     * remove canvas event to manage exiting on other instances\\n     * @private\\n     */\\n    _removeCanvasHandlers: function(canvas) {\\n      canvas.off('selection:cleared', canvas._canvasITextSelectionClearedHanlder);\\n      canvas.off('object:selected', canvas._canvasITextSelectionClearedHanlder);\\n      canvas.off('mouse:up', canvas._mouseUpITextHandler);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _tick: function() {\\n      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\\n\\n      var tickState;\\n\\n      tickState = {\\n        isAborted: false,\\n        abort: function() {\\n          this.isAborted = true;\\n        },\\n      };\\n\\n      obj.animate('_currentCursorOpacity', targetOpacity, {\\n        duration: duration,\\n        onComplete: function() {\\n          if (!tickState.isAborted) {\\n            obj[completeMethod]();\\n          }\\n        },\\n        onChange: function() {\\n          // we do not want to animate a selection, only cursor\\n          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {\\n            obj.renderCursorOrSelection();\\n          }\\n        },\\n        abort: function() {\\n          return tickState.isAborted;\\n        }\\n      });\\n      return tickState;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _onTickComplete: function() {\\n\\n      var _this = this;\\n\\n      if (this._cursorTimeout1) {\\n        clearTimeout(this._cursorTimeout1);\\n      }\\n      this._cursorTimeout1 = setTimeout(function() {\\n        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');\\n      }, 100);\\n    },\\n\\n    /**\\n     * Initializes delayed cursor\\n     */\\n    initDelayedCursor: function(restart) {\\n      var _this = this,\\n          delay = restart ? 0 : this.cursorDelay;\\n\\n      this.abortCursorAnimation();\\n      this._currentCursorOpacity = 1;\\n      this._cursorTimeout2 = setTimeout(function() {\\n        _this._tick();\\n      }, delay);\\n    },\\n\\n    /**\\n     * Aborts cursor animation and clears all timeouts\\n     */\\n    abortCursorAnimation: function() {\\n      var shouldClear = this._currentTickState || this._currentTickCompleteState;\\n      this._currentTickState && this._currentTickState.abort();\\n      this._currentTickCompleteState && this._currentTickCompleteState.abort();\\n\\n      clearTimeout(this._cursorTimeout1);\\n      clearTimeout(this._cursorTimeout2);\\n\\n      this._currentCursorOpacity = 0;\\n      // to clear just itext area we need to transform the context\\n      // it may not be worth it\\n      if (shouldClear) {\\n        this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx);\\n      }\\n\\n    },\\n\\n    /**\\n     * Selects entire text\\n     */\\n    selectAll: function() {\\n      this.selectionStart = 0;\\n      this.selectionEnd = this.text.length;\\n      this._fireSelectionChanged();\\n      this._updateTextarea();\\n    },\\n\\n    /**\\n     * Returns selected text\\n     * @return {String}\\n     */\\n    getSelectedText: function() {\\n      return this.text.slice(this.selectionStart, this.selectionEnd);\\n    },\\n\\n    /**\\n     * Find new selection index representing start of current word according to current selection index\\n     * @param {Number} startFrom Surrent selection index\\n     * @return {Number} New selection index\\n     */\\n    findWordBoundaryLeft: function(startFrom) {\\n      var offset = 0, index = startFrom - 1;\\n\\n      // remove space before cursor first\\n      if (this._reSpace.test(this.text.charAt(index))) {\\n        while (this._reSpace.test(this.text.charAt(index))) {\\n          offset++;\\n          index--;\\n        }\\n      }\\n      while (/\\\\S/.test(this.text.charAt(index)) && index > -1) {\\n        offset++;\\n        index--;\\n      }\\n\\n      return startFrom - offset;\\n    },\\n\\n    /**\\n     * Find new selection index representing end of current word according to current selection index\\n     * @param {Number} startFrom Current selection index\\n     * @return {Number} New selection index\\n     */\\n    findWordBoundaryRight: function(startFrom) {\\n      var offset = 0, index = startFrom;\\n\\n      // remove space after cursor first\\n      if (this._reSpace.test(this.text.charAt(index))) {\\n        while (this._reSpace.test(this.text.charAt(index))) {\\n          offset++;\\n          index++;\\n        }\\n      }\\n      while (/\\\\S/.test(this.text.charAt(index)) && index < this.text.length) {\\n        offset++;\\n        index++;\\n      }\\n\\n      return startFrom + offset;\\n    },\\n\\n    /**\\n     * Find new selection index representing start of current line according to current selection index\\n     * @param {Number} startFrom Current selection index\\n     * @return {Number} New selection index\\n     */\\n    findLineBoundaryLeft: function(startFrom) {\\n      var offset = 0, index = startFrom - 1;\\n\\n      while (!/\\\\n/.test(this.text.charAt(index)) && index > -1) {\\n        offset++;\\n        index--;\\n      }\\n\\n      return startFrom - offset;\\n    },\\n\\n    /**\\n     * Find new selection index representing end of current line according to current selection index\\n     * @param {Number} startFrom Current selection index\\n     * @return {Number} New selection index\\n     */\\n    findLineBoundaryRight: function(startFrom) {\\n      var offset = 0, index = startFrom;\\n\\n      while (!/\\\\n/.test(this.text.charAt(index)) && index < this.text.length) {\\n        offset++;\\n        index++;\\n      }\\n\\n      return startFrom + offset;\\n    },\\n\\n    /**\\n     * Returns number of newlines in selected text\\n     * @return {Number} Number of newlines in selected text\\n     */\\n    getNumNewLinesInSelectedText: function() {\\n      var selectedText = this.getSelectedText(),\\n          numNewLines  = 0;\\n\\n      for (var i = 0, len = selectedText.length; i < len; i++) {\\n        if (selectedText[i] === '\\\\n') {\\n          numNewLines++;\\n        }\\n      }\\n      return numNewLines;\\n    },\\n\\n    /**\\n     * Finds index corresponding to beginning or end of a word\\n     * @param {Number} selectionStart Index of a character\\n     * @param {Number} direction 1 or -1\\n     * @return {Number} Index of the beginning or end of a word\\n     */\\n    searchWordBoundary: function(selectionStart, direction) {\\n      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,\\n          _char     = this.text.charAt(index),\\n          reNonWord = /[ \\\\n\\\\.,;!\\\\?\\\\-]/;\\n\\n      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {\\n        index += direction;\\n        _char = this.text.charAt(index);\\n      }\\n      if (reNonWord.test(_char) && _char !== '\\\\n') {\\n        index += direction === 1 ? 0 : 1;\\n      }\\n      return index;\\n    },\\n\\n    /**\\n     * Selects a word based on the index\\n     * @param {Number} selectionStart Index of a character\\n     */\\n    selectWord: function(selectionStart) {\\n      selectionStart = selectionStart || this.selectionStart;\\n      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */\\n          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */\\n\\n      this.selectionStart = newSelectionStart;\\n      this.selectionEnd = newSelectionEnd;\\n      this._fireSelectionChanged();\\n      this._updateTextarea();\\n      this.renderCursorOrSelection();\\n    },\\n\\n    /**\\n     * Selects a line based on the index\\n     * @param {Number} selectionStart Index of a character\\n     */\\n    selectLine: function(selectionStart) {\\n      selectionStart = selectionStart || this.selectionStart;\\n      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),\\n          newSelectionEnd = this.findLineBoundaryRight(selectionStart);\\n\\n      this.selectionStart = newSelectionStart;\\n      this.selectionEnd = newSelectionEnd;\\n      this._fireSelectionChanged();\\n      this._updateTextarea();\\n    },\\n\\n    /**\\n     * Enters editing state\\n     * @return {fabric.IText} thisArg\\n     * @chainable\\n     */\\n    enterEditing: function(e) {\\n      if (this.isEditing || !this.editable) {\\n        return;\\n      }\\n\\n      if (this.canvas) {\\n        this.exitEditingOnOthers(this.canvas);\\n      }\\n\\n      this.isEditing = true;\\n\\n      this.initHiddenTextarea(e);\\n      this.hiddenTextarea.focus();\\n      this._updateTextarea();\\n      this._saveEditingProps();\\n      this._setEditingProps();\\n      this._textBeforeEdit = this.text;\\n\\n      this._tick();\\n      this.fire('editing:entered');\\n\\n      if (!this.canvas) {\\n        return this;\\n      }\\n      this.canvas.fire('text:editing:entered', { target: this });\\n      this.initMouseMoveHandler();\\n      this.canvas.renderAll();\\n      return this;\\n    },\\n\\n    exitEditingOnOthers: function(canvas) {\\n      if (canvas._iTextInstances) {\\n        canvas._iTextInstances.forEach(function(obj) {\\n          obj.selected = false;\\n          if (obj.isEditing) {\\n            obj.exitEditing();\\n          }\\n        });\\n      }\\n    },\\n\\n    /**\\n     * Initializes \\\"mousemove\\\" event handler\\n     */\\n    initMouseMoveHandler: function() {\\n      this.canvas.on('mouse:move', this.mouseMoveHandler);\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    mouseMoveHandler: function(options) {\\n      if (!this.__isMousedown || !this.isEditing) {\\n        return;\\n      }\\n\\n      var newSelectionStart = this.getSelectionStartFromPointer(options.e),\\n          currentStart = this.selectionStart,\\n          currentEnd = this.selectionEnd;\\n      if (newSelectionStart === this.__selectionStartOnMouseDown) {\\n        return;\\n      }\\n      if (newSelectionStart > this.__selectionStartOnMouseDown) {\\n        this.selectionStart = this.__selectionStartOnMouseDown;\\n        this.selectionEnd = newSelectionStart;\\n      }\\n      else {\\n        this.selectionStart = newSelectionStart;\\n        this.selectionEnd = this.__selectionStartOnMouseDown;\\n      }\\n      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {\\n        this._fireSelectionChanged();\\n        this._updateTextarea();\\n        this.renderCursorOrSelection();\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setEditingProps: function() {\\n      this.hoverCursor = 'text';\\n\\n      if (this.canvas) {\\n        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';\\n      }\\n\\n      this.borderColor = this.editingBorderColor;\\n\\n      this.hasControls = this.selectable = false;\\n      this.lockMovementX = this.lockMovementY = true;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _updateTextarea: function() {\\n      if (!this.hiddenTextarea || this.inCompositionMode) {\\n        return;\\n      }\\n      this.cursorOffsetCache = { };\\n      this.hiddenTextarea.value = this.text;\\n      this.hiddenTextarea.selectionStart = this.selectionStart;\\n      this.hiddenTextarea.selectionEnd = this.selectionEnd;\\n      if (this.selectionStart === this.selectionEnd) {\\n        var style = this._calcTextareaPosition();\\n        this.hiddenTextarea.style.left = style.left;\\n        this.hiddenTextarea.style.top = style.top;\\n        this.hiddenTextarea.style.fontSize = style.fontSize;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     * @return {Object} style contains style for hiddenTextarea\\n     */\\n    _calcTextareaPosition: function() {\\n      if (!this.canvas) {\\n        return { x: 1, y: 1 };\\n      }\\n      var chars = this.text.split(''),\\n          boundaries = this._getCursorBoundaries(chars, 'cursor'),\\n          cursorLocation = this.get2DCursorLocation(),\\n          lineIndex = cursorLocation.lineIndex,\\n          charIndex = cursorLocation.charIndex,\\n          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),\\n          leftOffset = (lineIndex === 0 && charIndex === 0)\\n                    ? this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex))\\n                    : boundaries.leftOffset,\\n          m = this.calcTransformMatrix(),\\n          p = {\\n            x: boundaries.left + leftOffset,\\n            y: boundaries.top + boundaries.topOffset + charHeight\\n          },\\n          upperCanvas = this.canvas.upperCanvasEl,\\n          maxWidth = upperCanvas.width - charHeight,\\n          maxHeight = upperCanvas.height - charHeight;\\n\\n      p = fabric.util.transformPoint(p, m);\\n      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);\\n\\n      if (p.x < 0) {\\n        p.x = 0;\\n      }\\n      if (p.x > maxWidth) {\\n        p.x = maxWidth;\\n      }\\n      if (p.y < 0) {\\n        p.y = 0;\\n      }\\n      if (p.y > maxHeight) {\\n        p.y = maxHeight;\\n      }\\n\\n      // add canvas offset on document\\n      p.x += this.canvas._offset.left;\\n      p.y += this.canvas._offset.top;\\n\\n      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _saveEditingProps: function() {\\n      this._savedProps = {\\n        hasControls: this.hasControls,\\n        borderColor: this.borderColor,\\n        lockMovementX: this.lockMovementX,\\n        lockMovementY: this.lockMovementY,\\n        hoverCursor: this.hoverCursor,\\n        defaultCursor: this.canvas && this.canvas.defaultCursor,\\n        moveCursor: this.canvas && this.canvas.moveCursor\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _restoreEditingProps: function() {\\n      if (!this._savedProps) {\\n        return;\\n      }\\n\\n      this.hoverCursor = this._savedProps.overCursor;\\n      this.hasControls = this._savedProps.hasControls;\\n      this.borderColor = this._savedProps.borderColor;\\n      this.lockMovementX = this._savedProps.lockMovementX;\\n      this.lockMovementY = this._savedProps.lockMovementY;\\n\\n      if (this.canvas) {\\n        this.canvas.defaultCursor = this._savedProps.defaultCursor;\\n        this.canvas.moveCursor = this._savedProps.moveCursor;\\n      }\\n    },\\n\\n    /**\\n     * Exits from editing state\\n     * @return {fabric.IText} thisArg\\n     * @chainable\\n     */\\n    exitEditing: function() {\\n      var isTextChanged = (this._textBeforeEdit !== this.text);\\n      this.selected = false;\\n      this.isEditing = false;\\n      this.selectable = true;\\n\\n      this.selectionEnd = this.selectionStart;\\n      this.hiddenTextarea.blur && this.hiddenTextarea.blur();\\n      this.hiddenTextarea && this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);\\n      this.hiddenTextarea = null;\\n\\n      this.abortCursorAnimation();\\n      this._restoreEditingProps();\\n      this._currentCursorOpacity = 0;\\n\\n      this.fire('editing:exited');\\n      isTextChanged && this.fire('modified');\\n      if (this.canvas) {\\n        this.canvas.off('mouse:move', this.mouseMoveHandler);\\n        this.canvas.fire('text:editing:exited', { target: this });\\n        isTextChanged && this.canvas.fire('object:modified', { target: this });\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _removeExtraneousStyles: function() {\\n      for (var prop in this.styles) {\\n        if (!this._textLines[prop]) {\\n          delete this.styles[prop];\\n        }\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _removeCharsFromTo: function(start, end) {\\n      while (end !== start) {\\n        this._removeSingleCharAndStyle(start + 1);\\n        end--;\\n      }\\n      this.selectionStart = start;\\n      this.selectionEnd = start;\\n    },\\n\\n    _removeSingleCharAndStyle: function(index) {\\n      var isBeginningOfLine = this.text[index - 1] === '\\\\n',\\n          indexStyle        = isBeginningOfLine ? index : index - 1;\\n      this.removeStyleObject(isBeginningOfLine, indexStyle);\\n      this.text = this.text.slice(0, index - 1) +\\n        this.text.slice(index);\\n\\n      this._textLines = this._splitTextIntoLines();\\n    },\\n\\n    /**\\n     * Inserts characters where cursor is (replacing selection if one exists)\\n     * @param {String} _chars Characters to insert\\n     * @param {Boolean} useCopiedStyle use fabric.copiedTextStyle\\n     */\\n    insertChars: function(_chars, useCopiedStyle) {\\n      var style;\\n\\n      if (this.selectionEnd - this.selectionStart > 1) {\\n        this._removeCharsFromTo(this.selectionStart, this.selectionEnd);\\n      }\\n      //short circuit for block paste\\n      if (!useCopiedStyle && this.isEmptyStyles()) {\\n        this.insertChar(_chars, false);\\n        return;\\n      }\\n      for (var i = 0, len = _chars.length; i < len; i++) {\\n        if (useCopiedStyle) {\\n          style = fabric.copiedTextStyle[i];\\n        }\\n        this.insertChar(_chars[i], i < len - 1, style);\\n      }\\n    },\\n\\n    /**\\n     * Inserts a character where cursor is\\n     * @param {String} _char Characters to insert\\n     * @param {Boolean} skipUpdate trigger rendering and updates at the end of text insert\\n     * @param {Object} styleObject Style to be inserted for the new char\\n     */\\n    insertChar: function(_char, skipUpdate, styleObject) {\\n      var isEndOfLine = this.text[this.selectionStart] === '\\\\n';\\n      this.text = this.text.slice(0, this.selectionStart) +\\n        _char + this.text.slice(this.selectionEnd);\\n      this._textLines = this._splitTextIntoLines();\\n      this.insertStyleObjects(_char, isEndOfLine, styleObject);\\n      this.selectionStart += _char.length;\\n      this.selectionEnd = this.selectionStart;\\n      if (skipUpdate) {\\n        return;\\n      }\\n      this._updateTextarea();\\n      this.setCoords();\\n      this._fireSelectionChanged();\\n      this.fire('changed');\\n      this.canvas && this.canvas.fire('text:changed', { target: this });\\n      this.canvas && this.canvas.renderAll();\\n    },\\n\\n    /**\\n     * Inserts new style object\\n     * @param {Number} lineIndex Index of a line\\n     * @param {Number} charIndex Index of a char\\n     * @param {Boolean} isEndOfLine True if it's end of line\\n     */\\n    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {\\n\\n      this.shiftLineStyles(lineIndex, +1);\\n\\n      if (!this.styles[lineIndex + 1]) {\\n        this.styles[lineIndex + 1] = {};\\n      }\\n\\n      var currentCharStyle = {},\\n          newLineStyles    = {};\\n\\n      if (this.styles[lineIndex] && this.styles[lineIndex][charIndex - 1]) {\\n        currentCharStyle = this.styles[lineIndex][charIndex - 1];\\n      }\\n\\n      // if there's nothing after cursor,\\n      // we clone current char style onto the next (otherwise empty) line\\n      if (isEndOfLine) {\\n        newLineStyles[0] = clone(currentCharStyle);\\n        this.styles[lineIndex + 1] = newLineStyles;\\n      }\\n      // otherwise we clone styles of all chars\\n      // after cursor onto the next line, from the beginning\\n      else {\\n        for (var index in this.styles[lineIndex]) {\\n          if (parseInt(index, 10) >= charIndex) {\\n            newLineStyles[parseInt(index, 10) - charIndex] = this.styles[lineIndex][index];\\n            // remove lines from the previous line since they're on a new line now\\n            delete this.styles[lineIndex][index];\\n          }\\n        }\\n        this.styles[lineIndex + 1] = newLineStyles;\\n      }\\n      this._forceClearCache = true;\\n    },\\n\\n    /**\\n     * Inserts style object for a given line/char index\\n     * @param {Number} lineIndex Index of a line\\n     * @param {Number} charIndex Index of a char\\n     * @param {Object} [style] Style object to insert, if given\\n     */\\n    insertCharStyleObject: function(lineIndex, charIndex, style) {\\n\\n      var currentLineStyles       = this.styles[lineIndex],\\n          currentLineStylesCloned = clone(currentLineStyles);\\n\\n      if (charIndex === 0 && !style) {\\n        charIndex = 1;\\n      }\\n\\n      // shift all char styles by 1 forward\\n      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\\n      for (var index in currentLineStylesCloned) {\\n        var numericIndex = parseInt(index, 10);\\n\\n        if (numericIndex >= charIndex) {\\n          currentLineStyles[numericIndex + 1] = currentLineStylesCloned[numericIndex];\\n\\n          // only delete the style if there was nothing moved there\\n          if (!currentLineStylesCloned[numericIndex - 1]) {\\n            delete currentLineStyles[numericIndex];\\n          }\\n        }\\n      }\\n\\n      this.styles[lineIndex][charIndex] =\\n        style || clone(currentLineStyles[charIndex - 1]);\\n      this._forceClearCache = true;\\n    },\\n\\n    /**\\n     * Inserts style object(s)\\n     * @param {String} _chars Characters at the location where style is inserted\\n     * @param {Boolean} isEndOfLine True if it's end of line\\n     * @param {Object} [styleObject] Style to insert\\n     */\\n    insertStyleObjects: function(_chars, isEndOfLine, styleObject) {\\n      // removed shortcircuit over isEmptyStyles\\n\\n      var cursorLocation = this.get2DCursorLocation(),\\n          lineIndex      = cursorLocation.lineIndex,\\n          charIndex      = cursorLocation.charIndex;\\n\\n      if (!this._getLineStyle(lineIndex)) {\\n        this._setLineStyle(lineIndex, {});\\n      }\\n\\n      if (_chars === '\\\\n') {\\n        this.insertNewlineStyleObject(lineIndex, charIndex, isEndOfLine);\\n      }\\n      else {\\n        this.insertCharStyleObject(lineIndex, charIndex, styleObject);\\n      }\\n    },\\n\\n    /**\\n     * Shifts line styles up or down\\n     * @param {Number} lineIndex Index of a line\\n     * @param {Number} offset Can be -1 or +1\\n     */\\n    shiftLineStyles: function(lineIndex, offset) {\\n      // shift all line styles by 1 upward\\n      var clonedStyles = clone(this.styles);\\n      for (var line in this.styles) {\\n        var numericLine = parseInt(line, 10);\\n        if (numericLine > lineIndex) {\\n          this.styles[numericLine + offset] = clonedStyles[numericLine];\\n          if (!clonedStyles[numericLine - offset]) {\\n            delete this.styles[numericLine];\\n          }\\n        }\\n      }\\n      //TODO: evaluate if delete old style lines with offset -1\\n    },\\n\\n    /**\\n     * Removes style object\\n     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line\\n     * @param {Number} [index] Optional index. When not given, current selectionStart is used.\\n     */\\n    removeStyleObject: function(isBeginningOfLine, index) {\\n\\n      var cursorLocation = this.get2DCursorLocation(index),\\n          lineIndex      = cursorLocation.lineIndex,\\n          charIndex      = cursorLocation.charIndex;\\n\\n      this._removeStyleObject(isBeginningOfLine, cursorLocation, lineIndex, charIndex);\\n    },\\n\\n    _getTextOnPreviousLine: function(lIndex) {\\n      return this._textLines[lIndex - 1];\\n    },\\n\\n    _removeStyleObject: function(isBeginningOfLine, cursorLocation, lineIndex, charIndex) {\\n\\n      if (isBeginningOfLine) {\\n        var textOnPreviousLine     = this._getTextOnPreviousLine(cursorLocation.lineIndex),\\n            newCharIndexOnPrevLine = textOnPreviousLine ? textOnPreviousLine.length : 0;\\n\\n        if (!this.styles[lineIndex - 1]) {\\n          this.styles[lineIndex - 1] = {};\\n        }\\n        for (charIndex in this.styles[lineIndex]) {\\n          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]\\n            = this.styles[lineIndex][charIndex];\\n        }\\n        this.shiftLineStyles(cursorLocation.lineIndex, -1);\\n      }\\n      else {\\n        var currentLineStyles = this.styles[lineIndex];\\n\\n        if (currentLineStyles) {\\n          delete currentLineStyles[charIndex];\\n        }\\n        var currentLineStylesCloned = clone(currentLineStyles);\\n        // shift all styles by 1 backwards\\n        for (var i in currentLineStylesCloned) {\\n          var numericIndex = parseInt(i, 10);\\n          if (numericIndex >= charIndex && numericIndex !== 0) {\\n            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];\\n            delete currentLineStyles[numericIndex];\\n          }\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Inserts new line\\n     */\\n    insertNewline: function() {\\n      this.insertChars('\\\\n');\\n    },\\n\\n    /**\\n     * Set the selectionStart and selectionEnd according to the ne postion of cursor\\n     * mimic the key - mouse navigation when shift is pressed.\\n     */\\n    setSelectionStartEndWithShift: function(start, end, newSelection) {\\n      if (newSelection <= start) {\\n        if (end === start) {\\n          this._selectionDirection = 'left';\\n        }\\n        else if (this._selectionDirection === 'right') {\\n          this._selectionDirection = 'left';\\n          this.selectionEnd = start;\\n        }\\n        this.selectionStart = newSelection;\\n      }\\n      else if (newSelection > start && newSelection < end) {\\n        if (this._selectionDirection === 'right') {\\n          this.selectionEnd = newSelection;\\n        }\\n        else {\\n          this.selectionStart = newSelection;\\n        }\\n      }\\n      else {\\n        // newSelection is > selection start and end\\n        if (end === start) {\\n          this._selectionDirection = 'right';\\n        }\\n        else if (this._selectionDirection === 'left') {\\n          this._selectionDirection = 'right';\\n          this.selectionStart = end;\\n        }\\n        this.selectionEnd = newSelection;\\n      }\\n    },\\n\\n    setSelectionInBoundaries: function() {\\n      var length = this.text.length;\\n      if (this.selectionStart > length) {\\n        this.selectionStart = length;\\n      }\\n      else if (this.selectionStart < 0) {\\n        this.selectionStart = 0;\\n      }\\n      if (this.selectionEnd > length) {\\n        this.selectionEnd = length;\\n      }\\n      else if (this.selectionEnd < 0) {\\n        this.selectionEnd = 0;\\n      }\\n    }\\n  });\\n})();\\n\\n\\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\\n  /**\\n   * Initializes \\\"dbclick\\\" event handler\\n   */\\n  initDoubleClickSimulation: function() {\\n\\n    // for double click\\n    this.__lastClickTime = +new Date();\\n\\n    // for triple click\\n    this.__lastLastClickTime = +new Date();\\n\\n    this.__lastPointer = { };\\n\\n    this.on('mousedown', this.onMouseDown.bind(this));\\n  },\\n\\n  onMouseDown: function(options) {\\n\\n    this.__newClickTime = +new Date();\\n    var newPointer = this.canvas.getPointer(options.e);\\n\\n    if (this.isTripleClick(newPointer)) {\\n      this.fire('tripleclick', options);\\n      this._stopEvent(options.e);\\n    }\\n    else if (this.isDoubleClick(newPointer)) {\\n      this.fire('dblclick', options);\\n      this._stopEvent(options.e);\\n    }\\n\\n    this.__lastLastClickTime = this.__lastClickTime;\\n    this.__lastClickTime = this.__newClickTime;\\n    this.__lastPointer = newPointer;\\n    this.__lastIsEditing = this.isEditing;\\n    this.__lastSelected = this.selected;\\n  },\\n\\n  isDoubleClick: function(newPointer) {\\n    return this.__newClickTime - this.__lastClickTime < 500 &&\\n        this.__lastPointer.x === newPointer.x &&\\n        this.__lastPointer.y === newPointer.y && this.__lastIsEditing;\\n  },\\n\\n  isTripleClick: function(newPointer) {\\n    return this.__newClickTime - this.__lastClickTime < 500 &&\\n        this.__lastClickTime - this.__lastLastClickTime < 500 &&\\n        this.__lastPointer.x === newPointer.x &&\\n        this.__lastPointer.y === newPointer.y;\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _stopEvent: function(e) {\\n    e.preventDefault && e.preventDefault();\\n    e.stopPropagation && e.stopPropagation();\\n  },\\n\\n  /**\\n   * Initializes event handlers related to cursor or selection\\n   */\\n  initCursorSelectionHandlers: function() {\\n    this.initSelectedHandler();\\n    this.initMousedownHandler();\\n    this.initMouseupHandler();\\n    this.initClicks();\\n  },\\n\\n  /**\\n   * Initializes double and triple click event handlers\\n   */\\n  initClicks: function() {\\n    this.on('dblclick', function(options) {\\n      this.selectWord(this.getSelectionStartFromPointer(options.e));\\n    });\\n    this.on('tripleclick', function(options) {\\n      this.selectLine(this.getSelectionStartFromPointer(options.e));\\n    });\\n  },\\n\\n  /**\\n   * Initializes \\\"mousedown\\\" event handler\\n   */\\n  initMousedownHandler: function() {\\n    this.on('mousedown', function(options) {\\n      if (!this.editable) {\\n        return;\\n      }\\n      var pointer = this.canvas.getPointer(options.e);\\n\\n      this.__mousedownX = pointer.x;\\n      this.__mousedownY = pointer.y;\\n      this.__isMousedown = true;\\n\\n      if (this.selected) {\\n        this.setCursorByClick(options.e);\\n      }\\n\\n      if (this.isEditing) {\\n        this.__selectionStartOnMouseDown = this.selectionStart;\\n        if (this.selectionStart === this.selectionEnd) {\\n          this.abortCursorAnimation();\\n        }\\n        this.renderCursorOrSelection();\\n      }\\n    });\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _isObjectMoved: function(e) {\\n    var pointer = this.canvas.getPointer(e);\\n\\n    return this.__mousedownX !== pointer.x ||\\n           this.__mousedownY !== pointer.y;\\n  },\\n\\n  /**\\n   * Initializes \\\"mouseup\\\" event handler\\n   */\\n  initMouseupHandler: function() {\\n    this.on('mouseup', function(options) {\\n      this.__isMousedown = false;\\n      if (!this.editable || this._isObjectMoved(options.e)) {\\n        return;\\n      }\\n\\n      if (this.__lastSelected && !this.__corner) {\\n        this.enterEditing(options.e);\\n        if (this.selectionStart === this.selectionEnd) {\\n          this.initDelayedCursor(true);\\n        }\\n        else {\\n          this.renderCursorOrSelection();\\n        }\\n      }\\n      this.selected = true;\\n    });\\n  },\\n\\n  /**\\n   * Changes cursor location in a text depending on passed pointer (x/y) object\\n   * @param {Event} e Event object\\n   */\\n  setCursorByClick: function(e) {\\n    var newSelection = this.getSelectionStartFromPointer(e),\\n        start = this.selectionStart, end = this.selectionEnd;\\n    if (e.shiftKey) {\\n      this.setSelectionStartEndWithShift(start, end, newSelection);\\n    }\\n    else {\\n      this.selectionStart = newSelection;\\n      this.selectionEnd = newSelection;\\n    }\\n    this._fireSelectionChanged();\\n    this._updateTextarea();\\n  },\\n\\n  /**\\n   * Returns index of a character corresponding to where an object was clicked\\n   * @param {Event} e Event object\\n   * @return {Number} Index of a character\\n   */\\n  getSelectionStartFromPointer: function(e) {\\n    var mouseOffset = this.getLocalPointer(e),\\n        prevWidth = 0,\\n        width = 0,\\n        height = 0,\\n        charIndex = 0,\\n        newSelectionStart,\\n        line;\\n\\n    for (var i = 0, len = this._textLines.length; i < len; i++) {\\n      line = this._textLines[i];\\n      height += this._getHeightOfLine(this.ctx, i) * this.scaleY;\\n\\n      var widthOfLine = this._getLineWidth(this.ctx, i),\\n          lineLeftOffset = this._getLineLeftOffset(widthOfLine);\\n\\n      width = lineLeftOffset * this.scaleX;\\n\\n      for (var j = 0, jlen = line.length; j < jlen; j++) {\\n\\n        prevWidth = width;\\n\\n        width += this._getWidthOfChar(this.ctx, line[j], i, this.flipX ? jlen - j : j) *\\n                 this.scaleX;\\n\\n        if (height <= mouseOffset.y || width <= mouseOffset.x) {\\n          charIndex++;\\n          continue;\\n        }\\n\\n        return this._getNewSelectionStartFromOffset(\\n          mouseOffset, prevWidth, width, charIndex + i, jlen);\\n      }\\n\\n      if (mouseOffset.y < height) {\\n        //this happens just on end of lines.\\n        return this._getNewSelectionStartFromOffset(\\n          mouseOffset, prevWidth, width, charIndex + i - 1, jlen);\\n      }\\n    }\\n\\n    // clicked somewhere after all chars, so set at the end\\n    if (typeof newSelectionStart === 'undefined') {\\n      return this.text.length;\\n    }\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\\n\\n    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,\\n        distanceBtwNextCharAndCursor = width - mouseOffset.x,\\n        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ? 0 : 1,\\n        newSelectionStart = index + offset;\\n\\n    // if object is horizontally flipped, mirror cursor location from the end\\n    if (this.flipX) {\\n      newSelectionStart = jlen - newSelectionStart;\\n    }\\n\\n    if (newSelectionStart > this.text.length) {\\n      newSelectionStart = this.text.length;\\n    }\\n\\n    return newSelectionStart;\\n  }\\n});\\n\\n\\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\\n\\n  /**\\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\\n   */\\n  initHiddenTextarea: function() {\\n    this.hiddenTextarea = fabric.document.createElement('textarea');\\n    this.hiddenTextarea.setAttribute('autocapitalize', 'off');\\n    var style = this._calcTextareaPosition();\\n    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top + '; left: ' + style.left + ';'\\n                                        + ' opacity: 0; width: 0px; height: 0px; z-index: -999;';\\n    fabric.document.body.appendChild(this.hiddenTextarea);\\n\\n    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'cut', this.cut.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));\\n    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));\\n\\n    if (!this._clickHandlerInitialized && this.canvas) {\\n      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));\\n      this._clickHandlerInitialized = true;\\n    }\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _keysMap: {\\n    8:  'removeChars',\\n    9:  'exitEditing',\\n    27: 'exitEditing',\\n    13: 'insertNewline',\\n    33: 'moveCursorUp',\\n    34: 'moveCursorDown',\\n    35: 'moveCursorRight',\\n    36: 'moveCursorLeft',\\n    37: 'moveCursorLeft',\\n    38: 'moveCursorUp',\\n    39: 'moveCursorRight',\\n    40: 'moveCursorDown',\\n    46: 'forwardDelete'\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _ctrlKeysMapUp: {\\n    67: 'copy',\\n    88: 'cut'\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _ctrlKeysMapDown: {\\n    65: 'selectAll'\\n  },\\n\\n  onClick: function() {\\n    // No need to trigger click event here, focus is enough to have the keyboard appear on Android\\n    this.hiddenTextarea && this.hiddenTextarea.focus();\\n  },\\n\\n  /**\\n   * Handles keyup event\\n   * @param {Event} e Event object\\n   */\\n  onKeyDown: function(e) {\\n    if (!this.isEditing) {\\n      return;\\n    }\\n    if (e.keyCode in this._keysMap) {\\n      this[this._keysMap[e.keyCode]](e);\\n    }\\n    else if ((e.keyCode in this._ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {\\n      this[this._ctrlKeysMapDown[e.keyCode]](e);\\n    }\\n    else {\\n      return;\\n    }\\n    e.stopImmediatePropagation();\\n    e.preventDefault();\\n    this.canvas && this.canvas.renderAll();\\n  },\\n\\n  /**\\n   * Handles keyup event\\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\\n   * if a copy/cut event fired, keyup is dismissed\\n   * @param {Event} e Event object\\n   */\\n  onKeyUp: function(e) {\\n    if (!this.isEditing || this._copyDone) {\\n      this._copyDone = false;\\n      return;\\n    }\\n    if ((e.keyCode in this._ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {\\n      this[this._ctrlKeysMapUp[e.keyCode]](e);\\n    }\\n    else {\\n      return;\\n    }\\n    e.stopImmediatePropagation();\\n    e.preventDefault();\\n    this.canvas && this.canvas.renderAll();\\n  },\\n\\n  /**\\n   * Handles onInput event\\n   * @param {Event} e Event object\\n   */\\n  onInput: function(e) {\\n    if (!this.isEditing || this.inCompositionMode) {\\n      return;\\n    }\\n    var offset = this.selectionStart || 0,\\n        offsetEnd = this.selectionEnd || 0,\\n        textLength = this.text.length,\\n        newTextLength = this.hiddenTextarea.value.length,\\n        diff, charsToInsert, start;\\n    if (newTextLength > textLength) {\\n      //we added some character\\n      start = this._selectionDirection === 'left' ? offsetEnd : offset;\\n      diff = newTextLength - textLength;\\n      charsToInsert = this.hiddenTextarea.value.slice(start, start + diff);\\n    }\\n    else {\\n      //we selected a portion of text and then input something else.\\n      //Internet explorer does not trigger this else\\n      diff = newTextLength - textLength + offsetEnd - offset;\\n      charsToInsert = this.hiddenTextarea.value.slice(offset, offset + diff);\\n    }\\n    this.insertChars(charsToInsert);\\n    e.stopPropagation();\\n  },\\n\\n  /**\\n   * Composition start\\n   */\\n  onCompositionStart: function() {\\n    this.inCompositionMode = true;\\n    this.prevCompositionLength = 0;\\n    this.compositionStart = this.selectionStart;\\n  },\\n\\n  /**\\n   * Composition end\\n   */\\n  onCompositionEnd: function() {\\n    this.inCompositionMode = false;\\n  },\\n\\n  /**\\n   * Composition update\\n   */\\n  onCompositionUpdate: function(e) {\\n    var data = e.data;\\n    this.selectionStart = this.compositionStart;\\n    this.selectionEnd = this.selectionEnd === this.selectionStart ?\\n      this.compositionStart + this.prevCompositionLength : this.selectionEnd;\\n    this.insertChars(data, false);\\n    this.prevCompositionLength = data.length;\\n  },\\n\\n  /**\\n   * Forward delete\\n   */\\n  forwardDelete: function(e) {\\n    if (this.selectionStart === this.selectionEnd) {\\n      if (this.selectionStart === this.text.length) {\\n        return;\\n      }\\n      this.moveCursorRight(e);\\n    }\\n    this.removeChars(e);\\n  },\\n\\n  /**\\n   * Copies selected text\\n   * @param {Event} e Event object\\n   */\\n  copy: function(e) {\\n    if (this.selectionStart === this.selectionEnd) {\\n      //do not cut-copy if no selection\\n      return;\\n    }\\n    var selectedText = this.getSelectedText(),\\n        clipboardData = this._getClipboardData(e);\\n\\n    // Check for backward compatibility with old browsers\\n    if (clipboardData) {\\n      clipboardData.setData('text', selectedText);\\n    }\\n\\n    fabric.copiedText = selectedText;\\n    fabric.copiedTextStyle = fabric.util.object.clone(\\n      this.getSelectionStyles(\\n        this.selectionStart,\\n        this.selectionEnd\\n      )\\n    );\\n    e.stopImmediatePropagation();\\n    e.preventDefault();\\n    this._copyDone = true;\\n  },\\n\\n  /**\\n   * Pastes text\\n   * @param {Event} e Event object\\n   */\\n  paste: function(e) {\\n    var copiedText = null,\\n        clipboardData = this._getClipboardData(e),\\n        useCopiedStyle = true;\\n\\n    // Check for backward compatibility with old browsers\\n    if (clipboardData) {\\n      copiedText = clipboardData.getData('text').replace(/\\\\r/g, '');\\n      if (!fabric.copiedTextStyle || fabric.copiedText !== copiedText) {\\n        useCopiedStyle = false;\\n      }\\n    }\\n    else {\\n      copiedText = fabric.copiedText;\\n    }\\n\\n    if (copiedText) {\\n      this.insertChars(copiedText, useCopiedStyle);\\n    }\\n    e.stopImmediatePropagation();\\n    e.preventDefault();\\n  },\\n\\n  /**\\n   * Cuts text\\n   * @param {Event} e Event object\\n   */\\n  cut: function(e) {\\n    if (this.selectionStart === this.selectionEnd) {\\n      return;\\n    }\\n\\n    this.copy(e);\\n    this.removeChars(e);\\n  },\\n\\n  /**\\n   * @private\\n   * @param {Event} e Event object\\n   * @return {Object} Clipboard data object\\n   */\\n  _getClipboardData: function(e) {\\n    return (e && e.clipboardData) || fabric.window.clipboardData;\\n  },\\n\\n  /**\\n   * Finds the width in pixels before the cursor on the same line\\n   * @private\\n   * @param {Number} lineIndex\\n   * @param {Number} charIndex\\n   * @return {Number} widthBeforeCursor width before cursor\\n   */\\n  _getWidthBeforeCursor: function(lineIndex, charIndex) {\\n    var textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex),\\n        widthOfLine = this._getLineWidth(this.ctx, lineIndex),\\n        widthBeforeCursor = this._getLineLeftOffset(widthOfLine), _char;\\n\\n    for (var i = 0, len = textBeforeCursor.length; i < len; i++) {\\n      _char = textBeforeCursor[i];\\n      widthBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);\\n    }\\n    return widthBeforeCursor;\\n  },\\n\\n  /**\\n   * Gets start offset of a selection\\n   * @param {Event} e Event object\\n   * @param {Boolean} isRight\\n   * @return {Number}\\n   */\\n  getDownCursorOffset: function(e, isRight) {\\n    var selectionProp = this._getSelectionForOffset(e, isRight),\\n        cursorLocation = this.get2DCursorLocation(selectionProp),\\n        lineIndex = cursorLocation.lineIndex;\\n    // if on last line, down cursor goes to end of line\\n    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\\n      // move to the end of a text\\n      return this.text.length - selectionProp;\\n    }\\n    var charIndex = cursorLocation.charIndex,\\n        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),\\n        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),\\n        textAfterCursor = this._textLines[lineIndex].slice(charIndex);\\n\\n    return textAfterCursor.length + indexOnOtherLine + 2;\\n  },\\n\\n  /**\\n   * private\\n   * Helps finding if the offset should be counted from Start or End\\n   * @param {Event} e Event object\\n   * @param {Boolean} isRight\\n   * @return {Number}\\n   */\\n  _getSelectionForOffset: function(e, isRight) {\\n    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {\\n      return this.selectionEnd;\\n    }\\n    else {\\n      return this.selectionStart;\\n    }\\n  },\\n\\n  /**\\n   * @param {Event} e Event object\\n   * @param {Boolean} isRight\\n   * @return {Number}\\n   */\\n  getUpCursorOffset: function(e, isRight) {\\n    var selectionProp = this._getSelectionForOffset(e, isRight),\\n        cursorLocation = this.get2DCursorLocation(selectionProp),\\n        lineIndex = cursorLocation.lineIndex;\\n    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\\n      // if on first line, up cursor goes to start of line\\n      return -selectionProp;\\n    }\\n    var charIndex = cursorLocation.charIndex,\\n        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),\\n        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),\\n        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);\\n    // return a negative offset\\n    return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;\\n  },\\n\\n  /**\\n   * find for a given width it founds the matching character.\\n   * @private\\n   */\\n  _getIndexOnLine: function(lineIndex, width) {\\n\\n    var widthOfLine = this._getLineWidth(this.ctx, lineIndex),\\n        textOnLine = this._textLines[lineIndex],\\n        lineLeftOffset = this._getLineLeftOffset(widthOfLine),\\n        widthOfCharsOnLine = lineLeftOffset,\\n        indexOnLine = 0,\\n        foundMatch;\\n\\n    for (var j = 0, jlen = textOnLine.length; j < jlen; j++) {\\n\\n      var _char = textOnLine[j],\\n          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);\\n\\n      widthOfCharsOnLine += widthOfChar;\\n\\n      if (widthOfCharsOnLine > width) {\\n\\n        foundMatch = true;\\n\\n        var leftEdge = widthOfCharsOnLine - widthOfChar,\\n            rightEdge = widthOfCharsOnLine,\\n            offsetFromLeftEdge = Math.abs(leftEdge - width),\\n            offsetFromRightEdge = Math.abs(rightEdge - width);\\n\\n        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);\\n\\n        break;\\n      }\\n    }\\n\\n    // reached end\\n    if (!foundMatch) {\\n      indexOnLine = textOnLine.length - 1;\\n    }\\n\\n    return indexOnLine;\\n  },\\n\\n\\n  /**\\n   * Moves cursor down\\n   * @param {Event} e Event object\\n   */\\n  moveCursorDown: function(e) {\\n    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {\\n      return;\\n    }\\n    this._moveCursorUpOrDown('Down', e);\\n  },\\n\\n  /**\\n   * Moves cursor up\\n   * @param {Event} e Event object\\n   */\\n  moveCursorUp: function(e) {\\n    if (this.selectionStart === 0 && this.selectionEnd === 0) {\\n      return;\\n    }\\n    this._moveCursorUpOrDown('Up', e);\\n  },\\n\\n  /**\\n   * Moves cursor up or down, fires the events\\n   * @param {String} direction 'Up' or 'Down'\\n   * @param {Event} e Event object\\n   */\\n  _moveCursorUpOrDown: function(direction, e) {\\n    // getUpCursorOffset\\n    // getDownCursorOffset\\n    var action = 'get' + direction + 'CursorOffset',\\n        offset = this[action](e, this._selectionDirection === 'right');\\n    if (e.shiftKey) {\\n      this.moveCursorWithShift(offset);\\n    }\\n    else {\\n      this.moveCursorWithoutShift(offset);\\n    }\\n    if (offset !== 0) {\\n      this.setSelectionInBoundaries();\\n      this.abortCursorAnimation();\\n      this._currentCursorOpacity = 1;\\n      this.initDelayedCursor();\\n      this._fireSelectionChanged();\\n      this._updateTextarea();\\n    }\\n  },\\n\\n  /**\\n   * Moves cursor with shift\\n   * @param {Number} offset\\n   */\\n  moveCursorWithShift: function(offset) {\\n    var newSelection = this._selectionDirection === 'left'\\n    ? this.selectionStart + offset\\n    : this.selectionEnd + offset;\\n    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);\\n    return offset !== 0;\\n  },\\n\\n  /**\\n   * Moves cursor up without shift\\n   * @param {Number} offset\\n   */\\n  moveCursorWithoutShift: function(offset) {\\n    if (offset < 0) {\\n      this.selectionStart += offset;\\n      this.selectionEnd = this.selectionStart;\\n    }\\n    else {\\n      this.selectionEnd += offset;\\n      this.selectionStart = this.selectionEnd;\\n    }\\n    return offset !== 0;\\n  },\\n\\n  /**\\n   * Moves cursor left\\n   * @param {Event} e Event object\\n   */\\n  moveCursorLeft: function(e) {\\n    if (this.selectionStart === 0 && this.selectionEnd === 0) {\\n      return;\\n    }\\n    this._moveCursorLeftOrRight('Left', e);\\n  },\\n\\n  /**\\n   * @private\\n   * @return {Boolean} true if a change happened\\n   */\\n  _move: function(e, prop, direction) {\\n    var newValue;\\n    if (e.altKey) {\\n      newValue = this['findWordBoundary' + direction](this[prop]);\\n    }\\n    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {\\n      newValue = this['findLineBoundary' + direction](this[prop]);\\n    }\\n    else {\\n      this[prop] += direction === 'Left' ? -1 : 1;\\n      return true;\\n    }\\n    if (typeof newValue !== undefined && this[prop] !== newValue) {\\n      this[prop] = newValue;\\n      return true;\\n    }\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _moveLeft: function(e, prop) {\\n    return this._move(e, prop, 'Left');\\n  },\\n\\n  /**\\n   * @private\\n   */\\n  _moveRight: function(e, prop) {\\n    return this._move(e, prop, 'Right');\\n  },\\n\\n  /**\\n   * Moves cursor left without keeping selection\\n   * @param {Event} e\\n   */\\n  moveCursorLeftWithoutShift: function(e) {\\n    var change = true;\\n    this._selectionDirection = 'left';\\n\\n    // only move cursor when there is no selection,\\n    // otherwise we discard it, and leave cursor on same place\\n    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {\\n      change = this._moveLeft(e, 'selectionStart');\\n\\n    }\\n    this.selectionEnd = this.selectionStart;\\n    return change;\\n  },\\n\\n  /**\\n   * Moves cursor left while keeping selection\\n   * @param {Event} e\\n   */\\n  moveCursorLeftWithShift: function(e) {\\n    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {\\n      return this._moveLeft(e, 'selectionEnd');\\n    }\\n    else if (this.selectionStart !== 0){\\n      this._selectionDirection = 'left';\\n      return this._moveLeft(e, 'selectionStart');\\n    }\\n  },\\n\\n  /**\\n   * Moves cursor right\\n   * @param {Event} e Event object\\n   */\\n  moveCursorRight: function(e) {\\n    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {\\n      return;\\n    }\\n    this._moveCursorLeftOrRight('Right', e);\\n  },\\n\\n  /**\\n   * Moves cursor right or Left, fires event\\n   * @param {String} direction 'Left', 'Right'\\n   * @param {Event} e Event object\\n   */\\n  _moveCursorLeftOrRight: function(direction, e) {\\n    var actionName = 'moveCursor' + direction + 'With';\\n    this._currentCursorOpacity = 1;\\n\\n    if (e.shiftKey) {\\n      actionName += 'Shift';\\n    }\\n    else {\\n      actionName += 'outShift';\\n    }\\n    if (this[actionName](e)) {\\n      this.abortCursorAnimation();\\n      this.initDelayedCursor();\\n      this._fireSelectionChanged();\\n      this._updateTextarea();\\n    }\\n  },\\n\\n  /**\\n   * Moves cursor right while keeping selection\\n   * @param {Event} e\\n   */\\n  moveCursorRightWithShift: function(e) {\\n    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {\\n      return this._moveRight(e, 'selectionStart');\\n    }\\n    else if (this.selectionEnd !== this.text.length) {\\n      this._selectionDirection = 'right';\\n      return this._moveRight(e, 'selectionEnd');\\n    }\\n  },\\n\\n  /**\\n   * Moves cursor right without keeping selection\\n   * @param {Event} e Event object\\n   */\\n  moveCursorRightWithoutShift: function(e) {\\n    var changed = true;\\n    this._selectionDirection = 'right';\\n\\n    if (this.selectionStart === this.selectionEnd) {\\n      changed = this._moveRight(e, 'selectionStart');\\n      this.selectionEnd = this.selectionStart;\\n    }\\n    else {\\n      this.selectionStart = this.selectionEnd;\\n    }\\n    return changed;\\n  },\\n\\n  /**\\n   * Removes characters selected by selection\\n   * @param {Event} e Event object\\n   */\\n  removeChars: function(e) {\\n    if (this.selectionStart === this.selectionEnd) {\\n      this._removeCharsNearCursor(e);\\n    }\\n    else {\\n      this._removeCharsFromTo(this.selectionStart, this.selectionEnd);\\n    }\\n\\n    this.setSelectionEnd(this.selectionStart);\\n\\n    this._removeExtraneousStyles();\\n\\n    this.canvas && this.canvas.renderAll();\\n\\n    this.setCoords();\\n    this.fire('changed');\\n    this.canvas && this.canvas.fire('text:changed', { target: this });\\n  },\\n\\n  /**\\n   * @private\\n   * @param {Event} e Event object\\n   */\\n  _removeCharsNearCursor: function(e) {\\n    if (this.selectionStart === 0) {\\n      return;\\n    }\\n    if (e.metaKey) {\\n      // remove all till the start of current line\\n      var leftLineBoundary = this.findLineBoundaryLeft(this.selectionStart);\\n\\n      this._removeCharsFromTo(leftLineBoundary, this.selectionStart);\\n      this.setSelectionStart(leftLineBoundary);\\n    }\\n    else if (e.altKey) {\\n      // remove all till the start of current word\\n      var leftWordBoundary = this.findWordBoundaryLeft(this.selectionStart);\\n\\n      this._removeCharsFromTo(leftWordBoundary, this.selectionStart);\\n      this.setSelectionStart(leftWordBoundary);\\n    }\\n    else {\\n      this._removeSingleCharAndStyle(this.selectionStart);\\n      this.setSelectionStart(this.selectionStart - 1);\\n    }\\n  }\\n});\\n\\n\\n/* _TO_SVG_START_ */\\n(function() {\\n  var toFixed = fabric.util.toFixed,\\n      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\\n\\n  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGTextLineText: function(lineIndex, textSpans, height, textLeftOffset, textTopOffset, textBgRects) {\\n      if (!this._getLineStyle(lineIndex)) {\\n        fabric.Text.prototype._setSVGTextLineText.call(this,\\n          lineIndex, textSpans, height, textLeftOffset, textTopOffset);\\n      }\\n      else {\\n        this._setSVGTextLineChars(\\n          lineIndex, textSpans, height, textLeftOffset, textBgRects);\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _setSVGTextLineChars: function(lineIndex, textSpans, height, textLeftOffset, textBgRects) {\\n\\n      var chars = this._textLines[lineIndex],\\n          charOffset = 0,\\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex)) - this.width / 2,\\n          lineOffset = this._getSVGLineTopOffset(lineIndex),\\n          heightOfLine = this._getHeightOfLine(this.ctx, lineIndex);\\n\\n      for (var i = 0, len = chars.length; i < len; i++) {\\n        var styleDecl = this._getStyleDeclaration(lineIndex, i) || { };\\n\\n        textSpans.push(\\n          this._createTextCharSpan(\\n            chars[i], styleDecl, lineLeftOffset, lineOffset.lineTop + lineOffset.offset, charOffset));\\n\\n        var charWidth = this._getWidthOfChar(this.ctx, chars[i], lineIndex, i);\\n\\n        if (styleDecl.textBackgroundColor) {\\n          textBgRects.push(\\n            this._createTextCharBg(\\n              styleDecl, lineLeftOffset, lineOffset.lineTop, heightOfLine, charWidth, charOffset));\\n        }\\n\\n        charOffset += charWidth;\\n      }\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _getSVGLineTopOffset: function(lineIndex) {\\n      var lineTopOffset = 0, lastHeight = 0;\\n      for (var j = 0; j < lineIndex; j++) {\\n        lineTopOffset += this._getHeightOfLine(this.ctx, j);\\n      }\\n      lastHeight = this._getHeightOfLine(this.ctx, j);\\n      return {\\n        lineTop: lineTopOffset,\\n        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\\n      };\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _createTextCharBg: function(styleDecl, lineLeftOffset, lineTopOffset, heightOfLine, charWidth, charOffset) {\\n      return [\\n        '\\\\t\\\\t<rect fill=\\\"', styleDecl.textBackgroundColor,\\n        '\\\" x=\\\"', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS),\\n        '\\\" y=\\\"', toFixed(lineTopOffset - this.height / 2, NUM_FRACTION_DIGITS),\\n        '\\\" width=\\\"', toFixed(charWidth, NUM_FRACTION_DIGITS),\\n        '\\\" height=\\\"', toFixed(heightOfLine / this.lineHeight, NUM_FRACTION_DIGITS),\\n        '\\\"></rect>\\\\n'\\n      ].join('');\\n    },\\n\\n    /**\\n     * @private\\n     */\\n    _createTextCharSpan: function(_char, styleDecl, lineLeftOffset, lineTopOffset, charOffset) {\\n\\n      var fillStyles = this.getSvgStyles.call(fabric.util.object.extend({\\n        visible: true,\\n        fill: this.fill,\\n        stroke: this.stroke,\\n        type: 'text',\\n        getSvgFilter: fabric.Object.prototype.getSvgFilter\\n      }, styleDecl));\\n\\n      return [\\n        '\\\\t\\\\t\\\\t<tspan x=\\\"', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS), '\\\" y=\\\"',\\n        toFixed(lineTopOffset - this.height / 2, NUM_FRACTION_DIGITS), '\\\" ',\\n          (styleDecl.fontFamily ? 'font-family=\\\"' + styleDecl.fontFamily.replace(/\\\"/g, '\\\\'') + '\\\" ' : ''),\\n          (styleDecl.fontSize ? 'font-size=\\\"' + styleDecl.fontSize + '\\\" ' : ''),\\n          (styleDecl.fontStyle ? 'font-style=\\\"' + styleDecl.fontStyle + '\\\" ' : ''),\\n          (styleDecl.fontWeight ? 'font-weight=\\\"' + styleDecl.fontWeight + '\\\" ' : ''),\\n          (styleDecl.textDecoration ? 'text-decoration=\\\"' + styleDecl.textDecoration + '\\\" ' : ''),\\n        'style=\\\"', fillStyles, '\\\">',\\n        fabric.util.string.escapeXml(_char),\\n        '</tspan>\\\\n'\\n      ].join('');\\n    }\\n  });\\n})();\\n/* _TO_SVG_END_ */\\n\\n\\n(function(global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n      clone  = fabric.util.object.clone;\\n\\n  /**\\n   * Textbox class, based on IText, allows the user to resize the text rectangle\\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\\n   * user can only change width. Height is adjusted automatically based on the\\n   * wrapping of lines.\\n   * @class fabric.Textbox\\n   * @extends fabric.IText\\n   * @mixes fabric.Observable\\n   * @return {fabric.Textbox} thisArg\\n   * @see {@link fabric.Textbox#initialize} for constructor definition\\n   */\\n  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\\n\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'textbox',\\n\\n    /**\\n     * Minimum width of textbox, in pixels.\\n     * @type Number\\n     * @default\\n     */\\n    minWidth: 20,\\n\\n    /**\\n     * Minimum calculated width of a textbox, in pixels.\\n     * fixed to 2 so that an empty textbox cannot go to 0\\n     * and is still selectable without text.\\n     * @type Number\\n     * @default\\n     */\\n    dynamicMinWidth: 2,\\n\\n    /**\\n     * Cached array of text wrapping.\\n     * @type Array\\n     */\\n    __cachedLines: null,\\n\\n    /**\\n     * Override standard Object class values\\n     */\\n    lockScalingY: true,\\n\\n    /**\\n     * Override standard Object class values\\n     */\\n    lockScalingFlip: true,\\n\\n    /**\\n     * Override standard Object class values\\n     * Textbox needs this on false\\n     */\\n    noScaleCache: false,\\n\\n    /**\\n     * Constructor. Some scaling related property values are forced. Visibility\\n     * of controls is also fixed; only the rotation and width controls are\\n     * made available.\\n     * @param {String} text Text string\\n     * @param {Object} [options] Options object\\n     * @return {fabric.Textbox} thisArg\\n     */\\n    initialize: function(text, options) {\\n\\n      this.callSuper('initialize', text, options);\\n      this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());\\n      this.ctx = this.objectCaching ? this._cacheContext : fabric.util.createCanvasElement().getContext('2d');\\n      // add width to this list of props that effect line wrapping.\\n      this._dimensionAffectingProps.push('width');\\n    },\\n\\n    /**\\n     * Unlike superclass's version of this function, Textbox does not update\\n     * its width.\\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\\n     * @private\\n     * @override\\n     */\\n    _initDimensions: function(ctx) {\\n      if (this.__skipDimension) {\\n        return;\\n      }\\n\\n      if (!ctx) {\\n        ctx = fabric.util.createCanvasElement().getContext('2d');\\n        this._setTextStyles(ctx);\\n        this.clearContextTop();\\n      }\\n\\n      // clear dynamicMinWidth as it will be different after we re-wrap line\\n      this.dynamicMinWidth = 0;\\n\\n      // wrap lines\\n      this._textLines = this._splitTextIntoLines(ctx);\\n      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\\n      if (this.dynamicMinWidth > this.width) {\\n        this._set('width', this.dynamicMinWidth);\\n      }\\n\\n      // clear cache and re-calculate height\\n      this._clearCache();\\n      this.height = this._getTextHeight(ctx);\\n    },\\n\\n    /**\\n     * Generate an object that translates the style object so that it is\\n     * broken up by visual lines (new lines and automatic wrapping).\\n     * The original text styles object is broken up by actual lines (new lines only),\\n     * which is only sufficient for Text / IText\\n     * @private\\n     */\\n    _generateStyleMap: function() {\\n      var realLineCount     = 0,\\n          realLineCharCount = 0,\\n          charCount         = 0,\\n          map               = {};\\n\\n      for (var i = 0; i < this._textLines.length; i++) {\\n        if (this.text[charCount] === '\\\\n' && i > 0) {\\n          realLineCharCount = 0;\\n          charCount++;\\n          realLineCount++;\\n        }\\n        else if (this.text[charCount] === ' ' && i > 0) {\\n          // this case deals with space's that are removed from end of lines when wrapping\\n          realLineCharCount++;\\n          charCount++;\\n        }\\n\\n        map[i] = { line: realLineCount, offset: realLineCharCount };\\n\\n        charCount += this._textLines[i].length;\\n        realLineCharCount += this._textLines[i].length;\\n      }\\n\\n      return map;\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     * @param {Boolean} [returnCloneOrEmpty=false]\\n     * @private\\n     */\\n    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {\\n      if (this._styleMap) {\\n        var map = this._styleMap[lineIndex];\\n        if (!map) {\\n          return returnCloneOrEmpty ? { } : null;\\n        }\\n        lineIndex = map.line;\\n        charIndex = map.offset + charIndex;\\n      }\\n      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex, returnCloneOrEmpty);\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     * @param {Object} style\\n     * @private\\n     */\\n    _setStyleDeclaration: function(lineIndex, charIndex, style) {\\n      var map = this._styleMap[lineIndex];\\n      lineIndex = map.line;\\n      charIndex = map.offset + charIndex;\\n\\n      this.styles[lineIndex][charIndex] = style;\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @param {Number} charIndex\\n     * @private\\n     */\\n    _deleteStyleDeclaration: function(lineIndex, charIndex) {\\n      var map = this._styleMap[lineIndex];\\n      lineIndex = map.line;\\n      charIndex = map.offset + charIndex;\\n\\n      delete this.styles[lineIndex][charIndex];\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @private\\n     */\\n    _getLineStyle: function(lineIndex) {\\n      var map = this._styleMap[lineIndex];\\n      return this.styles[map.line];\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @param {Object} style\\n     * @private\\n     */\\n    _setLineStyle: function(lineIndex, style) {\\n      var map = this._styleMap[lineIndex];\\n      this.styles[map.line] = style;\\n    },\\n\\n    /**\\n     * @param {Number} lineIndex\\n     * @private\\n     */\\n    _deleteLineStyle: function(lineIndex) {\\n      var map = this._styleMap[lineIndex];\\n      delete this.styles[map.line];\\n    },\\n\\n    /**\\n     * Wraps text using the 'width' property of Textbox. First this function\\n     * splits text on newlines, so we preserve newlines entered by the user.\\n     * Then it wraps each line using the width of the Textbox by calling\\n     * _wrapLine().\\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\\n     * @param {String} text The string of text that is split into lines\\n     * @returns {Array} Array of lines\\n     */\\n    _wrapText: function(ctx, text) {\\n      var lines = text.split(this._reNewline), wrapped = [], i;\\n\\n      for (i = 0; i < lines.length; i++) {\\n        wrapped = wrapped.concat(this._wrapLine(ctx, lines[i], i));\\n      }\\n\\n      return wrapped;\\n    },\\n\\n    /**\\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\\n     *\\n     * @param {CanvasRenderingContext2D} ctx\\n     * @param {String} text\\n     * @param {number} lineIndex\\n     * @param {number} charOffset\\n     * @returns {number}\\n     * @private\\n     */\\n    _measureText: function(ctx, text, lineIndex, charOffset) {\\n      var width = 0;\\n      charOffset = charOffset || 0;\\n      for (var i = 0, len = text.length; i < len; i++) {\\n        width += this._getWidthOfChar(ctx, text[i], lineIndex, i + charOffset);\\n      }\\n      return width;\\n    },\\n\\n    /**\\n     * Wraps a line of text using the width of the Textbox and a context.\\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\\n     * @param {String} text The string of text to split into lines\\n     * @param {Number} lineIndex\\n     * @returns {Array} Array of line(s) into which the given text is wrapped\\n     * to.\\n     */\\n    _wrapLine: function(ctx, text, lineIndex) {\\n      var lineWidth        = 0,\\n          lines            = [],\\n          line             = '',\\n          words            = text.split(' '),\\n          word             = '',\\n          offset           = 0,\\n          infix            = ' ',\\n          wordWidth        = 0,\\n          infixWidth       = 0,\\n          largestWordWidth = 0,\\n          lineJustStarted = true,\\n          additionalSpace = this._getWidthOfCharSpacing();\\n\\n      for (var i = 0; i < words.length; i++) {\\n        word = words[i];\\n        wordWidth = this._measureText(ctx, word, lineIndex, offset);\\n\\n        offset += word.length;\\n\\n        lineWidth += infixWidth + wordWidth - additionalSpace;\\n\\n        if (lineWidth >= this.width && !lineJustStarted) {\\n          lines.push(line);\\n          line = '';\\n          lineWidth = wordWidth;\\n          lineJustStarted = true;\\n        }\\n        else {\\n          lineWidth += additionalSpace;\\n        }\\n\\n        if (!lineJustStarted) {\\n          line += infix;\\n        }\\n        line += word;\\n\\n        infixWidth = this._measureText(ctx, infix, lineIndex, offset);\\n        offset++;\\n        lineJustStarted = false;\\n        // keep track of largest word\\n        if (wordWidth > largestWordWidth) {\\n          largestWordWidth = wordWidth;\\n        }\\n      }\\n\\n      i && lines.push(line);\\n\\n      if (largestWordWidth > this.dynamicMinWidth) {\\n        this.dynamicMinWidth = largestWordWidth - additionalSpace;\\n      }\\n\\n      return lines;\\n    },\\n    /**\\n     * Gets lines of text to render in the Textbox. This function calculates\\n     * text wrapping on the fly everytime it is called.\\n     * @returns {Array} Array of lines in the Textbox.\\n     * @override\\n     */\\n    _splitTextIntoLines: function(ctx) {\\n      ctx = ctx || this.ctx;\\n      var originalAlign = this.textAlign;\\n      ctx.save();\\n      this._setTextStyles(ctx);\\n      this.textAlign = 'left';\\n      var lines = this._wrapText(ctx, this.text);\\n      this.textAlign = originalAlign;\\n      ctx.restore();\\n      this._textLines = lines;\\n      this._styleMap = this._generateStyleMap();\\n      return lines;\\n    },\\n\\n    /**\\n     * When part of a group, we don't want the Textbox's scale to increase if\\n     * the group's increases. That's why we reduce the scale of the Textbox by\\n     * the amount that the group's increases. This is to maintain the effective\\n     * scale of the Textbox at 1, so that font-size values make sense. Otherwise\\n     * the same font-size value would result in different actual size depending\\n     * on the value of the scale.\\n     * @param {String} key\\n     * @param {*} value\\n     */\\n    setOnGroup: function(key, value) {\\n      if (key === 'scaleX') {\\n        this.set('scaleX', Math.abs(1 / value));\\n        this.set('width', (this.get('width') * value) /\\n          (typeof this.__oldScaleX === 'undefined' ? 1 : this.__oldScaleX));\\n        this.__oldScaleX = value;\\n      }\\n    },\\n\\n    /**\\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start).\\n     * Overrides the superclass function to take into account text wrapping.\\n     *\\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\\n     */\\n    get2DCursorLocation: function(selectionStart) {\\n      if (typeof selectionStart === 'undefined') {\\n        selectionStart = this.selectionStart;\\n      }\\n\\n      var numLines = this._textLines.length,\\n          removed  = 0;\\n\\n      for (var i = 0; i < numLines; i++) {\\n        var line    = this._textLines[i],\\n            lineLen = line.length;\\n\\n        if (selectionStart <= removed + lineLen) {\\n          return {\\n            lineIndex: i,\\n            charIndex: selectionStart - removed\\n          };\\n        }\\n\\n        removed += lineLen;\\n\\n        if (this.text[removed] === '\\\\n' || this.text[removed] === ' ') {\\n          removed++;\\n        }\\n      }\\n\\n      return {\\n        lineIndex: numLines - 1,\\n        charIndex: this._textLines[numLines - 1].length\\n      };\\n    },\\n\\n    /**\\n     * Overrides superclass function and uses text wrapping data to get cursor\\n     * boundary offsets instead of the array of chars.\\n     * @param {Array} chars Unused\\n     * @param {String} typeOfBoundaries Can be 'cursor' or 'selection'\\n     * @returns {Object} Object with 'top', 'left', and 'lineLeft' properties set.\\n     */\\n    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {\\n      var topOffset      = 0,\\n          leftOffset     = 0,\\n          cursorLocation = this.get2DCursorLocation(),\\n          lineChars      = this._textLines[cursorLocation.lineIndex].split(''),\\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, cursorLocation.lineIndex));\\n\\n      for (var i = 0; i < cursorLocation.charIndex; i++) {\\n        leftOffset += this._getWidthOfChar(this.ctx, lineChars[i], cursorLocation.lineIndex, i);\\n      }\\n\\n      for (i = 0; i < cursorLocation.lineIndex; i++) {\\n        topOffset += this._getHeightOfLine(this.ctx, i);\\n      }\\n\\n      if (typeOfBoundaries === 'cursor') {\\n        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, cursorLocation.lineIndex)\\n          / this.lineHeight - this.getCurrentCharFontSize(cursorLocation.lineIndex, cursorLocation.charIndex)\\n          * (1 - this._fontSizeFraction);\\n      }\\n\\n      return {\\n        top: topOffset,\\n        left: leftOffset,\\n        lineLeft: lineLeftOffset\\n      };\\n    },\\n\\n    getMinWidth: function() {\\n      return Math.max(this.minWidth, this.dynamicMinWidth);\\n    },\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @method toObject\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} object representation of an instance\\n     */\\n    toObject: function(propertiesToInclude) {\\n      return this.callSuper('toObject', ['minWidth'].concat(propertiesToInclude));\\n    }\\n  });\\n  /**\\n   * Returns fabric.Textbox instance from an object representation\\n   * @static\\n   * @memberOf fabric.Textbox\\n   * @param {Object} object Object to create an instance from\\n   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created\\n   * @return {fabric.Textbox} instance of fabric.Textbox\\n   */\\n  fabric.Textbox.fromObject = function(object, callback) {\\n    var textbox = new fabric.Textbox(object.text, clone(object));\\n    callback && callback(textbox);\\n    return textbox;\\n  };\\n  /**\\n   * Returns the default controls visibility required for Textboxes.\\n   * @returns {Object}\\n   */\\n  fabric.Textbox.getTextboxControlVisibility = function() {\\n    return {\\n      tl: false,\\n      tr: false,\\n      br: false,\\n      bl: false,\\n      ml: true,\\n      mt: false,\\n      mr: true,\\n      mb: false,\\n      mtr: true\\n    };\\n  };\\n\\n})(typeof exports !== 'undefined' ? exports : this);\\n\\n\\n(function() {\\n\\n  /**\\n   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing\\n   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.\\n   */\\n  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;\\n\\n  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,\\n                                                     lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {\\n\\n    var t = transform.target;\\n    if (t instanceof fabric.Textbox) {\\n      var w = t.width * ((localMouse.x / transform.scaleX) / (t.width + t.strokeWidth));\\n      if (w >= t.getMinWidth()) {\\n        t.set('width', w);\\n        return true;\\n      }\\n    }\\n    else {\\n      return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,\\n        lockScalingX, lockScalingY, by, lockScalingFlip, _dim);\\n    }\\n  };\\n\\n  /**\\n   * Sets controls of this group to the Textbox's special configuration if\\n   * one is present in the group. Deletes _controlsVisibility otherwise, so that\\n   * it gets initialized to default value at runtime.\\n   */\\n  fabric.Group.prototype._refreshControlsVisibility = function() {\\n    if (typeof fabric.Textbox === 'undefined') {\\n      return;\\n    }\\n    for (var i = this._objects.length; i--;) {\\n      if (this._objects[i] instanceof fabric.Textbox) {\\n        this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());\\n        return;\\n      }\\n    }\\n  };\\n\\n  var clone = fabric.util.object.clone;\\n\\n  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {\\n    /**\\n     * @private\\n     */\\n    _removeExtraneousStyles: function() {\\n      for (var prop in this._styleMap) {\\n        if (!this._textLines[prop]) {\\n          delete this.styles[this._styleMap[prop].line];\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Inserts style object for a given line/char index\\n     * @param {Number} lineIndex Index of a line\\n     * @param {Number} charIndex Index of a char\\n     * @param {Object} [style] Style object to insert, if given\\n     */\\n    insertCharStyleObject: function(lineIndex, charIndex, style) {\\n      // adjust lineIndex and charIndex\\n      var map = this._styleMap[lineIndex];\\n      lineIndex = map.line;\\n      charIndex = map.offset + charIndex;\\n\\n      fabric.IText.prototype.insertCharStyleObject.apply(this, [lineIndex, charIndex, style]);\\n    },\\n\\n    /**\\n     * Inserts new style object\\n     * @param {Number} lineIndex Index of a line\\n     * @param {Number} charIndex Index of a char\\n     * @param {Boolean} isEndOfLine True if it's end of line\\n     */\\n    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {\\n      // adjust lineIndex and charIndex\\n      var map = this._styleMap[lineIndex];\\n      lineIndex = map.line;\\n      charIndex = map.offset + charIndex;\\n\\n      fabric.IText.prototype.insertNewlineStyleObject.apply(this, [lineIndex, charIndex, isEndOfLine]);\\n    },\\n\\n    /**\\n     * Shifts line styles up or down. This function is slightly different than the one in\\n     * itext_behaviour as it takes into account the styleMap.\\n     *\\n     * @param {Number} lineIndex Index of a line\\n     * @param {Number} offset Can be -1 or +1\\n     */\\n    shiftLineStyles: function(lineIndex, offset) {\\n      // shift all line styles by 1 upward\\n      var clonedStyles = clone(this.styles),\\n          map          = this._styleMap[lineIndex];\\n\\n      // adjust line index\\n      lineIndex = map.line;\\n\\n      for (var line in this.styles) {\\n        var numericLine = parseInt(line, 10);\\n\\n        if (numericLine > lineIndex) {\\n          this.styles[numericLine + offset] = clonedStyles[numericLine];\\n\\n          if (!clonedStyles[numericLine - offset]) {\\n            delete this.styles[numericLine];\\n          }\\n        }\\n      }\\n      //TODO: evaluate if delete old style lines with offset -1\\n    },\\n\\n    /**\\n     * Figure out programatically the text on previous actual line (actual = separated by \\\\n);\\n     *\\n     * @param {Number} lIndex\\n     * @returns {String}\\n     * @private\\n     */\\n    _getTextOnPreviousLine: function(lIndex) {\\n      var textOnPreviousLine = this._textLines[lIndex - 1];\\n\\n      while (this._styleMap[lIndex - 2] && this._styleMap[lIndex - 2].line === this._styleMap[lIndex - 1].line) {\\n        textOnPreviousLine = this._textLines[lIndex - 2] + textOnPreviousLine;\\n\\n        lIndex--;\\n      }\\n\\n      return textOnPreviousLine;\\n    },\\n\\n    /**\\n     * Removes style object\\n     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line\\n     * @param {Number} [index] Optional index. When not given, current selectionStart is used.\\n     */\\n    removeStyleObject: function(isBeginningOfLine, index) {\\n\\n      var cursorLocation = this.get2DCursorLocation(index),\\n          map            = this._styleMap[cursorLocation.lineIndex],\\n          lineIndex      = map.line,\\n          charIndex      = map.offset + cursorLocation.charIndex;\\n      this._removeStyleObject(isBeginningOfLine, cursorLocation, lineIndex, charIndex);\\n    }\\n  });\\n})();\\n\\n\\n(function() {\\n  var override = fabric.IText.prototype._getNewSelectionStartFromOffset;\\n  /**\\n   * Overrides the IText implementation and adjusts character index as there is not always a linebreak\\n   *\\n   * @param {Number} mouseOffset\\n   * @param {Number} prevWidth\\n   * @param {Number} width\\n   * @param {Number} index\\n   * @param {Number} jlen\\n   * @returns {Number}\\n   */\\n  fabric.IText.prototype._getNewSelectionStartFromOffset = function(mouseOffset, prevWidth, width, index, jlen) {\\n    index = override.call(this, mouseOffset, prevWidth, width, index, jlen);\\n\\n    // the index passed into the function is padded by the amount of lines from _textLines (to account for \\\\n)\\n    // we need to remove this padding, and pad it by actual lines, and / or spaces that are meant to be there\\n    var tmp     = 0,\\n        removed = 0;\\n\\n    // account for removed characters\\n    for (var i = 0; i < this._textLines.length; i++) {\\n      tmp += this._textLines[i].length;\\n\\n      if (tmp + removed >= index) {\\n        break;\\n      }\\n\\n      if (this.text[tmp + removed] === '\\\\n' || this.text[tmp + removed] === ' ') {\\n        removed++;\\n      }\\n    }\\n\\n    return index - i + removed;\\n  };\\n})();\\n\\n\\n(function() {\\n\\n  if (typeof document !== 'undefined' && typeof window !== 'undefined') {\\n    return;\\n  }\\n\\n  var DOMParser = require('xmldom').DOMParser,\\n      URL = require('url'),\\n      HTTP = require('http'),\\n      HTTPS = require('https'),\\n\\n      Canvas = require('canvas'),\\n      Image = require('canvas').Image;\\n\\n  /** @private */\\n  function request(url, encoding, callback) {\\n    var oURL = URL.parse(url);\\n\\n    // detect if http or https is used\\n    if ( !oURL.port ) {\\n      oURL.port = ( oURL.protocol.indexOf('https:') === 0 ) ? 443 : 80;\\n    }\\n\\n    // assign request handler based on protocol\\n    var reqHandler = (oURL.protocol.indexOf('https:') === 0 ) ? HTTPS : HTTP,\\n        req = reqHandler.request({\\n          hostname: oURL.hostname,\\n          port: oURL.port,\\n          path: oURL.path,\\n          method: 'GET'\\n        }, function(response) {\\n          var body = '';\\n          if (encoding) {\\n            response.setEncoding(encoding);\\n          }\\n          response.on('end', function () {\\n            callback(body);\\n          });\\n          response.on('data', function (chunk) {\\n            if (response.statusCode === 200) {\\n              body += chunk;\\n            }\\n          });\\n        });\\n\\n    req.on('error', function(err) {\\n      if (err.errno === process.ECONNREFUSED) {\\n        fabric.log('ECONNREFUSED: connection refused to ' + oURL.hostname + ':' + oURL.port);\\n      }\\n      else {\\n        fabric.log(err.message);\\n      }\\n      callback(null);\\n    });\\n\\n    req.end();\\n  }\\n\\n  /** @private */\\n  function requestFs(path, callback) {\\n    var fs = require('fs');\\n    fs.readFile(path, function (err, data) {\\n      if (err) {\\n        fabric.log(err);\\n        throw err;\\n      }\\n      else {\\n        callback(data);\\n      }\\n    });\\n  }\\n\\n  fabric.util.loadImage = function(url, callback, context) {\\n    function createImageAndCallBack(data) {\\n      if (data) {\\n        img.src = new Buffer(data, 'binary');\\n        // preserving original url, which seems to be lost in node-canvas\\n        img._src = url;\\n        callback && callback.call(context, img);\\n      }\\n      else {\\n        img = null;\\n        callback && callback.call(context, null, true);\\n      }\\n    }\\n    var img = new Image();\\n    if (url && (url instanceof Buffer || url.indexOf('data') === 0)) {\\n      img.src = img._src = url;\\n      callback && callback.call(context, img);\\n    }\\n    else if (url && url.indexOf('http') !== 0) {\\n      requestFs(url, createImageAndCallBack);\\n    }\\n    else if (url) {\\n      request(url, 'binary', createImageAndCallBack);\\n    }\\n    else {\\n      callback && callback.call(context, url);\\n    }\\n  };\\n\\n  fabric.loadSVGFromURL = function(url, callback, reviver) {\\n    url = url.replace(/^\\\\n\\\\s*/, '').replace(/\\\\?.*$/, '').trim();\\n    if (url.indexOf('http') !== 0) {\\n      requestFs(url, function(body) {\\n        fabric.loadSVGFromString(body.toString(), callback, reviver);\\n      });\\n    }\\n    else {\\n      request(url, '', function(body) {\\n        fabric.loadSVGFromString(body, callback, reviver);\\n      });\\n    }\\n  };\\n\\n  fabric.loadSVGFromString = function(string, callback, reviver) {\\n    var doc = new DOMParser().parseFromString(string);\\n    fabric.parseSVGDocument(doc.documentElement, function(results, options) {\\n      callback && callback(results, options);\\n    }, reviver);\\n  };\\n\\n  fabric.util.getScript = function(url, callback) {\\n    request(url, '', function(body) {\\n      // eslint-disable-next-line no-eval\\n      eval(body);\\n      callback && callback();\\n    });\\n  };\\n\\n  // fabric.util.createCanvasElement = function(_, width, height) {\\n  //   return new Canvas(width, height);\\n  // }\\n\\n  /**\\n   * Only available when running fabric on node.js\\n   * @param {Number} width Canvas width\\n   * @param {Number} height Canvas height\\n   * @param {Object} [options] Options to pass to FabricCanvas.\\n   * @param {Object} [nodeCanvasOptions] Options to pass to NodeCanvas.\\n   * @return {Object} wrapped canvas instance\\n   */\\n  fabric.createCanvasForNode = function(width, height, options, nodeCanvasOptions) {\\n    nodeCanvasOptions = nodeCanvasOptions || options;\\n\\n    var canvasEl = fabric.document.createElement('canvas'),\\n        nodeCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions),\\n        nodeCacheCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions);\\n\\n    // jsdom doesn't create style on canvas element, so here be temp. workaround\\n    canvasEl.style = { };\\n\\n    canvasEl.width = nodeCanvas.width;\\n    canvasEl.height = nodeCanvas.height;\\n    options = options || { };\\n    options.nodeCanvas = nodeCanvas;\\n    options.nodeCacheCanvas = nodeCacheCanvas;\\n    var FabricCanvas = fabric.Canvas || fabric.StaticCanvas,\\n        fabricCanvas = new FabricCanvas(canvasEl, options);\\n    fabricCanvas.nodeCanvas = nodeCanvas;\\n    fabricCanvas.nodeCacheCanvas = nodeCacheCanvas;\\n    fabricCanvas.contextContainer = nodeCanvas.getContext('2d');\\n    fabricCanvas.contextCache = nodeCacheCanvas.getContext('2d');\\n    fabricCanvas.Font = Canvas.Font;\\n    return fabricCanvas;\\n  };\\n\\n  var originaInitStatic = fabric.StaticCanvas.prototype._initStatic;\\n  fabric.StaticCanvas.prototype._initStatic = function(el, options) {\\n    el = el || fabric.document.createElement('canvas');\\n    this.nodeCanvas = new Canvas(el.width, el.height);\\n    this.nodeCacheCanvas = new Canvas(el.width, el.height);\\n    originaInitStatic.call(this, el, options);\\n    this.contextContainer = this.nodeCanvas.getContext('2d');\\n    this.contextCache = this.nodeCacheCanvas.getContext('2d');\\n    this.Font = Canvas.Font;\\n  }\\n\\n  /** @ignore */\\n  fabric.StaticCanvas.prototype.createPNGStream = function() {\\n    return this.nodeCanvas.createPNGStream();\\n  };\\n\\n  fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\\n    return this.nodeCanvas.createJPEGStream(opts);\\n  };\\n\\n  fabric.StaticCanvas.prototype._initRetinaScaling = function() {\\n    if (!this._isRetinaScaling()) {\\n      return;\\n    }\\n\\n    this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);\\n    this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);\\n    this.nodeCanvas.width = this.width * fabric.devicePixelRatio;\\n    this.nodeCanvas.height = this.height * fabric.devicePixelRatio;\\n    this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);\\n    return this;\\n  };\\n  if (fabric.Canvas) {\\n    fabric.Canvas.prototype._initRetinaScaling = fabric.StaticCanvas.prototype._initRetinaScaling;\\n  }\\n\\n  var origSetBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;\\n  fabric.StaticCanvas.prototype._setBackstoreDimension = function(prop, value) {\\n    origSetBackstoreDimension.call(this, prop, value);\\n    this.nodeCanvas[prop] = value;\\n    return this;\\n  };\\n  if (fabric.Canvas) {\\n    fabric.Canvas.prototype._setBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;\\n  }\\n\\n})();\\n\\n\"","module.exports = \"(function ($, BaseShape, pluginsNamespace) {\\n  /**\\n   * Provides a line button which can be used to draw lines.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * Tool is using drawerInstance.options['lineAngleTooltip']\\n   * Default settings are:\\n   * {  enabled: false,\\n   *    fontSize: 11,\\n   *    fontFamily:  'Arial, sans serif',\\n   *    color: 'black'};\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var Line = function LineConstructor(drawerInstance) {\\n    // call super\\n    BaseShape.call(this, drawerInstance);\\n\\n    this.name = 'Line';\\n    /**\\n     * List of tool options to show when tool is activated.\\n     * Deviating from BaseShape tool, Line has no 'color', only 'border'.\\n     * @type {String[]}\\n     */\\n    this.toolOptionsList = ['border', 'opacity', 'lineWidth', 'strokeWidth'];\\n\\n    this.btnClass = 'btn-line';\\n    this.faClass = 'fa-line';\\n    this.tooltip = drawerInstance.t('Draw a line');\\n\\n    this.group = {\\n      name: 'lines',\\n      tooltip: drawerInstance.t('Lines and arrows')\\n    };\\n\\n    this._setupOptions({});\\n    $.extend(true, this.options.lineAngleTooltip, drawerInstance.options.lineAngleTooltip || {});\\n\\n    // add fallback for fontFamily\\n    this.options.lineAngleTooltip.fontFamily += ', ' + this._defaultOptions.lineAngleTooltip.fontFamily;\\n  };\\n\\n  Line.prototype = Object.create(BaseShape.prototype);\\n  Line.prototype.constructor = Line;\\n\\n  Line.prototype.checkOnlyWidthOrHeight = true;\\n\\n  Line.prototype._defaultOptions = {\\n    lineAngleTooltip: {\\n      enabled: false,\\n      fontSize: 11,\\n      fontFamily:  'Arial, sans serif',\\n      color: 'black'\\n    }\\n  };\\n\\n\\n  /**\\n   * Create new shape with minimal size.\\n   * Is called from BaseShape nmouseDown handler.\\n   *\\n   * @param  {Number} left [description]\\n   * @param  {Number} top  [description]\\n   * @return {fabric.ErasableLine}\\n   */\\n  Line.prototype.createShape = function (left, top) {\\n    var line = new fabric.ErasableLine();\\n\\n    line.set('x1', left);\\n    line.set('x2', left + 1);\\n    line.set('y1', top);\\n    line.set('y2', top + 1);\\n    line.set('stroke', this.drawerInstance.activeColor);\\n    line.set('opacity', this.drawerInstance.activeOpacity);\\n    line.set('strokeWidth', this.drawerInstance.lineStrokeWidth || 2);\\n\\n    this.createAngleTooltip(line);\\n\\n    return line;\\n  };\\n\\n\\n  /**\\n   * Update shape with new left, top,\\n   * Is called from BaseShape mouseMove handler\\n   *\\n   * @param  {fabric.Line} line    [description]\\n   * @param  {Number} newLeft [description]\\n   * @param  {Number} newTop  [description]\\n   */\\n  Line.prototype.updateShape = function (line, newLeft, newTop) {\\n    line.set('x2', newLeft);\\n    line.set('y2', newTop);\\n\\n    this.updateAngleTooltip(line);\\n  };\\n\\n\\n  /**\\n   * Is called from BaseShape mouseUp handler.\\n   */\\n  Line.prototype.finishShape = function () {\\n    this.removeAngleTooltip();\\n  };\\n\\n\\n  /**\\n   * Create text object for line angle tooltip\\n   *\\n   * @param  {fabric.Line} line\\n   */\\n  Line.prototype.createAngleTooltip = function (line) {\\n    if (!this.options.lineAngleTooltip.enabled)\\n      return;\\n\\n    this.angleTooltip = new fabric.IText('Text');\\n    this.angleTooltip.set('fontFamily', this.options.lineAngleTooltip.fontFamily);\\n    this.angleTooltip.set('fontSize', this.options.lineAngleTooltip.fontSize);\\n    this.angleTooltip.set('left', line.x1 - 10);\\n    this.angleTooltip.set('top', line.y1 - 10);\\n    this.angleTooltip.set('stroke', this.options.lineAngleTooltip.color);\\n    this.angleTooltip.set('fill', this.options.lineAngleTooltip.color);\\n    this.angleTooltip.set('text', '');\\n\\n    this.drawerInstance.fCanvas.add(this.angleTooltip);\\n    this.updateAngleTooltip(line);\\n  };\\n\\n\\n  /**\\n   * Update angle tooltip with line current angle\\n   *\\n   * @param  {fabric.Line} line\\n   */\\n  Line.prototype.updateAngleTooltip = function (line) {\\n    if (!this.options.lineAngleTooltip.enabled)\\n      return;\\n\\n    // calc line angle\\n    var angleRad = Math.atan((line.y2 - line.y1) / (line.x2 - line.x1));\\n    var angle = Math.abs(fabric.util.radiansToDegrees(angleRad));\\n    this.angleTooltip.setText(angle.toFixed().toString());\\n\\n    // determine tooltip position\\n    var tooltipOffsetX = this.options.lineAngleTooltip.fontSize;\\n    var tooltipOffsetY = -this.options.lineAngleTooltip.fontSize;\\n    // if line is pointing to the left\\n    if (line.x2 < line.x1) {\\n      tooltipOffsetX = -(this.options.lineAngleTooltip.fontSize + 10);\\n    }\\n    // if line is pointing downside\\n    if (line.y2 > line.y1) {\\n      tooltipOffsetY = 2;\\n    }\\n\\n    this.angleTooltip.set('left', line.x1 + tooltipOffsetX);\\n    this.angleTooltip.set('top', line.y1 + tooltipOffsetY);\\n    // this is needed to overpower strange issue, when tooltip is always same color as line\\n    this.angleTooltip.set('stroke', this.options.lineAngleTooltip.color);\\n    this.angleTooltip.set('fill', this.options.lineAngleTooltip.color);\\n  };\\n\\n\\n  /**\\n   * Removes angle tooltip.\\n   */\\n  Line.prototype.removeAngleTooltip = function () {\\n    if (this.options.lineAngleTooltip.enabled) {\\n      if (this.angleTooltip) {\\n        this.angleTooltip.remove();\\n        delete this.tooltip;\\n      }\\n    }\\n  };\\n\\n  pluginsNamespace.Line = Line;\\n\\n}(jQuery, Easel.plugins.BaseShape, Easel.plugins));\"","module.exports = \"(function ($, pluginsNamespace, util) {\\n  \\\"use strict\\\";\\n\\n  var MOUSE_DOWN = util.mouseDown('easelCrop');\\n  var MOUSE_UP = util.mouseUp('easelCrop');\\n  var MOUSE_MOVE = util.mouseMove('easelCrop');\\n\\n  var emptyFunc = function () {},\\n      cssPrefixes = ['Webkit', 'Moz', 'ms'],\\n      emptyStyles = document.createElement('div').style,\\n      CSS_TRANS_ORG,\\n      CSS_TRANSFORM,\\n      CSS_USERSELECT;\\n\\n  function vendorPrefix(prop) {\\n    if (prop in emptyStyles) {\\n      return prop;\\n    }\\n\\n    var capProp = prop[0].toUpperCase() + prop.slice(1),\\n        i = cssPrefixes.length;\\n\\n    while (i--) {\\n      prop = cssPrefixes[i] + capProp;\\n      if (prop in emptyStyles) {\\n        return prop;\\n      }\\n    }\\n  }\\n\\n  CSS_TRANSFORM = vendorPrefix('transform');\\n  CSS_TRANS_ORG = vendorPrefix('transformOrigin');\\n  CSS_USERSELECT = vendorPrefix('userSelect');\\n\\n  /**\\n   * Provides a button to minimize canvas.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * @param {jQuery} $element\\n   * @param {object} [options]\\n   * options\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ImageCropPlugin = function ImageCropPluginConstructor(drawer, $element, options) {\\n    /**\\n     * @type {Easel}\\n     */\\n    this.name = 'ImageCropPlugin';\\n    this.drawer = drawer;\\n    this.$element = $element;\\n\\n    this._resetData();\\n    this.options = $.extend(true, {}, this._defaultOptions, options || {});\\n\\n    this._init();\\n    return this;\\n  };\\n\\n  ImageCropPlugin.prototype._defaultOptions = {\\n    boundary: { },\\n    enableExif: false,\\n    minSize: 10,\\n    enableOrientation: false,\\n    update: emptyFunc,\\n    controlsCss: {},\\n    controlsTouchCss: {}\\n  };\\n\\n  ImageCropPlugin.prototype.globals = {\\n    translate: 'translate3d'\\n  };\\n\\n  /**\\n   *\\n   * @param {String|Object} bindOptions\\n   * @param {Function} [callback]\\n   * @returns {Promise}\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._bind = function (bindOptions, callback) {\\n    var url,\\n        callbackIsValid = callback && typeof callback === 'function';\\n\\n    if (typeof bindOptions === 'string') {\\n      this.data = {\\n        url: bindOptions\\n      };\\n    } else {\\n      this.data = $.extend(true, {}, bindOptions || {});\\n    }\\n\\n    this._resetData();\\n\\n    this.successCallback = callbackIsValid ? callback : this.successCallback || emptyFunc;\\n\\n    if (this.data && this.data.newImage) {\\n      this.originalImage = this.data.url;\\n      this.prevImages = [];\\n    }\\n    this.currentImage = this.data.url;\\n\\n    this.elements.$fullsizePreview.attr('src', this.data.url);\\n    var loadImagePromise = util.loadImage(this.data.url, this.elements.$img.get(0), this.data).then(this.startCropping.bind(this));\\n    return loadImagePromise;\\n  };\\n\\n  /** Draw data and get canvas\\n   * @param {Object} data\\n   * @returns {HTMLElement}\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._getCanvas = function(data) {\\n    var points = data.points,\\n        left = parseInt(points[0],10),\\n        top = parseInt(points[1],10),\\n        right = parseInt(points[2],10),\\n        bottom = parseInt(points[3],10),\\n        width = right-left,\\n        height = bottom-top,\\n        canvas = document.createElement('canvas'),\\n        ctx = canvas.getContext('2d'),\\n        outWidth = width,\\n        outHeight = height,\\n        startX = 0,\\n        startY = 0,\\n        canvasWidth = outWidth,\\n        canvasHeight = outHeight,\\n        customDimensions = (data.outputWidth && data.outputHeight),\\n        outputRatio = 1;\\n\\n    if (!outputRatio && customDimensions) {\\n      canvasWidth = data.outputWidth;\\n      canvasHeight = data.outputHeight;\\n      outputRatio = canvasWidth / outWidth;\\n    }\\n\\n    canvas.width = canvasWidth;\\n    canvas.height = canvasHeight;\\n\\n    if (data.backgroundColor) {\\n      ctx.fillStyle = data.backgroundColor;\\n      ctx.fillRect(0, 0, outWidth, outHeight);\\n    }\\n\\n    if (left < 0) {\\n      startX = Math.abs(left);\\n      left = 0;\\n    }\\n    if (top < 0) {\\n      startY = Math.abs(top);\\n      top = 0;\\n    }\\n    if (right > this.originalWidth) {\\n      width = this.originalWidth - left;\\n      outWidth = width;\\n    }\\n    if (bottom > this.originalHeight) {\\n      height = this.originalHeight - top;\\n      outHeight = height;\\n    }\\n\\n    if (outputRatio !== 1) {\\n      startX *= outputRatio;\\n      startY *= outputRatio;\\n      outWidth *= outputRatio;\\n      outHeight *= outputRatio;\\n    }\\n    ctx.drawImage(this.elements.$fullsizePreview.get(0), left, top, width, height, startX, startY, outWidth, outHeight);\\n    return canvas;\\n  };\\n\\n  /**\\n   *\\n   * @param {Object} data\\n   * @returns {jQuery}\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._getHtmlResult = function(data) {\\n    var points = data.points,\\n        $div = $('<div class=\\\"croppie-result\\\">'),\\n        $img = $('<img>'),\\n        width = points[2] - points[0],\\n        height = points[3] - points[1];\\n\\n    $div.append($img);\\n    $img.css({\\n      left: (-1 * points[0]) + 'px',\\n      top: (-1 * points[1]) + 'px'\\n    });\\n    img.src = data.url;\\n    $div.css({\\n      width: width + 'px',\\n      height: height + 'px'\\n    });\\n    return $div;\\n  };\\n\\n  /**\\n   * @param {Object} data\\n   * @returns {String}\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._getBase64Result = function(data) {\\n    var result = this._getCanvas(data).toDataURL(data.format, data.quality);\\n    return result;\\n  };\\n\\n  /**\\n   *\\n   * @param {Object} data\\n   * @returns {Promise}\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._getBlobResult = function(data) {\\n    var self = this;\\n    return new Promise(function (resolve, reject) {\\n      self._getCanvas(data).toBlob(function (blob) {\\n        resolve(blob);\\n      }, data.format, data.quality);\\n    });\\n  };\\n\\n\\n  /**\\n   * Get current state of cropper\\n   * @return {Object} - current state data\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._get = function () {\\n    var previewEl = this.elements.$img.get(0),\\n        viewportEl = this.elements.$viewport.get(0),\\n        imgData = previewEl.getBoundingClientRect(),\\n        vpData = viewportEl.getBoundingClientRect(),\\n        x1 = vpData.left - imgData.left,\\n        y1 = vpData.top - imgData.top,\\n        x2 = x1 + vpData.width,\\n        y2 = y1 + vpData.height,\\n        currZoom = (parseInt(this._currentZoom * 100) / 100) || 1;\\n\\n    x1 = Math.max(0, x1 / currZoom);\\n    y1 = Math.max(0, y1 / currZoom);\\n    x2 = Math.max(0, x2 / currZoom);\\n    y2 = Math.max(0, y2 / currZoom);\\n\\n    var p1 = parseFloat(x1).toFixed(4),\\n        p2 = parseFloat(y1).toFixed(4),\\n        p3 = parseFloat(x2).toFixed(4),\\n        p4 = parseFloat(y2).toFixed(4);\\n\\n    return {\\n      points: [p1, p2, p3, p4],\\n      zoom: currZoom\\n    };\\n  };\\n\\n  var RESULT_DEFAULTS = {\\n        type: 'canvas',\\n        format: 'png',\\n        quality: 1\\n      },\\n      RESULT_FORMATS = ['jpeg', 'webp', 'png'];\\n\\n  /**\\n   * Get result of image crop\\n   * @param {Object} [options]\\n   * @returns {Promise}\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._result = function (options) {\\n    var self = this,\\n        data = this._get(),\\n        opts = $.extend(true, {}, RESULT_DEFAULTS, options || {}),\\n        resultType = (typeof (options) === 'string' ? options : (opts.type || 'base64')),\\n        format = opts.format,\\n        quality = opts.quality,\\n        backgroundColor = opts.backgroundColor,\\n        viewport = this.elements.$viewport.get(0),\\n        vpRect = viewport.getBoundingClientRect(),\\n        prom;\\n\\n    /*\\n    if (size === 'viewport') {\\n      data.outputWidth = vpRect.width;\\n      data.outputHeight = vpRect.height;\\n    } else if (typeof size === 'object') {\\n      if (size.width && size.height) {\\n        data.outputWidth = size.width;\\n        data.outputHeight = size.height;\\n      } else if (size.width) {\\n        data.outputWidth = size.width;\\n        data.outputHeight = size.width / ratio;\\n      } else if (size.height) {\\n        data.outputWidth = size.height * ratio;\\n        data.outputHeight = size.height;\\n      }\\n    }\\n    */\\n\\n    if (RESULT_FORMATS.indexOf(format) > -1) {\\n      data.format = 'image/' + format;\\n      data.quality = quality;\\n    }\\n\\n    data.url = this.data.url;\\n    data.backgroundColor = backgroundColor;\\n\\n    prom = new Promise(function (resolve, reject) {\\n      switch (resultType.toLowerCase()) {\\n        case 'rawcanvas':\\n          resolve(self._getCanvas(data));\\n          break;\\n        case 'canvas':\\n        case 'base64':\\n          resolve(self._getBase64Result(data));\\n          break;\\n        case 'blob':\\n          self._getBlobResult(data).then(resolve);\\n          break;\\n        default:\\n          resolve(self._getHtmlResult(data));\\n          break;\\n      }\\n    });\\n    return prom;\\n  };\\n\\n  /**\\n   * @param {Image} img\\n   * @param {Function} cb - callback\\n   */\\n  ImageCropPlugin.prototype.getExifOrientation = function (img, cb) {\\n    if (!window.EXIF) {\\n      cb(0);\\n    }\\n\\n    EXIF.getData(img, function () {\\n      var orientation = EXIF.getTag(this, 'Orientation');\\n      cb(orientation);\\n    });\\n  };\\n\\n  /**\\n   *\\n   * @param {HTMLCanvasElement} canvas\\n   * @param {Image} img\\n   * @param {Number} orientation\\n   */\\n  ImageCropPlugin.prototype.drawCanvas = function (canvas, img, orientation) {\\n    var width = img.width,\\n        height = img.height,\\n        ctx = canvas.getContext('2d');\\n\\n    canvas.width = img.width;\\n    canvas.height = img.height;\\n\\n    ctx.save();\\n    switch (orientation) {\\n      case 2:\\n        ctx.translate(width, 0);\\n        ctx.scale(-1, 1);\\n        break;\\n\\n      case 3:\\n        ctx.translate(width, height);\\n        ctx.rotate(180*Math.PI/180);\\n        break;\\n\\n      case 4:\\n        ctx.translate(0, height);\\n        ctx.scale(1, -1);\\n        break;\\n\\n      case 5:\\n        canvas.width = height;\\n        canvas.height = width;\\n        ctx.rotate(90*Math.PI/180);\\n        ctx.scale(1, -1);\\n        break;\\n\\n      case 6:\\n        canvas.width = height;\\n        canvas.height = width;\\n        ctx.rotate(90*Math.PI/180);\\n        ctx.translate(0, -height);\\n        break;\\n\\n      case 7:\\n        canvas.width = height;\\n        canvas.height = width;\\n        ctx.rotate(-90*Math.PI/180);\\n        ctx.translate(-width, height);\\n        ctx.scale(1, -1);\\n        break;\\n\\n      case 8:\\n        canvas.width = height;\\n        canvas.height = width;\\n        ctx.translate(0, width);\\n        ctx.rotate(-90*Math.PI/180);\\n        break;\\n    }\\n    ctx.drawImage(img, 0,0, width, height);\\n    ctx.restore();\\n  };\\n\\n  /**\\n   * @param {Number} [customOrientation]\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._transferImageToCanvas = function (customOrientation) {\\n    customOrientation = this.options.enableOrientation && customOrientation;\\n    var $canvas = this.elements.$canvas,\\n        canvas = $canvas.get(0),\\n        img = this.elements.$img.get(0),\\n        ctx = canvas.get(0).getContext('2d'),\\n        exif = this.options.enableExif && window.EXIF;\\n\\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\\n    canvas.width = img.width;\\n    canvas.height = img.height;\\n\\n    if (exif) {\\n      this.getExifOrientation(img, function (orientation) {\\n        this.drawCanvas(canvas, img, parseInt(orientation, 10));\\n        if (customOrientation) {\\n          this.drawCanvas(canvas, img, customOrientation);\\n        }\\n      });\\n    } else {\\n      if (customOrientation) {\\n        this.drawCanvas(canvas, img, customOrientation);\\n      }\\n    }\\n  };\\n\\n  /**\\n   * React on image crop\\n   * @param {String} [result]\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._onCropSuccess = function (result) {\\n    this.success(result);\\n  };\\n\\n  /**\\n   * Success callback\\n   * @param {String} [result]\\n   */\\n  ImageCropPlugin.prototype.success = function (result) {\\n    if (this.successCallback) {\\n      this.successCallback(result);\\n    }\\n  };\\n\\n  /**\\n   * Reset data of cropper plugin\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._resetData = function() {\\n    this.weight = 0;\\n\\n    this.originalWidth = null;\\n    this.originalHeight = null;\\n    this.actualWidth = null;\\n    this.actualHeight = null;\\n\\n    this.croppedWidth = null;\\n    this.croppedHeight = null;\\n    this.croppedLeft = null;\\n    this.croppedTop = null;\\n  };\\n\\n  /**\\n   * Destroy instance of image crop plugin\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._destroy = function() {\\n\\n  };\\n\\n  /**\\n   * Update size values of cropper elements\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._updateViewportSizes = function() {\\n    var currentSizes = this.elements.$img.get(0).getBoundingClientRect(),\\n        parentCurrentSizes = this.elements.$img.parent().get(0).getBoundingClientRect(),\\n        offsetLeft = currentSizes && parentCurrentSizes && (currentSizes.left - parentCurrentSizes.left),\\n        offsetTop = currentSizes && parentCurrentSizes && (currentSizes.top - parentCurrentSizes.top),\\n        maxAvailableWidth = (currentSizes && currentSizes.width) || this.originalWidth,\\n        maxAvailableHeight = (currentSizes && currentSizes.height) || this.originalHeight;\\n\\n    this.actualWidth = maxAvailableWidth;\\n    this.actualHeight = maxAvailableHeight;\\n    this.offsetLeft = offsetLeft;\\n    this.offsetTop = offsetTop;\\n    this._currentZoom = parseInt(this.actualWidth / this.originalWidth * 100) / 100;\\n  };\\n\\n  /**\\n   * Update viewport position\\n   * @param {String} [styles] - style attribute\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._refreshViewportPosition = function(styles) {\\n    this._updateViewportSizes();\\n    var stylesForControls = {\\n      'width': this.croppedWidth ? this.croppedWidth : this.actualWidth,\\n      'height': this.croppedHeight ? this.croppedHeight : this.actualHeight,\\n      'max-width': this.actualWidth,\\n      'max-height': this.actualHeight,\\n      'left': this.croppedLeft ? this.croppedLeft : this.offsetLeft || 0,\\n      'top': this.croppedTop ? this.croppedTop : this.offsetTop || 0\\n    };\\n    if (styles) {\\n      this.elements.$viewport.attr('style', styles);\\n    } else {\\n      this.elements.$viewport.css(stylesForControls);\\n    }\\n  };\\n\\n  /**\\n   * Restore prev state of cropper\\n   */\\n  ImageCropPlugin.prototype.undoCrop = function() {\\n    var imageToUndo = this.prevImages.pop();\\n    if (imageToUndo) {\\n      this._bind(imageToUndo);\\n    }\\n  };\\n\\n  /**\\n   * Create cropper elements\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._setupCropElements = function () {\\n    var controlsBlockHtml,\\n        assetsUrl = util.getEaselFolderUrl() + 'assets/',\\n        cursorStyleAttr = 'style=\\\"cursor: url(' + assetsUrl + 'cursor-fa-crop-right.cur), crosshair\\\"',\\n        borderStyleAttr = 'style=\\\"background: url(' + assetsUrl + 'border.gif);\\\"';\\n\\n    controlsBlockHtml = ''+\\n        '<div class=\\\"imager-crop-container\\\">' +\\n        '<div class=\\\"crop-corner crop-top-left\\\"></div>' +\\n        '<div class=\\\"crop-corner crop-top-right\\\"></div>' +\\n        '<div class=\\\"crop-corner crop-bottom-right\\\"></div>' +\\n        '<div class=\\\"crop-corner crop-bottom-left\\\"></div>' +\\n        '<div class=\\\"crop-border crop-border-top\\\" '+borderStyleAttr+'></div>' +\\n        '<div class=\\\"crop-border crop-border-right\\\" '+borderStyleAttr+'></div>' +\\n        '<div class=\\\"crop-border crop-border-bottom\\\" '+borderStyleAttr+'></div>' +\\n        '<div class=\\\"crop-border crop-border-left\\\" '+borderStyleAttr+'></div>' +\\n        '</div>';\\n    \\n    this.elements = this.elements || {};\\n    this.elements.$viewport =  $(controlsBlockHtml);\\n\\n    this.elements.$img = $('<img class=\\\"cr-image\\\">');\\n    this.elements.$fullsizePreview = $('<img class=\\\"cr-image-fullsize\\\">');\\n    this.elements.$overlay = $('<div class=\\\"cr-overlay\\\">');\\n    this.elements.$preview = this.elements.$img;\\n\\n    this.$element.append(this.elements.$fullsizePreview);\\n    this.$element.append(this.elements.$preview);\\n    this.$element.append(this.elements.$overlay);\\n    this.$element.append(this.elements.$viewport);\\n  };\\n\\n  /**\\n   * Init cropper\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._init = function () {\\n    this._setupCropElements();\\n  };\\n\\n  /**\\n   * Save current state of cropper\\n   * @private\\n   */\\n  ImageCropPlugin.prototype._save = function () {\\n\\n    this.prevImages.push({\\n      viewportStyleAttr: this.elements.$viewport.attr('style'),\\n      points: this._get(),\\n      url: this.currentImage\\n    });\\n  };\\n\\n  /**\\n   * Process crop with current settings\\n   * @param {Boolean} [replaceCurrentImageWithResult]\\n   */\\n  ImageCropPlugin.prototype.applyCrop = function (replaceCurrentImageWithResult) {\\n    var self = this;\\n    self._result().then(function (result) {\\n      if (replaceCurrentImageWithResult) {\\n        self._save();\\n        self._bind(result);\\n      } else {\\n        self._onCropSuccess(result);\\n      }\\n    });\\n  };\\n\\n  /**\\n   * @param {Image} img\\n   */\\n  ImageCropPlugin.prototype.startCropping = function (img) {\\n    var _this = this;\\n\\n    img.style.opacity = 1;\\n\\n    _this.enableRendering = false;\\n    _this.renderCropped = false;\\n\\n    var $body = $('body');\\n\\n    _this.originalWidth = img.naturalWidth;\\n    _this.originalHeight = img.naturalHeight;\\n    _this.makePreview();\\n    _this._refreshViewportPosition(_this.data && _this.data.viewportStyleAttr);\\n    _this.viewportStyleAttr = false;\\n\\n    var $corners = _this.elements.$viewport.find('.crop-corner');\\n\\n    if (_this.drawer.touchDevice) {\\n      $corners.css(_this.options.controlsTouchCss);\\n    } else {\\n      $corners.css(_this.options.controlsCss);\\n    }\\n\\n    $corners.on(MOUSE_DOWN, function (clickEvent) {\\n      var controlItem = this,\\n          controlItemSize = this.getBoundingClientRect().width / 2;\\n\\n      _this.drawer.croppingNow = true;\\n\\n      var startPos = util.getEventPosition(clickEvent);\\n\\n      var viewportSizeBox = _this.elements.$viewport.get(0).getBoundingClientRect(),\\n          parentSizeBox = _this.elements.$viewport.parent().get(0).getBoundingClientRect(),\\n          startControlsLeft = viewportSizeBox.left - parentSizeBox.left,\\n          startControlsTop = viewportSizeBox.top - parentSizeBox.top,\\n          startControlsWidth = viewportSizeBox.width,\\n          startControlsHeight = viewportSizeBox.height;\\n\\n      var isTopLeft = $(controlItem).hasClass('crop-top-left'),\\n          isTopRight = $(controlItem).hasClass('crop-top-right'),\\n          isBottomLeft = $(controlItem).hasClass('crop-bottom-left'),\\n          isBottomRight = $(controlItem).hasClass('crop-bottom-right');\\n\\n      $body.on(MOUSE_MOVE, function (moveEvent) {\\n        var movePos = util.getEventPosition(moveEvent);\\n\\n        var diffLeft = movePos.left - startPos.left;\\n        var diffTop = movePos.top - startPos.top;\\n\\n        if (isTopLeft) {\\n          _this.croppedLeft = startControlsLeft + diffLeft;\\n          _this.croppedTop = startControlsTop + diffTop;\\n\\n          _this.croppedWidth = startControlsWidth - diffLeft;\\n          _this.croppedHeight = startControlsHeight - diffTop;\\n        }\\n\\n        if (isTopRight) {\\n          _this.croppedLeft = startControlsLeft;\\n          _this.croppedTop = startControlsTop + diffTop;\\n\\n          _this.croppedWidth = startControlsWidth - (diffLeft * -1);\\n          _this.croppedHeight = startControlsHeight - diffTop;\\n        }\\n\\n        if (isBottomRight) {\\n          _this.croppedLeft = startControlsLeft;\\n          _this.croppedTop = startControlsTop;\\n\\n          _this.croppedWidth = startControlsWidth - (diffLeft * -1);\\n          _this.croppedHeight = startControlsHeight + diffTop;\\n        }\\n\\n        if (isBottomLeft) {\\n          _this.croppedLeft = startControlsLeft + diffLeft;\\n          _this.croppedTop = startControlsTop;\\n\\n          _this.croppedWidth = startControlsWidth - diffLeft;\\n          _this.croppedHeight = startControlsHeight + diffTop;\\n        }\\n\\n        // bounds validation\\n        if (_this.croppedLeft < _this.offsetLeft) {\\n          _this.croppedLeft = _this.offsetLeft;\\n        }\\n\\n        if ((_this.croppedLeft + controlItemSize) > (_this.offsetLeft + _this.actualWidth)) {\\n          _this.croppedLeft = _this.offsetLeft + _this.actualWidth - _this.options.minSize;\\n          _this.croppedWidth = _this.options.minSize;\\n        }\\n\\n        if (_this.croppedTop < _this.offsetTop) {\\n          _this.croppedTop = _this.offsetTop;\\n        }\\n\\n        if ((_this.croppedTop + controlItemSize) > (_this.offsetTop + _this.actualHeight)) {\\n          _this.croppedTop = _this.offsetTop + _this.actualHeight - _this.options.minSize;\\n          _this.croppedHeight = _this.options.minSize;\\n        }\\n\\n        if (_this.croppedLeft + _this.croppedWidth > (_this.actualWidth + _this.offsetLeft)) {\\n          _this.croppedWidth = _this.actualWidth - _this.croppedLeft + _this.offsetLeft;\\n        }\\n\\n        if (_this.croppedTop + _this.croppedHeight > (_this.actualHeight + _this.offsetTop)) {\\n          _this.croppedHeight = _this.actualHeight - _this.croppedTop + _this.offsetTop;\\n        }\\n\\n        _this.elements.$viewport.css({\\n          left: _this.croppedLeft,\\n          top: _this.croppedTop,\\n          width: _this.croppedWidth,\\n          height: _this.croppedHeight\\n        });\\n\\n        moveEvent.preventDefault();\\n        moveEvent.stopPropagation();\\n        return false;\\n      });\\n\\n      $body.on(MOUSE_UP, function () {\\n        util.setTimeout(function(){\\n          _this.drawer.croppingNow = false;\\n        }, 50);\\n        $body.off(MOUSE_MOVE);\\n        $body.off(MOUSE_UP);\\n      });\\n    });\\n  };\\n\\n  /**\\n   * Create preview element\\n   * @param {Number} originalWidth\\n   * @param {Number} originalHeight\\n   */\\n  ImageCropPlugin.prototype.makePreview = function (originalWidth, originalHeight) {\\n    var _this = this;\\n\\n    _this.$preview = $('' +\\n        '<div class=\\\"imager-crop-preview-container\\\">' +\\n        '<canvas class=\\\"imager-crop-preview\\\"></canvas>' +\\n        '</div>').css('position', 'absolute').css('top', '50px').css({\\n      width: originalWidth,\\n      height: originalHeight,\\n      position: 'absolute',\\n      right: '50px',\\n      top: '50px'\\n    });\\n\\n    _this.previewCanvas = _this.$preview.find('canvas.imager-crop-preview')[0];\\n    _this.previewCanvas.__previewCanvas = true;\\n\\n    _this.previewCanvas.width = originalWidth * 1.5;\\n    _this.previewCanvas.height = originalHeight * 1.5;\\n\\n    $(_this.previewCanvas).css({\\n      height: '400px'\\n    });\\n\\n    _this.$element.append(this.$preview);\\n  };\\n\\n  /**\\n   * Reset data\\n   * @private\\n   */\\n  ImageCropPlugin.prototype.reset = function () {\\n    this.croppedLeft = null;\\n    this.croppedTop = null;\\n    this.croppedWidth = null;\\n    this.croppedHeight = null;\\n\\n    this.sizeBeforeCrop = null;\\n  };\\n\\n  /* CSS Transform Prototype */\\n  var TRANSLATE_OPTS = {\\n    'translate3d': {\\n      suffix: ', 0px'\\n    },\\n    'translate': {\\n      suffix: ''\\n    }\\n  };\\n  var Transform = function (x, y, scale) {\\n    this.x = parseFloat(x);\\n    this.y = parseFloat(y);\\n    this.scale = parseFloat(scale);\\n  };\\n\\n  Transform.parse = function (v) {\\n    if (v) {\\n      var isJquery = v && v instanceof jQuery && v.length,\\n          isNode = v instanceof Node,\\n          node = isJquery ? v.get(0) : (isNode && v),\\n          nodeStyle = node && node.style;\\n      if (nodeStyle) {\\n        return Transform.parse(nodeStyle[CSS_TRANSFORM]);\\n      } else {\\n        if (v.indexOf('matrix') > -1 || v.indexOf('none') > -1) {\\n          return Transform.fromMatrix(v);\\n        } else {\\n          return Transform.fromString(v);\\n        }\\n      }\\n    }\\n  };\\n\\n  Transform.fromMatrix = function (v) {\\n    var vals = v.substring(7).split(',');\\n    if (!vals.length || v === 'none') {\\n      vals = [1, 0, 0, 1, 0, 0];\\n    }\\n    var xVal = parseInt(vals[4], 10),\\n        yVal = parseInt(vals[5], 10),\\n        scaleVal = parseFloat(vals[0]);\\n\\n    return new Transform(xVal, yVal, scaleVal);\\n  };\\n\\n  Transform.fromString = function (v) {\\n    var values = v.split(') '),\\n        translate = values[0].substring(ImageCropPlugin.prototype.globals.translate.length + 1).split(','),\\n        scale = values.length > 1 ? values[1].substring(6) : 1,\\n        x = translate.length > 1 ? translate[0] : 0,\\n        y = translate.length > 1 ? translate[1] : 0;\\n\\n    return new Transform(x, y, scale);\\n  };\\n\\n  Transform.prototype.toString = function () {\\n    var suffix = TRANSLATE_OPTS[ImageCropPlugin.prototype.globals.translate].suffix || '',\\n        prefix = ImageCropPlugin.prototype.globals.translate,\\n        style = '(' + this.x + 'px, ' + this.y + 'px' + suffix + ') scale(' + this.scale + ')',\\n        result = prefix + style;\\n\\n    return result;\\n  };\\n\\n  var TransformOrigin = function (el) {\\n    var elIsJquery = el instanceof jQuery;\\n    el = elIsJquery ? el.get(0) : el;\\n    if (!el || !el.style[CSS_TRANS_ORG]) {\\n      this.x = 0;\\n      this.y = 0;\\n      return;\\n    }\\n    var css = el.style[CSS_TRANS_ORG].split(' ');\\n    this.x = parseFloat(css[0]);\\n    this.y = parseFloat(css[1]);\\n  };\\n\\n  TransformOrigin.prototype.toString = function () {\\n    return this.x + 'px ' + this.y + 'px';\\n  };\\n  /***********/\\n  pluginsNamespace.ImageCropPlugin = ImageCropPlugin;\\n})(jQuery, Easel.plugins, Easel.util);\"","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions, util) {\\n  \\\"use strict\\\";\\n\\n  var ShapeFill = function ShapeFillConstructor(drawer, options) {\\n    BaseToolOptions.call(this, drawer);\\n\\n    this.optionName = 'shapeFill';\\n    this.name = 'ShapeFill';\\n    this._setupOptions(options);\\n\\n    this.currentFill = this.drawer.activeColor || (this.options && this.options.defaultFill) || '#ffffff';\\n    this.colorpicker = new pluginsNamespace.ColorpickerControl(this.drawer, {\\n      colorText: this.drawer.t('Fill'),\\n      buttonOrder: this.options.buttonOrder\\n    });\\n\\n    this._bindedOnObjectAdded = this._onObjectAdded.bind(this);\\n    this.drawer.on(this.drawer.EVENT_OBJECT_ADDED, this._bindedOnObjectAdded);\\n  };\\n\\n  ShapeFill.prototype = Object.create(BaseToolOptions.prototype);\\n  ShapeFill.prototype.constructor = BaseToolOptions;\\n\\n  ShapeFill.prototype._defaultOptions = {\\n    buttonOrder: 4,\\n    defaultFill: '#ffffff'\\n  };\\n\\n  ShapeFill.prototype.createControls = function (toolbar) {\\n    this.$control = this.colorpicker.createControl(toolbar, this.onFillSelected.bind(this));\\n    this.colorpicker.setColor(this.currentFill);\\n    this.hideControls();\\n  };\\n\\n  ShapeFill.prototype.onFillSelected = function (color) {\\n    if (!color) {\\n      return;\\n    }\\n\\n    this.currentFill = color;\\n    this._applyFillToActiveObject(color);\\n    this.drawer.setColor(color);\\n  };\\n\\n  ShapeFill.prototype._applyFillToActiveObject = function (color) {\\n    if (!this.drawer.fCanvas) {\\n      return;\\n    }\\n\\n    var activeObject = this.drawer.fCanvas.getActiveObject();\\n    if (activeObject && util.isShape(activeObject) && !activeObject.path) {\\n      activeObject.set('fill', color);\\n      this.drawer.fCanvas.renderAll();\\n    }\\n  };\\n\\n  ShapeFill.prototype.updateControlsFromObject = function (target) {\\n    if (!target || !util.isShape(target)) {\\n      return;\\n    }\\n\\n    var fill = target.get('fill');\\n    if (fill) {\\n      this.currentFill = fill;\\n      this.colorpicker.setColor(fill);\\n    }\\n  };\\n\\n  ShapeFill.prototype._onObjectAdded = function (evt, fabricEvent) {\\n    var target = fabricEvent && fabricEvent.target;\\n    if (target && util.isShape(target) && !target.path) {\\n      target.set('fill', this.currentFill || this.drawer.activeColor);\\n      this.drawer.fCanvas.renderAll();\\n    }\\n  };\\n\\n  ShapeFill.prototype.showControls = function () {\\n    this.colorpicker.showControls();\\n  };\\n\\n  ShapeFill.prototype.hideControls = function () {\\n    this.colorpicker.hideControls();\\n  };\\n\\n  ShapeFill.prototype.removeTool = function () {\\n    BaseToolOptions.prototype.removeTool.call(this);\\n    if (this._bindedOnObjectAdded) {\\n      this.drawer.off(this.drawer.EVENT_OBJECT_ADDED, this._bindedOnObjectAdded);\\n    }\\n  };\\n\\n  pluginsNamespace.ShapeFill = ShapeFill;\\n})(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions, Easel.util);\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/ui-plugins/ToolbarTooltipManager.js\"))","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n    extend = fabric.util.object.extend,\\n    min = fabric.util.array.min,\\n    max = fabric.util.array.max,\\n    toFixed = fabric.util.toFixed;\\n\\n  fabric.PCircle = fabric.util.createClass(fabric.SegmentablePolygon, {\\n\\n    radius: 0,\\n    type: 'PCircle',\\n    initialize: function (options) {\\n      var _this = this;\\n      options = options || {};\\n      this.radius = options.radius || 0;\\n\\n      var points = this.makeCircle(this.radius);\\n\\n      this.width = this.radius * 2;\\n      this.height = this.radius * 2;\\n\\n      this.callSuper('initialize', points, options);\\n    },\\n    makeCircle: function (radius) {\\n      var points = [];\\n\\n      var centerX = 0;\\n      var centerY = 0;\\n\\n      for (var degree = 0; degree < 360; degree++) {\\n        var radians = degree * Math.PI / 180;\\n        var x = centerX + radius * Math.cos(radians);\\n        var y = centerY + radius * Math.sin(radians);\\n        points.push({x: x, y: y});\\n      }\\n\\n      return [points];\\n    },\\n    _render: function (ctx) {\\n      this.callSuper('_render', ctx);\\n    },\\n    _set: function (key, value) {\\n      if (key === 'radius') {\\n        this.points = this.makeCircle(value);\\n        this.width = value * 2;\\n        this.height = value * 2;\\n        this.callSuper('_set', 'points', this.points);\\n      }\\n\\n      this.callSuper('_set', key, value);\\n    },\\n    isPointInside: function (x, y) {\\n      var center = this.getCenterPoint();\\n      return Math.sqrt(\\n          (x - center.x) * (x - center.x) + (y - center.y) * (y - center.y)\\n        ) < this.radius;\\n    },\\n    getPerimeterPoints: function (deltaX, deltaY, useEntireCircle) {\\n      var result;\\n      var sectorAngleOffset = 0,\\n          sectorAngle = 360;\\n\\n      var deltaIsValid = typeof deltaX == 'number' && typeof deltaY == 'number',\\n          getPointsFromSector = deltaIsValid && !useEntireCircle;\\n      if (getPointsFromSector) {\\n        // Check if eraser tool position is changed\\n        if (deltaX || deltaY) {\\n          sectorAngle = deltaX !== 0 && deltaY !== 0 ? 90 : 180;\\n          if (deltaY < 0) {\\n            sectorAngleOffset = 180;\\n            if (deltaX > 0) {\\n              sectorAngleOffset = 270;\\n            }\\n          } else {\\n            if (deltaX < 0) {\\n              sectorAngleOffset = 90;\\n            }\\n          }\\n        }\\n      }\\n\\n      result = this.getSectorPoints(sectorAngleOffset, sectorAngle);\\n      return result;\\n    },\\n    getSectorPoints: function (sectorAngleOffset, sectorAngle) {\\n      var result = [],\\n          sizeOfStepInDeg = 15,\\n          randomDiff = Math.round(Math.random() * sizeOfStepInDeg / 2),\\n          endPoint = sectorAngleOffset + sectorAngle + sizeOfStepInDeg - randomDiff,\\n          currPointAngle = sectorAngleOffset - randomDiff;\\n\\n      for (currPointAngle; currPointAngle <= endPoint; currPointAngle += sizeOfStepInDeg) {\\n        var currPointCoords = {},\\n            currPointAngleRad = fabric.util.degreesToRadians(currPointAngle % 360),\\n            pointOffsetX = (this.radius * Math.cos(currPointAngleRad)),\\n            pointOffsetY = (this.radius * Math.sin(currPointAngleRad));\\n\\n        currPointCoords.x = this.left  + Math.round(pointOffsetX);\\n        currPointCoords.y = this.top + Math.round(pointOffsetY);\\n        result.push(currPointCoords);\\n      }\\n      return result;\\n    },\\n    toObject: function (propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        radius: this.radius\\n      });\\n    }\\n  });\\n\\n  fabric.PCircle.fromObject = function (object) {\\n    return new fabric.PCircle(object, true);\\n  };\\n\\n  fabric.PCircle.async = false;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","module.exports = \"(function ($, pluginsNamespace, BaseToolOptions) {\\n  'use strict';\\n\\n  /**\\n   * Provides range control for selecting brush size in free drawing mode.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var BrushSize = function BrushSizeConstructor(drawer) {\\n    // call super constructor\\n    BaseToolOptions.call(this, drawer);\\n\\n    this.name = 'BrushSize';\\n\\n    /**\\n     * Option name. On selecting tool/object, if this.toolName is in array of\\n     * object allowed options - tool will show controls\\n     * @type {String}\\n     */\\n    this.optionName = 'brushSize';\\n\\n    /**\\n     * Size controls element\\n     * @type {Object}\\n     */\\n    this.$sizeControl = null;\\n\\n    // set handlers\\n    drawer.on(drawer.EVENT_BRUSH_SIZE_CHANGED, this.updateValue.bind(this));\\n    drawer.on(drawer.EVENT_BRUSH_CHANGED, this.updateValue.bind(this));\\n  };\\n\\n\\n  BrushSize.prototype = Object.create(BaseToolOptions.prototype);\\n  BrushSize.prototype.constructor = BaseToolOptions;\\n\\n\\n//////////////////////////////////////////////////////////////////////////////////////////\\n    /**\\n     * Creates controls. Is called from BaseToolOptions._onToolbarCreated\\n     * @param  {EaselToolbar} toolbar\\n     */\\n    BrushSize.prototype.createControls = function(toolbar) {\\n        this.createSizeControl(toolbar);\\n    };\\n\\n    /**\\n     * Deletes tool button.\\n     * If  doDeleteToolbarCreationListeners is true - removes listenin on toolbar creation event.\\n     * So, tool will not appear on toolbar next time, when toolbar is created.\\n     *\\n     * @param {boolean} doDeleteToolbarCreationListeners\\n     */\\n    BrushSize.prototype.removeTool = function(doDeleteToolbarCreationListeners) {\\n        this.$sizeControl.remove();\\n\\n        // stop listening toolbar creation\\n        if (doDeleteToolbarCreationListeners) {\\n            this.drawer.off(this.drawer.EVENT_OPTIONS_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n        }\\n    };\\n\\n\\n  /**\\n   * Create controls.\\n   * @param  {EaselToolbar} toolbar to add control to\\n   */\\n  BrushSize.prototype.createSizeControl = function (toolbar) {\\n    var _this = this;\\n\\n    _this.$sizeControl = $(\\n      '<li style=\\\"display:none\\\" ' +\\n          'class=\\\"editable-canvas-brushsize toolbar-item-range list-item-range\\\"' +\\n      '>' +\\n        '<div class=\\\"toolbar-item-description\\\">' +\\n          '<span class=\\\"toolbar-label\\\">' +\\n          this.drawer.t('Size:') + ' ' +\\n          '</span>' +\\n          '<span class=\\\"toolbar-label toolbar-label-indicator editable-canvas-brushsize-indicator\\\">' +\\n            '0px' +\\n          '</span>' +\\n        '</div>' +\\n        '<input class=\\\"editable-canvas-brushsize-input\\\" ' +\\n               'type=\\\"range\\\" name=\\\"drawer-size\\\" min=\\\"1\\\"' +\\n               'value=\\\"0\\\" />' +\\n        '</li>');\\n\\n    toolbar.addControl(_this.$sizeControl, this.options.buttonOrder);\\n\\n    $(_this.$sizeControl).on('change', function () {\\n      var size = $(_this.$sizeControl).find('input').val();\\n      $(_this.$sizeControl).find('.editable-canvas-brushsize-indicator')\\n        .text(size + 'px');\\n      _this.drawer.setBrushSize(size);\\n    });\\n  };\\n\\n\\n  BrushSize.prototype.showControls = function() {\\n      this.updateValue();\\n      this.$sizeControl.show();\\n  };\\n\\n  BrushSize.prototype.hideControls = function() {\\n      this.$sizeControl.hide();\\n  };\\n\\n\\n  /**\\n   * Update size control with current drawer brush size.\\n   */\\n  BrushSize.prototype.updateValue = function () {\\n    var size = this.drawer.getBrushSize();\\n    this.$sizeControl.find('input').val(size);\\n    this.$sizeControl.find('.editable-canvas-brushsize-indicator')\\n      .text(size + 'px');\\n  };\\n\\n  pluginsNamespace.BrushSize = BrushSize;\\n\\n}(jQuery, Easel.plugins, Easel.plugins.BaseToolOptions));\\n\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-text-styles/TextDecoration.js\"))","module.exports = \"(function ($, BaseBrush, pluginsNamespace, util) {\\n  /**\\n   * Provides a a simple eraser button which activates free drawing mode and\\n   * makes a brush with white color.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {number} options.brushSize\\n   * Eraser default brush size\\n   *\\n   * @param {String} options.cursorUrl\\n   * Custom CSS url for eraser cursor.\\n   *\\n   * Example:\\n   * <code><pre>url(path/to/cursor.cur), default</pre></code>\\n   *\\n   * Note the word 'default' at the end: that is the name of cursor that will\\n   * be used when url is unavailable.\\n   *\\n   * More information about css cursor property could be found here:\\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}\\n   *\\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}\\n   *\\n   * @memberof Easel.plugins\\n   * @augments Easel.plugins.BaseBrush\\n   * @constructor\\n   */\\n  var SimpleWhiteEraser = function SimpleWhiteEraserPlugin(drawerInstance,\\n                                                           options) {\\n    var _this = this;\\n\\n    BaseBrush.call(_this, drawerInstance);\\n\\n    this.name = 'SimpleWhiteEraser';\\n    this.btnClass = 'btn-simple-eraser';\\n    this.faClass = 'fa-eraser';\\n    this.tooltip = drawerInstance.t('SimpleWhiteEraser');\\n\\n    _this._defaultOptions = {\\n      brushSize: 3,\\n      cursorUrl: 'eraser'\\n    };\\n\\n    this._setupOptions(options);\\n\\n    if (_this.options.cursorUrl == 'eraser') {\\n      var drawerFolderUrl = util.getEaselFolderUrl();\\n      if(drawerFolderUrl){\\n        _this.options.cursorUrl = 'url(' + drawerFolderUrl +\\n        'assets/cursor-fa-eraser.cur), default';\\n      }\\n    }\\n\\n    /**\\n     * Color value before eraser tool.\\n     * @type {String}\\n     */\\n    this.previousColor = null;\\n\\n    /**\\n     * BrushSize before eraser tool. Used to separate eraser brush size from\\n     * other brushes.\\n     * @type {Number}\\n     */\\n    this.previousBrushSize = null;\\n\\n    /**\\n     * Last used eraser brush size. Used to restore eraser size after another\\n     * brush tool.\\n     * @type {Number}\\n     */\\n    this.savedBrushSize = this.options.brushSize;\\n  };\\n\\n  SimpleWhiteEraser.prototype = Object.create(BaseBrush.prototype);\\n  SimpleWhiteEraser.prototype.constructor = SimpleWhiteEraser;\\n\\n  /**\\n   * This method is called in BaseBrush._activateTool()\\n   * Children of BaseBrush MUST implement afterActivateTool().e\\n   */\\n  SimpleWhiteEraser.prototype.afterActivateTool = function () {\\n    this.previousColor = this.drawerInstance.fCanvas.freeDrawingBrush.color;\\n    this.drawerInstance.fCanvas.freeDrawingBrush.color = '#fff';\\n    this.drawerInstance.fCanvas.freeDrawingBrush.fill = '#fff';\\n    this.drawerInstance.fCanvas.freeDrawingBrush.opacity = this.drawerInstance.activeOpacity;\\n\\n    this._previousCursor = this.drawerInstance.fCanvas.freeDrawingCursor;\\n    this.drawerInstance.fCanvas.freeDrawingCursor = this.options.cursorUrl;\\n\\n    this.previousBrushSize = this.drawerInstance.freeDrawingBrushSize;\\n    this.drawerInstance.setFreeDrawingBrushSize(this.savedBrushSize);\\n  };\\n\\n  /**\\n   * This method is called in BaseBrush._deactivateTool()\\n   * Children of BaseBrush MUST implement afterDeactivateTool().\\n   */\\n  SimpleWhiteEraser.prototype.afterDeactivateTool = function () {\\n    this.drawerInstance.fCanvas.freeDrawingCursor = this._previousCursor;\\n    this.drawerInstance.fCanvas.freeDrawingBrush.color = this.previousColor;\\n    this.drawerInstance.fCanvas.freeDrawingBrush.fill = this.previousColor;\\n\\n    this.savedBrushSize = this.drawerInstance.freeDrawingBrushSize;\\n    this.drawerInstance.setFreeDrawingBrushSize(this.previousBrushSize);\\n  };\\n\\n  pluginsNamespace.SimpleWhiteEraser = SimpleWhiteEraser;\\n\\n}(jQuery, Easel.plugins.BaseBrush, Easel.plugins, Easel.util));\"","module.exports = \"(function (window, $, util, utilPlugins) {\\n  'use strict';\\n\\n  /**\\n   * @typeDef {Object} returnObj\\n   * @memberOf Easel.utilPlugins.TooltipManager\\n   * @property {TooltipManager} instance - instance of tooltip manager\\n   * @property {TooltipManager#createTooltip} createTooltip - Create tooltip\\n   * @property {TooltipManager#removeAllTooltips} removeAllTooltips - Destroy all tooltips and all attached events\\n   * @property {TooltipManager#hideAllTooltips} hideAllTooltips - Hide all tooltips\\n   **/\\n\\n  /**\\n   * Provides ability for Easel to create/use tooltips.\\n   * @param {Easel} drawer - trigger element\\n   * @param {TooltipManager.defaultOptions} [options] - configuration object\\n   * @returns {Easel.utilPlugins.TooltipManager.returnObj}\\n   * @memberOf Easel.utilPlugins\\n   * @constructs TooltipManager\\n   */\\n  var TooltipManager = function (drawer, options) {\\n    this.drawerInstance = drawer;\\n\\n    this._setupOptions(options);\\n    this._processOptions();\\n    this._createHelperElements();\\n    this._attachEaselEventHandlers();\\n    this._attachEventHandlers();\\n\\n    return {\\n      instance: this,\\n      createTooltip: this.createTooltip.bind(this)\\n    };\\n  };\\n\\n  /**\\n   * @memberOf Easel.utilPlugins.TooltipManager\\n   * @typeDef {Object} defaultOptions\\n   * @property {Object} [style] - Allows css customizations of buttons tooltips. Could be any valid css object\\n   *\\n   **/\\n\\n  /**\\n   *\\n   * @type {Easel.utilPlugins.TooltipManager.defaultOptions}\\n   * @private\\n   */\\n  TooltipManager.prototype._defaultOptions = {\\n    tooltipCss: {}\\n  };\\n\\n  /**\\n   * Array of tooltip instances\\n   * @type {Array}\\n   * @private\\n   */\\n  TooltipManager.prototype._tooltipInstances = [];\\n\\n  /**\\n   * Setup options\\n   * @param {Easel.utilPlugins.TooltipManager.defaultOptions | Object} [options] - Configuration object\\n   * @returns {Easel.utilPlugins.TooltipManager.defaultOptions}\\n   * @private\\n   */\\n  TooltipManager.prototype._setupOptions = function (options) {\\n    var optionsFromEasel = {\\n      styleObj: this.drawerInstance.options.tooltipCss\\n    };\\n    this.options = $.extend(true, {}, this._defaultOptions || {}, optionsFromEasel, options || {});\\n    this._initialOptions = $.extend(true, {}, options);\\n    return this.options;\\n  };\\n\\n  /**\\n   * Process options\\n   * @private\\n   */\\n  TooltipManager.prototype._processOptions = function () {\\n\\n  };\\n\\n\\n  /**\\n   * Create new tooltip(s)\\n   * @param {jQuery} elements\\n   * @param {Easel.utilPlugins.Tooltip.defaultOptions} [options]\\n   * @returns {Easel.utilPlugins.Tooltip[]}\\n   */\\n  TooltipManager.prototype.createTooltip = function (elements, options) {\\n    elements = elements || [];\\n    var self = this,\\n        newInstances = [],\\n        newTooltip,\\n        optionsForTooltip = $.extend(true, {}, this.options, options || {});\\n    elements.each(function (i, element) {\\n      newTooltip = new utilPlugins.Tooltip(element, optionsForTooltip);\\n      self._tooltipInstances.push(newTooltip);\\n      newInstances.push(newTooltip);\\n    });\\n    return newInstances;\\n  };\\n\\n  /**\\n   * Destroy all tooltips and all attached events\\n   */\\n  TooltipManager.prototype.removeAllTooltips = function () {\\n    this._tooltipInstances.forEach(function (tooltip) {\\n      tooltip.destroy();\\n    });\\n    this._tooltipInstances = [];\\n  };\\n\\n  /**\\n   * Hide all tooltips\\n   */\\n  TooltipManager.prototype.hideAllTooltips = function () {\\n    this._tooltipInstances.forEach(function (tooltip) {\\n      tooltip.hideTooltip();\\n    });\\n  };\\n\\n  /**\\n   * Remove helper elements such as tooltip container\\n   * @private\\n   */\\n  TooltipManager.prototype._removeHelperElements = function () {\\n    if (this.drawerInstance.$tooltipContainer && this.drawerInstance.$tooltipContainer.length) {\\n      this.drawerInstance.$tooltipContainer.remove();\\n    }\\n  };\\n\\n  /**\\n   * Create helper elements such as tooltip container\\n   * @private\\n   */\\n  TooltipManager.prototype._createHelperElements = function () {\\n    this._removeHelperElements();\\n    var currEaselInstanceId = this.drawerInstance.id,\\n        tooltipContainerHtml = '' +\\n            '<div ' +\\n            'class=\\\"tooltip-container\\\" ' +\\n            'data-drawer-instance=\\\"' + currEaselInstanceId + '\\\">' +\\n            '</div>';\\n\\n    var $tooltipContainer = $(tooltipContainerHtml),\\n        $body = $('body');\\n\\n    $body.append($tooltipContainer);\\n\\n    this.options.$tooltipWrapper = $tooltipContainer;\\n    this.drawerInstance.$tooltipContainer = $tooltipContainer;\\n  };\\n\\n  /**\\n   * Setup/attach drawer handlers\\n   * @private\\n   */\\n  TooltipManager.prototype._attachEaselEventHandlers = function () {\\n    var self = this;\\n\\n    this.drawerInstance.on(this.drawerInstance.EVENT_CREATE_TOOLTIP, function (fEvent, elements, options) {\\n      return self.createTooltip(elements, options);\\n    });\\n\\n    this.drawerInstance.on(this.drawerInstance.EVENT_HIDE_TOOLTIPS, function () {\\n      self.hideAllTooltips();\\n    });\\n\\n    this.drawerInstance.on(this.drawerInstance.EVENT_DESTROY_TOOLTIPS, function () {\\n      self.removeAllTooltips();\\n    });\\n\\n    this.drawerInstance.on('destroy', function () {\\n      self.removeAllTooltips();\\n    });\\n  };\\n\\n\\n  /**\\n   * Setup/attach event handlers\\n   * @private\\n   */\\n  TooltipManager.prototype._attachEventHandlers = function () {\\n    $('body').off('showTooltip').on('showTooltip', '.tooltip-trigger', function (e) {\\n      var $trigger = $(e.currentTarget),\\n          tooltipInstance = $trigger.data('EaselTooltip');\\n      if (tooltipInstance._firstShow) {\\n        var $toolbarPlaceholder = $trigger.closest('.toolbar-placeholder'),\\n            toolbarPosition = $toolbarPlaceholder.attr('data-position'),\\n            tooltipPosition;\\n        switch (toolbarPosition) {\\n          case ToolbarPlaceholder.prototype.TOP_POSITION :\\n            tooltipPosition = ToolbarPlaceholder.prototype.BOTTOM_POSITION;\\n            break;\\n          case ToolbarPlaceholder.prototype.BOTTOM_POSITION :\\n            tooltipPosition = ToolbarPlaceholder.prototype.TOP_POSITION;\\n            break;\\n          case ToolbarPlaceholder.prototype.LEFT_POSITION :\\n            tooltipPosition = ToolbarPlaceholder.prototype.RIGHT_POSITION;\\n            break;\\n          case ToolbarPlaceholder.prototype.RIGHT_POSITION :\\n            tooltipPosition = ToolbarPlaceholder.prototype.LEFT_POSITION;\\n            break;\\n        }\\n        if (tooltipPosition) {\\n          tooltipInstance.options.position = tooltipPosition;\\n        }\\n      }\\n    });\\n  };\\n\\n  utilPlugins.TooltipManager = TooltipManager;\\n})(window, jQuery, Easel.util, Easel.utilPlugins);\"","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {});\\n\\n  fabric.ErasableArrow = fabric.util.createClass(fabric.Arrow, {\\n    /**\\n     * Type of an object\\n     * @type String\\n     * @default\\n     */\\n    type: 'ErasableArrow',\\n    originX: 'center',\\n    originY: 'center',\\n\\n\\n    /**\\n     * Constructor\\n     * @param {Array} points Array of points\\n     * @param {Object} [options] Options object\\n     * @return {fabric.ErasableArrow}\\n     */\\n    initialize: function (points, options) {\\n      options = options || {};\\n      this.callSuper('initialize', points, options);\\n    },\\n\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\\n     * @return {Object} Objectr representation of an instance\\n     */\\n    toObject: function (propertiesToInclude) {\\n      return this.callSuper('toObject', propertiesToInclude);\\n    },\\n\\n    /**\\n     * @private\\n     * @param {CanvasRenderingContext2D} ctx Context to render on\\n     */\\n    _render: function (ctx) {\\n        this.callSuper('_render', ctx);\\n    }\\n\\n  });\\n\\n  /**\\n   * Returns fabric.Polygon instance from an object representation\\n   * @static\\n   * @memberOf fabric.Polygon\\n   * @param {Object} object Object to create an instance from\\n   * @return {fabric.Polygon} Instance of fabric.Polygon\\n   */\\n  fabric.ErasableArrow.fromObject = function (object) {\\n      // form 'points' array, for first parameter in fabric.ErasableArrow c-tor\\n      var points = [object.x1, object.y1, object.x2, object.y2];\\n      return new fabric.ErasableArrow(points, object);\\n  };\\n\\n\\n  // make our object erasable via ErasableMixin.\\n  fabric.makeObjectErasable(fabric.ErasableArrow);\\n})(typeof exports !== 'undefined' ? exports : this);\\n\"","module.exports = \"(function (global) {\\n\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {}),\\n        extend = fabric.util.object.extend;\\n\\n    /**\\n     * @class\\n     * @extends fabric.Image\\n     */\\n    fabric.ErasableText = fabric.util.createClass(fabric.PText, {\\n        type: 'ErasableText',\\n        isErasable : true,\\n\\n        /**\\n         */\\n        initialize: function (text, options) {\\n            this.callSuper('initialize', text, options);\\n        },\\n    });\\n\\n\\n    /**\\n     * Creates fabric object from data.\\n     * Is async, so always use callback param.\\n     *\\n     * @param objData\\n     * @param {function} callback\\n     */\\n    fabric.ErasableText.fromObject = function (objData/*, callback*/) {\\n        return new fabric.ErasableText(objData.text, objData);\\n    };\\n\\n    // important! set 'ErasableText.async'\\n    // It is already set for the prototype, but if do not set here - it WILL CRASH on image load from object;\\n    // idiotic stuff...\\n    // fabric.ErasableText.async = true;\\n\\n    // make our object erasable via ErasableMixin.\\n    fabric.makeObjectErasable(fabric.ErasableText);\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n    extend = fabric.util.object.extend,\\n    min = fabric.util.array.min,\\n    max = fabric.util.array.max,\\n    toFixed = fabric.util.toFixed;\\n\\n  fabric.PTriangle = fabric.util.createClass(fabric.SegmentablePolygon, {\\n    type: 'PTriangle',\\n    initialize: function (options) {\\n      var _this = this;\\n      options = options || {};\\n\\n      this.width = options.width || 10;\\n      this.height = options.height || 10;\\n\\n      var points = this.makeTriangle(this.width, this.height);\\n\\n      this.callSuper('initialize', points, options);\\n    },\\n    makeTriangle: function (width, height) {\\n      var halfWidth = width / 2;\\n      var halfHeight = height / 2;\\n\\n      var points = [\\n        {x: halfWidth * -1, y: halfHeight},\\n        {x: 0, y: halfHeight * -1},\\n        {x: halfWidth, y: halfHeight}\\n      ];\\n\\n      return [points];\\n    },\\n    _render: function (ctx) {\\n      this.callSuper('_render', ctx);\\n    },\\n    _set: function (key, value) {\\n      var dimensionsChanged = false;\\n      if (key === 'width') {\\n        this.width = value;\\n        dimensionsChanged = true;\\n      }\\n      if (key === 'height') {\\n        this.height = value;\\n        dimensionsChanged = true;\\n      }\\n      if (dimensionsChanged) {\\n        this.points = this.makeTriangle(this.width, this.height);\\n        this.callSuper('_set', 'points', this.points);\\n      }\\n\\n      this.callSuper('_set', key, value);\\n    },\\n    toObject: function (propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        width: this.width,\\n        height: this.height\\n      });\\n    }\\n  });\\n\\n\\n  fabric.PTriangle.fromObject = function (object) {\\n    return new fabric.PTriangle(object, true);\\n  };\\n\\n  fabric.PTriangle.async = false;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-brushSize/BrushSize.js\"))","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/shape-image/ImageToolApi.js\"))","module.exports = \"(function (global) {\\n\\n  'use strict';\\n\\n  var fabric = global.fabric || (global.fabric = {}),\\n    extend = fabric.util.object.extend,\\n    min = fabric.util.array.min,\\n    max = fabric.util.array.max,\\n    toFixed = fabric.util.toFixed;\\n\\n  fabric.PRect = fabric.util.createClass(fabric.SegmentablePolygon, {\\n    type: 'PRect',\\n    initialize: function (options) {\\n      var _this = this;\\n      options = options || {};\\n\\n      this.width = options.width || 10;\\n      this.height = options.height || 10;\\n\\n      var points = this.makeRect(this.width, this.height);\\n\\n      this.callSuper('initialize', points, options);\\n    },\\n    makeRect: function (width, height) {\\n      var halfWidth = width / 2;\\n      var halfHeight = height / 2;\\n\\n      var points = [\\n        {x: halfWidth * -1, y: halfHeight * -1},\\n        {x: halfWidth, y: halfHeight * -1},\\n        {x: halfWidth, y: halfHeight},\\n        {x: halfWidth * -1, y: halfHeight}\\n      ];\\n\\n      return [points];\\n    },\\n    _render: function (ctx) {\\n      this.callSuper('_render', ctx);\\n    },\\n    _set: function (key, value) {\\n      var dimensionsChanged = false;\\n      if (key === 'width') {\\n        this.width = value;\\n        dimensionsChanged = true;\\n      }\\n      if (key === 'height') {\\n        this.height = value;\\n        dimensionsChanged = true;\\n      }\\n      if (dimensionsChanged) {\\n        this.points = this.makeRect(this.width, this.height);\\n        this.callSuper('_set', 'points', this.points);\\n      }\\n\\n      this.callSuper('_set', key, value);\\n    },\\n    toObject: function (propertiesToInclude) {\\n      return extend(this.callSuper('toObject', propertiesToInclude), {\\n        width: this.width,\\n        height: this.height\\n      });\\n    }\\n  });\\n\\n\\n  fabric.PRect.fromObject = function (object) {\\n    return new fabric.PRect(object, true);\\n  };\\n\\n  fabric.PRect.async = false;\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","module.exports = \"(function ($, pluginsNamespace, util) {\\n  var MOUSE_DOWN = util.mouseDown('ShapeContextMenu');\\n  /**\\n   *\\n   * Provides context menu for moving shapes to background-foreground and\\n   * remove them.\\n   *\\n   * @param {Easel.Easel} drawerInstance\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @param {Object} options\\n   * Configuration object.\\n   *\\n   * @param {Object} [options.position.mouse=cursor]\\n   * Defines placement of context menu when working on non-touch screen.\\n   * <br><br>\\n   * Valid values are: <code>cursor</code>, <code>shapeRightBottom</code>,.\\n   *\\n   * @param {Object} [options.position.touch=shapeRightBottom]\\n   * Defines placement of context menu when working on touch screen.\\n   * <br><br>\\n   *\\n   * @param {Function} [options.customFitViewportMethod]\\n   * Custom function to calc coords to fit menu in viewport.\\n   * Arguments : (left, top)\\n   * Returns :  Object with keys {left, top}\\n   * <br><br>\\n   *\\n   * @param {Function} [options.customMenuRenderer]\\n   * Custom function to render context menu.\\n   * Arguments : ()\\n   * Returns :  Object with keys {left, top}\\n   * <br><br>\\n   *\\n   * Valid values are: <code>cursor</code>, <code>shapeRightBottom</code>.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var ShapeContextMenu = function ShapeContextMenuConstructor(drawerInstance, options) {\\n    var _this = this;\\n    _this.drawerInstance = drawerInstance;\\n\\n    this.options = $.extend(true, {}, this._defaultOptions || {}, options || {});\\n    this.left = this.top = 0;\\n\\n    this._bindedOnContextMenu = this._onContextMenu.bind(this);\\n\\n    // using here EVENT_OPTIONS_TOOLBAR_CREATED just to make tool responsive to tools reload,\\n    // tool by itself does not belong to any toolbar\\n    this._bindedSetHandlers = this._setHandlers.bind(this);\\n    drawerInstance.on(drawerInstance.EVENT_OPTIONS_TOOLBAR_CREATED, this._bindedSetHandlers);\\n\\n    drawerInstance.on(drawerInstance.EVENT_EDIT_STOP, this._onEditStop.bind(this));\\n    drawerInstance.on(drawerInstance.EVENT_OBJECT_MOVING, this._onObjectMoved.bind(this));\\n  };\\n\\n\\n  ShapeContextMenu.prototype.eventsNamespace = 'shapeContextMenu';\\n\\n  ShapeContextMenu.prototype._defaultOptions = {\\n      position: {\\n        touch: 'shapeRightBottom', // context menu will be placed at shape's right bottom corner\\n        mouse: 'cursor' // context menu will be placed in the position of click\\n      }\\n    };\\n\\n\\n\\n  ShapeContextMenu.prototype._setHandlers = function () {\\n    if (this.options.customMenuRenderer) {\\n      this.drawerInstance.on(this.drawerInstance.EVENT_CONTEXTMENU + '.' + this.eventsNamespace, this.options.customMenuRenderer);\\n    }\\n    else {\\n      this.drawerInstance.on(this.drawerInstance.EVENT_CONTEXTMENU + '.' + this.eventsNamespace, this._bindedOnContextMenu);\\n\\n      var self = this;\\n      util.bindClick($('body'), 'shapeContextMenu', function () {\\n        self.hideContextMenu();\\n      });\\n    }\\n    this.drawerInstance.$canvasEditContainer.off(MOUSE_DOWN).on(MOUSE_DOWN, this._onMouseDown.bind(this));\\n  };\\n\\n\\n  ShapeContextMenu.prototype._unsetHandlers = function (doDeleteToolbarCreationListeners) {\\n    if (this.options.customMenuRenderer) {\\n      this.drawerInstance.off(this.drawerInstance.EVENT_CONTEXTMENU + '.' + this.eventsNamespace);\\n    }\\n    else {\\n      util.unbindClick($('body'), 'shapeContextMenu');\\n      this.drawerInstance.off(this.drawerInstance.EVENT_CONTEXTMENU + '.' + this.eventsNamespace);\\n\\n      if (doDeleteToolbarCreationListeners) {\\n        this.drawerInstance.off(this.drawerInstance.EVENT_OPTIONS_TOOLBAR_CREATED, this._bindedSetHandlers);\\n      }\\n    }\\n  };\\n\\n\\n  ShapeContextMenu.prototype.removeTool = function (doDeleteToolbarCreationListeners) {\\n      this._unsetHandlers(doDeleteToolbarCreationListeners);\\n  };\\n\\n  ShapeContextMenu.prototype._onObjectMoved = function () {\\n    this.objectWasMoved = true;\\n  };\\n\\n  ShapeContextMenu.prototype._onEditStop = function () {\\n      this._unsetHandlers();\\n  };\\n\\n  ShapeContextMenu.prototype._onMouseDown = function () {\\n    this.objectWasMoved = false;\\n  };\\n\\n  ShapeContextMenu.prototype._onContextMenu = function (event, originalEvent) {\\n    var drawingInProgress = this.drawerInstance.drawingInProgress,\\n        isBrushDrawing = this.drawerInstance.isBrushDrawing,\\n        objectWasMoved = this.objectWasMoved,\\n        ignoreContextMenu = drawingInProgress || isBrushDrawing || objectWasMoved;\\n    if (!ignoreContextMenu) {\\n      if (originalEvent.type.indexOf('touch') > -1) {\\n        originalEvent = originalEvent.originalEvent;\\n      }\\n      this.handleContextMenuEvent(originalEvent);\\n    }\\n  };\\n\\n  /**\\n   * Handles context menu event: finds object by click coordinates, selects\\n   * that object and invokes {@link ShapeContextMenu.showContextMenu()}\\n   *\\n   * @param event mouse right click event or touch.originalEvent\\n   */\\n  ShapeContextMenu.prototype.handleContextMenuEvent = function (event) {\\n    var _this = this,\\n        targetIsCanvas = $(event.target).hasClass('upper-canvas'),\\n        canvasTarget = targetIsCanvas && _this.drawerInstance.fCanvas.findTarget(event),\\n        canvasTargetIsMoving = canvasTarget && canvasTarget.isMoving,\\n        targetCorner = canvasTarget && canvasTarget.__corner,\\n        needToShowContextMenu = canvasTarget && !canvasTargetIsMoving && !targetCorner;\\n    if (needToShowContextMenu) {\\n        _this.drawerInstance.fCanvas.setActiveObject(canvasTarget);\\n        _this.showContextMenu(canvasTarget, event);\\n      }\\n  };\\n\\n  /**\\n   * Shows context menu for specified fabricjs object.\\n   *\\n   * @param fabricItem\\n   * @param event\\n   */\\n  ShapeContextMenu.prototype.showContextMenu = function (fabricItem, event) {\\n    var _this = this;\\n    _this.hideContextMenu();\\n\\n    var eventsNS = _this.eventsNamespace;\\n\\n    _this.$contextMenu = $(\\n      '<ul class=\\\"editable-canvas-shape-context-menu\\\"' +\\n      '></ul>'\\n    );\\n\\n    var $bringForward = $('<li><a>' +\\n      _this.drawerInstance.t('Bring forward') +\\n    '</a></li>');\\n    util.bindClick($bringForward.find('a'), eventsNS, this._bringObjectForward.bind(this, fabricItem));\\n    _this.$contextMenu.append($bringForward);\\n\\n    var $sendBackwards = $('<li><a>' +\\n      _this.drawerInstance.t('Send backwards') +\\n    '</a></li>');\\n    util.bindClick($sendBackwards.find('a'), eventsNS, this._sendObjectBackwards.bind(this, fabricItem));\\n    _this.$contextMenu.append($sendBackwards);\\n\\n    var $bringToFront = $('<li><a>' +\\n      _this.drawerInstance.t('Bring to front') +\\n    '</a></li>');\\n    util.bindClick($bringToFront.find('a'), eventsNS, this._bringObjectToFront.bind(this, fabricItem));\\n\\n    _this.$contextMenu.append($bringToFront);\\n\\n    var $sendToBack = $('<li><a>' +\\n      _this.drawerInstance.t('Send to back') +\\n    '</a></li>');\\n    util.bindClick($sendToBack.find('a'), eventsNS, this._sendObjectToBack.bind(this, fabricItem));\\n\\n    _this.$contextMenu.append($sendToBack);\\n\\n    var $duplicate = $('<li><a>' +\\n    _this.drawerInstance.t('Duplicate') +\\n    '</a></li>');\\n    util.bindClick($duplicate.find('a'), eventsNS, this._duplicateObject.bind(this, fabricItem));\\n    _this.$contextMenu.append($duplicate);\\n\\n    var $remove = $('<li><a>' +\\n      _this.drawerInstance.t('Remove') +\\n    '</a></li>');\\n    util.bindClick($remove.find('a'), eventsNS, this._removeObject.bind(this, fabricItem));\\n    _this.$contextMenu.append($remove);\\n\\n    var paddings = 20;\\n    if (_this.drawerInstance.touchDevice) {\\n      paddings = _this.drawerInstance.options.toolbarSizeTouch;\\n    } else {\\n      paddings = _this.drawerInstance.options.toolbarSize;\\n    }\\n\\n    paddings = paddings / 3;\\n\\n    _this.$contextMenu.find('li > a').each(function (k, v) {\\n      $(v).css({\\n        'padding-top': paddings + 'px',\\n        'padding-bottom': paddings + 'px'\\n      });\\n    });\\n\\n    _this.drawerInstance.$canvasEditContainer.append(_this.$contextMenu);\\n\\n    this._positionMenu(fabricItem, util.getEventPosition(event));\\n  };\\n\\n  /**\\n   * Hides context menu.\\n   */\\n  ShapeContextMenu.prototype.hideContextMenu = function () {\\n    if (this.$contextMenu) {\\n      this.$contextMenu.remove();\\n    }\\n  };\\n\\n\\n  /**\\n   * Set Menu left and top coords.\\n   * @param {number} left\\n   * @param {number} top\\n   */\\n  ShapeContextMenu.prototype.setMenuPosition = function(left, top) {\\n    this.left = Number(left);\\n    this.top  = Number(top);\\n    this.$contextMenu.css('left', left + 'px');\\n    this.$contextMenu.css('top', top + 'px');\\n  };\\n\\n\\n  /**\\n   * Get menu origin.\\n   * @return {Object} object with keys {left, top}\\n   */\\n  ShapeContextMenu.prototype.getMenuPosition = function() {\\n    return {left : this.left, top: this.top};\\n  };\\n\\n\\n  /**\\n   * Calcs menu position based on plugin options. click coords and object coords.\\n   * Then adjusts menu position to fit viewport.\\n   *\\n   * @param  {fabric.Object} fabricItem object for which context menu is called\\n   * @param  {Coords} clickCoords coords of mouse click\\n   */\\n  ShapeContextMenu.prototype._positionMenu = function (fabricItem, clickCoords) {\\n    // calc menu starting point based  on options\\n    var canvasOffset = $(this.drawerInstance.fCanvas.upperCanvasEl).offset();\\n    var left = 0;\\n    var top = 0;\\n\\n    var optionsType = this.drawerInstance.touchDevice ? 'touch' : 'mouse';\\n    var positionOption = this.options.position[optionsType];\\n\\n\\n    if (positionOption == 'shapeRightBottom') {\\n      left = fabricItem.left + fabricItem.width;\\n      top = fabricItem.top + fabricItem.height;\\n    } else if (positionOption == 'cursor') {\\n      left = clickCoords.left - canvasOffset.left + 10;\\n      top = clickCoords.top - canvasOffset.top + 10;\\n    }\\n\\n    var adjustedCoords = {};\\n    if (this.options.customFitViewportMethod) {\\n      adjustedCoords = this.options.customFitViewportMethod(left, top);\\n    } else {\\n      adjustedCoords = this._calcCoordsToFitViewport(left, top);\\n    }\\n\\n    left = adjustedCoords.left;\\n    top  = adjustedCoords.top;\\n\\n    this.setMenuPosition(left, top);\\n  };\\n\\n\\n /**\\n  * Calcualtes new coords for conetx menu to fit in viewport\\n  * @param  {number} left current menu origin left\\n  * @param  {number} top  current menu origin coord\\n  * @return {Object}      returns Object with keys {left, top}\\n  */\\n ShapeContextMenu.prototype._calcCoordsToFitViewport = function (left, top) {\\n    left = Number(left);\\n    top  = Number(top);\\n    // check if bottom edge is not outside viewport\\n    var menuHeight = this.$contextMenu.height();\\n    var canvasHeight = this.drawerInstance.fCanvas.height;\\n    var bottom = top + menuHeight;\\n    if (bottom > canvasHeight) {\\n        top = canvasHeight - menuHeight - 10;\\n    }\\n\\n    var menuWidth = this.$contextMenu.width();\\n    var canvasWidth = this.drawerInstance.fCanvas.width;\\n    var right = left + menuWidth;\\n    if (right > canvasWidth) {\\n        left = canvasWidth - menuWidth - 10;\\n    }\\n\\n    return {left : left, top: top};\\n };\\n\\n\\n  ShapeContextMenu.prototype._bringObjectForward = function(fabricItem) {\\n      this.drawerInstance.api.bringObjectForward(fabricItem);\\n      this.hideContextMenu();\\n      return false;\\n  };\\n\\n  ShapeContextMenu.prototype._sendObjectBackwards = function(fabricItem) {\\n      this.drawerInstance.api.sendObjectBackwards(fabricItem);\\n      this.hideContextMenu();\\n      return false;\\n  };\\n\\n\\n  ShapeContextMenu.prototype._bringObjectToFront = function(fabricItem) {\\n      this.drawerInstance.api.bringObjectToFront(fabricItem);\\n      this.hideContextMenu();\\n      return false;\\n  };\\n\\n\\n  ShapeContextMenu.prototype._sendObjectToBack = function(fabricItem) {\\n      this.drawerInstance.api.sendObjectToBack(fabricItem);\\n      this.hideContextMenu();\\n      return false;\\n  };\\n\\n\\n  ShapeContextMenu.prototype._removeObject = function(fabricItem) {\\n      this.drawerInstance.api.removeObject(fabricItem);\\n      this.hideContextMenu();\\n      return false;\\n  };\\n\\n\\n  ShapeContextMenu.prototype._duplicateObject = function(fabricItem) {\\n      this.drawerInstance.api.duplicateObject(fabricItem);\\n      this.hideContextMenu();\\n      return false;\\n  };\\n\\n\\n  pluginsNamespace.ShapeContextMenu = ShapeContextMenu;\\n}(jQuery, Easel.plugins, Easel.util));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/plugins/option-line-width/LineWidth.js\"))","module.exports = \"(function ($, pluginsNamespace, util) {\\n  \\\"use strict\\\";\\n\\n  /**\\n   * Provides a button to enter fullscreen mode.\\n   *\\n   * @param {Easel.Easel} drawer\\n   * @param {Object} options\\n   * Instance of {@link Easel.Easel}.\\n   *\\n   * @constructor\\n   * @memberof Easel.plugins\\n   */\\n  var Fullscreen = function FullscreenConstructor(drawer, options) {\\n    var _this = this;\\n\\n    /**\\n     * @type {Easel}\\n     */\\n    _this.drawer = drawer;\\n    _this.LOGTAG = _this.name;\\n\\n    _this._setupOptions(options);\\n\\n    _this.previousWidth = null;\\n    _this.previousHeight = null;\\n    _this.previousOffset = null;\\n\\n    _this.$enterButton = null;\\n    _this.$exitButton = null;\\n\\n    _this.onlyForEditing = false;\\n\\n    // set handlers on toolbar creation\\n    this._bindedOnToolbarCreated = this._onToolbarCreated.bind(this);\\n    drawer.on(drawer.EVENT_CONFIG_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n\\n\\n    // befre loading\\n    _this.drawer\\n      .on(_this.drawer.EVENT_EDIT_START, function () {\\n        var dataBeforeFullscreen = _this.drawer\\n          .$imageElement.attr('data-before-fullscreen');\\n\\n        if (dataBeforeFullscreen) {\\n          _this.$enterButton.hide();\\n          _this.$exitButton.show();\\n        } else {\\n          _this.$enterButton.show();\\n          _this.$exitButton.hide();\\n        }\\n\\n      });\\n\\n    _this.drawer.on(_this.drawer.EVENT_EDIT_STOP, function () {\\n      if (_this.onlyForEditing) {\\n        _this.exitFullscreen();\\n      }\\n    });\\n\\n    $(window).on('resize', function(){\\n      if(_this.isInFullscreenMode()){\\n        _this.adjustFullscreenSize();\\n      }\\n    });\\n  };\\n\\n  /**\\n   * Setup data\\n   * @param {Object} [options] - options to save\\n   * @param {String} [pluginName] - name of plugin\\n   * @param {Boolean} [doNotSave] - set true to not save result as this.options\\n   * @returns {Object} config of plugin\\n   */\\n  Fullscreen.prototype._setupOptions = function (options, pluginName, doNotSave) {\\n    pluginName = pluginName || this.name;\\n    var drawer = this.drawerInstance || this.drawer,\\n        optionsFromEasel = drawer && drawer.getPluginConfig(pluginName),\\n        result = $.extend(true,\\n            {},\\n            this._defaultOptions || {},\\n            optionsFromEasel || {},\\n            options || {}\\n        );\\n\\n    if (!doNotSave) {\\n      this.options = result;\\n    }\\n    return result;\\n  };\\n\\n    /**\\n     * On toolbar created - create tool button.\\n     */\\n    Fullscreen.prototype._onToolbarCreated = function (ev, toolbar) {\\n        this.toolbar = toolbar;\\n        var enterButtonConfig = {\\n              buttonOrder: this.options.buttonOrder,\\n              additionalClass: 'btn-fullscreen',\\n              iconClass: 'fa-expand',\\n              tooltipText: this.drawer.t('Enter fullscreen mode'),\\n              clickHandler: this.enterFullscreen.bind(this)\\n            },\\n            exitButtonConfig = {\\n              buttonOrder: this.options.buttonOrder,\\n              additionalClass: 'btn-fullscreen',\\n              iconClass: 'fa-compress',\\n              tooltipText: this.drawer.t('Exit fullscreen mode'),\\n              clickHandler: this.exitFullscreen.bind(this)\\n            };\\n\\n        // add button expand\\n      this.$enterButton = toolbar.addButton(enterButtonConfig);\\n\\n        // add button shrink\\n      this.$exitButton = toolbar.addButton(exitButtonConfig);\\n      this.$exitButton.hide();\\n    };\\n\\n\\n    /**\\n     * Deletes tool button.\\n     * If  doDeleteToolbarCreationListeners is true - removes listeners of toolbar creation event.\\n     * So, tool will not appear on toolbar next time, when toolbar is created.\\n     *\\n     * @param {boolean} doDeleteToolbarCreationListeners\\n     */\\n    Fullscreen.prototype.removeTool = function(doDeleteToolbarCreationListeners) {\\n        if (this.deleteControls) {\\n            this.deleteControls();\\n        }\\n\\n        // stop listening toolbar creation\\n        if (doDeleteToolbarCreationListeners) {\\n            this.drawer.off(this.drawer.EVENT_CONFIG_TOOLBAR_CREATED, this._bindedOnToolbarCreated);\\n        }\\n    };\\n\\n\\n\\n\\n\\n  Fullscreen.prototype.isInFullscreenMode = function () {\\n    var $image = this.drawer.$imageElement;\\n\\n    if ($image.attr('data-before-fullscreen') !== undefined) {\\n      return true;\\n    }\\n\\n    return false;\\n  };\\n\\n  Fullscreen.prototype.adjustFullscreenSize = function () {\\n    var _this = this;\\n    var redactorInstance = _this.drawer.redactorInstance;\\n\\n    var $image = _this.drawer.$imageElement;\\n\\n    var toolbarSize = _this.drawer.options.toolbarSize;\\n\\n    var width = redactorInstance.$box.width() - toolbarSize;\\n    var height = redactorInstance.$box.height() - toolbarSize;\\n\\n    var offset = redactorInstance.$box.offset();\\n\\n    _this.drawer.$canvasEditContainer.css({\\n      'left': offset.left + 'px',\\n      'top': (offset.top + toolbarSize ) + 'px',\\n      'width': width + 'px',\\n      'height': height + 'px'\\n    });\\n\\n    _this.drawer.fCanvas.setWidth(width);\\n    _this.drawer.fCanvas.setHeight(height);\\n\\n    if(!_this.onlyForEditing) {\\n      $image.css({\\n        'position': 'absolute',\\n        'left': '0px',\\n        'top': '0px',\\n        'width': width + 'px',\\n        'height': height + 'px'\\n      });\\n    }\\n  };\\n\\n  Fullscreen.prototype.enterFullscreen = function () {\\n    var _this = this;\\n    var redactorInstance = _this.drawer.redactorInstance;\\n\\n    var $image = _this.drawer.$imageElement;\\n\\n    var toolbarSize = _this.drawer.options.toolbarSize;\\n\\n    // this.drawer.trigger(this.drawer.EVENT_HIDE_TOOLTIPS);\\n\\n    _this.$enterButton.hide();\\n    _this.$exitButton.show();\\n\\n    $image.attr('data-before-fullscreen',\\n      JSON.stringify({\\n        imageCss: {\\n          'position': $image.css('position'),\\n          'display': $image.css('display'),\\n          'left': $image.css('float'),\\n          'top': $image.css('top'),\\n          'margin-left': $image.css('margin-left'),\\n          'margin-right': $image.css('margin-right'),\\n          'width': $image.css('width'),\\n          'height': $image.css('height')\\n        },\\n        canvasCss: {\\n          'width': _this.drawer.width,\\n          'height': _this.drawer.height,\\n          'offset': _this.drawer.$canvasEditContainer.offset()\\n        }\\n      })\\n    );\\n\\n    if (!this.onlyForEditing) {\\n      $image.css('position', 'absolute');\\n    }\\n\\n    _this.adjustFullscreenSize();\\n\\n    if (this.onlyForEditing) {\\n      var duration = util.getTransitionDuration(\\n        _this.drawer.$canvasEditContainer[0]\\n      );\\n\\n      util.setTimeout(function () {\\n        redactorInstance.$box.css('opacity', '0');\\n      }, duration);\\n    }\\n\\n    // @todo: rework this!\\n    _this.drawer.toolbars.toolOptionsToolbar\\n      .removeClass('toolbar-bottomLeft').detach();\\n    _this.drawer\\n      .appendToolbar(_this.drawer.toolbars.toolOptionsToolbar, 'topRight');\\n\\n    _this.drawer.toolbars.setToolbarButtonsSize();\\n    _this.drawer.onCanvasModified();\\n  };\\n\\n  Fullscreen.prototype.exitFullscreen = function () {\\n    var _this = this;\\n    var $image = _this.drawer.$imageElement;\\n\\n    $('.editable-canvas-tooltip').removeClass('active');\\n\\n    _this.$enterButton.show();\\n    _this.$exitButton.hide();\\n\\n    var dataBeforeFullscreenStr = $image.attr('data-before-fullscreen');\\n    var dataBeforeFullscreen = JSON.parse(dataBeforeFullscreenStr);\\n    $image.attr('data-before-fullscreen', null);\\n\\n    if (this.onlyForEditing) {\\n      _this.drawer.redactorInstance.$box.css('opacity', '1');\\n    } else {\\n      $image.css(dataBeforeFullscreen.imageCss);\\n    }\\n\\n    if (_this.drawer.$canvasEditContainer) {\\n      var duration = util.getTransitionDuration(\\n        _this.drawer.$canvasEditContainer[0]\\n      );\\n\\n      var previousWidth = dataBeforeFullscreen.canvasCss.width;\\n      var previousHeight = dataBeforeFullscreen.canvasCss.height;\\n\\n      _this.drawer.$canvasEditContainer.css({\\n        'left': dataBeforeFullscreen.canvasCss.offset.left + 'px',\\n        'top': dataBeforeFullscreen.canvasCss.offset.top + 'px',\\n        'width': previousWidth + 'px',\\n        'height': previousHeight + 'px'\\n      });\\n\\n      _this.drawer.$canvasEditContainer.find('.canvas-container')\\n        .css({\\n          'width': previousWidth + 'px',\\n          'height': previousHeight + 'px'\\n        });\\n\\n      util.setTimeout(function () {\\n        _this.drawer.fCanvas.setWidth(previousWidth);\\n        _this.drawer.fCanvas.setHeight(previousHeight);\\n      }, duration);\\n\\n      _this.drawer.width = previousWidth;\\n      _this.drawer.height = previousHeight;\\n\\n      _this.drawer.adjustEditContainer(true, true);\\n    }\\n\\n    _this.drawer.toolbars.toolOptionsToolbar\\n      .removeClass('toolbar-topRight').detach();\\n    _this.drawer\\n      .appendToolbar(_this.drawer.toolbars.toolOptionsToolbar, 'bottomLeft');\\n\\n    _this.drawer.toolbars.setToolbarButtonsSize();\\n    _this.drawer.onCanvasModified();\\n  };\\n\\n  pluginsNamespace.Fullscreen = Fullscreen;\\n}(jQuery, Easel.plugins, Easel.util));\"","require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/script-loader/addScript.js\")(require(\"!!/home/vmcode/Desktop/Atlas/DrawerJs/node_modules/raw-loader/index.js!/home/vmcode/Desktop/Atlas/DrawerJs/src/toolbars/instances/DrawingToolsToolbar.js\"))","module.exports = \"(function (global) {\\n    'use strict';\\n\\n    var fabric = global.fabric || (global.fabric = {}),\\n        extend = fabric.util.object.extend;\\n\\n\\n    /**\\n     *\\n     * @param {Object[]} eraserPathsData\\n     * @constructor\\n     */\\n    fabric.ErasableMixin = function(objData) {\\n        // clear eraserPaths. Do this, because inside fabric.Object.initialize()\\n        // options properties were merged into 'this', and this.eraserPaths is copy of objData.eraserPaths\\n        this.eraserPaths = [];\\n        if (objData) {\\n            // create eraserPaths from eraserPathsData\\n            this.eraserPaths = this._createEraserPaths(objData.eraserPaths);\\n        }\\n    };\\n\\n\\n    /**\\n     * Initialization of object instance.\\n     * Resets this.eraserPaths, then instantiates array of eraserPaths in it,\\n     * data taken from objData.eraserPaths\\n     *\\n     * @param {Object} objData\\n     */\\n    fabric.ErasableMixin.prototype.initialize = function(objData) {\\n        // add eraserPaths property to object instance\\n        this.eraserPaths = [];\\n\\n        // TODO: do we need this??\\n        if (objData) {\\n            this.eraserPaths = fabric.ErasableMixin.prototype._createEraserPaths.call(this, objData.eraserPaths);\\n            // this.eraserPaths = this._createEraserPaths(objData.eraserPaths);\\n        }\\n    };\\n\\n\\n    /**\\n     * Fills this.eraserPaths with paths, created from objData.eraserPaths\\n     *\\n     * @param {Object[]} eraserPathsData\\n     * @private\\n     */\\n    fabric.ErasableMixin.prototype._createEraserPaths = function(eraserPathsData) {\\n        var eraserPaths = [];\\n        // fill this.eraserPaths with EraserPath objects, created from objData.eraserPaths\\n        if (eraserPathsData) {\\n            eraserPathsData.map(function (p) {\\n                fabric.EraserPath.fromObject(p, function (createdPath) {\\n                    eraserPaths.push(createdPath);\\n                });\\n            });\\n        }\\n        return eraserPaths;\\n    };\\n\\n\\n    /**\\n     *\\n     * @param ctx\\n     */\\n    fabric.ErasableMixin.prototype.render = function ErasableMixinRender (ctx, mainObjectRenderer) {\\n        // get temp canvas\\n        var tempCanvas = Easel.util.getTemporaryCanvas(this.canvas);\\n        var tempContext = tempCanvas.getContext('2d');\\n\\n        // clear rect with size as working canvas\\n        var width = this.canvas.width;\\n        var height = this.canvas.height;\\n        tempContext.clearRect(0, 0, width, height);\\n\\n        // render object in tempContext, (Object._render() will be called)\\n        mainObjectRenderer(tempContext);\\n\\n        // now render erasers on top of object\\n        for (var i = 0; i < this.eraserPaths.length; i++) {\\n            this.eraserPaths[i].globalCompositeOperation = 'destination-out';\\n            this.eraserPaths[i].render(tempContext);\\n        }\\n\\n        // render tempCanvas on working one\\n        ctx.drawImage(tempCanvas, 0, 0);\\n    };\\n\\n\\n    /**\\n     * Add eraser path to object.\\n     * Sets neccessary path properties;\\n     * Sets path angle same as object's,\\n     * to keep path points in same place - rotates them back individually\\n     *\\n     * @param {fabric.Path} path\\n     * @param {Function} callback\\n     */\\n    fabric.ErasableMixin.prototype.addEraserPath = function (srcPath, callback) {\\n        var self = this;\\n        // clone path, modify clone and add it\\n        srcPath.clone(function (clonedPath) {\\n            // eraser path must be non-interactive\\n            clonedPath.set('stroke', 'blue');\\n            clonedPath.selectable = false;\\n            clonedPath.evented = false;\\n\\n            var thisCenter = self.getCenterPoint();\\n            var pathCenter = clonedPath.getCenterPoint();\\n\\n            // eraser path offset to object\\n            clonedPath.polygonOffsetX = pathCenter.x - thisCenter.x;\\n            clonedPath.polygonOffsetY = pathCenter.y - thisCenter.y;\\n\\n            // set path angle same, as angle of object\\n            var a = self.angle;\\n            clonedPath.set({angle : a});\\n\\n            // to keep path points in same place - rotate them by -a\\n            for (var i = 0; i < clonedPath.path.length; i++) {\\n                fabric.ErasableMixin.prototype._rotatePathPoints(clonedPath.path[i], thisCenter, -a);\\n            }\\n\\n            // call to make path be in correct position with object\\n            fabric.ErasableMixin.prototype._updatePathPosition.call(self, clonedPath);\\n\\n            // now add modified clonedPath to list of eraser paths\\n            self.eraserPaths.push(clonedPath);\\n\\n            // call callback\\n            if (callback) {\\n                callback(this);\\n            }\\n        });\\n    };\\n\\n\\n    /**\\n     * Override default _set().\\n     * Updates eraser paths' position, angle and scale,\\n     * to be consistent with changes in object.\\n     *\\n     * @param key\\n     * @param value\\n     * @private\\n     */\\n    fabric.ErasableMixin.prototype._updateEPathsOnSet = function (key, value) {\\n        if (!this.eraserPaths)\\n            return;\\n\\n        var thisCenter = this.getCenterPoint();\\n\\n        for (var p = 0; p < this.eraserPaths.length; p++) {\\n            var ePath = this.eraserPaths[p];\\n\\n            if (!(ePath instanceof fabric.EraserPath)) {\\n                continue;\\n            }\\n\\n            var ePathScaleX = ePath.scaleX, ePathScaleY = ePath.scaleY;\\n            var coeff;\\n\\n            // if object's scaleX has changed - update each ePath individual scaleX\\n            if (key == 'scaleX') {\\n                coeff = value / this.scaleX;\\n                ePathScaleX = ePathScaleX * coeff;\\n                ePath.set('scaleX', ePathScaleX);\\n            }\\n\\n            // if object's scaleY has changed - update each ePath individual scaleY\\n            if (key == 'scaleY') {\\n                coeff = value / this.scaleY;\\n                ePathScaleY = ePathScaleY * coeff;\\n                ePath.set('scaleY', ePathScaleY);\\n            }\\n\\n            // eraser's angle is always same as object's\\n            if (key == 'angle') {\\n                ePath.set('angle', this.angle);\\n            }\\n\\n            fabric.ErasableMixin.prototype._updatePathPosition.call(this, ePath);\\n        }\\n    };\\n\\n\\n    fabric.ErasableMixin.prototype._updatePathPosition = function(ePath) {\\n        var thisCenter = this.getCenterPoint();\\n        var ePathScaleX = ePath.scaleX, ePathScaleY = ePath.scaleY;\\n\\n        // global ePath origin coord = object center coord +  scaled ePath offset\\n        var globalOffsetPointX = thisCenter.x + (ePath.polygonOffsetX * ePathScaleX);\\n        var globalOffsetPointY = thisCenter.y + (ePath.polygonOffsetY * ePathScaleY);\\n\\n        // calc ePath origin offset, respecting rotation\\n        var rotatedPoint = fabric.util.rotatePoint(\\n            new fabric.Point(globalOffsetPointX, globalOffsetPointY),\\n            thisCenter,\\n            fabric.util.degreesToRadians(ePath.angle)\\n        );\\n\\n        ePath.set('left', rotatedPoint.x);\\n        ePath.set('top', rotatedPoint.y);\\n    };\\n\\n   /**\\n     * Rotate all points in path around 'rotationOrigin' by 'angle'\\n     * Iterates through 'data', and makes changes in-place\\n     *\\n     * @param  array data  array with path commands and coords, and coords WILL BE CHANGED\\n     * @param  fabric.Point rotationOrigin\\n     * @param  number angle angle in degrees\\n     *\\n     * @return array\\n     */\\n    fabric.ErasableMixin.prototype._rotatePathPoints = function(data, rotationOrigin, angle) {\\n        var point, rotatedPoint;\\n        var angleRad = fabric.util.degreesToRadians(angle);\\n        var l = data.length;\\n        for (var i = 0; i < l; i++) {\\n            // skip non-numeric\\n            if (typeof data[i] != 'number')\\n                continue;\\n\\n            // if data[i] is number, then it and next number are coords of point in path:\\n            // data[i] -> x, data[i + 1] -> y\\n            point = new fabric.Point(data[i], data[i + 1]);\\n\\n            // rotate point around rotationOrigin\\n            rotatedPoint = fabric.util.rotatePoint(point, rotationOrigin, angleRad);\\n\\n            // write rotatedPoint coords back in data[]\\n            data[i] = rotatedPoint.x;\\n            data[i + 1] = rotatedPoint.y;\\n\\n            // jump to next pair\\n            i++;\\n        }\\n\\n        return data;\\n    };\\n\\n\\n    /**\\n     * Returns object representation of an instance\\n     * @return {Object} Object representation of an instance\\n     */\\n    fabric.ErasableMixin.prototype.toObject = function () {\\n        var o =  { eraserPaths : this.eraserPaths.map(function (p) {\\n            return p.toObject();\\n        })\\n        };\\n        return o;\\n    };\\n\\n\\n    /**\\n     * Returns fabric.ErasableObject instance from an object representation\\n     *\\n     * @static\\n     * @memberOf fabric.Polygon\\n     * @param {Object} objectData Object to create an instance from\\n     * @return {fabric.ErasableObject} Instance of fabric.ErasableObject\\n     */\\n    fabric.ErasableMixin.prototype.fromObject = function (objectData) {\\n        this.eraserPaths = fabric.ErasableMixin.prototype._createEraserPaths(objectData.eraserPaths);\\n        return this;\\n    };\\n\\n\\n    /**\\n     * @param {fabric.Object} obj\\n     */\\n    fabric.makeObjectErasable = function(obj) {\\n        var mixin = new fabric.ErasableMixin();\\n\\n        // will be used in Eraser to determine, which objects are erasable\\n        obj.prototype.isErasable = true;\\n\\n        var objInitialize = obj.prototype.initialize;\\n        obj.prototype.initialize = function() {\\n            // first call object initialize() with arguments\\n            objInitialize.apply(this, arguments);\\n            // then call mixin initialize()\\n            mixin.initialize.apply(this, arguments);\\n        };\\n\\n        obj.prototype.addEraserPath = function(path) {\\n            mixin.addEraserPath.call(this, path);\\n        };\\n\\n        var oldRender = obj.prototype.render;\\n        obj.prototype.render = function(ctx) {\\n            mixin.render.call(this, ctx, oldRender.bind(this));   // then render eraser paths\\n        };\\n\\n        var oldSet = obj.prototype._set;\\n        obj.prototype._set = function(key, value) {\\n            mixin._updateEPathsOnSet.call(this, key, value);   // first update eraserPaths\\n            oldSet.call(this, key, value);  // then call original _set() of object\\n        };\\n\\n\\n        // fromObject - special case. It is part of obj, not its prototype\\n        var oldFromObject = obj.fromObject;\\n          obj.fromObject = function(objData, callback) {\\n            if (this.async) {\\n                // first call fromObject() of object\\n                oldFromObject.call(this, objData,\\n                    function(createdObject){\\n                        // then call ErasableMixin.fromObject to instantiate eraserPath\\n                        var objWithErasers = mixin.fromObject.call(createdObject, objData);\\n                        if(callback) {\\n                          callback(objWithErasers);\\n                        }\\n                    });\\n            } else {\\n                // first call fromObject() of object\\n                var createdObject = oldFromObject.call(this, objData);\\n                // then call ErasableMixin.fromObject to instantiate eraserPath\\n                var objWithErasers = mixin.fromObject.call(createdObject, objData);\\n\\n                return objWithErasers;\\n            }\\n        };\\n\\n\\n        var oldToObject = obj.prototype.toObject;\\n        obj.prototype.toObject = function() {\\n            // first call oldToObject () of object\\n            var objData = oldToObject.call(this);\\n            // then extend result with\\n            extend(objData, mixin.toObject.call(this));\\n\\n            return objData;\\n        };\\n    };\\n\\n\\n})(typeof exports !== 'undefined' ? exports : this);\"","module.exports = \"if (!this.Easel) {\\n  this.Easel = {};\\n}\\n\\nthis.Easel.clipping = {};\\n\\n(function (namespace) {\\n  \\\"use strict\\\";\\n\\n  namespace.runClippingOperation = function (params) {\\n    var firstShape = params.firstShape;\\n    var secondShape = params.secondShape;\\n\\n    var polyPoints = prepareForClipper(\\n      firstShape.width, firstShape.currentWidth,\\n      firstShape.height, firstShape.currentHeight,\\n      firstShape.center, firstShape.angleInRadians, firstShape.points);\\n\\n    // TODO: another shape angle and scaling needed\\n    var anotherShapePointsGlobal =\\n      localToGlobal(secondShape.center, secondShape.points);\\n\\n    var solution = processShape(params.cmd, polyPoints,\\n      uppercaseCoords(anotherShapePointsGlobal));\\n\\n    if (secondShape.centersQueue) {\\n      for (var i = 0; i < secondShape.centersQueue.length; i++) {\\n\\n        anotherShapePointsGlobal = localToGlobal(\\n          secondShape.centersQueue[i], secondShape.points\\n        );\\n\\n        solution = processShape(\\n          params.cmd, solution, uppercaseCoords(anotherShapePointsGlobal)\\n        );\\n      }\\n    }\\n\\n    solution = ClipperLib.JS.Lighten(solution, 0.1);\\n\\n    var result = null;\\n\\n    if (solution.length > 0) {\\n      result = restoreAfterClipper(\\n        firstShape.currentWidth, firstShape.width,\\n        firstShape.currentHeight, firstShape.height,\\n        firstShape.center, firstShape.angleInRadians * -1, solution);\\n    }\\n\\n    return result;\\n  };\\n\\n\\n  var processShape = function (cmd, firstShapePoints, secondShapePoints) {\\n    var solution = new ClipperLib.Paths();\\n    var c = new ClipperLib.Clipper();\\n\\n    c.AddPaths(firstShapePoints,\\n      ClipperLib.PolyType.ptSubject, true\\n    );\\n\\n    c.AddPaths(secondShapePoints,\\n      ClipperLib.PolyType.ptClip, true\\n    );\\n    c.Execute(cmd, solution);\\n\\n    return solution;\\n  };\\n\\n  var localToGlobal = function (center, pointsSegments) {\\n    var result = [];\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        segmentResult.push({\\n          x: center.x + pointsSegments[s][p].x,\\n          y: center.y + pointsSegments[s][p].y\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n  var globalToLocal = function (center, pointsSegments) {\\n    var result = [];\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        segmentResult.push({\\n          x: pointsSegments[s][p].x - center.x,\\n          y: pointsSegments[s][p].y - center.y\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n  var rotatePoints = function (pointsSegments, center, angle) {\\n    var result = [];\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        var point = new fabric.Point(pointsSegments[s][p].x,\\n          pointsSegments[s][p].y\\n        );\\n        var rotatedPoint = fabric.util.rotatePoint(point, center, angle);\\n        segmentResult.push({\\n          x: rotatedPoint.x,\\n          y: rotatedPoint.y\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n  var uppercaseCoords = function (pointsSegments) {\\n    var result = [];\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        segmentResult.push({\\n          X: pointsSegments[s][p].x,\\n          Y: pointsSegments[s][p].y\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n  var lowercaseCoords = function (pointsSegments) {\\n    var result = [];\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        segmentResult.push({\\n          x: pointsSegments[s][p].X,\\n          y: pointsSegments[s][p].Y\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n  var scaleCoords = function (originalWidth, scaledWidth,\\n                              originalHeight, scaledHeight, pointsSegments) {\\n    var result = [];\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        var x = pointsSegments[s][p].x;\\n        var y = pointsSegments[s][p].y;\\n\\n        var originalWidthPercent = x * 100 / originalWidth;\\n        var newX = originalWidthPercent * scaledWidth / 100;\\n\\n        var originalHeightPercent = y * 100 / originalHeight;\\n        var newY = originalHeightPercent * scaledHeight / 100;\\n\\n        segmentResult.push({\\n          x: newX,\\n          y: newY\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n  var prepareForClipper = function (originalWidth, scaledWidth,\\n                                    originalHeight, scaledHeight,\\n                                    centerPoint, rotationAngleInRadians,\\n                                    pointsSegments) {\\n    var result = [];\\n    var sin = Math.sin(rotationAngleInRadians),\\n      cos = Math.cos(rotationAngleInRadians);\\n\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        var x = pointsSegments[s][p].x;\\n        var y = pointsSegments[s][p].y;\\n\\n        // --- scale ---\\n        var originalWidthPercent = x * 100 / originalWidth;\\n        var newX = originalWidthPercent * scaledWidth / 100;\\n\\n        var originalHeightPercent = y * 100 / originalHeight;\\n        var newY = originalHeightPercent * scaledHeight / 100;\\n        // --- /scale ---\\n\\n        // ---- local to global ----\\n        newX = centerPoint.x + newX;\\n        newY = centerPoint.y + newY;\\n        // ---- /local to global ----\\n\\n\\n        // ---- rotation angle ----\\n        // we could not use fabric point here because it's needed to be constructed\\n        // with memory allocation but that is bad idea for large data processing\\n        newX -= centerPoint.x;\\n        newY -= centerPoint.y;\\n\\n        var rx = newX * cos - newY * sin,\\n          ry = newX * sin + newY * cos;\\n\\n        newX = rx += centerPoint.x;\\n        newY = ry += centerPoint.y;\\n        // ---- /rotation angle ----\\n\\n        segmentResult.push({\\n          X: newX,\\n          Y: newY\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n  var restoreAfterClipper = function (originalWidth, scaledWidth,\\n                                      originalHeight, scaledHeight,\\n                                      centerPoint, rotationAngleInRadians,\\n                                      pointsSegments) {\\n    var result = [];\\n    var sin = Math.sin(rotationAngleInRadians),\\n      cos = Math.cos(rotationAngleInRadians);\\n\\n    for (var s = 0; s < pointsSegments.length; s++) {\\n      var segmentResult = [];\\n      for (var p = 0; p < pointsSegments[s].length; p++) {\\n        var x = pointsSegments[s][p].X;\\n        var y = pointsSegments[s][p].Y;\\n\\n        // ---- rotation angle ----\\n        // we could not use fabric point here because it's needed to be constructed\\n        // with memory allocation but that is bad idea for large data processing\\n        x -= centerPoint.x;\\n        y -= centerPoint.y;\\n\\n        var rx = x * cos - y * sin,\\n          ry = x * sin + y * cos;\\n\\n        x = rx += centerPoint.x;\\n        y = ry += centerPoint.y;\\n        // ---- /rotation angle ----\\n\\n        // ---- local to global ----\\n        x = x - centerPoint.x;\\n        y = y - centerPoint.y;\\n        // ---- /local to global ----\\n\\n        // --- scale ---\\n        var originalWidthPercent = x * 100 / originalWidth;\\n        x = originalWidthPercent * scaledWidth / 100;\\n\\n        var originalHeightPercent = y * 100 / originalHeight;\\n        y = originalHeightPercent * scaledHeight / 100;\\n        // --- /scale ---\\n\\n        segmentResult.push({\\n          x: x,\\n          y: y\\n        });\\n      }\\n      result.push(segmentResult);\\n    }\\n    return result;\\n  };\\n\\n})(Easel.clipping);\"","module.exports = \"/**\\n * Toolbar where will be buttons for image cropper\\n *\\n * @param {Easel.Easel} drawerInstance\\n * @param {Object} [options]\\n * @extends EaselToolbar\\n * @constructor\\n */\\nvar CropImageToolbar = function (drawerInstance, options) {\\n  options = options || {};\\n  options.toolbarClass = 'tool-cropimage hidden';\\n  // call super c-tor\\n  EaselToolbar.call(this, drawerInstance, options);\\n\\n  // create default buttons for toolbar\\n  this._createDefaultButtons();\\n\\n  // Trigger event\\n  drawerInstance.trigger(drawerInstance.EVENT_IMAGECROP_TOOLBAR_CREATED, [this]);\\n};\\n\\nCropImageToolbar.prototype = Object.create(EaselToolbar.prototype);\\nCropImageToolbar.prototype.constructor = EaselToolbar;\\n\\n\\n/**\\n * Creates defaults buttons.\\n */\\nCropImageToolbar.prototype._createDefaultButtons = function() {\\n};\"","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;","\"use strict\";\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;","/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = \"\" + maybeKey);\n  void 0 !== config.key && (key = \"\" + config.key);\n  if (\"key\" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      \"key\" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nc = undefined;","\n      import API from \"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../node_modules/css-loader/dist/cjs.js!./easel.min.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../node_modules/css-loader/dist/cjs.js!./easel.min.css\";\n       export default content && content.locals ? content.locals : undefined;\n","import React, { useEffect, useRef, useImperativeHandle, forwardRef } from 'react';\nimport '../dist/easel.standalone.min.js';\nimport '../dist/easel.min.css';\n\n/**\n * EaselCanvas - React component wrapper for Easel drawing library\n * \n * @component\n * @example\n * ```jsx\n * import { EaselCanvas } from 'easel';\n * \n * function App() {\n *   const easelRef = useRef();\n *   \n *   const handleSave = () => {\n *     const imageData = easelRef.current.getImageDataUrl();\n *     console.log(imageData);\n *   };\n *   \n *   return (\n *     <EaselCanvas\n *       ref={easelRef}\n *       width={800}\n *       height={600}\n *       toolbars={{\n *         drawingTools: { position: 'top' }\n *       }}\n *       onSave={handleSave}\n *     />\n *   );\n * }\n * ```\n */\nconst EaselCanvas = forwardRef((props, ref) => {\n  const {\n    // Canvas dimensions\n    width = 800,\n    height = 600,\n    \n    // Easel configuration options\n    toolbars = {},\n    plugins = [],\n    defaultActivePlugin = null,\n    \n    // Canvas options\n    backgroundColor = '#FFFFFF',\n    transparentBackground = false,\n    \n    // Toolbar options\n    toolbarSize = 32,\n    toolbarSizeTouch = 48,\n    \n    // Feature flags\n    fullscreenMode = false,\n    selectMode = true,\n    \n    // Event handlers\n    onChange = null,\n    onSave = null,\n    onObjectAdded = null,\n    onObjectModified = null,\n    onObjectRemoved = null,\n    onSelectionCreated = null,\n    onSelectionCleared = null,\n    \n    // Custom options - spread any additional options\n    ...customOptions\n  } = props;\n\n  const containerRef = useRef(null);\n  const easelInstanceRef = useRef(null);\n\n  // Initialize Easel instance\n  useEffect(() => {\n    if (!containerRef.current || !window.Easel) {\n      console.error('Easel library not loaded or container not ready');\n      return;\n    }\n\n    // Prepare configuration\n    const easelConfig = {\n      ...customOptions,\n      canvasWidth: width,\n      canvasHeight: height,\n      toolbars,\n      plugins,\n      defaultActivePlugin,\n      backgroundColor,\n      transparentBackground,\n      toolbarSize,\n      toolbarSizeTouch,\n      fullscreenMode,\n      selectMode,\n    };\n\n    // Create Easel instance\n    try {\n      const easelInstance = new window.Easel(containerRef.current, easelConfig);\n      easelInstanceRef.current = easelInstance;\n\n      // Attach event handlers\n      if (onChange) {\n        easelInstance.on('canvas:changed', onChange);\n      }\n      if (onSave) {\n        easelInstance.on('canvas:save', onSave);\n      }\n      if (onObjectAdded) {\n        easelInstance.on('object:added', onObjectAdded);\n      }\n      if (onObjectModified) {\n        easelInstance.on('object:modified', onObjectModified);\n      }\n      if (onObjectRemoved) {\n        easelInstance.on('object:removed', onObjectRemoved);\n      }\n      if (onSelectionCreated) {\n        easelInstance.on('selection:created', onSelectionCreated);\n      }\n      if (onSelectionCleared) {\n        easelInstance.on('selection:cleared', onSelectionCleared);\n      }\n\n    } catch (error) {\n      console.error('Failed to initialize Easel:', error);\n    }\n\n    // Cleanup on unmount\n    return () => {\n      if (easelInstanceRef.current) {\n        try {\n          easelInstanceRef.current.destroy();\n        } catch (error) {\n          console.error('Error destroying Easel instance:', error);\n        }\n        easelInstanceRef.current = null;\n      }\n    };\n  }, []); // Empty dependency array - only initialize once\n\n  // Update dimensions if they change\n  useEffect(() => {\n    if (easelInstanceRef.current && easelInstanceRef.current.api) {\n      try {\n        easelInstanceRef.current.api.setSize(width, height);\n      } catch (error) {\n        console.error('Error updating Easel size:', error);\n      }\n    }\n  }, [width, height]);\n\n  // Expose methods via ref\n  useImperativeHandle(ref, () => ({\n    // Get the raw Easel instance\n    getInstance: () => easelInstanceRef.current,\n    \n    // Common API methods\n    getImageDataUrl: (format = 'png', quality = 1.0) => {\n      if (!easelInstanceRef.current || !easelInstanceRef.current.api) {\n        return null;\n      }\n      return easelInstanceRef.current.api.getImageDataUrl(format, quality);\n    },\n    \n    getImageBlob: (callback, format = 'png', quality = 1.0) => {\n      if (!easelInstanceRef.current || !easelInstanceRef.current.api) {\n        return;\n      }\n      easelInstanceRef.current.api.getImageBlob(callback, format, quality);\n    },\n    \n    loadImage: (imageData) => {\n      if (!easelInstanceRef.current || !easelInstanceRef.current.api) {\n        return;\n      }\n      easelInstanceRef.current.api.loadImage(imageData);\n    },\n    \n    clear: () => {\n      if (!easelInstanceRef.current || !easelInstanceRef.current.api) {\n        return;\n      }\n      easelInstanceRef.current.api.clearCanvas();\n    },\n    \n    setBackgroundColor: (color) => {\n      if (!easelInstanceRef.current || !easelInstanceRef.current.api) {\n        return;\n      }\n      easelInstanceRef.current.api.setBackgroundColor(color);\n    },\n    \n    setSize: (w, h) => {\n      if (!easelInstanceRef.current || !easelInstanceRef.current.api) {\n        return;\n      }\n      easelInstanceRef.current.api.setSize(w, h);\n    },\n    \n    undo: () => {\n      if (!easelInstanceRef.current) {\n        return;\n      }\n      easelInstanceRef.current.undo();\n    },\n    \n    redo: () => {\n      if (!easelInstanceRef.current) {\n        return;\n      }\n      easelInstanceRef.current.redo();\n    },\n    \n    activatePlugin: (pluginName) => {\n      if (!easelInstanceRef.current) {\n        return;\n      }\n      easelInstanceRef.current.trigger('canvas:tool:activated', pluginName);\n    },\n    \n    // Fabric.js canvas access\n    getFabricCanvas: () => {\n      if (!easelInstanceRef.current || !easelInstanceRef.current.fCanvas) {\n        return null;\n      }\n      return easelInstanceRef.current.fCanvas;\n    },\n  }));\n\n  return (\n    <div \n      ref={containerRef}\n      className=\"easel-react-wrapper\"\n      style={{ \n        width: '100%', \n        height: '100%',\n        position: 'relative'\n      }}\n    />\n  );\n});\n\nEaselCanvas.displayName = 'EaselCanvas';\n\nexport default EaselCanvas;\n","/**\n * Easel React Component Library\n * \n * A React wrapper for the Easel drawing canvas library.\n * Provides a declarative React interface for creating drawing canvases.\n * \n * @module easel-react\n */\n\nimport EaselCanvas from './EaselCanvas.jsx';\n\n// Export the main component\nexport default EaselCanvas;\nexport { EaselCanvas };\n\n// Export helper functions if needed\nexport const createEaselInstance = (container, options) => {\n  if (typeof window !== 'undefined' && window.Easel) {\n    return new window.Easel(container, options);\n  }\n  console.error('Easel library not loaded');\n  return null;\n};\n\nexport const version = '1.2.0';\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__12__","styleElement","nonce","setAttribute","stylesInDOM","getIndexByIdentifier","identifier","result","i","length","modulesToDom","list","options","idCountMap","identifiers","item","id","base","count","concat","indexByIdentifier","obj","css","media","sourceMap","supports","layer","references","updater","addElementStyle","byIndex","splice","push","api","domAPI","update","newObj","remove","lastIdentifiers","newList","index","newLastIdentifiers","_i","_index","styleSheet","cssText","firstChild","removeChild","appendChild","document","createTextNode","cssWithMappingToString","toString","map","content","needLayer","join","modules","dedupe","undefined","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","___CSS_LOADER_EXPORT___","t","n","e","console","error","log","execScript","attachEvent","addEventListener","eval","call","o","r","__esModule","default","d","a","Object","defineProperty","enumerable","get","prototype","hasOwnProperty","element","createElement","setAttributes","attributes","insert","memo","style","target","styleTarget","querySelector","window","HTMLIFrameElement","contentDocument","head","getTarget","Error","REACT_ELEMENT_TYPE","Symbol","for","jsxProd","type","config","maybeKey","key","propName","ref","$$typeof","props","jsx","insertStyleElement","styleTagTransform","apply","parentNode","removeStyleElement","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","definition","prop","nc","locals","EaselCanvas","forwardRef","_props$width","width","_props$height","height","_props$toolbars","toolbars","_props$plugins","plugins","_props$defaultActiveP","defaultActivePlugin","_props$backgroundColo","backgroundColor","_props$transparentBac","transparentBackground","_props$toolbarSize","toolbarSize","_props$toolbarSizeTou","toolbarSizeTouch","_props$fullscreenMode","fullscreenMode","_props$selectMode","selectMode","_props$onChange","onChange","_props$onSave","onSave","_props$onObjectAdded","onObjectAdded","_props$onObjectModifi","onObjectModified","_props$onObjectRemove","onObjectRemoved","_props$onSelectionCre","onSelectionCreated","_props$onSelectionCle","onSelectionCleared","customOptions","_objectWithoutProperties","_excluded","containerRef","useRef","easelInstanceRef","useEffect","current","Easel","easelConfig","_objectSpread","canvasWidth","canvasHeight","easelInstance","on","destroy","setSize","useImperativeHandle","getInstance","getImageDataUrl","format","arguments","quality","getImageBlob","callback","loadImage","imageData","clear","clearCanvas","setBackgroundColor","color","w","h","undo","redo","activatePlugin","pluginName","trigger","getFabricCanvas","fCanvas","_jsx","className","position","displayName"],"sourceRoot":""}